import * as t from "react";
import { f as P, t as w, Q as h, j as L, i as f, X as b } from "./Button-518a0ca9.js";
import { k as g } from "./utils-98f79634.js";
function T(c) {
  return c.substring(2).toLowerCase();
}
function x(c, s) {
  return s.documentElement.clientWidth < c.clientX || s.documentElement.clientHeight < c.clientY;
}
function R(c) {
  const {
    children: s,
    disableReactTree: k = !1,
    mouseEvent: i = "onClick",
    onClickAway: y,
    touchEvent: u = "onTouchEnd"
  } = c, l = t.useRef(!1), o = t.useRef(null), d = t.useRef(!1), p = t.useRef(!1);
  t.useEffect(() => (setTimeout(() => {
    d.current = !0;
  }, 0), () => {
    d.current = !1;
  }), []);
  const C = P(
    // @ts-expect-error TODO upstream fix
    s.ref,
    o
  ), a = w((e) => {
    const n = p.current;
    p.current = !1;
    const r = h(o.current);
    if (!d.current || !o.current || "clientX" in e && x(e, r))
      return;
    if (l.current) {
      l.current = !1;
      return;
    }
    let E;
    e.composedPath ? E = e.composedPath().indexOf(o.current) > -1 : E = !r.documentElement.contains(
      // @ts-expect-error returns `false` as intended when not dispatched from a Node
      e.target
    ) || o.current.contains(
      // @ts-expect-error returns `false` as intended when not dispatched from a Node
      e.target
    ), !E && (k || !n) && y(e);
  }), v = (e) => (n) => {
    p.current = !0;
    const r = s.props[e];
    r && r(n);
  }, m = {
    ref: C
  };
  return u !== !1 && (m[u] = v(u)), t.useEffect(() => {
    if (u !== !1) {
      const e = T(u), n = h(o.current), r = () => {
        l.current = !0;
      };
      return n.addEventListener(e, a), n.addEventListener("touchmove", r), () => {
        n.removeEventListener(e, a), n.removeEventListener("touchmove", r);
      };
    }
  }, [a, u]), i !== !1 && (m[i] = v(i)), t.useEffect(() => {
    if (i !== !1) {
      const e = T(i), n = h(o.current);
      return n.addEventListener(e, a), () => {
        n.removeEventListener(e, a);
      };
    }
  }, [a, i]), /* @__PURE__ */ L.jsx(t.Fragment, {
    children: /* @__PURE__ */ t.cloneElement(s, m)
  });
}
"production".NODE_ENV !== "production" && (R.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The wrapped element.
   */
  children: g.isRequired,
  /**
   * If `true`, the React tree is ignored and only the DOM tree is considered.
   * This prop changes how portaled elements are handled.
   * @default false
   */
  disableReactTree: f.bool,
  /**
   * The mouse event to listen to. You can disable the listener by providing `false`.
   * @default 'onClick'
   */
  mouseEvent: f.oneOf(["onClick", "onMouseDown", "onMouseUp", "onPointerDown", "onPointerUp", !1]),
  /**
   * Callback fired when a "click away" event is detected.
   */
  onClickAway: f.func.isRequired,
  /**
   * The touch event to listen to. You can disable the listener by providing `false`.
   * @default 'onTouchEnd'
   */
  touchEvent: f.oneOf(["onTouchEnd", "onTouchStart", !1])
});
"production".NODE_ENV !== "production" && (R["propTypes"] = b(R.propTypes));
export {
  R as C
};
//# sourceMappingURL=ClickAwayListener-0ed1644c.js.map
