(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode('.pl__wrapper{font:1em/1.5 sans-serif;height:100%;display:grid;place-items:center}.pl,.pl__ball,.pl__ball-inner-shadow,.pl__ball-side-shadows,.pl__ball-texture,.pl__inner-ring,.pl__outer-ring,.pl__track-cover{border-radius:50%}.pl{position:relative;width:16em;height:16em}.pl__ball,.pl__ball-inner-shadow,.pl__ball-outer-shadow,.pl__ball-side-shadows,.pl__ball-texture,.pl__ball-texture:before,.pl__inner-ring,.pl__outer-ring,.pl__track-cover{position:absolute}.pl__ball,.pl__ball-inner-shadow,.pl__ball-outer-shadow,.pl__ball-texture:before,.pl__track-cover{animation:ball 4s linear infinite}.pl__ball{top:calc(50% - 1.25em);left:calc(50% - 1.25em);transform:rotate(0) translateY(-6.5em);width:2.5em;height:2.5em}.pl__ball-inner-shadow{animation-name:ballInnerShadow;box-shadow:0 .1em .2em #0000004d,0 0 .2em #0000001a inset,0 -1em .5em #00000026 inset;width:100%;height:100%}.pl__ball-outer-shadow{animation-name:ballOuterShadow;background-image:linear-gradient(hsla(0,0%,0%,.15),hsla(0,0%,0%,0));border-radius:0 0 50% 50%/0 0 100% 100%;filter:blur(2px);top:50%;left:0;width:100%;height:250%;transform:rotate(20deg);transform-origin:50% 0;z-index:-2}.pl__ball-side-shadows{background-color:#0000001a;filter:blur(2px);width:100%;height:100%;transform:scale(.75,1.1);z-index:-1}.pl__ball-texture{overflow:hidden;width:100%;height:100%;transform:translateZ(0)}.pl__ball-texture:before{animation-name:ballTexture;animation-duration:.25s;background:#fffafa 0 0/50% 100%;content:"";display:block;filter:brightness(1.05);top:0;right:0;width:200%;height:100%}.pl__inner-ring{box-shadow:0 -.25em .5em #fff6,0 .5em .75em #fff6 inset,0 .5em .375em #00000026,0 -.5em .75em #00000026 inset;top:2.375em;left:2.375em;width:calc(100% - 4.75em);height:calc(100% - 4.75em)}.pl__outer-ring{box-shadow:0 -.45em .375em #00000026,0 .5em .75em #00000026 inset,0 .25em .5em #fff6,0 -.5em .75em #fff6 inset;top:.75em;left:.75em;width:calc(100% - 1.5em);height:calc(100% - 1.5em)}.pl__track-cover{animation-name:trackCover;background-image:conic-gradient(#f5f8fa 210deg,hsla(223,90%,95%,0) 270deg);top:0;left:0;width:100%;height:100%}@keyframes ball{0%{transform:rotate(0) translateY(-6.5em)}50%{transform:rotate(180deg) translateY(-6em)}to{transform:rotate(360deg) translateY(-6.5em)}}@keyframes ballInnerShadow{0%{transform:rotate(0)}to{transform:rotate(-360deg)}}@keyframes ballOuterShadow{0%{transform:rotate(20deg)}to{transform:rotate(-340deg)}}@keyframes ballTexture{0%{transform:translate(0)}to{transform:translate(50%)}}@keyframes trackCover{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.piche-login{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;font-size:16px}.piche-login input#email,.piche-login input#password{max-width:240px;width:100%}.piche-login .form{max-width:400px;width:100%;padding:1rem}.piche-login .form__group{display:flex;justify-content:space-between;margin-bottom:16px}.piche-login .form__text-wrapper{margin-bottom:48px;text-align:center}.piche-login .form__title{margin-bottom:16px}.piche-login .form__subtitle{margin-bottom:16px;font-weight:600}.piche-login .form__remember-me{display:flex;flex-direction:row!important;align-items:center;margin-bottom:16px;gap:8px}.piche-login .form label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.piche-login .form button{width:100%}:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: #e74c3c;--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-toast-width: 320px;--toastify-toast-background: #fff;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient( to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55 );--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error)}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;padding:4px;width:var(--toastify-toast-width);box-sizing:border-box;color:#fff}.Toastify__toast-container--top-left{top:1em;left:1em}.Toastify__toast-container--top-center{top:1em;left:50%;transform:translate(-50%)}.Toastify__toast-container--top-right{top:1em;right:1em}.Toastify__toast-container--bottom-left{bottom:1em;left:1em}.Toastify__toast-container--bottom-center{bottom:1em;left:50%;transform:translate(-50%)}.Toastify__toast-container--bottom-right{bottom:1em;right:1em}@media only screen and (max-width : 480px){.Toastify__toast-container{width:100vw;padding:0;left:0;margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:0;transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:0;transform:translate(0)}.Toastify__toast-container--rtl{right:0;left:initial}}.Toastify__toast{position:relative;min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:8px;border-radius:4px;box-shadow:0 1px 10px #0000001a,0 2px 15px #0000000d;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;max-height:var(--toastify-toast-max-height);overflow:hidden;font-family:var(--toastify-font-family);cursor:default;direction:ltr;z-index:0}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-body{margin:auto 0;-ms-flex:1 1 auto;flex:1 1 auto;padding:6px;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.Toastify__toast-body>div:last-child{word-break:break-word;-ms-flex:1;flex:1}.Toastify__toast-icon{-webkit-margin-end:10px;margin-inline-end:10px;width:20px;-ms-flex-negative:0;flex-shrink:0;display:-ms-flexbox;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.7s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}@media only screen and (max-width : 480px){.Toastify__toast{margin-bottom:0;border-radius:0}}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;-ms-flex-item-align:start;align-self:flex-start}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:5px;z-index:var(--toastify-z-index);opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(2000px,0,0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:perspective(400px)}30%{transform:perspective(400px) rotateX(-20deg);opacity:1}to{transform:perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideOutRight{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(110%,0,0)}}@keyframes Toastify__slideOutLeft{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(-110%,0,0)}}@keyframes Toastify__slideOutDown{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')),document.head.appendChild(t)}}catch(o){console.error("vite-plugin-css-injected-by-js",o)}})();
var Qn = Object.defineProperty;
var Yn = (t, e, r) => e in t ? Qn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var m = (t, e, r) => (Yn(t, typeof e != "symbol" ? e + "" : e, r), r);
import N, { createContext as Xn, useContext as Zn, useMemo as es, useRef as fe, useEffect as G, useState as ae, forwardRef as ts, useReducer as rs, isValidElement as Ce, cloneElement as Mt, useLayoutEffect as ns } from "react";
import { makeAutoObservable as ss, runInAction as Ye, autorun as os } from "mobx";
import is from "react-dom";
var jt = { exports: {} }, Le = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vr;
function as() {
  if (vr)
    return Le;
  vr = 1;
  var t = N, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function i(c, l, u) {
    var f, y = {}, b = null, g = null;
    u !== void 0 && (b = "" + u), l.key !== void 0 && (b = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (f in l)
      n.call(l, f) && !o.hasOwnProperty(f) && (y[f] = l[f]);
    if (c && c.defaultProps)
      for (f in l = c.defaultProps, l)
        y[f] === void 0 && (y[f] = l[f]);
    return { $$typeof: e, type: c, key: b, ref: g, props: y, _owner: s.current };
  }
  return Le.Fragment = r, Le.jsx = i, Le.jsxs = i, Le;
}
var xe = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Rr;
function cs() {
  return Rr || (Rr = 1, "production".NODE_ENV !== "production" && function() {
    var t = N, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), c = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), y = Symbol.for("react.memo"), b = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), h = Symbol.iterator, E = "@@iterator";
    function R(a) {
      if (a === null || typeof a != "object")
        return null;
      var p = h && a[h] || a[E];
      return typeof p == "function" ? p : null;
    }
    var v = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(a) {
      {
        for (var p = arguments.length, w = new Array(p > 1 ? p - 1 : 0), T = 1; T < p; T++)
          w[T - 1] = arguments[T];
        D("error", a, w);
      }
    }
    function D(a, p, w) {
      {
        var T = v.ReactDebugCurrentFrame, I = T.getStackAddendum();
        I !== "" && (p += "%s", w = w.concat([I]));
        var x = w.map(function(S) {
          return String(S);
        });
        x.unshift("Warning: " + p), Function.prototype.apply.call(console[a], console, x);
      }
    }
    var C = !1, L = !1, ne = !1, se = !1, q = !1, oe;
    oe = Symbol.for("react.module.reference");
    function pe(a) {
      return !!(typeof a == "string" || typeof a == "function" || a === n || a === o || q || a === s || a === u || a === f || se || a === g || C || L || ne || typeof a == "object" && a !== null && (a.$$typeof === b || a.$$typeof === y || a.$$typeof === i || a.$$typeof === c || a.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      a.$$typeof === oe || a.getModuleId !== void 0));
    }
    function le(a, p, w) {
      var T = a.displayName;
      if (T)
        return T;
      var I = p.displayName || p.name || "";
      return I !== "" ? w + "(" + I + ")" : w;
    }
    function H(a) {
      return a.displayName || "Context";
    }
    function $(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case s:
          return "StrictMode";
        case u:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case c:
            var p = a;
            return H(p) + ".Consumer";
          case i:
            var w = a;
            return H(w._context) + ".Provider";
          case l:
            return le(a, a.render, "ForwardRef");
          case y:
            var T = a.displayName || null;
            return T !== null ? T : $(a.type) || "Memo";
          case b: {
            var I = a, x = I._payload, S = I._init;
            try {
              return $(S(x));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var F = Object.assign, J = 0, W, Q, ie, Ee, nr, sr, or;
    function ir() {
    }
    ir.__reactDisabledLog = !0;
    function On() {
      {
        if (J === 0) {
          W = console.log, Q = console.info, ie = console.warn, Ee = console.error, nr = console.group, sr = console.groupCollapsed, or = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: ir,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        J++;
      }
    }
    function Sn() {
      {
        if (J--, J === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: F({}, a, {
              value: W
            }),
            info: F({}, a, {
              value: Q
            }),
            warn: F({}, a, {
              value: ie
            }),
            error: F({}, a, {
              value: Ee
            }),
            group: F({}, a, {
              value: nr
            }),
            groupCollapsed: F({}, a, {
              value: sr
            }),
            groupEnd: F({}, a, {
              value: or
            })
          });
        }
        J < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var wt = v.ReactCurrentDispatcher, bt;
    function Ve(a, p, w) {
      {
        if (bt === void 0)
          try {
            throw Error();
          } catch (I) {
            var T = I.stack.trim().match(/\n( *(at )?)/);
            bt = T && T[1] || "";
          }
        return `
` + bt + a;
      }
    }
    var vt = !1, Ke;
    {
      var An = typeof WeakMap == "function" ? WeakMap : Map;
      Ke = new An();
    }
    function ar(a, p) {
      if (!a || vt)
        return "";
      {
        var w = Ke.get(a);
        if (w !== void 0)
          return w;
      }
      var T;
      vt = !0;
      var I = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var x;
      x = wt.current, wt.current = null, On();
      try {
        if (p) {
          var S = function() {
            throw Error();
          };
          if (Object.defineProperty(S.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(S, []);
            } catch (de) {
              T = de;
            }
            Reflect.construct(a, [], S);
          } else {
            try {
              S.call();
            } catch (de) {
              T = de;
            }
            a.call(S.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (de) {
            T = de;
          }
          a();
        }
      } catch (de) {
        if (de && T && typeof de.stack == "string") {
          for (var O = de.stack.split(`
`), V = T.stack.split(`
`), M = O.length - 1, j = V.length - 1; M >= 1 && j >= 0 && O[M] !== V[j]; )
            j--;
          for (; M >= 1 && j >= 0; M--, j--)
            if (O[M] !== V[j]) {
              if (M !== 1 || j !== 1)
                do
                  if (M--, j--, j < 0 || O[M] !== V[j]) {
                    var Y = `
` + O[M].replace(" at new ", " at ");
                    return a.displayName && Y.includes("<anonymous>") && (Y = Y.replace("<anonymous>", a.displayName)), typeof a == "function" && Ke.set(a, Y), Y;
                  }
                while (M >= 1 && j >= 0);
              break;
            }
        }
      } finally {
        vt = !1, wt.current = x, Sn(), Error.prepareStackTrace = I;
      }
      var Se = a ? a.displayName || a.name : "", br = Se ? Ve(Se) : "";
      return typeof a == "function" && Ke.set(a, br), br;
    }
    function Cn(a, p, w) {
      return ar(a, !1);
    }
    function In(a) {
      var p = a.prototype;
      return !!(p && p.isReactComponent);
    }
    function Ge(a, p, w) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return ar(a, In(a));
      if (typeof a == "string")
        return Ve(a);
      switch (a) {
        case u:
          return Ve("Suspense");
        case f:
          return Ve("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case l:
            return Cn(a.render);
          case y:
            return Ge(a.type, p, w);
          case b: {
            var T = a, I = T._payload, x = T._init;
            try {
              return Ge(x(I), p, w);
            } catch {
            }
          }
        }
      return "";
    }
    var Je = Object.prototype.hasOwnProperty, cr = {}, ur = v.ReactDebugCurrentFrame;
    function Qe(a) {
      if (a) {
        var p = a._owner, w = Ge(a.type, a._source, p ? p.type : null);
        ur.setExtraStackFrame(w);
      } else
        ur.setExtraStackFrame(null);
    }
    function Pn(a, p, w, T, I) {
      {
        var x = Function.call.bind(Je);
        for (var S in a)
          if (x(a, S)) {
            var O = void 0;
            try {
              if (typeof a[S] != "function") {
                var V = Error((T || "React class") + ": " + w + " type `" + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[S] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw V.name = "Invariant Violation", V;
              }
              O = a[S](p, S, T, w, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (M) {
              O = M;
            }
            O && !(O instanceof Error) && (Qe(I), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", T || "React class", w, S, typeof O), Qe(null)), O instanceof Error && !(O.message in cr) && (cr[O.message] = !0, Qe(I), _("Failed %s type: %s", w, O.message), Qe(null));
          }
      }
    }
    var Nn = Array.isArray;
    function Rt(a) {
      return Nn(a);
    }
    function Ln(a) {
      {
        var p = typeof Symbol == "function" && Symbol.toStringTag, w = p && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return w;
      }
    }
    function xn(a) {
      try {
        return lr(a), !1;
      } catch {
        return !0;
      }
    }
    function lr(a) {
      return "" + a;
    }
    function dr(a) {
      if (xn(a))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ln(a)), lr(a);
    }
    var Ne = v.ReactCurrentOwner, kn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, fr, hr, Tt;
    Tt = {};
    function Un(a) {
      if (Je.call(a, "ref")) {
        var p = Object.getOwnPropertyDescriptor(a, "ref").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return a.ref !== void 0;
    }
    function Dn(a) {
      if (Je.call(a, "key")) {
        var p = Object.getOwnPropertyDescriptor(a, "key").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return a.key !== void 0;
    }
    function Fn(a, p) {
      if (typeof a.ref == "string" && Ne.current && p && Ne.current.stateNode !== p) {
        var w = $(Ne.current.type);
        Tt[w] || (_('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ne.current.type), a.ref), Tt[w] = !0);
      }
    }
    function Mn(a, p) {
      {
        var w = function() {
          fr || (fr = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        w.isReactWarning = !0, Object.defineProperty(a, "key", {
          get: w,
          configurable: !0
        });
      }
    }
    function jn(a, p) {
      {
        var w = function() {
          hr || (hr = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        w.isReactWarning = !0, Object.defineProperty(a, "ref", {
          get: w,
          configurable: !0
        });
      }
    }
    var $n = function(a, p, w, T, I, x, S) {
      var O = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: a,
        key: p,
        ref: w,
        props: S,
        // Record the component responsible for creating this element.
        _owner: x
      };
      return O._store = {}, Object.defineProperty(O._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(O, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: T
      }), Object.defineProperty(O, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: I
      }), Object.freeze && (Object.freeze(O.props), Object.freeze(O)), O;
    };
    function Bn(a, p, w, T, I) {
      {
        var x, S = {}, O = null, V = null;
        w !== void 0 && (dr(w), O = "" + w), Dn(p) && (dr(p.key), O = "" + p.key), Un(p) && (V = p.ref, Fn(p, I));
        for (x in p)
          Je.call(p, x) && !kn.hasOwnProperty(x) && (S[x] = p[x]);
        if (a && a.defaultProps) {
          var M = a.defaultProps;
          for (x in M)
            S[x] === void 0 && (S[x] = M[x]);
        }
        if (O || V) {
          var j = typeof a == "function" ? a.displayName || a.name || "Unknown" : a;
          O && Mn(S, j), V && jn(S, j);
        }
        return $n(a, O, V, I, T, Ne.current, S);
      }
    }
    var _t = v.ReactCurrentOwner, pr = v.ReactDebugCurrentFrame;
    function Oe(a) {
      if (a) {
        var p = a._owner, w = Ge(a.type, a._source, p ? p.type : null);
        pr.setExtraStackFrame(w);
      } else
        pr.setExtraStackFrame(null);
    }
    var Ot;
    Ot = !1;
    function St(a) {
      return typeof a == "object" && a !== null && a.$$typeof === e;
    }
    function mr() {
      {
        if (_t.current) {
          var a = $(_t.current.type);
          if (a)
            return `

Check the render method of \`` + a + "`.";
        }
        return "";
      }
    }
    function qn(a) {
      {
        if (a !== void 0) {
          var p = a.fileName.replace(/^.*[\\\/]/, ""), w = a.lineNumber;
          return `

Check your code at ` + p + ":" + w + ".";
        }
        return "";
      }
    }
    var gr = {};
    function Wn(a) {
      {
        var p = mr();
        if (!p) {
          var w = typeof a == "string" ? a : a.displayName || a.name;
          w && (p = `

Check the top-level render call using <` + w + ">.");
        }
        return p;
      }
    }
    function yr(a, p) {
      {
        if (!a._store || a._store.validated || a.key != null)
          return;
        a._store.validated = !0;
        var w = Wn(p);
        if (gr[w])
          return;
        gr[w] = !0;
        var T = "";
        a && a._owner && a._owner !== _t.current && (T = " It was passed a child from " + $(a._owner.type) + "."), Oe(a), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', w, T), Oe(null);
      }
    }
    function Er(a, p) {
      {
        if (typeof a != "object")
          return;
        if (Rt(a))
          for (var w = 0; w < a.length; w++) {
            var T = a[w];
            St(T) && yr(T, p);
          }
        else if (St(a))
          a._store && (a._store.validated = !0);
        else if (a) {
          var I = R(a);
          if (typeof I == "function" && I !== a.entries)
            for (var x = I.call(a), S; !(S = x.next()).done; )
              St(S.value) && yr(S.value, p);
        }
      }
    }
    function zn(a) {
      {
        var p = a.type;
        if (p == null || typeof p == "string")
          return;
        var w;
        if (typeof p == "function")
          w = p.propTypes;
        else if (typeof p == "object" && (p.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        p.$$typeof === y))
          w = p.propTypes;
        else
          return;
        if (w) {
          var T = $(p);
          Pn(w, a.props, "prop", T, a);
        } else if (p.PropTypes !== void 0 && !Ot) {
          Ot = !0;
          var I = $(p);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", I || "Unknown");
        }
        typeof p.getDefaultProps == "function" && !p.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Hn(a) {
      {
        for (var p = Object.keys(a.props), w = 0; w < p.length; w++) {
          var T = p[w];
          if (T !== "children" && T !== "key") {
            Oe(a), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", T), Oe(null);
            break;
          }
        }
        a.ref !== null && (Oe(a), _("Invalid attribute `ref` supplied to `React.Fragment`."), Oe(null));
      }
    }
    function wr(a, p, w, T, I, x) {
      {
        var S = pe(a);
        if (!S) {
          var O = "";
          (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (O += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var V = qn(I);
          V ? O += V : O += mr();
          var M;
          a === null ? M = "null" : Rt(a) ? M = "array" : a !== void 0 && a.$$typeof === e ? (M = "<" + ($(a.type) || "Unknown") + " />", O = " Did you accidentally export a JSX literal instead of a component?") : M = typeof a, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", M, O);
        }
        var j = Bn(a, p, w, I, x);
        if (j == null)
          return j;
        if (S) {
          var Y = p.children;
          if (Y !== void 0)
            if (T)
              if (Rt(Y)) {
                for (var Se = 0; Se < Y.length; Se++)
                  Er(Y[Se], a);
                Object.freeze && Object.freeze(Y);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Er(Y, a);
        }
        return a === n ? Hn(j) : zn(j), j;
      }
    }
    function Vn(a, p, w) {
      return wr(a, p, w, !0);
    }
    function Kn(a, p, w) {
      return wr(a, p, w, !1);
    }
    var Gn = Kn, Jn = Vn;
    xe.Fragment = n, xe.jsx = Gn, xe.jsxs = Jn;
  }()), xe;
}
"production".NODE_ENV === "production" ? jt.exports = as() : jt.exports = cs();
var P = jt.exports;
function zr(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number")
    n += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = zr(t[e])) && (n && (n += " "), n += r);
    else
      for (e in t)
        t[e] && (n && (n += " "), n += e);
  return n;
}
function us() {
  for (var t, e, r = 0, n = ""; r < arguments.length; )
    (t = arguments[r++]) && (e = zr(t)) && (n && (n += " "), n += e);
  return n;
}
var $t = /* @__PURE__ */ ((t) => (t.Completed = "completed", t.InProgress = "inProgress", t.Rejected = "rejected", t))($t || {}), Ue = /* @__PURE__ */ ((t) => (t[t.OK = 0] = "OK", t[t.ERROR = 1] = "ERROR", t[t.OperationRejected = 2] = "OperationRejected", t))(Ue || {}), ls = /* @__PURE__ */ ((t) => (t.VideoMessage = "videoMessage", t.ScreenRecord = "screenRecord", t))(ls || {}), z = /* @__PURE__ */ ((t) => (t[t.EMERGENCY = 0] = "EMERGENCY", t[t.ALERT = 1] = "ALERT", t[t.CRITICAL = 2] = "CRITICAL", t[t.ERROR = 3] = "ERROR", t[t.WARN = 4] = "WARN", t[t.INFO = 6] = "INFO", t[t.DEBUG = 7] = "DEBUG", t))(z || {});
const Tr = () => {
};
var ut = /* @__PURE__ */ ((t) => (t.password = "password", t.AD = "AD", t.microsoftEntraId = "microsoftEntraId", t.google = "google", t.refreshToken = "refresh_token", t))(ut || {});
const Hr = Xn({
  currentUser: void 0,
  currentUserLoading: !0,
  setCurrentUser: Tr,
  logout: Tr
}), ds = () => Zn(Hr), Vr = "piche-logger", _r = "_unknown_", Or = "logger.level.ns.", fs = "piche-navigate-host", it = 200, Kr = 2147483647, hs = "LOGIN_SUCCESSFULLY_FOR_PORTAL_USER", ps = "LOGOUT_SUCCESSFULLY_FOR_PORTAL_USER", ms = "/protocol/openid-connect/token", gs = "/protocol/openid-connect/logout", Gr = "piche-request-api-client", Jr = "piche-request-operation-client", ys = "REQUEST_TABLE_DATA_LOADER", Qr = "piche_request_api_configuration_event", Es = "piche-request-table-client", ws = "piche-request-view-client", Yr = "piche-react-toast", Xr = "REQUEST_PORTAL_USER_MANAGER", Zr = "piche-request-profile-contact-store", bs = "PROFILE_CONTACT_UPDATED";
class k {
}
m(k, "emitMessageAsync", (e, r) => {
  Promise.resolve().then(() => {
    const n = new CustomEvent(e, { detail: r });
    Promise.resolve().then(() => window.dispatchEvent(n));
  });
}), m(k, "subscribe", (e, r) => (window.addEventListener(e, r), {
  unsubscribe: () => window.removeEventListener(e, r)
}));
const lt = (t) => {
  k.emitMessageAsync(Vr, t);
}, vs = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.INFO, error: r }), Mi = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.DEBUG, error: r }), ji = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.WARN, error: r }), be = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.ERROR, error: r });
class re {
  isEmpty() {
    return !this.isPresent();
  }
  static of(e) {
    if (e != null)
      return new Sr(e);
    throw new TypeError("The passed value was null or undefined.");
  }
  static ofNonNull(e) {
    return re.of(e);
  }
  static ofNullable(e) {
    return e != null ? new Sr(e) : new Ar();
  }
  static empty() {
    return new Ar();
  }
  static from(e) {
    switch (e.kind) {
      case "present":
        return re.of(e.value);
      case "empty":
        return re.empty();
      default:
        throw new TypeError("The passed value was not an Option type.");
    }
  }
}
class Sr extends re {
  constructor(e) {
    super(), this.payload = e;
  }
  isPresent() {
    return !0;
  }
  get() {
    return this.payload;
  }
  ifPresent(e) {
    e(this.payload);
  }
  ifPresentOrElse(e, r) {
    e(this.payload);
  }
  filter(e) {
    return e(this.payload) ? this : re.empty();
  }
  map(e) {
    const r = e(this.payload);
    return re.ofNullable(r);
  }
  flatMap(e) {
    return e(this.payload);
  }
  or(e) {
    return this;
  }
  orElse(e) {
    return this.payload;
  }
  orElseGet(e) {
    return this.payload;
  }
  orElseThrow(e) {
    return this.payload;
  }
  orNull() {
    return this.payload;
  }
  orUndefined() {
    return this.payload;
  }
  toOption() {
    return { kind: "present", value: this.payload };
  }
  matches(e) {
    return e.present(this.payload);
  }
  toJSON(e) {
    return this.payload;
  }
}
class Ar extends re {
  isPresent() {
    return !1;
  }
  constructor() {
    super();
  }
  get() {
    throw new TypeError("The optional is not present.");
  }
  ifPresent(e) {
  }
  ifPresentOrElse(e, r) {
    r();
  }
  filter(e) {
    return this;
  }
  map(e) {
    return re.empty();
  }
  flatMap(e) {
    return re.empty();
  }
  or(e) {
    return e();
  }
  orElse(e) {
    return e;
  }
  orElseGet(e) {
    return this.orElse(e());
  }
  orElseThrow(e) {
    throw e();
  }
  orNull() {
    return null;
  }
  orUndefined() {
  }
  toOption() {
    return { kind: "empty" };
  }
  matches(e) {
    return e.empty();
  }
  toJSON(e) {
    return null;
  }
}
function en(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: Rs } = Object.prototype, { getPrototypeOf: Jt } = Object, dt = ((t) => (e) => {
  const r = Rs.call(e);
  return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), ue = (t) => (t = t.toLowerCase(), (e) => dt(e) === t), ft = (t) => (e) => typeof e === t, { isArray: Pe } = Array, qe = ft("undefined");
function Ts(t) {
  return t !== null && !qe(t) && t.constructor !== null && !qe(t.constructor) && ee(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const tn = ue("ArrayBuffer");
function _s(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && tn(t.buffer), e;
}
const Os = ft("string"), ee = ft("function"), rn = ft("number"), ht = (t) => t !== null && typeof t == "object", Ss = (t) => t === !0 || t === !1, tt = (t) => {
  if (dt(t) !== "object")
    return !1;
  const e = Jt(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, As = ue("Date"), Cs = ue("File"), Is = ue("Blob"), Ps = ue("FileList"), Ns = (t) => ht(t) && ee(t.pipe), Ls = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || ee(t.append) && ((e = dt(t)) === "formdata" || // detect form-data instance
  e === "object" && ee(t.toString) && t.toString() === "[object FormData]"));
}, xs = ue("URLSearchParams"), ks = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ze(t, e, { allOwnKeys: r = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let n, s;
  if (typeof t != "object" && (t = [t]), Pe(t))
    for (n = 0, s = t.length; n < s; n++)
      e.call(null, t[n], n, t);
  else {
    const o = r ? Object.getOwnPropertyNames(t) : Object.keys(t), i = o.length;
    let c;
    for (n = 0; n < i; n++)
      c = o[n], e.call(null, t[c], c, t);
  }
}
function nn(t, e) {
  e = e.toLowerCase();
  const r = Object.keys(t);
  let n = r.length, s;
  for (; n-- > 0; )
    if (s = r[n], e === s.toLowerCase())
      return s;
  return null;
}
const sn = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), on = (t) => !qe(t) && t !== sn;
function Bt() {
  const { caseless: t } = on(this) && this || {}, e = {}, r = (n, s) => {
    const o = t && nn(e, s) || s;
    tt(e[o]) && tt(n) ? e[o] = Bt(e[o], n) : tt(n) ? e[o] = Bt({}, n) : Pe(n) ? e[o] = n.slice() : e[o] = n;
  };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && ze(arguments[n], r);
  return e;
}
const Us = (t, e, r, { allOwnKeys: n } = {}) => (ze(e, (s, o) => {
  r && ee(s) ? t[o] = en(s, r) : t[o] = s;
}, { allOwnKeys: n }), t), Ds = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), Fs = (t, e, r, n) => {
  t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), r && Object.assign(t.prototype, r);
}, Ms = (t, e, r, n) => {
  let s, o, i;
  const c = {};
  if (e = e || {}, t == null)
    return e;
  do {
    for (s = Object.getOwnPropertyNames(t), o = s.length; o-- > 0; )
      i = s[o], (!n || n(i, t, e)) && !c[i] && (e[i] = t[i], c[i] = !0);
    t = r !== !1 && Jt(t);
  } while (t && (!r || r(t, e)) && t !== Object.prototype);
  return e;
}, js = (t, e, r) => {
  t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
  const n = t.indexOf(e, r);
  return n !== -1 && n === r;
}, $s = (t) => {
  if (!t)
    return null;
  if (Pe(t))
    return t;
  let e = t.length;
  if (!rn(e))
    return null;
  const r = new Array(e);
  for (; e-- > 0; )
    r[e] = t[e];
  return r;
}, Bs = ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Jt(Uint8Array)), qs = (t, e) => {
  const n = (t && t[Symbol.iterator]).call(t);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const o = s.value;
    e.call(t, o[0], o[1]);
  }
}, Ws = (t, e) => {
  let r;
  const n = [];
  for (; (r = t.exec(e)) !== null; )
    n.push(r);
  return n;
}, zs = ue("HTMLFormElement"), Hs = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, s) {
    return n.toUpperCase() + s;
  }
), Cr = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype), Vs = ue("RegExp"), an = (t, e) => {
  const r = Object.getOwnPropertyDescriptors(t), n = {};
  ze(r, (s, o) => {
    e(s, o, t) !== !1 && (n[o] = s);
  }), Object.defineProperties(t, n);
}, Ks = (t) => {
  an(t, (e, r) => {
    if (ee(t) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = t[r];
    if (ee(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, Gs = (t, e) => {
  const r = {}, n = (s) => {
    s.forEach((o) => {
      r[o] = !0;
    });
  };
  return Pe(t) ? n(t) : n(String(t).split(e)), r;
}, Js = () => {
}, Qs = (t, e) => (t = +t, Number.isFinite(t) ? t : e), At = "abcdefghijklmnopqrstuvwxyz", Ir = "0123456789", cn = {
  DIGIT: Ir,
  ALPHA: At,
  ALPHA_DIGIT: At + At.toUpperCase() + Ir
}, Ys = (t = 16, e = cn.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = e;
  for (; t--; )
    r += e[Math.random() * n | 0];
  return r;
};
function Xs(t) {
  return !!(t && ee(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const Zs = (t) => {
  const e = new Array(10), r = (n, s) => {
    if (ht(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[s] = n;
        const o = Pe(n) ? [] : {};
        return ze(n, (i, c) => {
          const l = r(i, s + 1);
          !qe(l) && (o[c] = l);
        }), e[s] = void 0, o;
      }
    }
    return n;
  };
  return r(t, 0);
}, eo = ue("AsyncFunction"), to = (t) => t && (ht(t) || ee(t)) && ee(t.then) && ee(t.catch), d = {
  isArray: Pe,
  isArrayBuffer: tn,
  isBuffer: Ts,
  isFormData: Ls,
  isArrayBufferView: _s,
  isString: Os,
  isNumber: rn,
  isBoolean: Ss,
  isObject: ht,
  isPlainObject: tt,
  isUndefined: qe,
  isDate: As,
  isFile: Cs,
  isBlob: Is,
  isRegExp: Vs,
  isFunction: ee,
  isStream: Ns,
  isURLSearchParams: xs,
  isTypedArray: Bs,
  isFileList: Ps,
  forEach: ze,
  merge: Bt,
  extend: Us,
  trim: ks,
  stripBOM: Ds,
  inherits: Fs,
  toFlatObject: Ms,
  kindOf: dt,
  kindOfTest: ue,
  endsWith: js,
  toArray: $s,
  forEachEntry: qs,
  matchAll: Ws,
  isHTMLForm: zs,
  hasOwnProperty: Cr,
  hasOwnProp: Cr,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: an,
  freezeMethods: Ks,
  toObjectSet: Gs,
  toCamelCase: Hs,
  noop: Js,
  toFiniteNumber: Qs,
  findKey: nn,
  global: sn,
  isContextDefined: on,
  ALPHABET: cn,
  generateString: Ys,
  isSpecCompliantForm: Xs,
  toJSONObject: Zs,
  isAsyncFn: eo,
  isThenable: to
};
function A(t, e, r, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), s && (this.response = s);
}
d.inherits(A, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: d.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const un = A.prototype, ln = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  ln[t] = { value: t };
});
Object.defineProperties(A, ln);
Object.defineProperty(un, "isAxiosError", { value: !0 });
A.from = (t, e, r, n, s, o) => {
  const i = Object.create(un);
  return d.toFlatObject(t, i, function(l) {
    return l !== Error.prototype;
  }, (c) => c !== "isAxiosError"), A.call(i, t.message, e, r, n, s), i.cause = t, i.name = t.name, o && Object.assign(i, o), i;
};
const ro = null;
function qt(t) {
  return d.isPlainObject(t) || d.isArray(t);
}
function dn(t) {
  return d.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function Pr(t, e, r) {
  return t ? t.concat(e).map(function(s, o) {
    return s = dn(s), !r && o ? "[" + s + "]" : s;
  }).join(r ? "." : "") : e;
}
function no(t) {
  return d.isArray(t) && !t.some(qt);
}
const so = d.toFlatObject(d, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function pt(t, e, r) {
  if (!d.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), r = d.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(E, R) {
    return !d.isUndefined(R[E]);
  });
  const n = r.metaTokens, s = r.visitor || f, o = r.dots, i = r.indexes, l = (r.Blob || typeof Blob < "u" && Blob) && d.isSpecCompliantForm(e);
  if (!d.isFunction(s))
    throw new TypeError("visitor must be a function");
  function u(h) {
    if (h === null)
      return "";
    if (d.isDate(h))
      return h.toISOString();
    if (!l && d.isBlob(h))
      throw new A("Blob is not supported. Use a Buffer instead.");
    return d.isArrayBuffer(h) || d.isTypedArray(h) ? l && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function f(h, E, R) {
    let v = h;
    if (h && !R && typeof h == "object") {
      if (d.endsWith(E, "{}"))
        E = n ? E : E.slice(0, -2), h = JSON.stringify(h);
      else if (d.isArray(h) && no(h) || (d.isFileList(h) || d.endsWith(E, "[]")) && (v = d.toArray(h)))
        return E = dn(E), v.forEach(function(D, C) {
          !(d.isUndefined(D) || D === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            i === !0 ? Pr([E], C, o) : i === null ? E : E + "[]",
            u(D)
          );
        }), !1;
    }
    return qt(h) ? !0 : (e.append(Pr(R, E, o), u(h)), !1);
  }
  const y = [], b = Object.assign(so, {
    defaultVisitor: f,
    convertValue: u,
    isVisitable: qt
  });
  function g(h, E) {
    if (!d.isUndefined(h)) {
      if (y.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + E.join("."));
      y.push(h), d.forEach(h, function(v, _) {
        (!(d.isUndefined(v) || v === null) && s.call(
          e,
          v,
          d.isString(_) ? _.trim() : _,
          E,
          b
        )) === !0 && g(v, E ? E.concat(_) : [_]);
      }), y.pop();
    }
  }
  if (!d.isObject(t))
    throw new TypeError("data must be an object");
  return g(t), e;
}
function Nr(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function Qt(t, e) {
  this._pairs = [], t && pt(t, this, e);
}
const fn = Qt.prototype;
fn.append = function(e, r) {
  this._pairs.push([e, r]);
};
fn.toString = function(e) {
  const r = e ? function(n) {
    return e.call(this, n, Nr);
  } : Nr;
  return this._pairs.map(function(s) {
    return r(s[0]) + "=" + r(s[1]);
  }, "").join("&");
};
function oo(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function hn(t, e, r) {
  if (!e)
    return t;
  const n = r && r.encode || oo, s = r && r.serialize;
  let o;
  if (s ? o = s(e, r) : o = d.isURLSearchParams(e) ? e.toString() : new Qt(e, r).toString(n), o) {
    const i = t.indexOf("#");
    i !== -1 && (t = t.slice(0, i)), t += (t.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return t;
}
class io {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, r, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    d.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const Lr = io, pn = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, ao = typeof URLSearchParams < "u" ? URLSearchParams : Qt, co = typeof FormData < "u" ? FormData : null, uo = typeof Blob < "u" ? Blob : null, lo = (() => {
  let t;
  return typeof navigator < "u" && ((t = navigator.product) === "ReactNative" || t === "NativeScript" || t === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), fo = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), ce = {
  isBrowser: !0,
  classes: {
    URLSearchParams: ao,
    FormData: co,
    Blob: uo
  },
  isStandardBrowserEnv: lo,
  isStandardBrowserWebWorkerEnv: fo,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function ho(t, e) {
  return pt(t, new ce.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, s, o) {
      return ce.isNode && d.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function po(t) {
  return d.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function mo(t) {
  const e = {}, r = Object.keys(t);
  let n;
  const s = r.length;
  let o;
  for (n = 0; n < s; n++)
    o = r[n], e[o] = t[o];
  return e;
}
function mn(t) {
  function e(r, n, s, o) {
    let i = r[o++];
    const c = Number.isFinite(+i), l = o >= r.length;
    return i = !i && d.isArray(s) ? s.length : i, l ? (d.hasOwnProp(s, i) ? s[i] = [s[i], n] : s[i] = n, !c) : ((!s[i] || !d.isObject(s[i])) && (s[i] = []), e(r, n, s[i], o) && d.isArray(s[i]) && (s[i] = mo(s[i])), !c);
  }
  if (d.isFormData(t) && d.isFunction(t.entries)) {
    const r = {};
    return d.forEachEntry(t, (n, s) => {
      e(po(n), s, r, 0);
    }), r;
  }
  return null;
}
const go = {
  "Content-Type": void 0
};
function yo(t, e, r) {
  if (d.isString(t))
    try {
      return (e || JSON.parse)(t), d.trim(t);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(t);
}
const mt = {
  transitional: pn,
  adapter: ["xhr", "http"],
  transformRequest: [function(e, r) {
    const n = r.getContentType() || "", s = n.indexOf("application/json") > -1, o = d.isObject(e);
    if (o && d.isHTMLForm(e) && (e = new FormData(e)), d.isFormData(e))
      return s && s ? JSON.stringify(mn(e)) : e;
    if (d.isArrayBuffer(e) || d.isBuffer(e) || d.isStream(e) || d.isFile(e) || d.isBlob(e))
      return e;
    if (d.isArrayBufferView(e))
      return e.buffer;
    if (d.isURLSearchParams(e))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let c;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return ho(e, this.formSerializer).toString();
      if ((c = d.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return pt(
          c ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return o || s ? (r.setContentType("application/json", !1), yo(e)) : e;
  }],
  transformResponse: [function(e) {
    const r = this.transitional || mt.transitional, n = r && r.forcedJSONParsing, s = this.responseType === "json";
    if (e && d.isString(e) && (n && !this.responseType || s)) {
      const i = !(r && r.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (c) {
        if (i)
          throw c.name === "SyntaxError" ? A.from(c, A.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ce.classes.FormData,
    Blob: ce.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
d.forEach(["delete", "get", "head"], function(e) {
  mt.headers[e] = {};
});
d.forEach(["post", "put", "patch"], function(e) {
  mt.headers[e] = d.merge(go);
});
const Yt = mt, Eo = d.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), wo = (t) => {
  const e = {};
  let r, n, s;
  return t && t.split(`
`).forEach(function(i) {
    s = i.indexOf(":"), r = i.substring(0, s).trim().toLowerCase(), n = i.substring(s + 1).trim(), !(!r || e[r] && Eo[r]) && (r === "set-cookie" ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n);
  }), e;
}, xr = Symbol("internals");
function ke(t) {
  return t && String(t).trim().toLowerCase();
}
function rt(t) {
  return t === !1 || t == null ? t : d.isArray(t) ? t.map(rt) : String(t);
}
function bo(t) {
  const e = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(t); )
    e[n[1]] = n[2];
  return e;
}
const vo = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Ct(t, e, r, n, s) {
  if (d.isFunction(n))
    return n.call(this, e, r);
  if (s && (e = r), !!d.isString(e)) {
    if (d.isString(n))
      return e.indexOf(n) !== -1;
    if (d.isRegExp(n))
      return n.test(e);
  }
}
function Ro(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n);
}
function To(t, e) {
  const r = d.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(t, n + r, {
      value: function(s, o, i) {
        return this[n].call(this, e, s, o, i);
      },
      configurable: !0
    });
  });
}
class gt {
  constructor(e) {
    e && this.set(e);
  }
  set(e, r, n) {
    const s = this;
    function o(c, l, u) {
      const f = ke(l);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const y = d.findKey(s, f);
      (!y || s[y] === void 0 || u === !0 || u === void 0 && s[y] !== !1) && (s[y || l] = rt(c));
    }
    const i = (c, l) => d.forEach(c, (u, f) => o(u, f, l));
    return d.isPlainObject(e) || e instanceof this.constructor ? i(e, r) : d.isString(e) && (e = e.trim()) && !vo(e) ? i(wo(e), r) : e != null && o(r, e, n), this;
  }
  get(e, r) {
    if (e = ke(e), e) {
      const n = d.findKey(this, e);
      if (n) {
        const s = this[n];
        if (!r)
          return s;
        if (r === !0)
          return bo(s);
        if (d.isFunction(r))
          return r.call(this, s, n);
        if (d.isRegExp(r))
          return r.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, r) {
    if (e = ke(e), e) {
      const n = d.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!r || Ct(this, this[n], n, r)));
    }
    return !1;
  }
  delete(e, r) {
    const n = this;
    let s = !1;
    function o(i) {
      if (i = ke(i), i) {
        const c = d.findKey(n, i);
        c && (!r || Ct(n, n[c], c, r)) && (delete n[c], s = !0);
      }
    }
    return d.isArray(e) ? e.forEach(o) : o(e), s;
  }
  clear(e) {
    const r = Object.keys(this);
    let n = r.length, s = !1;
    for (; n--; ) {
      const o = r[n];
      (!e || Ct(this, this[o], o, e, !0)) && (delete this[o], s = !0);
    }
    return s;
  }
  normalize(e) {
    const r = this, n = {};
    return d.forEach(this, (s, o) => {
      const i = d.findKey(n, o);
      if (i) {
        r[i] = rt(s), delete r[o];
        return;
      }
      const c = e ? Ro(o) : String(o).trim();
      c !== o && delete r[o], r[c] = rt(s), n[c] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const r = /* @__PURE__ */ Object.create(null);
    return d.forEach(this, (n, s) => {
      n != null && n !== !1 && (r[s] = e && d.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, r]) => e + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...r) {
    const n = new this(e);
    return r.forEach((s) => n.set(s)), n;
  }
  static accessor(e) {
    const n = (this[xr] = this[xr] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function o(i) {
      const c = ke(i);
      n[c] || (To(s, i), n[c] = !0);
    }
    return d.isArray(e) ? e.forEach(o) : o(e), this;
  }
}
gt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
d.freezeMethods(gt.prototype);
d.freezeMethods(gt);
const he = gt;
function It(t, e) {
  const r = this || Yt, n = e || r, s = he.from(n.headers);
  let o = n.data;
  return d.forEach(t, function(c) {
    o = c.call(r, o, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), o;
}
function gn(t) {
  return !!(t && t.__CANCEL__);
}
function He(t, e, r) {
  A.call(this, t ?? "canceled", A.ERR_CANCELED, e, r), this.name = "CanceledError";
}
d.inherits(He, A, {
  __CANCEL__: !0
});
function _o(t, e, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? t(r) : e(new A(
    "Request failed with status code " + r.status,
    [A.ERR_BAD_REQUEST, A.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
const Oo = ce.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(r, n, s, o, i, c) {
        const l = [];
        l.push(r + "=" + encodeURIComponent(n)), d.isNumber(s) && l.push("expires=" + new Date(s).toGMTString()), d.isString(o) && l.push("path=" + o), d.isString(i) && l.push("domain=" + i), c === !0 && l.push("secure"), document.cookie = l.join("; ");
      },
      read: function(r) {
        const n = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
        return n ? decodeURIComponent(n[3]) : null;
      },
      remove: function(r) {
        this.write(r, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function So(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function Ao(t, e) {
  return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function yn(t, e) {
  return t && !So(e) ? Ao(t, e) : e;
}
const Co = ce.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let n;
    function s(o) {
      let i = o;
      return e && (r.setAttribute("href", i), i = r.href), r.setAttribute("href", i), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return n = s(window.location.href), function(i) {
      const c = d.isString(i) ? s(i) : i;
      return c.protocol === n.protocol && c.host === n.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function Io(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function Po(t, e) {
  t = t || 10;
  const r = new Array(t), n = new Array(t);
  let s = 0, o = 0, i;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const u = Date.now(), f = n[o];
    i || (i = u), r[s] = l, n[s] = u;
    let y = o, b = 0;
    for (; y !== s; )
      b += r[y++], y = y % t;
    if (s = (s + 1) % t, s === o && (o = (o + 1) % t), u - i < e)
      return;
    const g = f && u - f;
    return g ? Math.round(b * 1e3 / g) : void 0;
  };
}
function kr(t, e) {
  let r = 0;
  const n = Po(50, 250);
  return (s) => {
    const o = s.loaded, i = s.lengthComputable ? s.total : void 0, c = o - r, l = n(c), u = o <= i;
    r = o;
    const f = {
      loaded: o,
      total: i,
      progress: i ? o / i : void 0,
      bytes: c,
      rate: l || void 0,
      estimated: l && i && u ? (i - o) / l : void 0,
      event: s
    };
    f[e ? "download" : "upload"] = !0, t(f);
  };
}
const No = typeof XMLHttpRequest < "u", Lo = No && function(t) {
  return new Promise(function(r, n) {
    let s = t.data;
    const o = he.from(t.headers).normalize(), i = t.responseType;
    let c;
    function l() {
      t.cancelToken && t.cancelToken.unsubscribe(c), t.signal && t.signal.removeEventListener("abort", c);
    }
    d.isFormData(s) && (ce.isStandardBrowserEnv || ce.isStandardBrowserWebWorkerEnv ? o.setContentType(!1) : o.setContentType("multipart/form-data;", !1));
    let u = new XMLHttpRequest();
    if (t.auth) {
      const g = t.auth.username || "", h = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
      o.set("Authorization", "Basic " + btoa(g + ":" + h));
    }
    const f = yn(t.baseURL, t.url);
    u.open(t.method.toUpperCase(), hn(f, t.params, t.paramsSerializer), !0), u.timeout = t.timeout;
    function y() {
      if (!u)
        return;
      const g = he.from(
        "getAllResponseHeaders" in u && u.getAllResponseHeaders()
      ), E = {
        data: !i || i === "text" || i === "json" ? u.responseText : u.response,
        status: u.status,
        statusText: u.statusText,
        headers: g,
        config: t,
        request: u
      };
      _o(function(v) {
        r(v), l();
      }, function(v) {
        n(v), l();
      }, E), u = null;
    }
    if ("onloadend" in u ? u.onloadend = y : u.onreadystatechange = function() {
      !u || u.readyState !== 4 || u.status === 0 && !(u.responseURL && u.responseURL.indexOf("file:") === 0) || setTimeout(y);
    }, u.onabort = function() {
      u && (n(new A("Request aborted", A.ECONNABORTED, t, u)), u = null);
    }, u.onerror = function() {
      n(new A("Network Error", A.ERR_NETWORK, t, u)), u = null;
    }, u.ontimeout = function() {
      let h = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
      const E = t.transitional || pn;
      t.timeoutErrorMessage && (h = t.timeoutErrorMessage), n(new A(
        h,
        E.clarifyTimeoutError ? A.ETIMEDOUT : A.ECONNABORTED,
        t,
        u
      )), u = null;
    }, ce.isStandardBrowserEnv) {
      const g = (t.withCredentials || Co(f)) && t.xsrfCookieName && Oo.read(t.xsrfCookieName);
      g && o.set(t.xsrfHeaderName, g);
    }
    s === void 0 && o.setContentType(null), "setRequestHeader" in u && d.forEach(o.toJSON(), function(h, E) {
      u.setRequestHeader(E, h);
    }), d.isUndefined(t.withCredentials) || (u.withCredentials = !!t.withCredentials), i && i !== "json" && (u.responseType = t.responseType), typeof t.onDownloadProgress == "function" && u.addEventListener("progress", kr(t.onDownloadProgress, !0)), typeof t.onUploadProgress == "function" && u.upload && u.upload.addEventListener("progress", kr(t.onUploadProgress)), (t.cancelToken || t.signal) && (c = (g) => {
      u && (n(!g || g.type ? new He(null, t, u) : g), u.abort(), u = null);
    }, t.cancelToken && t.cancelToken.subscribe(c), t.signal && (t.signal.aborted ? c() : t.signal.addEventListener("abort", c)));
    const b = Io(f);
    if (b && ce.protocols.indexOf(b) === -1) {
      n(new A("Unsupported protocol " + b + ":", A.ERR_BAD_REQUEST, t));
      return;
    }
    u.send(s || null);
  });
}, nt = {
  http: ro,
  xhr: Lo
};
d.forEach(nt, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const xo = {
  getAdapter: (t) => {
    t = d.isArray(t) ? t : [t];
    const { length: e } = t;
    let r, n;
    for (let s = 0; s < e && (r = t[s], !(n = d.isString(r) ? nt[r.toLowerCase()] : r)); s++)
      ;
    if (!n)
      throw n === !1 ? new A(
        `Adapter ${r} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        d.hasOwnProp(nt, r) ? `Adapter '${r}' is not available in the build` : `Unknown adapter '${r}'`
      );
    if (!d.isFunction(n))
      throw new TypeError("adapter is not a function");
    return n;
  },
  adapters: nt
};
function Pt(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new He(null, t);
}
function Ur(t) {
  return Pt(t), t.headers = he.from(t.headers), t.data = It.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), xo.getAdapter(t.adapter || Yt.adapter)(t).then(function(n) {
    return Pt(t), n.data = It.call(
      t,
      t.transformResponse,
      n
    ), n.headers = he.from(n.headers), n;
  }, function(n) {
    return gn(n) || (Pt(t), n && n.response && (n.response.data = It.call(
      t,
      t.transformResponse,
      n.response
    ), n.response.headers = he.from(n.response.headers))), Promise.reject(n);
  });
}
const Dr = (t) => t instanceof he ? t.toJSON() : t;
function Ie(t, e) {
  e = e || {};
  const r = {};
  function n(u, f, y) {
    return d.isPlainObject(u) && d.isPlainObject(f) ? d.merge.call({ caseless: y }, u, f) : d.isPlainObject(f) ? d.merge({}, f) : d.isArray(f) ? f.slice() : f;
  }
  function s(u, f, y) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(u))
        return n(void 0, u, y);
    } else
      return n(u, f, y);
  }
  function o(u, f) {
    if (!d.isUndefined(f))
      return n(void 0, f);
  }
  function i(u, f) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(u))
        return n(void 0, u);
    } else
      return n(void 0, f);
  }
  function c(u, f, y) {
    if (y in e)
      return n(u, f);
    if (y in t)
      return n(void 0, u);
  }
  const l = {
    url: o,
    method: o,
    data: o,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: c,
    headers: (u, f) => s(Dr(u), Dr(f), !0)
  };
  return d.forEach(Object.keys(Object.assign({}, t, e)), function(f) {
    const y = l[f] || s, b = y(t[f], e[f], f);
    d.isUndefined(b) && y !== c || (r[f] = b);
  }), r;
}
const En = "1.4.0", Xt = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  Xt[t] = function(n) {
    return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const Fr = {};
Xt.transitional = function(e, r, n) {
  function s(o, i) {
    return "[Axios v" + En + "] Transitional option '" + o + "'" + i + (n ? ". " + n : "");
  }
  return (o, i, c) => {
    if (e === !1)
      throw new A(
        s(i, " has been removed" + (r ? " in " + r : "")),
        A.ERR_DEPRECATED
      );
    return r && !Fr[i] && (Fr[i] = !0, console.warn(
      s(
        i,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), e ? e(o, i, c) : !0;
  };
};
function ko(t, e, r) {
  if (typeof t != "object")
    throw new A("options must be an object", A.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(t);
  let s = n.length;
  for (; s-- > 0; ) {
    const o = n[s], i = e[o];
    if (i) {
      const c = t[o], l = c === void 0 || i(c, o, t);
      if (l !== !0)
        throw new A("option " + o + " must be " + l, A.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new A("Unknown option " + o, A.ERR_BAD_OPTION);
  }
}
const Wt = {
  assertOptions: ko,
  validators: Xt
}, me = Wt.validators;
class at {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new Lr(),
      response: new Lr()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(e, r) {
    typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = Ie(this.defaults, r);
    const { transitional: n, paramsSerializer: s, headers: o } = r;
    n !== void 0 && Wt.assertOptions(n, {
      silentJSONParsing: me.transitional(me.boolean),
      forcedJSONParsing: me.transitional(me.boolean),
      clarifyTimeoutError: me.transitional(me.boolean)
    }, !1), s != null && (d.isFunction(s) ? r.paramsSerializer = {
      serialize: s
    } : Wt.assertOptions(s, {
      encode: me.function,
      serialize: me.function
    }, !0)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let i;
    i = o && d.merge(
      o.common,
      o[r.method]
    ), i && d.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete o[h];
      }
    ), r.headers = he.concat(i, o);
    const c = [];
    let l = !0;
    this.interceptors.request.forEach(function(E) {
      typeof E.runWhen == "function" && E.runWhen(r) === !1 || (l = l && E.synchronous, c.unshift(E.fulfilled, E.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(E) {
      u.push(E.fulfilled, E.rejected);
    });
    let f, y = 0, b;
    if (!l) {
      const h = [Ur.bind(this), void 0];
      for (h.unshift.apply(h, c), h.push.apply(h, u), b = h.length, f = Promise.resolve(r); y < b; )
        f = f.then(h[y++], h[y++]);
      return f;
    }
    b = c.length;
    let g = r;
    for (y = 0; y < b; ) {
      const h = c[y++], E = c[y++];
      try {
        g = h(g);
      } catch (R) {
        E.call(this, R);
        break;
      }
    }
    try {
      f = Ur.call(this, g);
    } catch (h) {
      return Promise.reject(h);
    }
    for (y = 0, b = u.length; y < b; )
      f = f.then(u[y++], u[y++]);
    return f;
  }
  getUri(e) {
    e = Ie(this.defaults, e);
    const r = yn(e.baseURL, e.url);
    return hn(r, e.params, e.paramsSerializer);
  }
}
d.forEach(["delete", "get", "head", "options"], function(e) {
  at.prototype[e] = function(r, n) {
    return this.request(Ie(n || {}, {
      method: e,
      url: r,
      data: (n || {}).data
    }));
  };
});
d.forEach(["post", "put", "patch"], function(e) {
  function r(n) {
    return function(o, i, c) {
      return this.request(Ie(c || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: i
      }));
    };
  }
  at.prototype[e] = r(), at.prototype[e + "Form"] = r(!0);
});
const st = at;
class Zt {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners)
        return;
      let o = n._listeners.length;
      for (; o-- > 0; )
        n._listeners[o](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let o;
      const i = new Promise((c) => {
        n.subscribe(c), o = c;
      }).then(s);
      return i.cancel = function() {
        n.unsubscribe(o);
      }, i;
    }, e(function(o, i, c) {
      n.reason || (n.reason = new He(o, i, c), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(e);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new Zt(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
}
const Uo = Zt;
function Do(t) {
  return function(r) {
    return t.apply(null, r);
  };
}
function Fo(t) {
  return d.isObject(t) && t.isAxiosError === !0;
}
const zt = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(zt).forEach(([t, e]) => {
  zt[e] = t;
});
const Mo = zt;
function wn(t) {
  const e = new st(t), r = en(st.prototype.request, e);
  return d.extend(r, st.prototype, e, { allOwnKeys: !0 }), d.extend(r, e, null, { allOwnKeys: !0 }), r.create = function(s) {
    return wn(Ie(t, s));
  }, r;
}
const B = wn(Yt);
B.Axios = st;
B.CanceledError = He;
B.CancelToken = Uo;
B.isCancel = gn;
B.VERSION = En;
B.toFormData = pt;
B.AxiosError = A;
B.Cancel = B.CanceledError;
B.all = function(e) {
  return Promise.all(e);
};
B.spread = Do;
B.isAxiosError = Fo;
B.mergeConfig = Ie;
B.AxiosHeaders = he;
B.formToJSON = (t) => mn(d.isHTMLForm(t) ? new FormData(t) : t);
B.HttpStatusCode = Mo;
B.default = B;
const jo = B;
let $o = () => ({
  emit(t, ...e) {
    for (let r = this.events[t] || [], n = 0, s = r.length; n < s; n++)
      r[n](...e);
  },
  events: {},
  on(t, e) {
    var r;
    return ((r = this.events)[t] || (r[t] = [])).push(e), () => {
      var n;
      this.events[t] = (n = this.events[t]) == null ? void 0 : n.filter((s) => e !== s);
    };
  }
});
class Bo {
  constructor() {
    m(this, "remove", (e) => sessionStorage.removeItem(e));
  }
  set(e, r) {
    try {
      return sessionStorage.setItem(e, JSON.stringify(r)), !0;
    } catch {
      return !1;
    }
  }
  get(e) {
    try {
      const r = sessionStorage.getItem(e);
      return r ? JSON.parse(r) : null;
    } catch {
      return null;
    }
  }
}
const X = new Bo(), qo = "/api/users/userinfo", Wo = async (t) => {
  const e = `${t}${qo}`;
  return (await (await ye()).get(e)).data;
}, Nt = "piche", zo = "authorization_code", Ho = "password";
async function er(t, e, r) {
  const n = await ye(), s = `${t.location}/${e}${ms}`, o = new URLSearchParams({
    ...r,
    client_id: e
  });
  return (await n.post(s, o, {
    headers: { "Content-Type": "application/x-www-form-urlencoded" }
  })).data;
}
const Vo = (t, e) => er(e, t.clientId, {
  grant_type: zo,
  code: t.code,
  scope: t.scope,
  redirect_uri: t.redirectUri
}), Ko = (t, e) => er(e, t.clientId, {
  grant_type: Ho,
  username: t.userName,
  password: t.password,
  scope: t.scope
});
async function Go(t, e, r) {
  const n = await ye(), s = `${t.location}/${e}${gs}`, o = new URLSearchParams({ client_id: e, refresh_token: r });
  await n.post(s, o, { headers: { "Content-Type": "application/x-www-form-urlencoded" } });
}
const Jo = (t, e) => er(e, t.client_id, {
  grant_type: ut.refreshToken,
  refresh_token: t.refresh_token
});
class Re {
  constructor(e, r, n) {
    m(this, "error");
    m(this, "response");
    m(this, "statusCode");
    m(this, "isError", () => this.statusCode === Ue.ERROR);
    this.error = e, this.response = r, this.statusCode = n;
  }
  static Ok(e) {
    return new Re(void 0, e, Ue.OK);
  }
  static Error(e) {
    return new Re(e, void 0, Ue.ERROR);
  }
  static OperationRejected(e) {
    return new Re(void 0, e, Ue.OperationRejected);
  }
}
function* Qo(t, e, r) {
  for (; t < e; )
    yield t, t += r;
}
const Yo = async () => new Promise((t) => {
  const e = (r) => t(r);
  k.emitMessageAsync(Jr, e);
});
class $i {
  constructor(e) {
    m(this, "url");
    m(this, "handleRetry", (e, r, n) => {
      const s = e.shift();
      s == null ? n(Re.Error(new Error("retry count depleted"))) : setTimeout(() => r(), s);
    });
    m(this, "fetchOperationStatusAsync", async (e, r = "1.0") => new Promise((n) => {
      const s = Array.from(Qo(1, 10, 1), (i, c) => Math.pow(2, c) * 100), o = async () => {
        try {
          const i = await ei(this.url, e, r);
          switch (i.state) {
            case $t.Completed:
              n(Re.Ok(i));
              break;
            case $t.InProgress:
              this.handleRetry(s, o, n);
              break;
            default:
              n(Re.OperationRejected(i));
              break;
          }
        } catch (i) {
          be("Error while fetching for operation status", "error_fetching_operation", i), this.handleRetry(s, o, n);
        }
      };
      o();
    }));
    this.url = e;
  }
  subscribe() {
    k.subscribe(Jr, (e) => e.detail(this));
  }
}
const Xo = async (t, e) => {
  const n = (await e()).headers["x-operation"];
  if (t.pendingCreateOperationRequests -= 1, n == null)
    throw Error("operation id not found");
  return t.operationIds.push({ operationId: n, time: Date.now() }), t.pendingCreateOperationRequests === 0 && t.emitter.emit("no-pending-create-operation-requests"), await (await Yo()).fetchOperationStatusAsync(n);
};
class Zo {
  constructor() {
    m(this, "queue", []);
    m(this, "tripWire", !1);
    m(this, "enqueue", (e) => {
      this.queue.push(e);
    });
    m(this, "dequeue", () => this.queue.shift());
  }
  get length() {
    return this.queue.length;
  }
  get isTripWire() {
    return this.tripWire;
  }
  set isTripWire(e) {
    this.tripWire = e;
  }
}
const ye = async () => new Promise((t) => {
  k.emitMessageAsync(
    Gr,
    (e) => t(e)
  );
});
class Bi {
  constructor(e) {
    m(this, "getLocale", () => this.locale);
    m(this, "setLocale", (e) => this.locale = e);
    m(this, "getAxiosInstance", () => this.instance);
    m(this, "identityService");
    m(this, "instance");
    m(this, "locale", "lv-LV");
    m(this, "userManager");
    m(this, "onRejected", async (e, r) => {
      var i, c, l, u;
      const n = e.config, s = this.identityService.storageKey, o = X.get(`${s}.refresh_token`);
      if (!o)
        throw new Error("Session expired");
      if (r.isTripWire)
        return new Promise((f, y) => {
          r.enqueue({ resolve: f, reject: y, config: n });
        });
      {
        r.isTripWire = !0;
        const f = {
          client_id: ((i = this.userManager) == null ? void 0 : i.tenantId) || "",
          refresh_token: o
        }, y = await Jo(f, this.identityService);
        for ((c = this.userManager) == null || c.storeToken(y, f.client_id), r.isTripWire = !1; r.length > 0; ) {
          const b = r.dequeue();
          b && (b.config.headers.Authorization = `${y.token_type} ${y.access_token}`, await ((l = this.instance) == null ? void 0 : l.request(b.config)));
        }
        return (u = this.instance) == null ? void 0 : u.request(n);
      }
    });
    this.identityService = e, setInterval(() => this.cleanupOperations(), 10 * 60 * 1e3);
  }
  setup(e) {
    this.userManager = e, this.instance = Object.assign(jo.create({ baseURL: {}.VITE_API_URL }), {
      operationIds: [],
      pendingCreateOperationRequests: 0,
      emitter: $o()
    }), this.instance.interceptors.request.use((n) => {
      var s, o;
      return (s = n.url) != null && s.includes("/protocol/openid-connect/") || (n.headers["x-piche-locale"] = this.locale), (o = this.userManager) != null && o.IsAuthenticated && (n.headers.Authorization = `Bearer ${this.userManager.AuthorizationToken}`), n;
    });
    const r = new Zo();
    this.instance.interceptors.response.use(
      (n) => n,
      async (n) => {
        var s;
        try {
          if (((s = n.response) == null ? void 0 : s.status) === 401)
            return await this.onRejected(n, r);
          throw n;
        } catch (o) {
          return Promise.reject(o);
        }
      }
    );
  }
  cleanupOperations() {
    if (!this.instance)
      return;
    const e = Date.now();
    this.instance.operationIds = this.instance.operationIds.filter(
      (r) => e - r.time <= 10 * 60 * 1e3
    );
  }
  subscribe() {
    k.subscribe(Gr, (e) => {
      e.detail(this.instance);
    });
  }
}
const Te = async (t) => {
  const e = await ye();
  return await t(e);
}, te = async (t) => {
  const e = await ye();
  return e.pendingCreateOperationRequests += 1, await Xo(e, async () => await t(e));
}, ei = async (t, e, r) => {
  const n = `${t}/api/operations/${e}?api-version=${r}`;
  return (await (await ye()).get(n)).data;
}, Ae = () => {
  function t() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return t() + t() + "-" + t() + "-" + t() + "-" + t() + "-" + t() + t() + t();
}, qi = () => (window && window.location && window.location.hostname) === "localhost", Lt = () => Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), ti = 1e4, De = /* @__PURE__ */ new Map(), ri = (t, e) => {
  if (De.size >= ti) {
    const r = De.keys().next().value;
    r && De.delete(r);
  }
  De.set(t, e);
}, ni = [
  [//g, "ss"],
  [/[]/g, "ae"],
  [/[]/g, "oe"],
  [/[]/g, "th"],
  [/[]/g, "d"],
  [/[]/g, "l"],
  [/[]/g, "o"],
  [/[]/g, "c"],
  [/[]/g, "n"]
], Mr = (t) => {
  if (t == null)
    return "";
  const e = String(t), r = De.get(e);
  if (r !== void 0)
    return r;
  let n = e.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  for (const [s, o] of ni)
    n = n.replace(s, o);
  return n = n.toLowerCase(), ri(e, n), n;
}, Wi = (t, e) => Mr(t).includes(Mr(e)), si = 1e4, rr = class {
  constructor() {
    m(this, "eventListeners", /* @__PURE__ */ new Map());
    m(this, "requestHandlers", /* @__PURE__ */ new Map());
    m(this, "pendingRequests", /* @__PURE__ */ new Map());
    m(this, "errorListeners", /* @__PURE__ */ new Set());
  }
  static getInstance() {
    return this.instance || (this.instance = new rr()), this.instance;
  }
  onError(e) {
    return this.errorListeners.add(e), () => this.errorListeners.delete(e);
  }
  onEvent(e, r, n) {
    let s = this.eventListeners.get(e);
    s || (s = /* @__PURE__ */ new Set(), this.eventListeners.set(e, s));
    const o = (i) => {
      try {
        r(i);
      } catch (c) {
        this.emitError(c, { message: i, localErrorHandler: n });
      }
    };
    return s.add(o), () => {
      s == null || s.delete(o), (s == null ? void 0 : s.size) === 0 && this.eventListeners.delete(e);
    };
  }
  emit(e, r, n, s) {
    const o = {
      id: Ae(),
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "event",
      event: e,
      payload: r
    };
    this.deliverMessage(o);
  }
  onRequest(e, r) {
    return this.requestHandlers.set(e, r), () => {
      this.requestHandlers.delete(e);
    };
  }
  async request(e, r, n, s) {
    const o = Ae(), i = {
      id: o,
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "request",
      action: e,
      payload: r,
      expectsResponse: !0,
      requestId: o
    };
    return new Promise((c, l) => {
      const u = setTimeout(() => {
        this.pendingRequests.delete(o), l(new Error(`Request "${String(e)}" timed out`));
      }, si);
      this.pendingRequests.set(o, { resolve: c, reject: l, timeout: u }), this.deliverMessage(i);
    });
  }
  respond(e, r, n, s, o) {
    const i = {
      id: Ae(),
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "response",
      action: r,
      requestId: e,
      payload: o,
      success: !0
    };
    this.deliverMessage(i);
  }
  deliverMessage(e) {
    switch (e.type) {
      case "event":
        this.handleEvent(e);
        break;
      case "request":
        this.handleRequest(e);
        break;
      case "response":
        this.handleResponse(e);
        break;
      default:
        console.warn("[MessageBus] Unknown message type:", e);
    }
  }
  handleEvent(e) {
    const r = this.eventListeners.get(e.event);
    if (r)
      for (const n of r)
        try {
          n(e);
        } catch (s) {
          this.emitError(s, { message: e });
        }
  }
  handleRequest(e) {
    const r = e.action, n = this.requestHandlers.get(r);
    if (!n) {
      this.respondError(
        e.id,
        r,
        e.source,
        e.target,
        `No handler registered for action "${String(r)}"`
      );
      return;
    }
    try {
      const s = n(e.payload);
      Promise.resolve(s).then((o) => {
        this.respond(e.id, r, e.source, e.target, o);
      }).catch((o) => {
        this.respondError(e.id, r, e.source, e.target, o.message);
      });
    } catch (s) {
      const o = s instanceof Error ? s : new Error(String(s));
      this.respondError(e.id, r, e.source, e.target, o.message);
    }
  }
  handleResponse(e) {
    const r = this.pendingRequests.get(e.requestId);
    r && (clearTimeout(r.timeout), this.pendingRequests.delete(e.requestId), e.success ? r.resolve(e.payload) : r.reject(new Error(e.error ?? "Unknown error")));
  }
  respondError(e, r, n, s, o) {
    const i = {
      id: Ae(),
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "response",
      action: r,
      requestId: e,
      payload: {},
      success: !1,
      error: o
    };
    this.deliverMessage(i);
  }
  emitError(e, r) {
    const n = e instanceof Error ? e : new Error(String(e));
    if (r != null && r.localErrorHandler)
      try {
        r.localErrorHandler(n, r.message);
        return;
      } catch (s) {
        console.error("[MessageBus] Error in localErrorHandler", s);
      }
    if (this.errorListeners.size > 0) {
      for (const s of this.errorListeners)
        try {
          s(n, r);
        } catch (o) {
          console.error("[MessageBus] Error in global error listener", o);
        }
      return;
    }
    console.error("[MessageBus] Unhandled error", n, r == null ? void 0 : r.message);
  }
};
let Me = rr;
m(Me, "instance");
const zi = Me.getInstance(), Ht = Symbol.for("__picheBridge_internal");
function Hi() {
  if (window[Ht])
    return;
  const t = Me.getInstance();
  window[Ht] = { messageBus: t };
}
function oi() {
  const t = window[Ht];
  if (!t)
    throw new Error("Bridge not initialized. Call initializeBridge() first.");
  return t;
}
function bn() {
  return es(() => {
    try {
      return oi().messageBus;
    } catch (e) {
      console.warn(e);
    }
  }, []);
}
function Vi(t, e) {
  const r = bn(), n = fe(e);
  G(() => {
    n.current = e;
  }, [e]), G(() => r == null ? void 0 : r.onEvent(t, (o) => {
    n.current(o);
  }), [t, r]);
}
function Ki(t, e) {
  const r = bn(), n = fe(e);
  G(() => {
    n.current = e;
  }, [e]), G(() => r == null ? void 0 : r.onRequest(t, (o) => n.current(o)), [t, r]);
}
class ii {
  constructor() {
    m(this, "listeners", {});
    m(this, "addListener", (e, r) => this.storeListener(e, r, !1));
    m(this, "on", (e, r) => this.addListener(e, r));
    m(this, "subscribe", (e, r) => (this.on(e, r), { unsubscribe: () => this.off(e, r) }));
    m(this, "addOnceListener", (e, r) => this.storeListener(e, r, !0));
    m(this, "once", (e, r) => this.addOnceListener(e, r));
    m(this, "removeListener", (e, r) => this.listeners[e] ? this.listeners[e].length ? r ? (this.listeners[e] = this.listeners[e].filter((n) => n.listener !== r), this) : (delete this.listeners[e], this) : this : this);
    m(this, "emit", (e, r) => this.listeners[e] ? (this.listeners[e].forEach((n) => {
      Promise.resolve().then(() => {
        n.listener.apply(this, [r]), n.once && this.removeListener(e, n.listener);
      });
    }), this) : this);
    m(this, "storeListener", (e, r, n) => (this.listeners[e] = this.listeners[e] || [], this.listeners[e].push({ listener: r, once: n }), this));
  }
  off(e, r) {
    return this.removeListener(e, r);
  }
}
const ai = async (t, e) => {
  const r = {
    headers: {
      "Content-Type": "application/json;charset=UTF-8",
      "Access-Control-Allow-Origin": "*"
    },
    withCredentials: !1
  };
  r.headers = { ...r.headers, ...e.headers }, await (await ye()).post(e.url, t, r);
}, jr = "logger.id", ci = "logger.console", ui = {
  [z.INFO]: console.info,
  [z.ERROR]: console.error,
  [z.DEBUG]: console.debug,
  [z.WARN]: console.warn,
  [z.ALERT]: console.info,
  [z.EMERGENCY]: console.error,
  [z.CRITICAL]: console.error
}, Be = class {
  constructor(e) {
    m(this, "loggerId");
    m(this, "options");
    m(this, "messages", []);
    m(this, "interval");
    m(this, "events", new ii());
    m(this, "lastTimeLogsWasSent", 0);
    m(this, "getKey", (e) => re.ofNullable(localStorage.getItem(e)));
    m(this, "setKey", (e, r) => localStorage.setItem(e, r));
    m(this, "isConsoleOutputEnabled", () => this.getKey(ci).orElse("false") === "true");
    m(this, "enableRemoteLogging", () => {
      if (!this.options.remote)
        throw Error("Remote options not set");
      return this.startLogSending(), this;
    });
    m(this, "log", (e, r, n, s, o) => {
      const i = {
        id: Ae(),
        version: "1.0",
        loggerId: this.loggerId,
        identity: this.getLogIdentity(),
        text: e,
        code: r,
        logLevel: n,
        timestamp: Lt()
      };
      return s && (i.error = {
        message: s.message || "",
        stack: s.stack || ""
      }), this.write(i, n, o || ""), i;
    });
    m(this, "getStoredLogLevel", (e) => {
      const r = this.getKey(e);
      if (!r.isPresent())
        return !1;
      const n = z[r.get()];
      return n || z.ERROR;
    });
    m(this, "enableEventDrivenLogging", () => {
      const e = (r) => {
        const n = r.detail;
        setTimeout(() => this.log(n.message, n.code, n.level, n.error, n.nameSpace), 0);
      };
      return k.subscribe(Vr, e), this;
    });
    m(this, "canWriteLog", (e, r) => {
      const n = this.getStoredLogLevel(`${Or}*`), s = this.getStoredLogLevel(`${Or}${r || "*"}`);
      return s ? e <= s : n ? e <= n : e <= z.INFO;
    });
    m(this, "write", (e, r, n) => {
      this.canWriteLog(r, n) && this.events.emit(Be.WRITE_LOG_EVENT, e);
    });
    m(this, "handleConsole", (e) => {
      this.isConsoleOutputEnabled() && ui[e.logLevel](e);
    });
    m(this, "handleRemote", (e) => {
      this.interval && (this.resetLastTimeLogsWasSent(), this.messages.push(e));
    });
    m(this, "resetLastTimeLogsWasSent", () => {
      this.messages.length === 0 && (this.lastTimeLogsWasSent = Lt());
    });
    m(this, "getLogIdentity", () => {
      var r;
      const e = { userId: _r };
      return this.options.userManager && this.options.userManager.IsAuthenticated && this.options.userManager.userInfo() !== void 0 && (e.userId = ((r = this.options.userManager.userInfo()) == null ? void 0 : r.id) || _r), e;
    });
    m(this, "getLoggerId", () => this.getKey(jr).orElseGet(() => this.createLoggerId()));
    m(this, "createLoggerId", () => {
      const e = Ae();
      return this.setKey(jr, e), e;
    });
    m(this, "startLogSending", () => {
      clearInterval(this.interval), this.interval = setInterval(this.checkForLogsToSend, 1e3);
    });
    m(this, "checkForLogsToSend", () => {
      if (!this.isThereSomethingToSend())
        return;
      const e = this.cloneLogMessages();
      this.clearLogMessages();
      const r = async (n) => {
        try {
          await ai(e, this.options.remote);
        } catch (s) {
          this.log("Log send error", "log_send_error", z.ERROR, s), setTimeout(() => r(Math.pow(2, n)), n * 1e3);
        }
      };
      setTimeout(() => r(1), 0);
    });
    m(this, "cloneLogMessages", () => this.messages.slice(0));
    m(this, "clearLogMessages", () => {
      this.messages = [];
    });
    m(this, "isSendTimeReached", () => {
      const e = this.options.remote.sendIntervalInSeconds || 60;
      return Lt() - this.lastTimeLogsWasSent > e;
    });
    m(this, "isThereSomethingToSend", () => {
      const e = this.messages.length, r = this.options.remote.batchSize || 0;
      return e !== 0 && (e >= r || this.isSendTimeReached());
    });
    this.loggerId = this.getLoggerId(), this.options = e, this.events.subscribe(Be.WRITE_LOG_EVENT, this.handleConsole), this.events.subscribe(Be.WRITE_LOG_EVENT, this.handleRemote);
  }
};
let xt = Be;
m(xt, "WRITE_LOG_EVENT", "write_log_event");
const ve = async () => new Promise((t) => {
  k.emitMessageAsync(Qr, (e) => t(e));
});
class Gi {
  constructor(e) {
    m(this, "config", { apiUrl: "", domain: "", graphQLUrl: "", signalRUrl: "", hubLinkUrl: "" });
    this.config = e;
  }
  subscribe() {
    k.subscribe(Qr, (e) => {
      e.detail(this.config);
    });
  }
}
const Vt = () => new Promise((t) => {
  const e = (r) => {
    t(r);
  };
  k.emitMessageAsync(Xr, { consumerUserManager: e });
});
class Ji {
  constructor(e) {
    m(this, "accessToken");
    m(this, "refreshToken");
    m(this, "expiresIn");
    m(this, "userInformation");
    m(this, "identityService");
    m(this, "tenantId", Nt);
    m(this, "userInfo", () => this.userInformation);
    m(this, "loginWithCodeAsync", async (e) => this.processLogin(e, e.type, Vo));
    m(this, "loginAsync", async (e) => this.processLogin(e, ut.password, Ko));
    m(this, "tryAutoLogin", async () => {
      const e = X.get(`${this.identityService.storageKey}.access_token`), r = X.get(`${this.identityService.storageKey}.expireDate`), n = X.get(`${this.identityService.storageKey}.tenantId`);
      if (!r)
        return Promise.resolve();
      if (/* @__PURE__ */ new Date() < new Date(r)) {
        this.accessToken = e || void 0, this.expiresIn = new Date(r), this.tenantId = n ?? "";
        try {
          await this.getUserInformation();
        } catch (o) {
          be("Unable to retrieve user information", "user_info_fetch_error", o, "UserManager"), this.logout();
        }
      }
      return Promise.resolve();
    });
    m(this, "logout", async () => {
      const e = this.userInformation;
      if (this.refreshToken)
        try {
          await Go(this.identityService, this.tenantId, this.refreshToken);
        } catch (r) {
          be("KC logout failed", "kc_logout_failed", r, "UserManager");
        }
      this.removeSessionFromBrowser(), this.accessToken = void 0, this.refreshToken = void 0, this.expiresIn = void 0, this.userInformation = void 0, k.emitMessageAsync(ps, e);
    });
    m(this, "getUserInformation", async () => {
      const e = await ve(), { name: r, role: n, sub: s } = await Wo(e.apiUrl), o = typeof n == "string" ? [n] : n;
      this.userInformation = {
        id: s,
        name: r,
        roles: o,
        tenantId: this.tenantId
      };
    });
    m(this, "setupEventListener", () => {
      k.subscribe(Xr, (e) => {
        e.detail.consumerUserManager(this);
      });
    });
    this.identityService = e;
  }
  get IsAuthenticated() {
    return !this.accessToken || !this.expiresIn ? !1 : /* @__PURE__ */ new Date() < this.expiresIn;
  }
  get AuthorizationToken() {
    return this.accessToken;
  }
  get RefreshToken() {
    return this.refreshToken;
  }
  subscribe() {
    this.setupEventListener();
  }
  async processLogin(e, r, n) {
    if (e.type !== r)
      return !1;
    try {
      const s = await n(e, this.identityService);
      this.storeToken(s, e.clientId);
      try {
        await this.getUserInformation();
      } catch (o) {
        return be("Unable to retrieve user information", "user_info_fetch_error", o, "UserManager"), !1;
      }
      return k.emitMessageAsync(hs, this.userInformation), vs("Authentication successful", "authentication_successful", void 0, "UserManager"), !0;
    } catch (s) {
      return be("Authentication failed", "authentication_unsuccessful", s, "UserManager"), !1;
    }
  }
  async resetPasswordAsync(e, r = Nt) {
    const s = `${(await ve()).apiUrl}/api/users/${r ?? this.tenantId}/${e}/reset`;
    return await te(async (o) => await o.get(s));
  }
  async updatePasswordAsync(e, r = Nt) {
    const s = `${(await ve()).apiUrl}/api/users/${r}/update-password`;
    return await te(async (o) => await o.post(s, e));
  }
  async registerAsync(e, r) {
    const s = `${(await ve()).apiUrl}/api/public/${this.tenantId}/user-invites/${r}`;
    return await te(async (o) => await o.post(s, e));
  }
  removeSessionFromBrowser() {
    X.remove(`${this.identityService.storageKey}.access_token`), X.remove(`${this.identityService.storageKey}.refresh_token`), X.remove(`${this.identityService.storageKey}.expireDate`), X.remove(`${this.identityService.storageKey}.tenantId`);
  }
  storeToken(e, r) {
    const n = e.access_token, s = e.refresh_token, o = new Date((/* @__PURE__ */ new Date()).getTime() + e.expires_in * 1e3);
    X.set(`${this.identityService.storageKey}.access_token`, n), X.set(`${this.identityService.storageKey}.refresh_token`, s), X.set(`${this.identityService.storageKey}.expireDate`, o.toString()), X.set(`${this.identityService.storageKey}.tenantId`, r), this.accessToken = n, this.refreshToken = s, this.expiresIn = o, this.tenantId = r;
  }
}
const li = () => {
  const [t, e] = ae(""), [r, n] = ae(""), [s, o] = ae(!0), [i, c] = ae(!1), { setCurrentUser: l } = ds(), u = async (g) => {
    g.preventDefault();
    try {
      c(!0);
      const h = await Vt();
      await h.loginAsync({
        scope: "email openid profile",
        clientId: "piche",
        password: r,
        userName: t,
        type: ut.password
      });
      const E = h.userInfo();
      l(E);
    } finally {
      c(!1);
    }
  }, f = (g) => {
    e(g.target.value);
  }, y = (g) => {
    n(g.target.value);
  }, b = (g) => {
    o(g.target.checked);
  };
  return /* @__PURE__ */ P.jsx("div", { className: "piche-login", children: /* @__PURE__ */ P.jsxs(
    "form",
    {
      className: "form",
      onSubmit: u,
      children: [
        /* @__PURE__ */ P.jsxs("div", { className: "form__text-wrapper", children: [
          /* @__PURE__ */ P.jsx("h1", { className: "form__title", children: "Sign In" }),
          /* @__PURE__ */ P.jsx("div", { className: "form__subtitle", children: "Piche Bosio" })
        ] }),
        /* @__PURE__ */ P.jsxs("div", { className: "form__group", children: [
          /* @__PURE__ */ P.jsx("label", { htmlFor: "email", children: "Email address" }),
          /* @__PURE__ */ P.jsx(
            "input",
            {
              name: "email",
              type: "email",
              id: "email",
              value: t,
              onChange: f,
              placeholder: "Enter email",
              autoComplete: "email"
            }
          )
        ] }),
        /* @__PURE__ */ P.jsxs("div", { className: "form__group", children: [
          /* @__PURE__ */ P.jsx("label", { htmlFor: "password", children: "Password" }),
          /* @__PURE__ */ P.jsx(
            "input",
            {
              name: "password",
              type: "password",
              id: "password",
              value: r,
              onChange: y,
              placeholder: "Password",
              autoComplete: "current-password"
            }
          )
        ] }),
        /* @__PURE__ */ P.jsxs("div", { className: "form__remember-me", children: [
          /* @__PURE__ */ P.jsx(
            "input",
            {
              type: "checkbox",
              checked: s,
              onChange: b,
              id: "remember-me"
            }
          ),
          /* @__PURE__ */ P.jsx("label", { htmlFor: "remember-me", children: "Remember Me" })
        ] }),
        /* @__PURE__ */ P.jsx(
          "button",
          {
            disabled: i,
            type: "submit",
            children: "Continue"
          }
        )
      ]
    }
  ) });
}, Qi = ({ children: t, withLogin: e }) => {
  const [r, n] = ae(), [s, o] = ae(!0), i = () => {
    n(void 0), Vt().then((l) => l.logout());
  };
  G(() => {
    o(!0);
    try {
      Vt().then((l) => l.userInfo && n(l.userInfo())).finally(() => o(!1));
    } catch (l) {
      o(!1), be("LoginPage init error", "login_init", l, "AuthInit");
    }
  }, []);
  const c = !r && e;
  return /* @__PURE__ */ P.jsx(Hr.Provider, { value: { currentUser: r, currentUserLoading: s, setCurrentUser: n, logout: i }, children: c ? /* @__PURE__ */ P.jsx(li, {}) : t });
};
class vn {
  constructor() {
    m(this, "cache", {});
  }
  get(e, r) {
    const n = this.getCacheKey(e, r), s = this.cache[n];
    if (s)
      return s.data;
  }
  set(e, r, n, s) {
    const o = this.getCacheKey(e, r), i = this.cache[o];
    i && clearTimeout(i.timeout), this.cache[o] = {
      data: n,
      timeout: setTimeout(() => {
        this.clearCacheKey(e, r);
      }, s),
      cacheClearTime: s
    };
  }
  clearCacheKey(e, r) {
    const n = this.getCacheKey(e, r), s = this.cache[n];
    s && (clearTimeout(s.timeout), delete this.cache[n]);
  }
  getCacheKey(e, r) {
    return `${e}_${r}`;
  }
}
const di = new vn();
class Yi {
  constructor(e) {
    m(this, "requestQueue", {});
    m(this, "configuration");
    m(this, "tableCache", new vn());
    this.configuration = e, this.tableCache = di;
  }
  subscribe() {
    k.subscribe(ys, (e) => {
      e.detail(this);
    });
  }
  async request(e, r) {
    if (this.tableCache) {
      const o = this.tableCache.get(e, r);
      if (o)
        return Promise.resolve(o);
    }
    this.requestQueue[e] || (this.requestQueue[e] = {
      ids: {},
      timeout: null
    });
    const n = this.requestQueue[e];
    if (n.ids[r] !== void 0)
      return n.ids[r].promise;
    n.ids[r] = {};
    const s = new Promise((o, i) => {
      n.ids[r].resolver = { resolve: o, reject: i };
    });
    return n.ids[r].promise = s, Object.keys(n.ids).length >= this.configuration.maxBatchSize ? await this.executeBatchRequest(e) : (n.timeout && clearTimeout(n.timeout), n.timeout = setTimeout(async () => {
      await this.executeBatchRequest(e);
    }, this.configuration.debounceTime)), s;
  }
  async executeBatchRequest(e) {
    const r = this.requestQueue[e];
    r.timeout && (clearTimeout(r.timeout), r.timeout = null);
    const n = r.ids;
    r.ids = {};
    const i = (await (await ye()).post(
      this.configuration.apiTemplateUrl.replace("[table]", e),
      Object.keys(n).map((c) => c)
    )).data;
    if (i != null) {
      const c = /* @__PURE__ */ new Map();
      i.rows.forEach((l) => {
        c.set(l.id, l);
      }), Object.keys(n).forEach((l) => {
        const u = c.get(l);
        n[l].resolver.resolve(u), this.tableCache && this.tableCache.set(e, l, u, this.configuration.cacheClearTime);
      });
    } else
      Object.keys(n).forEach((c) => {
        n[c].resolver.resolve(void 0);
      });
  }
}
const Xi = (t) => k.emitMessageAsync(fs, { url: t }), fi = `
query GetContacts($tenantId: String!, $userId: String!) {
  contacts(tenantId: $tenantId, userIds: [$userId]) {
    id
    userId
    name
    avatarUrl
    avatarColor
    email
    details
    phone
    birthDate
    phoneNumbers
    address
    company
    socialMedia
    statusMessage
    additionalEmails
    publicColumns
    pathAlias
    coverImageUrl
    coverImageConfig
    user {
      id
    }
    positionId
    departmentId
    additionalAttributes
    department {
      id
      name
    }
    position {
      id
      jobTitle
    }
  }
}
`, hi = async (t, e) => {
  const { graphQLUrl: r } = await ve(), n = `${r}/graphql`;
  return await Te(
    async (s) => await s.post(n, { query: fi, variables: { tenantId: t, userId: e } })
  ).then((s) => s.data.data.contacts).catch((s) => {
    throw be("Error fetching contacts", "error_fetching_contacts", s), s;
  });
}, Zi = async () => new Promise((t) => {
  k.emitMessageAsync(
    Zr,
    (e) => t(e)
  );
});
class ea {
  constructor(e, r) {
    m(this, "_contactData", null);
    m(this, "_tenantId");
    m(this, "_userId");
    m(this, "_disposer", null);
    m(this, "_isInitialLoad", !0);
    this._tenantId = e, this._userId = r, ss(this), this.setReactions();
  }
  get contactData() {
    return this._contactData;
  }
  updateContactData(e) {
    Ye(() => {
      this._contactData = e;
    }), this._isInitialLoad || k.emitMessageAsync(bs, e);
  }
  updateContactDataSilent(e) {
    Ye(() => {
      this._contactData = e;
    });
  }
  updateUser(e, r) {
    (this._tenantId !== e || this._userId !== r) && (Ye(() => {
      this._tenantId = e, this._userId = r, this._contactData = null;
    }), this.restartReactions());
  }
  setReactions() {
    this._disposer = os(async () => {
      if (this._tenantId && this._userId)
        try {
          const e = await hi(this._tenantId, this._userId);
          Ye(() => {
            this._contactData = e[0], this._isInitialLoad = !1;
          });
        } catch (e) {
          console.error("Failed to fetch contact data", e);
        }
    });
  }
  restartReactions() {
    this._disposer && this._disposer(), this.setReactions();
  }
  subscribe() {
    k.subscribe(Zr, (e) => {
      e.detail(this);
    });
  }
  dispose() {
    this._disposer && (this._disposer(), this._disposer = null);
  }
}
class We {
}
m(We, "buildQuery", (e) => {
  const { skip: r = 0, search: n = "", orderBy: s = "", top: o = 30, filter: i = "", select: c = "" } = e, l = ["skip=" + r, "top=" + o];
  return n !== "" && l.push("search=" + n), s !== "" && l.push("orderBy=" + s), i !== "" && l.push("filter=" + i), c !== "" && l.push("select=" + c), "?" + l.filter((f) => f).join("&");
});
class pi {
  subscribe() {
    k.subscribe(Es, (e) => e.detail(this));
  }
  async getAsync(e, r) {
    const n = await this.getUrl(e, r), s = await Te(async (o) => await o.get(n));
    if (s.status == it)
      return s.data;
    throw new Error("Record not found");
  }
  async getAllAsync(e, r = Kr, n = 0) {
    const s = {
      skip: n,
      top: r
    }, o = We.buildQuery(s);
    let i = await this.getUrl(e);
    i = `${i}${o}`;
    const c = await Te(async (l) => await l.get(i));
    return this.getDataOrThrowRecordNotFound(c);
  }
  async filterAsync(e) {
    const { table: r } = e;
    if (!r)
      throw new Error("Table name is required");
    const n = We.buildQuery(e);
    let s = await this.getUrl(r);
    s = `${s}${n}`;
    const o = await Te(async (i) => await i.get(s));
    return this.getDataOrThrowRecordNotFound(o);
  }
  async updateAsync(e, r, n) {
    const s = await this.getUrl(e, r);
    return await te(async (o) => await o.put(s, n));
  }
  async insertAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.post(n, r));
  }
  async bulkInsertAsync(e, r) {
    const n = await this.getUrl(e), s = await this.insertRowsAsync(r, n);
    return this.formatInsertResults(s);
  }
  async deleteOneAsync(e, r) {
    return await this.deleteManyAsync(e, [r]);
  }
  async deleteManyAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.delete(n, { data: r }));
  }
  async getUrl(e, r = "") {
    return `${(await ve()).apiUrl}/api/tables/${e}/rows${r === "" ? "" : `/${r}`}`;
  }
  getDataOrThrowRecordNotFound(e) {
    if (e.status == it)
      return e.data;
    throw new Error("Record not found");
  }
  async insertRowsAsync(e, r) {
    const n = [];
    for (let o = 0; o < e.length; o++)
      n.push(te(async (i) => await i.post(r, e[o])));
    return await Promise.all(n);
  }
  formatInsertResults(e) {
    return e.map((r) => {
      var n;
      return {
        rowId: (n = r.response) == null ? void 0 : n.resourceId,
        success: r.statusCode,
        error: r.error
      };
    });
  }
}
const ta = new pi();
class mi {
  subscribe() {
    k.subscribe(ws, (e) => e.detail(this));
  }
  async getAsync(e, r) {
    const n = await this.getUrl(e, r), s = await Te(async (o) => await o.get(n));
    if (s.status == it)
      return s.data;
    throw new Error("Record not found");
  }
  async getAllAsync(e, r = Kr, n = 0) {
    const s = {
      skip: n,
      top: r
    }, o = We.buildQuery(s);
    let i = await this.getUrl(e);
    i = `${i}${o}`;
    const c = await Te(async (l) => await l.get(i));
    return this.getDataOrThrowRecordNotFound(c);
  }
  async filterAsync(e) {
    const { table: r } = e;
    if (!r)
      throw new Error("Table name is required");
    const n = We.buildQuery(e);
    let s = await this.getUrl(r);
    s = `${s}${n}`;
    const o = await Te(async (i) => await i.get(s));
    return this.getDataOrThrowRecordNotFound(o);
  }
  async updateAsync(e, r, n) {
    const s = await this.getUrl(e, r);
    return await te(async (o) => await o.put(s, n));
  }
  async insertAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.post(n, r));
  }
  async bulkInsertAsync(e, r) {
    const n = await this.getUrl(e), s = await this.insertRowsAsync(r, n);
    return this.formatInsertResults(s);
  }
  async deleteOneAsync(e, r) {
    return await this.deleteManyAsync(e, [r]);
  }
  async deleteManyAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.delete(n, { data: r }));
  }
  async getUrl(e, r = "") {
    return `${(await ve()).apiUrl}/api/views/${e}/rows${r === "" ? "" : `/${r}`}`;
  }
  getDataOrThrowRecordNotFound(e) {
    if (e.status == it)
      return e.data;
    throw new Error("Record not found");
  }
  async insertRowsAsync(e, r) {
    const n = [];
    for (let o = 0; o < e.length; o++)
      n.push(te(async (i) => await i.post(r, e[o])));
    return await Promise.all(n);
  }
  formatInsertResults(e) {
    return e.map((r) => {
      var n;
      return {
        rowId: (n = r.response) == null ? void 0 : n.resourceId,
        success: r.statusCode,
        error: r.error
      };
    });
  }
}
const ra = new mi(), tr = "PICHE_EVENT_APP_LOADING", na = () => k.emitMessageAsync(tr, !0), sa = () => k.emitMessageAsync(tr, !1), oa = ({ children: t, loading: e }) => {
  const [r, n] = ae(e);
  return G(() => {
    const s = k.subscribe(tr, (o) => n(o.detail));
    return () => {
      s.unsubscribe();
    };
  }, []), /* @__PURE__ */ P.jsxs(P.Fragment, { children: [
    /* @__PURE__ */ P.jsx("div", { className: us({ "h-100 w-100 d-flex": !r }, { "d-none": r }), children: t }),
    r && /* @__PURE__ */ P.jsx("div", { className: "pl__wrapper w-100 h-100", children: /* @__PURE__ */ P.jsxs("div", { className: "pl", children: [
      /* @__PURE__ */ P.jsx("div", { className: "pl__outer-ring" }),
      /* @__PURE__ */ P.jsx("div", { className: "pl__inner-ring" }),
      /* @__PURE__ */ P.jsx("div", { className: "pl__track-cover" }),
      /* @__PURE__ */ P.jsxs("div", { className: "pl__ball", children: [
        /* @__PURE__ */ P.jsx("div", { className: "pl__ball-texture" }),
        /* @__PURE__ */ P.jsx("div", { className: "pl__ball-outer-shadow" }),
        /* @__PURE__ */ P.jsx("div", { className: "pl__ball-inner-shadow" }),
        /* @__PURE__ */ P.jsx("div", { className: "pl__ball-side-shadows" })
      ] })
    ] }) })
  ] });
};
function Rn(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number")
    n += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = Rn(t[e])) && (n && (n += " "), n += r);
    else
      for (e in t)
        t[e] && (n && (n += " "), n += e);
  return n;
}
function ge() {
  for (var t, e, r = 0, n = ""; r < arguments.length; )
    (t = arguments[r++]) && (e = Rn(t)) && (n && (n += " "), n += e);
  return n;
}
const je = (t) => typeof t == "number" && !isNaN(t), _e = (t) => typeof t == "string", K = (t) => typeof t == "function", ot = (t) => _e(t) || K(t) ? t : null, kt = (t) => Ce(t) || _e(t) || K(t) || je(t);
function gi(t, e, r) {
  r === void 0 && (r = 300);
  const { scrollHeight: n, style: s } = t;
  requestAnimationFrame(() => {
    s.minHeight = "initial", s.height = n + "px", s.transition = `all ${r}ms`, requestAnimationFrame(() => {
      s.height = "0", s.padding = "0", s.margin = "0", setTimeout(e, r);
    });
  });
}
function yt(t) {
  let { enter: e, exit: r, appendPosition: n = !1, collapse: s = !0, collapseDuration: o = 300 } = t;
  return function(i) {
    let { children: c, position: l, preventExitTransition: u, done: f, nodeRef: y, isIn: b } = i;
    const g = n ? `${e}--${l}` : e, h = n ? `${r}--${l}` : r, E = fe(0);
    return ns(() => {
      const R = y.current, v = g.split(" "), _ = (D) => {
        D.target === y.current && (R.dispatchEvent(new Event("d")), R.removeEventListener("animationend", _), R.removeEventListener("animationcancel", _), E.current === 0 && D.type !== "animationcancel" && R.classList.remove(...v));
      };
      R.classList.add(...v), R.addEventListener("animationend", _), R.addEventListener("animationcancel", _);
    }, []), G(() => {
      const R = y.current, v = () => {
        R.removeEventListener("animationend", v), s ? gi(R, f, o) : f();
      };
      b || (u ? v() : (E.current = 1, R.className += ` ${h}`, R.addEventListener("animationend", v)));
    }, [b]), N.createElement(N.Fragment, null, c);
  };
}
function $r(t, e) {
  return t != null ? { content: t.content, containerId: t.props.containerId, id: t.props.toastId, theme: t.props.theme, type: t.props.type, data: t.props.data || {}, isLoading: t.props.isLoading, icon: t.props.icon, status: e } : {};
}
const Z = { list: /* @__PURE__ */ new Map(), emitQueue: /* @__PURE__ */ new Map(), on(t, e) {
  return this.list.has(t) || this.list.set(t, []), this.list.get(t).push(e), this;
}, off(t, e) {
  if (e) {
    const r = this.list.get(t).filter((n) => n !== e);
    return this.list.set(t, r), this;
  }
  return this.list.delete(t), this;
}, cancelEmit(t) {
  const e = this.emitQueue.get(t);
  return e && (e.forEach(clearTimeout), this.emitQueue.delete(t)), this;
}, emit(t) {
  this.list.has(t) && this.list.get(t).forEach((e) => {
    const r = setTimeout(() => {
      e(...[].slice.call(arguments, 1));
    }, 0);
    this.emitQueue.has(t) || this.emitQueue.set(t, []), this.emitQueue.get(t).push(r);
  });
} }, Xe = (t) => {
  let { theme: e, type: r, ...n } = t;
  return N.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: e === "colored" ? "currentColor" : `var(--toastify-icon-color-${r})`, ...n });
}, Ut = { info: function(t) {
  return N.createElement(Xe, { ...t }, N.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}, warning: function(t) {
  return N.createElement(Xe, { ...t }, N.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}, success: function(t) {
  return N.createElement(Xe, { ...t }, N.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}, error: function(t) {
  return N.createElement(Xe, { ...t }, N.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}, spinner: function() {
  return N.createElement("div", { className: "Toastify__spinner" });
} };
function yi(t) {
  const [, e] = rs((g) => g + 1, 0), [r, n] = ae([]), s = fe(null), o = fe(/* @__PURE__ */ new Map()).current, i = (g) => r.indexOf(g) !== -1, c = fe({ toastKey: 1, displayedToast: 0, count: 0, queue: [], props: t, containerId: null, isToastActive: i, getToast: (g) => o.get(g) }).current;
  function l(g) {
    let { containerId: h } = g;
    const { limit: E } = c.props;
    !E || h && c.containerId !== h || (c.count -= c.queue.length, c.queue = []);
  }
  function u(g) {
    n((h) => g == null ? [] : h.filter((E) => E !== g));
  }
  function f() {
    const { toastContent: g, toastProps: h, staleId: E } = c.queue.shift();
    b(g, h, E);
  }
  function y(g, h) {
    let { delay: E, staleId: R, ...v } = h;
    if (!kt(g) || function(H) {
      return !s.current || c.props.enableMultiContainer && H.containerId !== c.props.containerId || o.has(H.toastId) && H.updateId == null;
    }(v))
      return;
    const { toastId: _, updateId: D, data: C } = v, { props: L } = c, ne = () => u(_), se = D == null;
    se && c.count++;
    const q = { ...L, style: L.toastStyle, key: c.toastKey++, ...Object.fromEntries(Object.entries(v).filter((H) => {
      let [$, F] = H;
      return F != null;
    })), toastId: _, updateId: D, data: C, closeToast: ne, isIn: !1, className: ot(v.className || L.toastClassName), bodyClassName: ot(v.bodyClassName || L.bodyClassName), progressClassName: ot(v.progressClassName || L.progressClassName), autoClose: !v.isLoading && (oe = v.autoClose, pe = L.autoClose, oe === !1 || je(oe) && oe > 0 ? oe : pe), deleteToast() {
      const H = $r(o.get(_), "removed");
      o.delete(_), Z.emit(4, H);
      const $ = c.queue.length;
      if (c.count = _ == null ? c.count - c.displayedToast : c.count - 1, c.count < 0 && (c.count = 0), $ > 0) {
        const F = _ == null ? c.props.limit : 1;
        if ($ === 1 || F === 1)
          c.displayedToast++, f();
        else {
          const J = F > $ ? $ : F;
          c.displayedToast = J;
          for (let W = 0; W < J; W++)
            f();
        }
      } else
        e();
    } };
    var oe, pe;
    q.iconOut = function(H) {
      let { theme: $, type: F, isLoading: J, icon: W } = H, Q = null;
      const ie = { theme: $, type: F };
      return W === !1 || (K(W) ? Q = W(ie) : Ce(W) ? Q = Mt(W, ie) : _e(W) || je(W) ? Q = W : J ? Q = Ut.spinner() : ((Ee) => Ee in Ut)(F) && (Q = Ut[F](ie))), Q;
    }(q), K(v.onOpen) && (q.onOpen = v.onOpen), K(v.onClose) && (q.onClose = v.onClose), q.closeButton = L.closeButton, v.closeButton === !1 || kt(v.closeButton) ? q.closeButton = v.closeButton : v.closeButton === !0 && (q.closeButton = !kt(L.closeButton) || L.closeButton);
    let le = g;
    Ce(g) && !_e(g.type) ? le = Mt(g, { closeToast: ne, toastProps: q, data: C }) : K(g) && (le = g({ closeToast: ne, toastProps: q, data: C })), L.limit && L.limit > 0 && c.count > L.limit && se ? c.queue.push({ toastContent: le, toastProps: q, staleId: R }) : je(E) ? setTimeout(() => {
      b(le, q, R);
    }, E) : b(le, q, R);
  }
  function b(g, h, E) {
    const { toastId: R } = h;
    E && o.delete(E);
    const v = { content: g, props: h };
    o.set(R, v), n((_) => [..._, R].filter((D) => D !== E)), Z.emit(4, $r(v, v.props.updateId == null ? "added" : "updated"));
  }
  return G(() => (c.containerId = t.containerId, Z.cancelEmit(3).on(0, y).on(1, (g) => s.current && u(g)).on(5, l).emit(2, c), () => {
    o.clear(), Z.emit(3, c);
  }), []), G(() => {
    c.props = t, c.isToastActive = i, c.displayedToast = r.length;
  }), { getToastToRender: function(g) {
    const h = /* @__PURE__ */ new Map(), E = Array.from(o.values());
    return t.newestOnTop && E.reverse(), E.forEach((R) => {
      const { position: v } = R.props;
      h.has(v) || h.set(v, []), h.get(v).push(R);
    }), Array.from(h, (R) => g(R[0], R[1]));
  }, containerRef: s, isToastActive: i };
}
function Br(t) {
  return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientX : t.clientX;
}
function qr(t) {
  return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientY : t.clientY;
}
function Ei(t) {
  const [e, r] = ae(!1), [n, s] = ae(!1), o = fe(null), i = fe({ start: 0, x: 0, y: 0, delta: 0, removalDistance: 0, canCloseOnClick: !0, canDrag: !1, boundingRect: null, didMove: !1 }).current, c = fe(t), { autoClose: l, pauseOnHover: u, closeToast: f, onClick: y, closeOnClick: b } = t;
  function g(C) {
    if (t.draggable) {
      C.nativeEvent.type === "touchstart" && C.nativeEvent.preventDefault(), i.didMove = !1, document.addEventListener("mousemove", v), document.addEventListener("mouseup", _), document.addEventListener("touchmove", v), document.addEventListener("touchend", _);
      const L = o.current;
      i.canCloseOnClick = !0, i.canDrag = !0, i.boundingRect = L.getBoundingClientRect(), L.style.transition = "", i.x = Br(C.nativeEvent), i.y = qr(C.nativeEvent), t.draggableDirection === "x" ? (i.start = i.x, i.removalDistance = L.offsetWidth * (t.draggablePercent / 100)) : (i.start = i.y, i.removalDistance = L.offsetHeight * (t.draggablePercent === 80 ? 1.5 * t.draggablePercent : t.draggablePercent / 100));
    }
  }
  function h(C) {
    if (i.boundingRect) {
      const { top: L, bottom: ne, left: se, right: q } = i.boundingRect;
      C.nativeEvent.type !== "touchend" && t.pauseOnHover && i.x >= se && i.x <= q && i.y >= L && i.y <= ne ? R() : E();
    }
  }
  function E() {
    r(!0);
  }
  function R() {
    r(!1);
  }
  function v(C) {
    const L = o.current;
    i.canDrag && L && (i.didMove = !0, e && R(), i.x = Br(C), i.y = qr(C), i.delta = t.draggableDirection === "x" ? i.x - i.start : i.y - i.start, i.start !== i.x && (i.canCloseOnClick = !1), L.style.transform = `translate${t.draggableDirection}(${i.delta}px)`, L.style.opacity = "" + (1 - Math.abs(i.delta / i.removalDistance)));
  }
  function _() {
    document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", _), document.removeEventListener("touchmove", v), document.removeEventListener("touchend", _);
    const C = o.current;
    if (i.canDrag && i.didMove && C) {
      if (i.canDrag = !1, Math.abs(i.delta) > i.removalDistance)
        return s(!0), void t.closeToast();
      C.style.transition = "transform 0.2s, opacity 0.2s", C.style.transform = `translate${t.draggableDirection}(0)`, C.style.opacity = "1";
    }
  }
  G(() => {
    c.current = t;
  }), G(() => (o.current && o.current.addEventListener("d", E, { once: !0 }), K(t.onOpen) && t.onOpen(Ce(t.children) && t.children.props), () => {
    const C = c.current;
    K(C.onClose) && C.onClose(Ce(C.children) && C.children.props);
  }), []), G(() => (t.pauseOnFocusLoss && (document.hasFocus() || R(), window.addEventListener("focus", E), window.addEventListener("blur", R)), () => {
    t.pauseOnFocusLoss && (window.removeEventListener("focus", E), window.removeEventListener("blur", R));
  }), [t.pauseOnFocusLoss]);
  const D = { onMouseDown: g, onTouchStart: g, onMouseUp: h, onTouchEnd: h };
  return l && u && (D.onMouseEnter = R, D.onMouseLeave = E), b && (D.onClick = (C) => {
    y && y(C), i.canCloseOnClick && f();
  }), { playToast: E, pauseToast: R, isRunning: e, preventExitTransition: n, toastRef: o, eventHandlers: D };
}
function Tn(t) {
  let { closeToast: e, theme: r, ariaLabel: n = "close" } = t;
  return N.createElement("button", { className: `Toastify__close-button Toastify__close-button--${r}`, type: "button", onClick: (s) => {
    s.stopPropagation(), e(s);
  }, "aria-label": n }, N.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, N.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
}
function wi(t) {
  let { delay: e, isRunning: r, closeToast: n, type: s = "default", hide: o, className: i, style: c, controlledProgress: l, progress: u, rtl: f, isIn: y, theme: b } = t;
  const g = o || l && u === 0, h = { ...c, animationDuration: `${e}ms`, animationPlayState: r ? "running" : "paused", opacity: g ? 0 : 1 };
  l && (h.transform = `scaleX(${u})`);
  const E = ge("Toastify__progress-bar", l ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${b}`, `Toastify__progress-bar--${s}`, { "Toastify__progress-bar--rtl": f }), R = K(i) ? i({ rtl: f, type: s, defaultClassName: E }) : ge(E, i);
  return N.createElement("div", { role: "progressbar", "aria-hidden": g ? "true" : "false", "aria-label": "notification timer", className: R, style: h, [l && u >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: l && u < 1 ? null : () => {
    y && n();
  } });
}
const bi = (t) => {
  const { isRunning: e, preventExitTransition: r, toastRef: n, eventHandlers: s } = Ei(t), { closeButton: o, children: i, autoClose: c, onClick: l, type: u, hideProgressBar: f, closeToast: y, transition: b, position: g, className: h, style: E, bodyClassName: R, bodyStyle: v, progressClassName: _, progressStyle: D, updateId: C, role: L, progress: ne, rtl: se, toastId: q, deleteToast: oe, isIn: pe, isLoading: le, iconOut: H, closeOnClick: $, theme: F } = t, J = ge("Toastify__toast", `Toastify__toast-theme--${F}`, `Toastify__toast--${u}`, { "Toastify__toast--rtl": se }, { "Toastify__toast--close-on-click": $ }), W = K(h) ? h({ rtl: se, position: g, type: u, defaultClassName: J }) : ge(J, h), Q = !!ne || !c, ie = { closeToast: y, type: u, theme: F };
  let Ee = null;
  return o === !1 || (Ee = K(o) ? o(ie) : Ce(o) ? Mt(o, ie) : Tn(ie)), N.createElement(b, { isIn: pe, done: oe, position: g, preventExitTransition: r, nodeRef: n }, N.createElement("div", { id: q, onClick: l, className: W, ...s, style: E, ref: n }, N.createElement("div", { ...pe && { role: L }, className: K(R) ? R({ type: u }) : ge("Toastify__toast-body", R), style: v }, H != null && N.createElement("div", { className: ge("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !le }) }, H), N.createElement("div", null, i)), Ee, N.createElement(wi, { ...C && !Q ? { key: `pb-${C}` } : {}, rtl: se, theme: F, delay: c, isRunning: e, isIn: pe, closeToast: y, hide: f, type: u, style: D, className: _, controlledProgress: Q, progress: ne || 0 })));
}, Et = function(t, e) {
  return e === void 0 && (e = !1), { enter: `Toastify--animate Toastify__${t}-enter`, exit: `Toastify--animate Toastify__${t}-exit`, appendPosition: e };
}, vi = yt(Et("bounce", !0));
yt(Et("slide", !0));
yt(Et("zoom"));
yt(Et("flip"));
const Kt = ts((t, e) => {
  const { getToastToRender: r, containerRef: n, isToastActive: s } = yi(t), { className: o, style: i, rtl: c, containerId: l } = t;
  function u(f) {
    const y = ge("Toastify__toast-container", `Toastify__toast-container--${f}`, { "Toastify__toast-container--rtl": c });
    return K(o) ? o({ position: f, rtl: c, defaultClassName: y }) : ge(y, ot(o));
  }
  return G(() => {
    e && (e.current = n.current);
  }, []), N.createElement("div", { ref: n, className: "Toastify", id: l }, r((f, y) => {
    const b = y.length ? { ...i } : { ...i, pointerEvents: "none" };
    return N.createElement("div", { className: u(f), style: b, key: `container-${f}` }, y.map((g, h) => {
      let { content: E, props: R } = g;
      return N.createElement(bi, { ...R, isIn: s(R.toastId), style: { ...R.style, "--nth": h + 1, "--len": y.length }, key: `toast-${R.key}` }, E);
    }));
  }));
});
Kt.displayName = "ToastContainer", Kt.defaultProps = { position: "top-right", transition: vi, autoClose: 5e3, closeButton: Tn, pauseOnHover: !0, pauseOnFocusLoss: !0, closeOnClick: !0, draggable: !0, draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" };
let Dt, we = /* @__PURE__ */ new Map(), Fe = [], Ri = 1;
function _n() {
  return "" + Ri++;
}
function Ti(t) {
  return t && (_e(t.toastId) || je(t.toastId)) ? t.toastId : _n();
}
function $e(t, e) {
  return we.size > 0 ? Z.emit(0, t, e) : Fe.push({ content: t, options: e }), e.toastId;
}
function ct(t, e) {
  return { ...e, type: e && e.type || t, toastId: Ti(e) };
}
function Ze(t) {
  return (e, r) => $e(e, ct(t, r));
}
function U(t, e) {
  return $e(t, ct("default", e));
}
U.loading = (t, e) => $e(t, ct("default", { isLoading: !0, autoClose: !1, closeOnClick: !1, closeButton: !1, draggable: !1, ...e })), U.promise = function(t, e, r) {
  let n, { pending: s, error: o, success: i } = e;
  s && (n = _e(s) ? U.loading(s, r) : U.loading(s.render, { ...r, ...s }));
  const c = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, l = (f, y, b) => {
    if (y == null)
      return void U.dismiss(n);
    const g = { type: f, ...c, ...r, data: b }, h = _e(y) ? { render: y } : y;
    return n ? U.update(n, { ...g, ...h }) : U(h.render, { ...g, ...h }), b;
  }, u = K(t) ? t() : t;
  return u.then((f) => l("success", i, f)).catch((f) => l("error", o, f)), u;
}, U.success = Ze("success"), U.info = Ze("info"), U.error = Ze("error"), U.warning = Ze("warning"), U.warn = U.warning, U.dark = (t, e) => $e(t, ct("default", { theme: "dark", ...e })), U.dismiss = (t) => {
  we.size > 0 ? Z.emit(1, t) : Fe = Fe.filter((e) => t != null && e.options.toastId !== t);
}, U.clearWaitingQueue = function(t) {
  return t === void 0 && (t = {}), Z.emit(5, t);
}, U.isActive = (t) => {
  let e = !1;
  return we.forEach((r) => {
    r.isToastActive && r.isToastActive(t) && (e = !0);
  }), e;
}, U.update = function(t, e) {
  e === void 0 && (e = {}), setTimeout(() => {
    const r = function(n, s) {
      let { containerId: o } = s;
      const i = we.get(o || Dt);
      return i && i.getToast(n);
    }(t, e);
    if (r) {
      const { props: n, content: s } = r, o = { delay: 100, ...n, ...e, toastId: e.toastId || t, updateId: _n() };
      o.toastId !== t && (o.staleId = t);
      const i = o.render || s;
      delete o.render, $e(i, o);
    }
  }, 0);
}, U.done = (t) => {
  U.update(t, { progress: 1 });
}, U.onChange = (t) => (Z.on(4, t), () => {
  Z.off(4, t);
}), U.POSITION = { TOP_LEFT: "top-left", TOP_RIGHT: "top-right", TOP_CENTER: "top-center", BOTTOM_LEFT: "bottom-left", BOTTOM_RIGHT: "bottom-right", BOTTOM_CENTER: "bottom-center" }, U.TYPE = { INFO: "info", SUCCESS: "success", WARNING: "warning", ERROR: "error", DEFAULT: "default" }, Z.on(2, (t) => {
  Dt = t.containerId || t, we.set(Dt, t), Fe.forEach((e) => {
    Z.emit(0, e.content, e.options);
  }), Fe = [];
}).on(3, (t) => {
  we.delete(t.containerId || t), we.size === 0 && Z.off(0).off(1).off(5);
});
async function _i() {
  return new Promise((t) => {
    const e = (r) => {
      t(r);
    };
    k.emitMessageAsync(Yr, e);
  });
}
async function ia(t, e) {
  return (await _i())(t, e);
}
const aa = () => (G(() => {
  const t = k.subscribe(Yr, (e) => e.detail(U));
  return () => {
    t.unsubscribe();
  };
}, []), /* @__PURE__ */ P.jsx(Kt, {}));
var Gt, et = is;
if ("production".NODE_ENV === "production")
  Gt = et.createRoot, et.hydrateRoot;
else {
  var Wr = et.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  Gt = function(t, e) {
    Wr.usingClientEntryPoint = !0;
    try {
      return et.createRoot(t, e);
    } finally {
      Wr.usingClientEntryPoint = !1;
    }
  };
}
const Oi = {
  stringify: (t) => t ? "true" : "false",
  parse: (t) => /^[ty1-9]/i.test(t)
}, Si = {
  stringify: (t) => JSON.stringify(t),
  parse: (t) => JSON.parse(t)
}, Ai = {
  stringify: (t) => `${t}`,
  parse: (t) => parseFloat(t)
}, Ci = {
  stringify: (t) => t,
  parse: (t) => t
}, Ft = {
  string: Ci,
  number: Ai,
  boolean: Oi,
  json: Si
};
function Ii(t, e, r) {
  e.props || (e.props = t.propTypes ? Object.keys(t.propTypes) : []);
  const n = (Array.isArray(e.props) ? e.props.slice() : Object.keys(e.props)).filter((l) => l !== "container"), s = {}, o = {}, i = {};
  for (const l of n) {
    s[l] = Array.isArray(e.props) ? "string" : e.props[l];
    const u = Pi(l);
    o[l] = u, i[u] = l;
  }
  class c extends HTMLElement {
    constructor() {
      super();
      m(this, "connected", !0);
      m(this, "context");
      m(this, "props", {});
      m(this, "container");
      e.shadow ? this.container = this.attachShadow({
        mode: e.shadow
      }) : this.container = this, this.props.container = this.container;
      for (const f of n) {
        const y = o[f], b = this.getAttribute(y), g = s[f], h = Ft[g];
        b && (h != null && h.parse) && (this.props[f] = h.parse(b, this));
      }
    }
    static get observedAttributes() {
      return Object.keys(i);
    }
    connectedCallback() {
      this.connected = !0, this.render();
    }
    disconnectedCallback() {
      if (this.connected = !1, this.context !== void 0) {
        const f = this.context;
        this.context = void 0, setTimeout(() => r.unmount(f));
      }
    }
    attributeChangedCallback(f, y, b) {
      const g = i[f], h = s[g], E = Ft[h];
      g in s && (E != null && E.parse) && (this.props[g] = E.parse(b, this), this.render());
    }
    render() {
      this.connected && (this.context ? r.update(this.context, this.props) : this.context = r.mount(this.container, t, this.props));
    }
  }
  for (const l of n) {
    const u = o[l], f = s[l];
    Object.defineProperty(c.prototype, l, {
      enumerable: !0,
      configurable: !0,
      get() {
        return this.props[l];
      },
      set(y) {
        this.props[l] = y;
        const b = Ft[f];
        if (b != null && b.stringify) {
          const g = b.stringify(y);
          this.getAttribute(u) !== g && this.setAttribute(u, g);
        }
      }
    });
  }
  return c;
}
function Pi(t = "") {
  return t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function Ni(t, e, r) {
  const n = Gt(t), s = N.createElement(e, r);
  return n.render(s), {
    root: n,
    ReactComponent: e
  };
}
function Li({ root: t, ReactComponent: e }, r) {
  const n = N.createElement(e, r);
  t.render(n);
}
function xi({ root: t }) {
  t.unmount();
}
function ca(t, e = {}) {
  return Ii(t, e, { mount: Ni, update: Li, unmount: xi });
}
export {
  ut as AUTHENTICATION_TYPE,
  Bi as ApiClient,
  Gi as AppConfig,
  oa as AppLoadingScreen,
  Hr as AuthContext,
  Qi as AuthProvider,
  Tr as EmptyAction,
  Vr as LOGGER_EVENT_LISTENER,
  hs as LOGIN_SUCCESSFULLY_FOR_PORTAL_USER,
  gs as LOGOUT_PATH,
  ps as LOGOUT_SUCCESSFULLY_FOR_PORTAL_USER,
  Mi as LogDebug,
  be as LogError,
  vs as LogInfo,
  z as LogLevel,
  ji as LogWarn,
  xt as Logger,
  li as Login,
  Kr as MAX_ITEMS,
  Me as MessageBus,
  ii as MicroEmitter,
  fs as NAVIGATE_HOST,
  $i as OperationClient,
  $t as OperationResponseStatus,
  Re as OperationStatus,
  Ue as OperationStatusCode,
  aa as PicheToast,
  k as PortalMessage,
  ea as ProfileContactData,
  Gr as REQUEST_API_CLIENT_EVENT,
  Qr as REQUEST_API_CONFIGURATION_EVENT,
  Jr as REQUEST_OPERATION_CLIENT_EVENT,
  Xr as REQUEST_PORTAL_USER_MANAGER,
  Zr as REQUEST_PROFILE_CONTACT_STORE_EVENT,
  Yr as REQUEST_REACT_TOAST,
  Es as REQUEST_TABLE_CLIENT_EVENT,
  ys as REQUEST_TABLE_DATA_LOADER,
  ws as REQUEST_VIEW_CLIENT_EVENT,
  Zo as RequestQueue,
  it as STATUS_OK,
  Or as STORAGE_LOGGER_NAME_SPACE_PREFIX,
  ms as TOKEN_PATH,
  pi as TableClient,
  Yi as TableDataLoader,
  _r as UNKNOWN,
  bs as UPDATE_PROFILE_CONTACT,
  Ji as UserManager,
  ls as VideoRecordType,
  mi as ViewClient,
  Te as doAxiosAsync,
  te as doAxiosWithResult,
  oi as getBridge,
  Ae as guid,
  sa as hideAppLoading,
  Wi as includesNormalized,
  Hi as initializeBridge,
  qi as isLocal,
  zi as messageBus,
  Xi as navigateHost,
  Mr as normalizeEnglishForSearch,
  Yo as operationClient,
  ca as reactToWebComponent,
  ye as requestApiClientAsync,
  ve as requestApiConfigAsync,
  Zi as requestProfileContactStoreAsync,
  _i as requestToastAsync,
  Vt as requestUserManagerAsync,
  na as showAppLoading,
  ia as showMessage,
  ta as tableClient,
  Lt as unixTimestampUTC,
  ds as useAuth,
  Vi as useBusEvent,
  Ki as useBusRequest,
  bn as useMessageBus,
  ra as viewClient,
  Xo as waitForOperation
};
//# sourceMappingURL=index.js.map
