export type BridgeMessageType = 'event' | 'request' | 'response';
export interface BaseMessage {
    id: string;
    timestamp: number;
    source: string;
    target?: string;
    type: BridgeMessageType;
}
export interface EventMessage<T = Record<string, unknown>> extends BaseMessage {
    type: 'event';
    event: keyof BridgeEvents;
    payload: T;
}
export interface RequestMessage<T = Record<string, unknown>> extends BaseMessage {
    type: 'request';
    action: keyof BridgeRequests;
    payload: T;
    expectsResponse: boolean;
    requestId: string;
}
export interface ResponseMessage<T = object> extends BaseMessage {
    type: 'response';
    action: string;
    payload: T;
    requestId: string;
    success: boolean;
    error?: string;
}
export type BridgeMessage = EventMessage | RequestMessage | ResponseMessage;
export type MessageHandler<T = object> = (message: EventMessage<T>) => void;
export type RequestHandler<TReq = object, TRes = object> = (payload: TReq) => TRes | Promise<TRes>;
export declare enum VideoRecordType {
    VideoMessage = "videoMessage",
    ScreenRecord = "screenRecord"
}
export interface BridgeEvents {
    'start-recording': {
        conversationId: string;
        type: VideoRecordType;
    };
    'stop-recording': {
        conversationId: string;
    };
}
export interface BridgeRequests {
    ping: {
        request: {
            message: string;
        };
        response: {
            echo: string;
        };
    };
    'get-video-recording': {
        request: {
            conversationId: string;
        };
        response: {
            file: File;
        };
    };
}
export type EventPayload<K extends keyof BridgeEvents> = BridgeEvents[K];
export type RequestPayload<K extends keyof BridgeRequests> = BridgeRequests[K]['request'];
export type ResponsePayload<K extends keyof BridgeRequests> = BridgeRequests[K]['response'];
