import { h as _e, _ as k, U as B, j as w, V as Ol, i as n, P as Q, d as It, D as As, E as fo, w as Tl, S as kl, s as _l, W as wl } from "./Button-518a0ca9.js";
import * as A from "react";
import Un from "react";
import { u as ze } from "./useThemeProps-1d464a98.js";
import { u as vl } from "./useMediaQuery-020d0d6a.js";
import { N as Ml } from "./NoSsr-24fea6f3.js";
import "react-dom";
function Y(e) {
  return function() {
    return e;
  };
}
const Es = Math.cos, xn = Math.sin, ve = Math.sqrt, ii = 1e-12, On = Math.PI, et = 2 * On, Xr = Math.PI, Br = 2 * Xr, Ke = 1e-6, Cl = Br - Ke;
function Rs(e) {
  this._ += e[0];
  for (let t = 1, r = e.length; t < r; ++t)
    this._ += arguments[t] + e[t];
}
function Il(e) {
  let t = Math.floor(e);
  if (!(t >= 0))
    throw new Error(`invalid digits: ${e}`);
  if (t > 15)
    return Rs;
  const r = 10 ** t;
  return function(o) {
    this._ += o[0];
    for (let i = 1, s = o.length; i < s; ++i)
      this._ += Math.round(arguments[i] * r) / r + o[i];
  };
}
let Sl = class {
  constructor(t) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = t == null ? Rs : Il(t);
  }
  moveTo(t, r) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(t, r) {
    this._append`L${this._x1 = +t},${this._y1 = +r}`;
  }
  quadraticCurveTo(t, r, o, i) {
    this._append`Q${+t},${+r},${this._x1 = +o},${this._y1 = +i}`;
  }
  bezierCurveTo(t, r, o, i, s, a) {
    this._append`C${+t},${+r},${+o},${+i},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(t, r, o, i, s) {
    if (t = +t, r = +r, o = +o, i = +i, s = +s, s < 0)
      throw new Error(`negative radius: ${s}`);
    let a = this._x1, c = this._y1, u = o - t, l = i - r, h = a - t, f = c - r, d = h * h + f * f;
    if (this._x1 === null)
      this._append`M${this._x1 = t},${this._y1 = r}`;
    else if (d > Ke)
      if (!(Math.abs(f * u - l * h) > Ke) || !s)
        this._append`L${this._x1 = t},${this._y1 = r}`;
      else {
        let p = o - a, m = i - c, g = u * u + l * l, y = p * p + m * m, b = Math.sqrt(g), O = Math.sqrt(d), x = s * Math.tan((Xr - Math.acos((g + d - y) / (2 * b * O))) / 2), _ = x / O, M = x / b;
        Math.abs(_ - 1) > Ke && this._append`L${t + _ * h},${r + _ * f}`, this._append`A${s},${s},0,0,${+(f * p > h * m)},${this._x1 = t + M * u},${this._y1 = r + M * l}`;
      }
  }
  arc(t, r, o, i, s, a) {
    if (t = +t, r = +r, o = +o, a = !!a, o < 0)
      throw new Error(`negative radius: ${o}`);
    let c = o * Math.cos(i), u = o * Math.sin(i), l = t + c, h = r + u, f = 1 ^ a, d = a ? i - s : s - i;
    this._x1 === null ? this._append`M${l},${h}` : (Math.abs(this._x1 - l) > Ke || Math.abs(this._y1 - h) > Ke) && this._append`L${l},${h}`, o && (d < 0 && (d = d % Br + Br), d > Cl ? this._append`A${o},${o},0,1,${f},${t - c},${r - u}A${o},${o},0,1,${f},${this._x1 = l},${this._y1 = h}` : d > Ke && this._append`A${o},${o},0,${+(d >= Xr)},${f},${this._x1 = t + o * Math.cos(s)},${this._y1 = r + o * Math.sin(s)}`);
  }
  rect(t, r, o, i) {
    this._append`M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}h${o = +o}v${+i}h${-o}Z`;
  }
  toString() {
    return this._;
  }
};
function ho(e) {
  let t = 3;
  return e.digits = function(r) {
    if (!arguments.length)
      return t;
    if (r == null)
      t = null;
    else {
      const o = Math.floor(r);
      if (!(o >= 0))
        throw new RangeError(`invalid digits: ${r}`);
      t = o;
    }
    return e;
  }, () => new Sl(t);
}
function Hn(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function js(e) {
  this._context = e;
}
js.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, t);
        break;
    }
  }
};
function po(e) {
  return new js(e);
}
function Ps(e) {
  return e[0];
}
function Ns(e) {
  return e[1];
}
function $s(e, t) {
  var r = Y(!0), o = null, i = po, s = null, a = ho(c);
  e = typeof e == "function" ? e : e === void 0 ? Ps : Y(e), t = typeof t == "function" ? t : t === void 0 ? Ns : Y(t);
  function c(u) {
    var l, h = (u = Hn(u)).length, f, d = !1, p;
    for (o == null && (s = i(p = a())), l = 0; l <= h; ++l)
      !(l < h && r(f = u[l], l, u)) === d && ((d = !d) ? s.lineStart() : s.lineEnd()), d && s.point(+e(f, l, u), +t(f, l, u));
    if (p)
      return s = null, p + "" || null;
  }
  return c.x = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Y(+u), c) : e;
  }, c.y = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Y(+u), c) : t;
  }, c.defined = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Y(!!u), c) : r;
  }, c.curve = function(u) {
    return arguments.length ? (i = u, o != null && (s = i(o)), c) : i;
  }, c.context = function(u) {
    return arguments.length ? (u == null ? o = s = null : s = i(o = u), c) : o;
  }, c;
}
function Al(e, t, r) {
  var o = null, i = Y(!0), s = null, a = po, c = null, u = ho(l);
  e = typeof e == "function" ? e : e === void 0 ? Ps : Y(+e), t = typeof t == "function" ? t : Y(t === void 0 ? 0 : +t), r = typeof r == "function" ? r : r === void 0 ? Ns : Y(+r);
  function l(f) {
    var d, p, m, g = (f = Hn(f)).length, y, b = !1, O, x = new Array(g), _ = new Array(g);
    for (s == null && (c = a(O = u())), d = 0; d <= g; ++d) {
      if (!(d < g && i(y = f[d], d, f)) === b)
        if (b = !b)
          p = d, c.areaStart(), c.lineStart();
        else {
          for (c.lineEnd(), c.lineStart(), m = d - 1; m >= p; --m)
            c.point(x[m], _[m]);
          c.lineEnd(), c.areaEnd();
        }
      b && (x[d] = +e(y, d, f), _[d] = +t(y, d, f), c.point(o ? +o(y, d, f) : x[d], r ? +r(y, d, f) : _[d]));
    }
    if (O)
      return c = null, O + "" || null;
  }
  function h() {
    return $s().defined(i).curve(a).context(s);
  }
  return l.x = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Y(+f), o = null, l) : e;
  }, l.x0 = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Y(+f), l) : e;
  }, l.x1 = function(f) {
    return arguments.length ? (o = f == null ? null : typeof f == "function" ? f : Y(+f), l) : o;
  }, l.y = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : Y(+f), r = null, l) : t;
  }, l.y0 = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : Y(+f), l) : t;
  }, l.y1 = function(f) {
    return arguments.length ? (r = f == null ? null : typeof f == "function" ? f : Y(+f), l) : r;
  }, l.lineX0 = l.lineY0 = function() {
    return h().x(e).y(t);
  }, l.lineY1 = function() {
    return h().x(e).y(r);
  }, l.lineX1 = function() {
    return h().x(o).y(t);
  }, l.defined = function(f) {
    return arguments.length ? (i = typeof f == "function" ? f : Y(!!f), l) : i;
  }, l.curve = function(f) {
    return arguments.length ? (a = f, s != null && (c = a(s)), l) : a;
  }, l.context = function(f) {
    return arguments.length ? (f == null ? s = c = null : c = a(s = f), l) : s;
  }, l;
}
function El(e, t) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Rl(e) {
  return e;
}
function jl() {
  var e = Rl, t = El, r = null, o = Y(0), i = Y(et), s = Y(0);
  function a(c) {
    var u, l = (c = Hn(c)).length, h, f, d = 0, p = new Array(l), m = new Array(l), g = +o.apply(this, arguments), y = Math.min(et, Math.max(-et, i.apply(this, arguments) - g)), b, O = Math.min(Math.abs(y) / l, s.apply(this, arguments)), x = O * (y < 0 ? -1 : 1), _;
    for (u = 0; u < l; ++u)
      (_ = m[p[u] = u] = +e(c[u], u, c)) > 0 && (d += _);
    for (t != null ? p.sort(function(M, T) {
      return t(m[M], m[T]);
    }) : r != null && p.sort(function(M, T) {
      return r(c[M], c[T]);
    }), u = 0, f = d ? (y - l * x) / d : 0; u < l; ++u, g = b)
      h = p[u], _ = m[h], b = g + (_ > 0 ? _ * f : 0) + x, m[h] = {
        data: c[h],
        index: u,
        value: _,
        startAngle: g,
        endAngle: b,
        padAngle: O
      };
    return m;
  }
  return a.value = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Y(+c), a) : e;
  }, a.sortValues = function(c) {
    return arguments.length ? (t = c, r = null, a) : t;
  }, a.sort = function(c) {
    return arguments.length ? (r = c, t = null, a) : r;
  }, a.startAngle = function(c) {
    return arguments.length ? (o = typeof c == "function" ? c : Y(+c), a) : o;
  }, a.endAngle = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Y(+c), a) : i;
  }, a.padAngle = function(c) {
    return arguments.length ? (s = typeof c == "function" ? c : Y(+c), a) : s;
  }, a;
}
class Ls {
  constructor(t, r) {
    this._context = t, this._x = r;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(t, r) {
    switch (t = +t, r = +r, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(t, r) : this._context.moveTo(t, r);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + t) / 2, this._y0, this._x0, r, t, r) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + r) / 2, t, this._y0, t, r);
        break;
      }
    }
    this._x0 = t, this._y0 = r;
  }
}
function Pl(e) {
  return new Ls(e, !0);
}
function Nl(e) {
  return new Ls(e, !1);
}
const Ds = {
  draw(e, t) {
    const r = ve(t / On);
    e.moveTo(r, 0), e.arc(0, 0, r, 0, et);
  }
}, $l = {
  draw(e, t) {
    const r = ve(t / 5) / 2;
    e.moveTo(-3 * r, -r), e.lineTo(-r, -r), e.lineTo(-r, -3 * r), e.lineTo(r, -3 * r), e.lineTo(r, -r), e.lineTo(3 * r, -r), e.lineTo(3 * r, r), e.lineTo(r, r), e.lineTo(r, 3 * r), e.lineTo(-r, 3 * r), e.lineTo(-r, r), e.lineTo(-3 * r, r), e.closePath();
  }
}, qs = ve(1 / 3), Ll = qs * 2, Dl = {
  draw(e, t) {
    const r = ve(t / Ll), o = r * qs;
    e.moveTo(0, -r), e.lineTo(o, 0), e.lineTo(0, r), e.lineTo(-o, 0), e.closePath();
  }
}, ql = {
  draw(e, t) {
    const r = ve(t), o = -r / 2;
    e.rect(o, o, r, r);
  }
}, Fl = 0.8908130915292852, Fs = xn(On / 10) / xn(7 * On / 10), zl = xn(et / 10) * Fs, Ul = -Es(et / 10) * Fs, Hl = {
  draw(e, t) {
    const r = ve(t * Fl), o = zl * r, i = Ul * r;
    e.moveTo(0, -r), e.lineTo(o, i);
    for (let s = 1; s < 5; ++s) {
      const a = et * s / 5, c = Es(a), u = xn(a);
      e.lineTo(u * r, -c * r), e.lineTo(c * o - u * i, u * o + c * i);
    }
    e.closePath();
  }
}, wr = ve(3), Vl = {
  draw(e, t) {
    const r = -ve(t / (wr * 3));
    e.moveTo(0, r * 2), e.lineTo(-wr * r, -r), e.lineTo(wr * r, -r), e.closePath();
  }
}, pe = -0.5, me = ve(3) / 2, Kr = 1 / ve(12), Gl = (Kr / 2 + 1) * 3, Yl = {
  draw(e, t) {
    const r = ve(t / Gl), o = r / 2, i = r * Kr, s = o, a = r * Kr + r, c = -s, u = a;
    e.moveTo(o, i), e.lineTo(s, a), e.lineTo(c, u), e.lineTo(pe * o - me * i, me * o + pe * i), e.lineTo(pe * s - me * a, me * s + pe * a), e.lineTo(pe * c - me * u, me * c + pe * u), e.lineTo(pe * o + me * i, pe * i - me * o), e.lineTo(pe * s + me * a, pe * a - me * s), e.lineTo(pe * c + me * u, pe * u - me * c), e.closePath();
  }
}, zs = [
  Ds,
  $l,
  Dl,
  ql,
  Hl,
  Vl,
  Yl
];
function Us(e, t) {
  let r = null, o = ho(i);
  e = typeof e == "function" ? e : Y(e || Ds), t = typeof t == "function" ? t : Y(t === void 0 ? 64 : +t);
  function i() {
    let s;
    if (r || (r = s = o()), e.apply(this, arguments).draw(r, +t.apply(this, arguments)), s)
      return r = null, s + "" || null;
  }
  return i.type = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : Y(s), i) : e;
  }, i.size = function(s) {
    return arguments.length ? (t = typeof s == "function" ? s : Y(+s), i) : t;
  }, i.context = function(s) {
    return arguments.length ? (r = s ?? null, i) : r;
  }, i;
}
function si(e, t, r) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - t),
    e._y2 + e._k * (e._y1 - r),
    e._x2,
    e._y2
  );
}
function mo(e, t) {
  this._context = e, this._k = (1 - t) / 6;
}
mo.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        si(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = t;
        break;
      case 2:
        this._point = 3;
      default:
        si(this, e, t);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
(function e(t) {
  function r(o) {
    return new mo(o, t);
  }
  return r.tension = function(o) {
    return e(+o);
  }, r;
})(0);
function Wl(e, t, r) {
  var o = e._x1, i = e._y1, s = e._x2, a = e._y2;
  if (e._l01_a > ii) {
    var c = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, u = 3 * e._l01_a * (e._l01_a + e._l12_a);
    o = (o * c - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u, i = (i * c - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u;
  }
  if (e._l23_a > ii) {
    var l = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, h = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * l + e._x1 * e._l23_2a - t * e._l12_2a) / h, a = (a * l + e._y1 * e._l23_2a - r * e._l12_2a) / h;
  }
  e._context.bezierCurveTo(o, i, s, a, e._x2, e._y2);
}
function Hs(e, t) {
  this._context = e, this._alpha = t;
}
Hs.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    if (e = +e, t = +t, this._point) {
      var r = this._x2 - e, o = this._y2 - t;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + o * o, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        Wl(this, e, t);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
  }
};
const Xl = function e(t) {
  function r(o) {
    return t ? new Hs(o, t) : new mo(o, 0);
  }
  return r.alpha = function(o) {
    return e(+o);
  }, r;
}(0.5);
function ai(e) {
  return e < 0 ? -1 : 1;
}
function ci(e, t, r) {
  var o = e._x1 - e._x0, i = t - e._x1, s = (e._y1 - e._y0) / (o || i < 0 && -0), a = (r - e._y1) / (i || o < 0 && -0), c = (s * i + a * o) / (o + i);
  return (ai(s) + ai(a)) * Math.min(Math.abs(s), Math.abs(a), 0.5 * Math.abs(c)) || 0;
}
function li(e, t) {
  var r = e._x1 - e._x0;
  return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function vr(e, t, r) {
  var o = e._x0, i = e._y0, s = e._x1, a = e._y1, c = (s - o) / 3;
  e._context.bezierCurveTo(o + c, i + c * t, s - c, a - c * r, s, a);
}
function Tn(e) {
  this._context = e;
}
Tn.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        vr(this, this._t0, li(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, t) {
    var r = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, vr(this, li(this, r = ci(this, e, t)), r);
          break;
        default:
          vr(this, this._t0, r = ci(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
    }
  }
};
function Vs(e) {
  this._context = new Gs(e);
}
(Vs.prototype = Object.create(Tn.prototype)).point = function(e, t) {
  Tn.prototype.point.call(this, t, e);
};
function Gs(e) {
  this._context = e;
}
Gs.prototype = {
  moveTo: function(e, t) {
    this._context.moveTo(t, e);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(e, t) {
    this._context.lineTo(t, e);
  },
  bezierCurveTo: function(e, t, r, o, i, s) {
    this._context.bezierCurveTo(t, e, o, r, s, i);
  }
};
function ui(e) {
  return new Tn(e);
}
function Bl(e) {
  return new Vs(e);
}
function Ys(e) {
  this._context = e;
}
Ys.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var e = this._x, t = this._y, r = e.length;
    if (r)
      if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), r === 2)
        this._context.lineTo(e[1], t[1]);
      else
        for (var o = fi(e), i = fi(t), s = 0, a = 1; a < r; ++s, ++a)
          this._context.bezierCurveTo(o[0][s], i[0][s], o[1][s], i[1][s], e[a], t[a]);
    (this._line || this._line !== 0 && r === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(e, t) {
    this._x.push(+e), this._y.push(+t);
  }
};
function fi(e) {
  var t, r = e.length - 1, o, i = new Array(r), s = new Array(r), a = new Array(r);
  for (i[0] = 0, s[0] = 2, a[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t)
    i[t] = 1, s[t] = 4, a[t] = 4 * e[t] + 2 * e[t + 1];
  for (i[r - 1] = 2, s[r - 1] = 7, a[r - 1] = 8 * e[r - 1] + e[r], t = 1; t < r; ++t)
    o = i[t] / s[t - 1], s[t] -= o, a[t] -= o * a[t - 1];
  for (i[r - 1] = a[r - 1] / s[r - 1], t = r - 2; t >= 0; --t)
    i[t] = (a[t] - i[t + 1]) / s[t];
  for (s[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t)
    s[t] = 2 * e[t + 1] - i[t + 1];
  return [i, s];
}
function Kl(e) {
  return new Ys(e);
}
function Vn(e, t) {
  this._context = e, this._t = t;
}
Vn.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(e, t) {
    switch (e = +e, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, t), this._context.lineTo(e, t);
        else {
          var r = this._x * (1 - this._t) + e * this._t;
          this._context.lineTo(r, this._y), this._context.lineTo(r, t);
        }
        break;
      }
    }
    this._x = e, this._y = t;
  }
};
function Zl(e) {
  return new Vn(e, 0.5);
}
function Ql(e) {
  return new Vn(e, 0);
}
function Jl(e) {
  return new Vn(e, 1);
}
function xt(e, t) {
  if ((a = e.length) > 1)
    for (var r = 1, o, i, s = e[t[0]], a, c = s.length; r < a; ++r)
      for (i = s, s = e[t[r]], o = 0; o < c; ++o)
        s[o][1] += s[o][0] = isNaN(i[o][1]) ? i[o][0] : i[o][1];
}
function Ot(e) {
  for (var t = e.length, r = new Array(t); --t >= 0; )
    r[t] = t;
  return r;
}
function eu(e, t) {
  return e[t];
}
function tu(e) {
  const t = [];
  return t.key = e, t;
}
function Ws() {
  var e = Y([]), t = Ot, r = xt, o = eu;
  function i(s) {
    var a = Array.from(e.apply(this, arguments), tu), c, u = a.length, l = -1, h;
    for (const f of s)
      for (c = 0, ++l; c < u; ++c)
        (a[c][l] = [0, +o(f, a[c].key, l, s)]).data = f;
    for (c = 0, h = Hn(t(a)); c < u; ++c)
      a[h[c]].index = c;
    return r(a, h), a;
  }
  return i.keys = function(s) {
    return arguments.length ? (e = typeof s == "function" ? s : Y(Array.from(s)), i) : e;
  }, i.value = function(s) {
    return arguments.length ? (o = typeof s == "function" ? s : Y(+s), i) : o;
  }, i.order = function(s) {
    return arguments.length ? (t = s == null ? Ot : typeof s == "function" ? s : Y(Array.from(s)), i) : t;
  }, i.offset = function(s) {
    return arguments.length ? (r = s ?? xt, i) : r;
  }, i;
}
function nu(e, t) {
  if ((o = e.length) > 0) {
    for (var r, o, i = 0, s = e[0].length, a; i < s; ++i) {
      for (a = r = 0; r < o; ++r)
        a += e[r][i][1] || 0;
      if (a)
        for (r = 0; r < o; ++r)
          e[r][i][1] /= a;
    }
    xt(e, t);
  }
}
function ru(e, t) {
  if ((u = e.length) > 0)
    for (var r, o = 0, i, s, a, c, u, l = e[t[0]].length; o < l; ++o)
      for (a = c = 0, r = 0; r < u; ++r)
        (s = (i = e[t[r]][o])[1] - i[0]) > 0 ? (i[0] = a, i[1] = a += s) : s < 0 ? (i[1] = c, i[0] = c += s) : (i[0] = 0, i[1] = s);
}
function ou(e, t) {
  if ((i = e.length) > 0) {
    for (var r = 0, o = e[t[0]], i, s = o.length; r < s; ++r) {
      for (var a = 0, c = 0; a < i; ++a)
        c += e[a][r][1] || 0;
      o[r][1] += o[r][0] = -c / 2;
    }
    xt(e, t);
  }
}
function iu(e, t) {
  if (!(!((a = e.length) > 0) || !((s = (i = e[t[0]]).length) > 0))) {
    for (var r = 0, o = 1, i, s, a; o < s; ++o) {
      for (var c = 0, u = 0, l = 0; c < a; ++c) {
        for (var h = e[t[c]], f = h[o][1] || 0, d = h[o - 1][1] || 0, p = (f - d) / 2, m = 0; m < c; ++m) {
          var g = e[t[m]], y = g[o][1] || 0, b = g[o - 1][1] || 0;
          p += y - b;
        }
        u += f, l += p * f;
      }
      i[o - 1][1] += i[o - 1][0] = r, u && (r -= l / u);
    }
    i[o - 1][1] += i[o - 1][0] = r, xt(e, t);
  }
}
function Xs(e) {
  var t = e.map(su);
  return Ot(e).sort(function(r, o) {
    return t[r] - t[o];
  });
}
function su(e) {
  for (var t = -1, r = 0, o = e.length, i, s = -1 / 0; ++t < o; )
    (i = +e[t][1]) > s && (s = i, r = t);
  return r;
}
function Bs(e) {
  var t = e.map(Ks);
  return Ot(e).sort(function(r, o) {
    return t[r] - t[o];
  });
}
function Ks(e) {
  for (var t = 0, r = -1, o = e.length, i; ++r < o; )
    (i = +e[r][1]) && (t += i);
  return t;
}
function au(e) {
  return Bs(e).reverse();
}
function cu(e) {
  var t = e.length, r, o, i = e.map(Ks), s = Xs(e), a = 0, c = 0, u = [], l = [];
  for (r = 0; r < t; ++r)
    o = s[r], a < c ? (a += i[o], u.push(o)) : (c += i[o], l.push(o));
  return l.reverse().concat(u);
}
function lu(e) {
  return Ot(e).reverse();
}
function be(e, t, r = void 0) {
  const o = {};
  for (const i in e) {
    const s = e[i];
    let a = "", c = !0;
    for (let u = 0; u < s.length; u += 1) {
      const l = s[u];
      l && (a += (c === !0 ? "" : " ") + t(l), c = !1, r && r[l] && (a += " " + r[l]));
    }
    o[i] = a;
  }
  return o;
}
function go(...e) {
  const t = A.useRef(void 0), r = A.useCallback((o) => {
    const i = e.map((s) => {
      if (s == null)
        return null;
      if (typeof s == "function") {
        const a = s, c = a(o);
        return typeof c == "function" ? c : () => {
          a(null);
        };
      }
      return s.current = o, () => {
        s.current = null;
      };
    });
    return () => {
      i.forEach((s) => s == null ? void 0 : s());
    };
  }, e);
  return A.useMemo(() => e.every((o) => o == null) ? null : (o) => {
    t.current && (t.current(), t.current = void 0), o != null && (t.current = r(o));
  }, e);
}
function uu(e) {
  return typeof e == "string";
}
function fu(e, t, r) {
  return e === void 0 || uu(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...r
    }
  };
}
function du(e, t = []) {
  if (e === void 0)
    return {};
  const r = {};
  return Object.keys(e).filter((o) => o.match(/^on[A-Z]/) && typeof e[o] == "function" && !t.includes(o)).forEach((o) => {
    r[o] = e[o];
  }), r;
}
function di(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((r) => !(r.match(/^on[A-Z]/) && typeof e[r] == "function")).forEach((r) => {
    t[r] = e[r];
  }), t;
}
function hu(e) {
  const {
    getSlotProps: t,
    additionalProps: r,
    externalSlotProps: o,
    externalForwardedProps: i,
    className: s
  } = e;
  if (!t) {
    const p = _e(r == null ? void 0 : r.className, s, i == null ? void 0 : i.className, o == null ? void 0 : o.className), m = {
      ...r == null ? void 0 : r.style,
      ...i == null ? void 0 : i.style,
      ...o == null ? void 0 : o.style
    }, g = {
      ...r,
      ...i,
      ...o
    };
    return p.length > 0 && (g.className = p), Object.keys(m).length > 0 && (g.style = m), {
      props: g,
      internalRef: void 0
    };
  }
  const a = du({
    ...i,
    ...o
  }), c = di(o), u = di(i), l = t(a), h = _e(l == null ? void 0 : l.className, r == null ? void 0 : r.className, s, i == null ? void 0 : i.className, o == null ? void 0 : o.className), f = {
    ...l == null ? void 0 : l.style,
    ...r == null ? void 0 : r.style,
    ...i == null ? void 0 : i.style,
    ...o == null ? void 0 : o.style
  }, d = {
    ...l,
    ...r,
    ...u,
    ...c
  };
  return h.length > 0 && (d.className = h), Object.keys(f).length > 0 && (d.style = f), {
    props: d,
    internalRef: l.ref
  };
}
function pu(e, t, r) {
  return typeof e == "function" ? e(t, r) : e;
}
function We(e) {
  var f;
  const {
    elementType: t,
    externalSlotProps: r,
    ownerState: o,
    skipResolvingSlotProps: i = !1,
    ...s
  } = e, a = i ? {} : pu(r, o), {
    props: c,
    internalRef: u
  } = hu({
    ...s,
    externalSlotProps: a
  }), l = go(u, a == null ? void 0 : a.ref, (f = e.additionalProps) == null ? void 0 : f.ref);
  return fu(t, {
    ...c,
    ref: l
  }, o);
}
const hi = (e) => e, mu = () => {
  let e = hi;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = hi;
    }
  };
}, gu = mu(), yu = gu, bu = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function xe(e, t, r = "Mui") {
  const o = bu[t];
  return o ? `${r}-${o}` : `${yu.generate(e)}-${t}`;
}
function Oe(e, t, r = "Mui") {
  const o = {};
  return t.forEach((i) => {
    o[i] = xe(e, i, r);
  }), o;
}
let pi = 0;
function xu(e) {
  const [t, r] = A.useState(e), o = e || t;
  return A.useEffect(() => {
    t == null && (pi += 1, r(`mui-${pi}`));
  }, [t]), o;
}
const Ou = {
  ...A
}, mi = Ou.useId;
function Zs(e) {
  if (mi !== void 0) {
    const t = mi();
    return e ?? t;
  }
  return xu(e);
}
class Tu {
  constructor(t) {
    this.value = void 0, this.listeners = void 0, this.subscribe = (r) => (this.listeners.add(r), () => {
      this.listeners.delete(r);
    }), this.getSnapshot = () => this.value, this.update = (r) => {
      const o = r(this.value);
      o !== this.value && (this.value = o, this.listeners.forEach((i) => i(o)));
    }, this.value = t, this.listeners = /* @__PURE__ */ new Set();
  }
}
const ku = typeof window < "u" ? A.useLayoutEffect : A.useEffect, Ae = ku, Gn = ({
  params: e,
  store: t
}) => {
  A.useEffect(() => {
    t.update((o) => k({}, o, {
      animation: k({}, o.animation, {
        skip: e.skipAnimation
      })
    }));
  }, [t, e.skipAnimation]);
  const r = A.useCallback(() => {
    let o = !1;
    return t.update((i) => k({}, i, {
      animation: k({}, i.animation, {
        skipAnimationRequests: i.animation.skipAnimationRequests + 1
      })
    })), () => {
      o || (o = !0, t.update((i) => k({}, i, {
        animation: k({}, i.animation, {
          skipAnimationRequests: i.animation.skipAnimationRequests - 1
        })
      })));
    };
  }, [t]);
  return Ae(() => {
    if (typeof window > "u" || !(window != null && window.matchMedia))
      return;
    let i;
    const s = (c) => {
      c.matches ? i = r() : i == null || i();
    }, a = window.matchMedia("(prefers-reduced-motion)");
    return s(a), a.addEventListener("change", s), () => {
      a.removeEventListener("change", s);
    };
  }, [r, t]), {
    instance: {
      disableAnimation: r
    }
  };
};
Gn.params = {
  skipAnimation: !0
};
Gn.getDefaultizedParams = ({
  params: e
}) => k({}, e, {
  skipAnimation: e.skipAnimation ?? !1
});
Gn.getInitialState = ({
  skipAnimation: e
}) => {
  const t = typeof window > "u" || !(window != null && window.matchMedia), r = "production".NODE_ENV === "test" ? t : !1;
  return {
    animation: {
      skip: e,
      // By initializing the skipAnimationRequests to 1, we ensure that the animation is always skipped
      skipAnimationRequests: r ? 1 : 0
    }
  };
};
var _u = (e, t, r) => {
  if (t.length === 1 && t[0] === r) {
    let o = !1;
    try {
      const i = {};
      e(i) === i && (o = !0);
    } catch {
    }
    if (o) {
      let i;
      try {
        throw new Error();
      } catch (s) {
        ({ stack: i } = s);
      }
      console.warn(
        `The result function returned its own inputs without modification. e.g
\`createSelector([state => state.todos], todos => todos)\`
This could lead to inefficient memoization and unnecessary re-renders.
Ensure transformation logic is in the result function, and extraction logic is in the input selectors.`,
        { stack: i }
      );
    }
  }
}, wu = (e, t, r) => {
  const { memoize: o, memoizeOptions: i } = t, { inputSelectorResults: s, inputSelectorResultsCopy: a } = e, c = o(() => ({}), ...i);
  if (!(c.apply(null, s) === c.apply(null, a))) {
    let l;
    try {
      throw new Error();
    } catch (h) {
      ({ stack: l } = h);
    }
    console.warn(
      `An input selector returned a different result when passed same arguments.
This means your output selector will likely run more frequently than intended.
Avoid returning a new reference inside your input selector, e.g.
\`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)\``,
      {
        arguments: r,
        firstInputs: s,
        secondInputs: a,
        stack: l
      }
    );
  }
}, vu = {
  inputStabilityCheck: "once",
  identityFunctionCheck: "once"
}, kn = /* @__PURE__ */ Symbol("NOT_FOUND");
function Mu(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function")
    throw new TypeError(t);
}
function Cu(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object")
    throw new TypeError(t);
}
function Iu(e, t = "expected all items to be functions, instead received the following types: ") {
  if (!e.every((r) => typeof r == "function")) {
    const r = e.map(
      (o) => typeof o == "function" ? `function ${o.name || "unnamed"}()` : typeof o
    ).join(", ");
    throw new TypeError(`${t}[${r}]`);
  }
}
var gi = (e) => Array.isArray(e) ? e : [e];
function Su(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return Iu(
    t,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), t;
}
function yi(e, t) {
  const r = [], { length: o } = e;
  for (let i = 0; i < o; i++)
    r.push(e[i].apply(null, t));
  return r;
}
var Au = (e, t) => {
  const { identityFunctionCheck: r, inputStabilityCheck: o } = {
    ...vu,
    ...t
  };
  return {
    identityFunctionCheck: {
      shouldRun: r === "always" || r === "once" && e,
      run: _u
    },
    inputStabilityCheck: {
      shouldRun: o === "always" || o === "once" && e,
      run: wu
    }
  };
};
function Eu(e) {
  let t;
  return {
    get(r) {
      return t && e(t.key, r) ? t.value : kn;
    },
    put(r, o) {
      t = { key: r, value: o };
    },
    getEntries() {
      return t ? [t] : [];
    },
    clear() {
      t = void 0;
    }
  };
}
function Ru(e, t) {
  let r = [];
  function o(c) {
    const u = r.findIndex((l) => t(c, l.key));
    if (u > -1) {
      const l = r[u];
      return u > 0 && (r.splice(u, 1), r.unshift(l)), l.value;
    }
    return kn;
  }
  function i(c, u) {
    o(c) === kn && (r.unshift({ key: c, value: u }), r.length > e && r.pop());
  }
  function s() {
    return r;
  }
  function a() {
    r = [];
  }
  return { get: o, put: i, getEntries: s, clear: a };
}
var ju = (e, t) => e === t;
function Pu(e) {
  return function(r, o) {
    if (r === null || o === null || r.length !== o.length)
      return !1;
    const { length: i } = r;
    for (let s = 0; s < i; s++)
      if (!e(r[s], o[s]))
        return !1;
    return !0;
  };
}
function Nu(e, t) {
  const r = typeof t == "object" ? t : { equalityCheck: t }, {
    equalityCheck: o = ju,
    maxSize: i = 1,
    resultEqualityCheck: s
  } = r, a = Pu(o);
  let c = 0;
  const u = i <= 1 ? Eu(a) : Ru(i, a);
  function l() {
    let h = u.get(arguments);
    if (h === kn) {
      if (h = e.apply(null, arguments), c++, s) {
        const d = u.getEntries().find(
          (p) => s(p.value, h)
        );
        d && (h = d.value, c !== 0 && c--);
      }
      u.put(arguments, h);
    }
    return h;
  }
  return l.clearCache = () => {
    u.clear(), l.resetResultsCount();
  }, l.resultsCount = () => c, l.resetResultsCount = () => {
    c = 0;
  }, l;
}
var $u = class {
  constructor(e) {
    this.value = e;
  }
  deref() {
    return this.value;
  }
}, Lu = typeof WeakRef < "u" ? WeakRef : $u, Du = 0, bi = 1;
function cn() {
  return {
    s: Du,
    v: void 0,
    o: null,
    p: null
  };
}
function Qs(e, t = {}) {
  let r = cn();
  const { resultEqualityCheck: o } = t;
  let i, s = 0;
  function a() {
    var f;
    let c = r;
    const { length: u } = arguments;
    for (let d = 0, p = u; d < p; d++) {
      const m = arguments[d];
      if (typeof m == "function" || typeof m == "object" && m !== null) {
        let g = c.o;
        g === null && (c.o = g = /* @__PURE__ */ new WeakMap());
        const y = g.get(m);
        y === void 0 ? (c = cn(), g.set(m, c)) : c = y;
      } else {
        let g = c.p;
        g === null && (c.p = g = /* @__PURE__ */ new Map());
        const y = g.get(m);
        y === void 0 ? (c = cn(), g.set(m, c)) : c = y;
      }
    }
    const l = c;
    let h;
    if (c.s === bi)
      h = c.v;
    else if (h = e.apply(null, arguments), s++, o) {
      const d = ((f = i == null ? void 0 : i.deref) == null ? void 0 : f.call(i)) ?? i;
      d != null && o(d, h) && (h = d, s !== 0 && s--), i = typeof h == "object" && h !== null || typeof h == "function" ? new Lu(h) : h;
    }
    return l.s = bi, l.v = h, h;
  }
  return a.clearCache = () => {
    r = cn(), a.resetResultsCount();
  }, a.resultsCount = () => s, a.resetResultsCount = () => {
    s = 0;
  }, a;
}
function Js(e, ...t) {
  const r = typeof e == "function" ? {
    memoize: e,
    memoizeOptions: t
  } : e, o = (...i) => {
    let s = 0, a = 0, c, u = {}, l = i.pop();
    typeof l == "object" && (u = l, l = i.pop()), Mu(
      l,
      `createSelector expects an output function after the inputs, but received: [${typeof l}]`
    );
    const h = {
      ...r,
      ...u
    }, {
      memoize: f,
      memoizeOptions: d = [],
      argsMemoize: p = Qs,
      argsMemoizeOptions: m = [],
      devModeChecks: g = {}
    } = h, y = gi(d), b = gi(m), O = Su(i), x = f(function() {
      return s++, l.apply(
        null,
        arguments
      );
    }, ...y);
    let _ = !0;
    const M = p(function() {
      a++;
      const v = yi(
        O,
        arguments
      );
      if (c = x.apply(null, v), "production".NODE_ENV !== "production") {
        const { identityFunctionCheck: S, inputStabilityCheck: C } = Au(_, g);
        if (S.shouldRun && S.run(
          l,
          v,
          c
        ), C.shouldRun) {
          const P = yi(
            O,
            arguments
          );
          C.run(
            { inputSelectorResults: v, inputSelectorResultsCopy: P },
            { memoize: f, memoizeOptions: y },
            arguments
          );
        }
        _ && (_ = !1);
      }
      return c;
    }, ...b);
    return Object.assign(M, {
      resultFunc: l,
      memoizedResultFunc: x,
      dependencies: O,
      dependencyRecomputations: () => a,
      resetDependencyRecomputations: () => {
        a = 0;
      },
      lastResult: () => c,
      recomputations: () => s,
      resetRecomputations: () => {
        s = 0;
      },
      memoize: f,
      argsMemoize: p
    });
  };
  return Object.assign(o, {
    withTypes: () => o
  }), o;
}
var qu = /* @__PURE__ */ Js(Qs), Fu = Object.assign(
  (e, t = qu) => {
    Cu(
      e,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
    );
    const r = Object.keys(e), o = r.map(
      (s) => e[s]
    );
    return t(
      o,
      (...s) => s.reduce((a, c, u) => (a[r[u]] = c, a), {})
    );
  },
  { withTypes: () => Fu }
);
const zu = Js({
  memoize: Nu,
  memoizeOptions: {
    maxSize: 1,
    equalityCheck: Object.is
  }
}), xi = /* @__PURE__ */ new WeakMap(), F = (...e) => (r, o) => {
  const i = r.cacheKey;
  let s = xi.get(i);
  s || (s = /* @__PURE__ */ new Map(), xi.set(i, s));
  const a = s.get(e);
  if (a)
    return a(r, o);
  const c = zu(...e);
  return s.set(e, c), c(r, o);
}, Uu = (e) => e.animation, Hu = F(Uu, (e) => e.skip || e.skipAnimationRequests > 0);
function Vu(e) {
  return e && e.ownerDocument || document;
}
function Gu(e) {
  return Vu(e).defaultView || window;
}
var Zr = { exports: {} }, Mr = {}, ln = { exports: {} }, Cr = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Oi;
function Yu() {
  if (Oi)
    return Cr;
  Oi = 1;
  var e = Un;
  function t(f, d) {
    return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d;
  }
  var r = typeof Object.is == "function" ? Object.is : t, o = e.useState, i = e.useEffect, s = e.useLayoutEffect, a = e.useDebugValue;
  function c(f, d) {
    var p = d(), m = o({ inst: { value: p, getSnapshot: d } }), g = m[0].inst, y = m[1];
    return s(
      function() {
        g.value = p, g.getSnapshot = d, u(g) && y({ inst: g });
      },
      [f, p, d]
    ), i(
      function() {
        return u(g) && y({ inst: g }), f(function() {
          u(g) && y({ inst: g });
        });
      },
      [f]
    ), a(p), p;
  }
  function u(f) {
    var d = f.getSnapshot;
    f = f.value;
    try {
      var p = d();
      return !r(f, p);
    } catch {
      return !0;
    }
  }
  function l(f, d) {
    return d();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : c;
  return Cr.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : h, Cr;
}
var Ir = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ti;
function Wu() {
  return Ti || (Ti = 1, "production".NODE_ENV !== "production" && function() {
    function e(p, m) {
      return p === m && (p !== 0 || 1 / p === 1 / m) || p !== p && m !== m;
    }
    function t(p, m) {
      h || i.startTransition === void 0 || (h = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var g = m();
      if (!f) {
        var y = m();
        s(g, y) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), f = !0);
      }
      y = a({
        inst: { value: g, getSnapshot: m }
      });
      var b = y[0].inst, O = y[1];
      return u(
        function() {
          b.value = g, b.getSnapshot = m, r(b) && O({ inst: b });
        },
        [p, g, m]
      ), c(
        function() {
          return r(b) && O({ inst: b }), p(function() {
            r(b) && O({ inst: b });
          });
        },
        [p]
      ), l(g), g;
    }
    function r(p) {
      var m = p.getSnapshot;
      p = p.value;
      try {
        var g = m();
        return !s(p, g);
      } catch {
        return !0;
      }
    }
    function o(p, m) {
      return m();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var i = Un, s = typeof Object.is == "function" ? Object.is : e, a = i.useState, c = i.useEffect, u = i.useLayoutEffect, l = i.useDebugValue, h = !1, f = !1, d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? o : t;
    Ir.useSyncExternalStore = i.useSyncExternalStore !== void 0 ? i.useSyncExternalStore : d, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Ir;
}
var ki;
function ea() {
  return ki || (ki = 1, "production".NODE_ENV === "production" ? ln.exports = Yu() : ln.exports = Wu()), ln.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _i;
function Xu() {
  if (_i)
    return Mr;
  _i = 1;
  var e = Un, t = ea();
  function r(l, h) {
    return l === h && (l !== 0 || 1 / l === 1 / h) || l !== l && h !== h;
  }
  var o = typeof Object.is == "function" ? Object.is : r, i = t.useSyncExternalStore, s = e.useRef, a = e.useEffect, c = e.useMemo, u = e.useDebugValue;
  return Mr.useSyncExternalStoreWithSelector = function(l, h, f, d, p) {
    var m = s(null);
    if (m.current === null) {
      var g = { hasValue: !1, value: null };
      m.current = g;
    } else
      g = m.current;
    m = c(
      function() {
        function b(T) {
          if (!O) {
            if (O = !0, x = T, T = d(T), p !== void 0 && g.hasValue) {
              var v = g.value;
              if (p(v, T))
                return _ = v;
            }
            return _ = T;
          }
          if (v = _, o(x, T))
            return v;
          var S = d(T);
          return p !== void 0 && p(v, S) ? (x = T, v) : (x = T, _ = S);
        }
        var O = !1, x, _, M = f === void 0 ? null : f;
        return [
          function() {
            return b(h());
          },
          M === null ? void 0 : function() {
            return b(M());
          }
        ];
      },
      [h, f, d, p]
    );
    var y = i(l, m[0], m[1]);
    return a(
      function() {
        g.hasValue = !0, g.value = y;
      },
      [y]
    ), u(y), y;
  }, Mr;
}
var Sr = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wi;
function Bu() {
  return wi || (wi = 1, "production".NODE_ENV !== "production" && function() {
    function e(l, h) {
      return l === h && (l !== 0 || 1 / l === 1 / h) || l !== l && h !== h;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var t = Un, r = ea(), o = typeof Object.is == "function" ? Object.is : e, i = r.useSyncExternalStore, s = t.useRef, a = t.useEffect, c = t.useMemo, u = t.useDebugValue;
    Sr.useSyncExternalStoreWithSelector = function(l, h, f, d, p) {
      var m = s(null);
      if (m.current === null) {
        var g = { hasValue: !1, value: null };
        m.current = g;
      } else
        g = m.current;
      m = c(
        function() {
          function b(T) {
            if (!O) {
              if (O = !0, x = T, T = d(T), p !== void 0 && g.hasValue) {
                var v = g.value;
                if (p(v, T))
                  return _ = v;
              }
              return _ = T;
            }
            if (v = _, o(x, T))
              return v;
            var S = d(T);
            return p !== void 0 && p(v, S) ? (x = T, v) : (x = T, _ = S);
          }
          var O = !1, x, _, M = f === void 0 ? null : f;
          return [
            function() {
              return b(h());
            },
            M === null ? void 0 : function() {
              return b(M());
            }
          ];
        },
        [h, f, d, p]
      );
      var y = i(l, m[0], m[1]);
      return a(
        function() {
          g.hasValue = !0, g.value = y;
        },
        [y]
      ), u(y), y;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  }()), Sr;
}
"production".NODE_ENV === "production" ? Zr.exports = Xu() : Zr.exports = Bu();
var Ku = Zr.exports;
const Zu = Object.is, V = (e, t, r = void 0, o = Zu) => {
  const i = (s) => t(s, r);
  return Ku.useSyncExternalStoreWithSelector(e.subscribe, e.getSnapshot, e.getSnapshot, i, o);
}, St = "DEFAULT_X_AXIS_KEY", Qu = "DEFAULT_Y_AXIS_KEY", Ju = {
  top: 20,
  bottom: 20,
  left: 20,
  right: 20
}, ef = 45, tf = 25, ta = 20, na = (e) => e.cartesianAxis, At = F(na, (e) => e == null ? void 0 : e.x), Bt = F(na, (e) => e == null ? void 0 : e.y), nf = F([Bt], (e) => (e ?? []).reduce((t, r) => {
  var o;
  return r.position === "left" ? t + (r.width || 0) + ((o = r.zoom) != null && o.slider.enabled ? r.zoom.slider.size : 0) : t;
}, 0)), rf = F([Bt], (e) => (e ?? []).reduce((t, r) => {
  var o;
  return r.position === "right" ? t + (r.width || 0) + ((o = r.zoom) != null && o.slider.enabled ? r.zoom.slider.size : 0) : t;
}, 0)), of = F([At], (e) => (e ?? []).reduce((t, r) => {
  var o;
  return r.position === "top" ? t + (r.height || 0) + ((o = r.zoom) != null && o.slider.enabled ? r.zoom.slider.size : 0) : t;
}, 0)), sf = F([At], (e) => (e ?? []).reduce((t, r) => {
  var o;
  return r.position === "bottom" ? t + (r.height || 0) + ((o = r.zoom) != null && o.slider.enabled ? r.zoom.slider.size : 0) : t;
}, 0)), Yn = (e) => e.dimensions, Wn = F(Yn, (e) => e.margin), ra = F(Yn, (e) => e.width), oa = F(Yn, (e) => e.height), af = F(Wn, (e) => e.top), cf = F(Wn, (e) => e.right), lf = F(Wn, (e) => e.bottom), uf = F(Wn, (e) => e.left), Ue = F(ra, oa, af, cf, lf, uf, of, rf, sf, nf, (e, t, r, o, i, s, a, c, u, l) => ({
  width: e - s - o - l - c,
  left: s + l,
  right: o + c,
  height: t - r - i - a - u,
  top: r + a,
  bottom: i + u
})), ia = F(Yn, (e) => ({
  width: e.propsWidth,
  height: e.propsHeight
})), ff = F(ra, oa, (e, t) => ({
  width: e,
  height: t
}));
function df(e, t) {
  return typeof e == "number" ? {
    top: e,
    bottom: e,
    left: e,
    right: e
  } : t ? k({}, t, e) : e;
}
const hf = 10, Xn = ({
  params: e,
  store: t,
  svgRef: r
}) => {
  const o = e.width !== void 0 && e.height !== void 0, i = A.useRef({
    displayError: !1,
    initialCompute: !0,
    computeRun: 0
  }), [s, a] = A.useState(0), [c, u] = A.useState(0), l = A.useCallback(() => {
    const m = r == null ? void 0 : r.current;
    if (!m)
      return {};
    const y = Gu(m).getComputedStyle(m), b = Math.floor(parseFloat(y.height)) || 0, O = Math.floor(parseFloat(y.width)) || 0;
    return t.update((x) => x.dimensions.width === O && x.dimensions.height === b ? x : k({}, x, {
      dimensions: {
        margin: {
          top: e.margin.top,
          right: e.margin.right,
          bottom: e.margin.bottom,
          left: e.margin.left
        },
        width: e.width ?? O,
        height: e.height ?? b,
        propsWidth: e.width,
        propsHeight: e.height
      }
    })), {
      height: b,
      width: O
    };
  }, [
    t,
    r,
    e.height,
    e.width,
    // Margin is an object, so we need to include all the properties to prevent infinite loops.
    e.margin.left,
    e.margin.right,
    e.margin.top,
    e.margin.bottom
  ]);
  A.useEffect(() => {
    t.update((m) => {
      const g = e.width ?? m.dimensions.width, y = e.height ?? m.dimensions.height;
      return k({}, m, {
        dimensions: {
          margin: {
            top: e.margin.top,
            right: e.margin.right,
            bottom: e.margin.bottom,
            left: e.margin.left
          },
          width: g,
          height: y,
          propsHeight: e.height,
          propsWidth: e.width
        }
      });
    });
  }, [
    t,
    e.height,
    e.width,
    // Margin is an object, so we need to include all the properties to prevent infinite loops.
    e.margin.left,
    e.margin.right,
    e.margin.top,
    e.margin.bottom
  ]), A.useEffect(() => {
    i.current.displayError = !0;
  }, []), Ae(() => {
    if (o || !i.current.initialCompute || i.current.computeRun > hf)
      return;
    const m = l();
    m.width !== s || m.height !== c ? (i.current.computeRun += 1, m.width !== void 0 && a(m.width), m.height !== void 0 && u(m.height)) : i.current.initialCompute && (i.current.initialCompute = !1);
  }, [c, s, l, o]), Ae(() => {
    if (o)
      return () => {
      };
    l();
    const m = r.current;
    if (typeof ResizeObserver > "u")
      return () => {
      };
    let g;
    const y = new ResizeObserver(() => {
      g = requestAnimationFrame(() => {
        l();
      });
    });
    return m && y.observe(m), () => {
      g && cancelAnimationFrame(g), m && y.unobserve(m);
    };
  }, [l, o, r]), "production".NODE_ENV !== "production" && (i.current.displayError && e.width === void 0 && s === 0 && (console.error("MUI X Charts: ChartContainer does not have `width` prop, and its container has no `width` defined."), i.current.displayError = !1), i.current.displayError && e.height === void 0 && c === 0 && (console.error("MUI X Charts: ChartContainer does not have `height` prop, and its container has no `height` defined."), i.current.displayError = !1));
  const h = V(t, Ue), f = A.useCallback((m) => m >= h.left - 1 && m <= h.left + h.width, [h.left, h.width]), d = A.useCallback((m) => m >= h.top - 1 && m <= h.top + h.height, [h.height, h.top]);
  return {
    instance: {
      isPointInside: A.useCallback((m, g, y) => y && y.closest("[data-drawing-container]") ? !0 : f(m) && d(g), [f, d]),
      isXInside: f,
      isYInside: d
    }
  };
};
Xn.params = {
  width: !0,
  height: !0,
  margin: !0
};
Xn.getDefaultizedParams = ({
  params: e
}) => k({}, e, {
  margin: df(e.margin, Ju)
});
Xn.getInitialState = ({
  width: e,
  height: t,
  margin: r
}) => ({
  dimensions: {
    margin: r,
    width: e ?? 0,
    height: t ?? 0,
    propsWidth: e,
    propsHeight: t
  }
});
let vi = 0;
const pf = () => (vi += 1, `mui-chart-${vi}`), yo = ({
  params: e,
  store: t
}) => (A.useEffect(() => {
  t.update((r) => e.id === void 0 || e.id === r.id.providedChartId && r.id.chartId !== void 0 ? r : k({}, r, {
    id: k({}, r.id, {
      chartId: e.id ?? pf()
    })
  }));
}, [t, e.id]), {});
yo.params = {
  id: !0
};
yo.getInitialState = ({
  id: e
}) => ({
  id: {
    chartId: e,
    providedChartId: e
  }
});
const mf = (e) => e.id, gf = F(mf, (e) => e.chartId), yf = ["#4254FB", "#FFB422", "#FA4F58", "#0DBEFF", "#22BF75", "#FA83B4", "#FF7511"], bf = ["#495AFB", "#FFC758", "#F35865", "#30C8FF", "#44CE8D", "#F286B3", "#FF8C39"], sa = (e) => e === "dark" ? bf : yf, aa = ({
  series: e,
  colors: t,
  seriesConfig: r,
  dataset: o
}) => {
  const i = {};
  e.forEach((a, c) => {
    var h;
    const u = r[a.type].getSeriesWithDefaultValues(a, c, t), l = u.id;
    if (i[a.type] === void 0 && (i[a.type] = {
      series: {},
      seriesOrder: []
    }), ((h = i[a.type]) == null ? void 0 : h.series[l]) !== void 0)
      throw new Error(`MUI X Charts: series' id "${l}" is not unique.`);
    i[a.type].series[l] = u, i[a.type].seriesOrder.push(l);
  });
  const s = {};
  return Object.keys(r).forEach((a) => {
    var u, l;
    const c = i[a];
    c !== void 0 && (s[a] = ((l = (u = r[a]) == null ? void 0 : u.seriesProcessor) == null ? void 0 : l.call(u, c, o)) ?? i[a]);
  }), s;
}, Bn = ({
  params: e,
  store: t,
  seriesConfig: r
}) => {
  const {
    series: o,
    dataset: i,
    theme: s,
    colors: a
  } = e, c = A.useRef(!0);
  return A.useEffect(() => {
    if (c.current) {
      c.current = !1;
      return;
    }
    t.update((u) => k({}, u, {
      series: k({}, u.series, {
        processedSeries: aa({
          series: o,
          colors: typeof a == "function" ? a(s) : a,
          seriesConfig: r,
          dataset: i
        })
      })
    }));
  }, [a, i, o, s, r, t]), {};
};
Bn.params = {
  dataset: !0,
  series: !0,
  colors: !0,
  theme: !0
};
const xf = [];
Bn.getDefaultizedParams = ({
  params: e
}) => {
  var t;
  return k({}, e, {
    series: (t = e.series) != null && t.length ? e.series : xf,
    colors: e.colors ?? sa,
    theme: e.theme ?? "light"
  });
};
Bn.getInitialState = ({
  series: e = [],
  colors: t,
  theme: r,
  dataset: o
}, i, s) => ({
  series: {
    seriesConfig: s,
    processedSeries: aa({
      series: e,
      colors: typeof t == "function" ? t(r) : t,
      seriesConfig: s,
      dataset: o
    })
  }
});
const ca = (e) => e.series, Ee = F(ca, (e) => e.processedSeries), He = F(ca, (e) => e.seriesConfig), Of = [yo, Xn, Bn, Gn], Tf = ["apiRef"], kf = (e) => {
  let {
    plugins: t
  } = e, r = B(e.props, Tf);
  const o = {};
  t.forEach((a) => {
    Object.assign(o, a.params);
  });
  const i = {};
  return Object.keys(r).forEach((a) => {
    const c = r[a];
    o[a] && (i[a] = c);
  }), t.reduce((a, c) => c.getDefaultizedParams ? c.getDefaultizedParams({
    params: a
  }) : a, i);
};
let Mi = 0;
function _f(e, t, r) {
  const o = Zs(), i = A.useMemo(() => [...Of, ...e], [e]), s = kf({
    plugins: i,
    props: t
  });
  s.id = s.id ?? o;
  const c = A.useRef({}).current, u = vf(t.apiRef), l = A.useRef(null), h = A.useRef(null), f = A.useRef(null);
  if (f.current == null) {
    Mi += 1;
    const m = {
      cacheKey: {
        id: Mi
      }
    };
    i.forEach((g) => {
      g.getInitialState && Object.assign(m, g.getInitialState(s, m, r));
    }), f.current = new Tu(m);
  }
  const d = (m) => {
    const g = m({
      instance: c,
      params: s,
      plugins: i,
      store: f.current,
      svgRef: h,
      chartRootRef: l,
      seriesConfig: r
    });
    g.publicAPI && Object.assign(u.current, g.publicAPI), g.instance && Object.assign(c, g.instance);
  };
  return i.forEach(d), {
    contextValue: A.useMemo(() => ({
      store: f.current,
      publicAPI: u.current,
      instance: c,
      svgRef: h,
      chartRootRef: l
    }), [c, u])
  };
}
function wf(e) {
  return e.current == null && (e.current = {}), e;
}
function vf(e) {
  const t = A.useRef({});
  return e ? wf(e) : t;
}
const bo = /* @__PURE__ */ A.createContext(null);
"production".NODE_ENV !== "production" && (bo.displayName = "ChartContext");
const Ci = /* @__PURE__ */ new Set();
function rt(e, t = "warning") {
  if ("production".NODE_ENV === "production")
    return;
  const r = Array.isArray(e) ? e.join(`
`) : e;
  Ci.has(r) || (Ci.add(r), t === "error" ? console.error(r) : console.warn(r));
}
const Mf = 4, Cf = 20 + 2 * Mf, If = "hover", Ar = {
  minStart: 0,
  maxEnd: 100,
  step: 5,
  minSpan: 10,
  maxSpan: 100,
  panning: !0,
  filterMode: "keep",
  slider: {
    enabled: !1,
    size: Cf,
    showTooltip: If
  }
}, xo = (e, t, r) => {
  if (e)
    return e === !0 ? k({
      axisId: t,
      axisDirection: r
    }, Ar) : k({
      axisId: t,
      axisDirection: r
    }, Ar, e, {
      slider: k({}, Ar.slider, e.slider)
    });
};
function la(e, t) {
  const r = {
    top: 0,
    bottom: 0,
    none: 0
  };
  return (e && e.length > 0 ? e : [{
    id: St,
    scaleType: "linear"
  }]).map((s, a) => {
    var p;
    const c = s.dataKey, u = a === 0 ? "bottom" : "none", l = s.position ?? u, h = tf + (s.label ? ta : 0), f = s.id ?? `defaultized-x-axis-${a}`, d = k({
      offset: r[l]
    }, s, {
      id: f,
      position: l,
      height: s.height ?? h,
      zoom: xo(s.zoom, f, "x")
    });
    if (l !== "none" && (r[l] += d.height, (p = d.zoom) != null && p.slider.enabled && (r[l] += d.zoom.slider.size)), c === void 0 || s.data !== void 0)
      return d;
    if (t === void 0)
      throw new Error("MUI X Charts: x-axis uses `dataKey` but no `dataset` is provided.");
    return k({}, d, {
      data: t.map((m) => m[c])
    });
  });
}
function ua(e, t) {
  const r = {
    right: 0,
    left: 0,
    none: 0
  };
  return (e && e.length > 0 ? e : [{
    id: Qu,
    scaleType: "linear"
  }]).map((s, a) => {
    var p;
    const c = s.dataKey, u = a === 0 ? "left" : "none", l = s.position ?? u, h = ef + (s.label ? ta : 0), f = s.id ?? `defaultized-y-axis-${a}`, d = k({
      offset: r[l]
    }, s, {
      id: f,
      position: l,
      width: s.width ?? h,
      zoom: xo(s.zoom, f, "y")
    });
    if (l !== "none" && (r[l] += d.width, (p = d.zoom) != null && p.slider.enabled && (r[l] += d.zoom.slider.size)), c === void 0 || s.data !== void 0)
      return d;
    if (t === void 0)
      throw new Error("MUI X Charts: y-axis uses `dataKey` but no `dataset` is provided.");
    return k({}, d, {
      data: t.map((m) => m[c])
    });
  });
}
function bn(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Sf(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Oo(e) {
  let t, r, o;
  e.length !== 2 ? (t = bn, r = (c, u) => bn(e(c), u), o = (c, u) => e(c) - u) : (t = e === bn || e === Sf ? e : Af, r = e, o = e);
  function i(c, u, l = 0, h = c.length) {
    if (l < h) {
      if (t(u, u) !== 0)
        return h;
      do {
        const f = l + h >>> 1;
        r(c[f], u) < 0 ? l = f + 1 : h = f;
      } while (l < h);
    }
    return l;
  }
  function s(c, u, l = 0, h = c.length) {
    if (l < h) {
      if (t(u, u) !== 0)
        return h;
      do {
        const f = l + h >>> 1;
        r(c[f], u) <= 0 ? l = f + 1 : h = f;
      } while (l < h);
    }
    return l;
  }
  function a(c, u, l = 0, h = c.length) {
    const f = i(c, u, l, h - 1);
    return f > l && o(c[f - 1], u) > -o(c[f], u) ? f - 1 : f;
  }
  return { left: i, center: a, right: s };
}
function Af() {
  return 0;
}
function Ef(e) {
  return e === null ? NaN : +e;
}
const Rf = Oo(bn), jf = Rf.right;
Oo(Ef).center;
const fa = jf;
class Ii extends Map {
  constructor(t, r = $f) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: r } }), t != null)
      for (const [o, i] of t)
        this.set(o, i);
  }
  get(t) {
    return super.get(Si(this, t));
  }
  has(t) {
    return super.has(Si(this, t));
  }
  set(t, r) {
    return super.set(Pf(this, t), r);
  }
  delete(t) {
    return super.delete(Nf(this, t));
  }
}
function Si({ _intern: e, _key: t }, r) {
  const o = t(r);
  return e.has(o) ? e.get(o) : r;
}
function Pf({ _intern: e, _key: t }, r) {
  const o = t(r);
  return e.has(o) ? e.get(o) : (e.set(o, r), r);
}
function Nf({ _intern: e, _key: t }, r) {
  const o = t(r);
  return e.has(o) && (r = e.get(o), e.delete(o)), r;
}
function $f(e) {
  return e !== null && typeof e == "object" ? e.valueOf() : e;
}
const Lf = Math.sqrt(50), Df = Math.sqrt(10), qf = Math.sqrt(2);
function _n(e, t, r) {
  const o = (t - e) / Math.max(0, r), i = Math.floor(Math.log10(o)), s = o / Math.pow(10, i), a = s >= Lf ? 10 : s >= Df ? 5 : s >= qf ? 2 : 1;
  let c, u, l;
  return i < 0 ? (l = Math.pow(10, -i) / a, c = Math.round(e * l), u = Math.round(t * l), c / l < e && ++c, u / l > t && --u, l = -l) : (l = Math.pow(10, i) * a, c = Math.round(e / l), u = Math.round(t / l), c * l < e && ++c, u * l > t && --u), u < c && 0.5 <= r && r < 2 ? _n(e, t, r * 2) : [c, u, l];
}
function Qr(e, t, r) {
  if (t = +t, e = +e, r = +r, !(r > 0))
    return [];
  if (e === t)
    return [e];
  const o = t < e, [i, s, a] = o ? _n(t, e, r) : _n(e, t, r);
  if (!(s >= i))
    return [];
  const c = s - i + 1, u = new Array(c);
  if (o)
    if (a < 0)
      for (let l = 0; l < c; ++l)
        u[l] = (s - l) / -a;
    else
      for (let l = 0; l < c; ++l)
        u[l] = (s - l) * a;
  else if (a < 0)
    for (let l = 0; l < c; ++l)
      u[l] = (i + l) / -a;
  else
    for (let l = 0; l < c; ++l)
      u[l] = (i + l) * a;
  return u;
}
function Jr(e, t, r) {
  return t = +t, e = +e, r = +r, _n(e, t, r)[2];
}
function eo(e, t, r) {
  t = +t, e = +e, r = +r;
  const o = t < e, i = o ? Jr(t, e, r) : Jr(e, t, r);
  return (o ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function Ff(e, t, r) {
  e = +e, t = +t, r = (i = arguments.length) < 2 ? (t = e, e = 0, 1) : i < 3 ? 1 : +r;
  for (var o = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, s = new Array(i); ++o < i; )
    s[o] = e + o * r;
  return s;
}
function Be(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function zf(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
    default: {
      this.domain(e), typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
  }
  return this;
}
const Ai = Symbol("implicit");
function wn() {
  var e = new Ii(), t = [], r = [], o = Ai;
  function i(s) {
    let a = e.get(s);
    if (a === void 0) {
      if (o !== Ai)
        return o;
      e.set(s, a = t.push(s) - 1);
    }
    return r[a % r.length];
  }
  return i.domain = function(s) {
    if (!arguments.length)
      return t.slice();
    t = [], e = new Ii();
    for (const a of s)
      e.has(a) || e.set(a, t.push(a) - 1);
    return i;
  }, i.range = function(s) {
    return arguments.length ? (r = Array.from(s), i) : r.slice();
  }, i.unknown = function(s) {
    return arguments.length ? (o = s, i) : o;
  }, i.copy = function() {
    return wn(t, r).unknown(o);
  }, Be.apply(i, arguments), i;
}
function Kn() {
  var e = wn().unknown(void 0), t = e.domain, r = e.range, o = 0, i = 1, s, a, c = !1, u = 0, l = 0, h = 0.5;
  delete e.unknown;
  function f() {
    var d = t().length, p = i < o, m = p ? i : o, g = p ? o : i;
    s = (g - m) / Math.max(1, d - u + l * 2), c && (s = Math.floor(s)), m += (g - m - s * (d - u)) * h, a = s * (1 - u), c && (m = Math.round(m), a = Math.round(a));
    var y = Ff(d).map(function(b) {
      return m + s * b;
    });
    return r(p ? y.reverse() : y);
  }
  return e.domain = function(d) {
    return arguments.length ? (t(d), f()) : t();
  }, e.range = function(d) {
    return arguments.length ? ([o, i] = d, o = +o, i = +i, f()) : [o, i];
  }, e.rangeRound = function(d) {
    return [o, i] = d, o = +o, i = +i, c = !0, f();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return s;
  }, e.round = function(d) {
    return arguments.length ? (c = !!d, f()) : c;
  }, e.padding = function(d) {
    return arguments.length ? (u = Math.min(1, l = +d), f()) : u;
  }, e.paddingInner = function(d) {
    return arguments.length ? (u = Math.min(1, d), f()) : u;
  }, e.paddingOuter = function(d) {
    return arguments.length ? (l = +d, f()) : l;
  }, e.align = function(d) {
    return arguments.length ? (h = Math.max(0, Math.min(1, d)), f()) : h;
  }, e.copy = function() {
    return Kn(t(), [o, i]).round(c).paddingInner(u).paddingOuter(l).align(h);
  }, Be.apply(f(), arguments);
}
function da(e) {
  var t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, delete e.paddingOuter, e.copy = function() {
    return da(t());
  }, e;
}
function ha() {
  return da(Kn.apply(null, arguments).paddingInner(1));
}
function To(e, t, r) {
  e.prototype = t.prototype = r, r.constructor = e;
}
function pa(e, t) {
  var r = Object.create(e.prototype);
  for (var o in t)
    r[o] = t[o];
  return r;
}
function Kt() {
}
var Ut = 0.7, vn = 1 / Ut, yt = "\\s*([+-]?\\d+)\\s*", Ht = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Se = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Uf = /^#([0-9a-f]{3,8})$/, Hf = new RegExp(`^rgb\\(${yt},${yt},${yt}\\)$`), Vf = new RegExp(`^rgb\\(${Se},${Se},${Se}\\)$`), Gf = new RegExp(`^rgba\\(${yt},${yt},${yt},${Ht}\\)$`), Yf = new RegExp(`^rgba\\(${Se},${Se},${Se},${Ht}\\)$`), Wf = new RegExp(`^hsl\\(${Ht},${Se},${Se}\\)$`), Xf = new RegExp(`^hsla\\(${Ht},${Se},${Se},${Ht}\\)$`), Ei = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
To(Kt, Vt, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Ri,
  // Deprecated! Use color.formatHex.
  formatHex: Ri,
  formatHex8: Bf,
  formatHsl: Kf,
  formatRgb: ji,
  toString: ji
});
function Ri() {
  return this.rgb().formatHex();
}
function Bf() {
  return this.rgb().formatHex8();
}
function Kf() {
  return ma(this).formatHsl();
}
function ji() {
  return this.rgb().formatRgb();
}
function Vt(e) {
  var t, r;
  return e = (e + "").trim().toLowerCase(), (t = Uf.exec(e)) ? (r = t[1].length, t = parseInt(t[1], 16), r === 6 ? Pi(t) : r === 3 ? new ue(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : r === 8 ? un(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : r === 4 ? un(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Hf.exec(e)) ? new ue(t[1], t[2], t[3], 1) : (t = Vf.exec(e)) ? new ue(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Gf.exec(e)) ? un(t[1], t[2], t[3], t[4]) : (t = Yf.exec(e)) ? un(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Wf.exec(e)) ? Li(t[1], t[2] / 100, t[3] / 100, 1) : (t = Xf.exec(e)) ? Li(t[1], t[2] / 100, t[3] / 100, t[4]) : Ei.hasOwnProperty(e) ? Pi(Ei[e]) : e === "transparent" ? new ue(NaN, NaN, NaN, 0) : null;
}
function Pi(e) {
  return new ue(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function un(e, t, r, o) {
  return o <= 0 && (e = t = r = NaN), new ue(e, t, r, o);
}
function Zf(e) {
  return e instanceof Kt || (e = Vt(e)), e ? (e = e.rgb(), new ue(e.r, e.g, e.b, e.opacity)) : new ue();
}
function to(e, t, r, o) {
  return arguments.length === 1 ? Zf(e) : new ue(e, t, r, o ?? 1);
}
function ue(e, t, r, o) {
  this.r = +e, this.g = +t, this.b = +r, this.opacity = +o;
}
To(ue, to, pa(Kt, {
  brighter(e) {
    return e = e == null ? vn : Math.pow(vn, e), new ue(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ut : Math.pow(Ut, e), new ue(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new ue(tt(this.r), tt(this.g), tt(this.b), Mn(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Ni,
  // Deprecated! Use color.formatHex.
  formatHex: Ni,
  formatHex8: Qf,
  formatRgb: $i,
  toString: $i
}));
function Ni() {
  return `#${Ze(this.r)}${Ze(this.g)}${Ze(this.b)}`;
}
function Qf() {
  return `#${Ze(this.r)}${Ze(this.g)}${Ze(this.b)}${Ze((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function $i() {
  const e = Mn(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${tt(this.r)}, ${tt(this.g)}, ${tt(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Mn(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function tt(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ze(e) {
  return e = tt(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Li(e, t, r, o) {
  return o <= 0 ? e = t = r = NaN : r <= 0 || r >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new ke(e, t, r, o);
}
function ma(e) {
  if (e instanceof ke)
    return new ke(e.h, e.s, e.l, e.opacity);
  if (e instanceof Kt || (e = Vt(e)), !e)
    return new ke();
  if (e instanceof ke)
    return e;
  e = e.rgb();
  var t = e.r / 255, r = e.g / 255, o = e.b / 255, i = Math.min(t, r, o), s = Math.max(t, r, o), a = NaN, c = s - i, u = (s + i) / 2;
  return c ? (t === s ? a = (r - o) / c + (r < o) * 6 : r === s ? a = (o - t) / c + 2 : a = (t - r) / c + 4, c /= u < 0.5 ? s + i : 2 - s - i, a *= 60) : c = u > 0 && u < 1 ? 0 : a, new ke(a, c, u, e.opacity);
}
function Jf(e, t, r, o) {
  return arguments.length === 1 ? ma(e) : new ke(e, t, r, o ?? 1);
}
function ke(e, t, r, o) {
  this.h = +e, this.s = +t, this.l = +r, this.opacity = +o;
}
To(ke, Jf, pa(Kt, {
  brighter(e) {
    return e = e == null ? vn : Math.pow(vn, e), new ke(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Ut : Math.pow(Ut, e), new ke(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, r = this.l, o = r + (r < 0.5 ? r : 1 - r) * t, i = 2 * r - o;
    return new ue(
      Er(e >= 240 ? e - 240 : e + 120, i, o),
      Er(e, i, o),
      Er(e < 120 ? e + 240 : e - 120, i, o),
      this.opacity
    );
  },
  clamp() {
    return new ke(Di(this.h), fn(this.s), fn(this.l), Mn(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Mn(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Di(this.h)}, ${fn(this.s) * 100}%, ${fn(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Di(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function fn(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Er(e, t, r) {
  return (e < 60 ? t + (r - t) * e / 60 : e < 180 ? r : e < 240 ? t + (r - t) * (240 - e) / 60 : t) * 255;
}
const ko = (e) => () => e;
function ed(e, t) {
  return function(r) {
    return e + r * t;
  };
}
function td(e, t, r) {
  return e = Math.pow(e, r), t = Math.pow(t, r) - e, r = 1 / r, function(o) {
    return Math.pow(e + o * t, r);
  };
}
function nd(e) {
  return (e = +e) == 1 ? ga : function(t, r) {
    return r - t ? td(t, r, e) : ko(isNaN(t) ? r : t);
  };
}
function ga(e, t) {
  var r = t - e;
  return r ? ed(e, r) : ko(isNaN(e) ? t : e);
}
const qi = function e(t) {
  var r = nd(t);
  function o(i, s) {
    var a = r((i = to(i)).r, (s = to(s)).r), c = r(i.g, s.g), u = r(i.b, s.b), l = ga(i.opacity, s.opacity);
    return function(h) {
      return i.r = a(h), i.g = c(h), i.b = u(h), i.opacity = l(h), i + "";
    };
  }
  return o.gamma = e, o;
}(1);
function rd(e, t) {
  t || (t = []);
  var r = e ? Math.min(t.length, e.length) : 0, o = t.slice(), i;
  return function(s) {
    for (i = 0; i < r; ++i)
      o[i] = e[i] * (1 - s) + t[i] * s;
    return o;
  };
}
function od(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function id(e, t) {
  var r = t ? t.length : 0, o = e ? Math.min(r, e.length) : 0, i = new Array(o), s = new Array(r), a;
  for (a = 0; a < o; ++a)
    i[a] = Zn(e[a], t[a]);
  for (; a < r; ++a)
    s[a] = t[a];
  return function(c) {
    for (a = 0; a < o; ++a)
      s[a] = i[a](c);
    return s;
  };
}
function _o(e, t) {
  var r = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(o) {
    return r.setTime(e * (1 - o) + t * o), r;
  };
}
function Tt(e, t) {
  return e = +e, t = +t, function(r) {
    return e * (1 - r) + t * r;
  };
}
function sd(e, t) {
  var r = {}, o = {}, i;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (i in t)
    i in e ? r[i] = Zn(e[i], t[i]) : o[i] = t[i];
  return function(s) {
    for (i in r)
      o[i] = r[i](s);
    return o;
  };
}
var no = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Rr = new RegExp(no.source, "g");
function ad(e) {
  return function() {
    return e;
  };
}
function cd(e) {
  return function(t) {
    return e(t) + "";
  };
}
function wo(e, t) {
  var r = no.lastIndex = Rr.lastIndex = 0, o, i, s, a = -1, c = [], u = [];
  for (e = e + "", t = t + ""; (o = no.exec(e)) && (i = Rr.exec(t)); )
    (s = i.index) > r && (s = t.slice(r, s), c[a] ? c[a] += s : c[++a] = s), (o = o[0]) === (i = i[0]) ? c[a] ? c[a] += i : c[++a] = i : (c[++a] = null, u.push({ i: a, x: Tt(o, i) })), r = Rr.lastIndex;
  return r < t.length && (s = t.slice(r), c[a] ? c[a] += s : c[++a] = s), c.length < 2 ? u[0] ? cd(u[0].x) : ad(t) : (t = u.length, function(l) {
    for (var h = 0, f; h < t; ++h)
      c[(f = u[h]).i] = f.x(l);
    return c.join("");
  });
}
function Zn(e, t) {
  var r = typeof t, o;
  return t == null || r === "boolean" ? ko(t) : (r === "number" ? Tt : r === "string" ? (o = Vt(t)) ? (t = o, qi) : wo : t instanceof Vt ? qi : t instanceof Date ? _o : od(t) ? rd : Array.isArray(t) ? id : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? sd : Tt)(e, t);
}
function ya(e, t) {
  return e = +e, t = +t, function(r) {
    return Math.round(e * (1 - r) + t * r);
  };
}
function ld(e) {
  return function() {
    return e;
  };
}
function ud(e) {
  return +e;
}
var Fi = [0, 1];
function ge(e) {
  return e;
}
function ro(e, t) {
  return (t -= e = +e) ? function(r) {
    return (r - e) / t;
  } : ld(isNaN(t) ? NaN : 0.5);
}
function fd(e, t) {
  var r;
  return e > t && (r = e, e = t, t = r), function(o) {
    return Math.max(e, Math.min(t, o));
  };
}
function dd(e, t, r) {
  var o = e[0], i = e[1], s = t[0], a = t[1];
  return i < o ? (o = ro(i, o), s = r(a, s)) : (o = ro(o, i), s = r(s, a)), function(c) {
    return s(o(c));
  };
}
function hd(e, t, r) {
  var o = Math.min(e.length, t.length) - 1, i = new Array(o), s = new Array(o), a = -1;
  for (e[o] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < o; )
    i[a] = ro(e[a], e[a + 1]), s[a] = r(t[a], t[a + 1]);
  return function(c) {
    var u = fa(e, c, 1, o) - 1;
    return s[u](i[u](c));
  };
}
function Qn(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function vo() {
  var e = Fi, t = Fi, r = Zn, o, i, s, a = ge, c, u, l;
  function h() {
    var d = Math.min(e.length, t.length);
    return a !== ge && (a = fd(e[0], e[d - 1])), c = d > 2 ? hd : dd, u = l = null, f;
  }
  function f(d) {
    return d == null || isNaN(d = +d) ? s : (u || (u = c(e.map(o), t, r)))(o(a(d)));
  }
  return f.invert = function(d) {
    return a(i((l || (l = c(t, e.map(o), Tt)))(d)));
  }, f.domain = function(d) {
    return arguments.length ? (e = Array.from(d, ud), h()) : e.slice();
  }, f.range = function(d) {
    return arguments.length ? (t = Array.from(d), h()) : t.slice();
  }, f.rangeRound = function(d) {
    return t = Array.from(d), r = ya, h();
  }, f.clamp = function(d) {
    return arguments.length ? (a = d ? !0 : ge, h()) : a !== ge;
  }, f.interpolate = function(d) {
    return arguments.length ? (r = d, h()) : r;
  }, f.unknown = function(d) {
    return arguments.length ? (s = d, f) : s;
  }, function(d, p) {
    return o = d, i = p, h();
  };
}
function ba() {
  return vo()(ge, ge);
}
function pd(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Cn(e, t) {
  if ((r = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var r, o = e.slice(0, r);
  return [
    o.length > 1 ? o[0] + o.slice(2) : o,
    +e.slice(r + 1)
  ];
}
function kt(e) {
  return e = Cn(Math.abs(e)), e ? e[1] : NaN;
}
function md(e, t) {
  return function(r, o) {
    for (var i = r.length, s = [], a = 0, c = e[0], u = 0; i > 0 && c > 0 && (u + c + 1 > o && (c = Math.max(1, o - u)), s.push(r.substring(i -= c, i + c)), !((u += c + 1) > o)); )
      c = e[a = (a + 1) % e.length];
    return s.reverse().join(t);
  };
}
function gd(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(r) {
      return e[+r];
    });
  };
}
var yd = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Gt(e) {
  if (!(t = yd.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new Mo({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Gt.prototype = Mo.prototype;
function Mo(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
Mo.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function bd(e) {
  e:
    for (var t = e.length, r = 1, o = -1, i; r < t; ++r)
      switch (e[r]) {
        case ".":
          o = i = r;
          break;
        case "0":
          o === 0 && (o = r), i = r;
          break;
        default:
          if (!+e[r])
            break e;
          o > 0 && (o = 0);
          break;
      }
  return o > 0 ? e.slice(0, o) + e.slice(i + 1) : e;
}
var xa;
function xd(e, t) {
  var r = Cn(e, t);
  if (!r)
    return e + "";
  var o = r[0], i = r[1], s = i - (xa = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1, a = o.length;
  return s === a ? o : s > a ? o + new Array(s - a + 1).join("0") : s > 0 ? o.slice(0, s) + "." + o.slice(s) : "0." + new Array(1 - s).join("0") + Cn(e, Math.max(0, t + s - 1))[0];
}
function zi(e, t) {
  var r = Cn(e, t);
  if (!r)
    return e + "";
  var o = r[0], i = r[1];
  return i < 0 ? "0." + new Array(-i).join("0") + o : o.length > i + 1 ? o.slice(0, i + 1) + "." + o.slice(i + 1) : o + new Array(i - o.length + 2).join("0");
}
const Ui = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: pd,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => zi(e * 100, t),
  r: zi,
  s: xd,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function Hi(e) {
  return e;
}
var Vi = Array.prototype.map, Gi = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Od(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? Hi : md(Vi.call(e.grouping, Number), e.thousands + ""), r = e.currency === void 0 ? "" : e.currency[0] + "", o = e.currency === void 0 ? "" : e.currency[1] + "", i = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? Hi : gd(Vi.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", c = e.minus === void 0 ? "" : e.minus + "", u = e.nan === void 0 ? "NaN" : e.nan + "";
  function l(f) {
    f = Gt(f);
    var d = f.fill, p = f.align, m = f.sign, g = f.symbol, y = f.zero, b = f.width, O = f.comma, x = f.precision, _ = f.trim, M = f.type;
    M === "n" ? (O = !0, M = "g") : Ui[M] || (x === void 0 && (x = 12), _ = !0, M = "g"), (y || d === "0" && p === "=") && (y = !0, d = "0", p = "=");
    var T = g === "$" ? r : g === "#" && /[boxX]/.test(M) ? "0" + M.toLowerCase() : "", v = g === "$" ? o : /[%p]/.test(M) ? a : "", S = Ui[M], C = /[defgprs%]/.test(M);
    x = x === void 0 ? 6 : /[gprs]/.test(M) ? Math.max(1, Math.min(21, x)) : Math.max(0, Math.min(20, x));
    function P(I) {
      var L = T, R = v, $, N, E;
      if (M === "c")
        R = S(I) + R, I = "";
      else {
        I = +I;
        var D = I < 0 || 1 / I < 0;
        if (I = isNaN(I) ? u : S(Math.abs(I), x), _ && (I = bd(I)), D && +I == 0 && m !== "+" && (D = !1), L = (D ? m === "(" ? m : c : m === "-" || m === "(" ? "" : m) + L, R = (M === "s" ? Gi[8 + xa / 3] : "") + R + (D && m === "(" ? ")" : ""), C) {
          for ($ = -1, N = I.length; ++$ < N; )
            if (E = I.charCodeAt($), 48 > E || E > 57) {
              R = (E === 46 ? i + I.slice($ + 1) : I.slice($)) + R, I = I.slice(0, $);
              break;
            }
        }
      }
      O && !y && (I = t(I, 1 / 0));
      var U = L.length + I.length + R.length, z = U < b ? new Array(b - U + 1).join(d) : "";
      switch (O && y && (I = t(z + I, z.length ? b - R.length : 1 / 0), z = ""), p) {
        case "<":
          I = L + I + R + z;
          break;
        case "=":
          I = L + z + I + R;
          break;
        case "^":
          I = z.slice(0, U = z.length >> 1) + L + I + R + z.slice(U);
          break;
        default:
          I = z + L + I + R;
          break;
      }
      return s(I);
    }
    return P.toString = function() {
      return f + "";
    }, P;
  }
  function h(f, d) {
    var p = l((f = Gt(f), f.type = "f", f)), m = Math.max(-8, Math.min(8, Math.floor(kt(d) / 3))) * 3, g = Math.pow(10, -m), y = Gi[8 + m / 3];
    return function(b) {
      return p(g * b) + y;
    };
  }
  return {
    format: l,
    formatPrefix: h
  };
}
var dn, Co, Oa;
Td({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function Td(e) {
  return dn = Od(e), Co = dn.format, Oa = dn.formatPrefix, dn;
}
function kd(e) {
  return Math.max(0, -kt(Math.abs(e)));
}
function _d(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(kt(t) / 3))) * 3 - kt(Math.abs(e)));
}
function wd(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, kt(t) - kt(e)) + 1;
}
function vd(e, t, r, o) {
  var i = eo(e, t, r), s;
  switch (o = Gt(o ?? ",f"), o.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return o.precision == null && !isNaN(s = _d(i, a)) && (o.precision = s), Oa(o, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      o.precision == null && !isNaN(s = wd(i, Math.max(Math.abs(e), Math.abs(t)))) && (o.precision = s - (o.type === "e"));
      break;
    }
    case "f":
    case "%": {
      o.precision == null && !isNaN(s = kd(i)) && (o.precision = s - (o.type === "%") * 2);
      break;
    }
  }
  return Co(o);
}
function Io(e) {
  var t = e.domain;
  return e.ticks = function(r) {
    var o = t();
    return Qr(o[0], o[o.length - 1], r ?? 10);
  }, e.tickFormat = function(r, o) {
    var i = t();
    return vd(i[0], i[i.length - 1], r ?? 10, o);
  }, e.nice = function(r) {
    r == null && (r = 10);
    var o = t(), i = 0, s = o.length - 1, a = o[i], c = o[s], u, l, h = 10;
    for (c < a && (l = a, a = c, c = l, l = i, i = s, s = l); h-- > 0; ) {
      if (l = Jr(a, c, r), l === u)
        return o[i] = a, o[s] = c, t(o);
      if (l > 0)
        a = Math.floor(a / l) * l, c = Math.ceil(c / l) * l;
      else if (l < 0)
        a = Math.ceil(a * l) / l, c = Math.floor(c * l) / l;
      else
        break;
      u = l;
    }
    return e;
  }, e;
}
function Ta() {
  var e = ba();
  return e.copy = function() {
    return Qn(e, Ta());
  }, Be.apply(e, arguments), Io(e);
}
function ka(e, t) {
  e = e.slice();
  var r = 0, o = e.length - 1, i = e[r], s = e[o], a;
  return s < i && (a = r, r = o, o = a, a = i, i = s, s = a), e[r] = t.floor(i), e[o] = t.ceil(s), e;
}
function Yi(e) {
  return Math.log(e);
}
function Wi(e) {
  return Math.exp(e);
}
function Md(e) {
  return -Math.log(-e);
}
function Cd(e) {
  return -Math.exp(-e);
}
function Id(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function Sd(e) {
  return e === 10 ? Id : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function Ad(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function Xi(e) {
  return (t, r) => -e(-t, r);
}
function Ed(e) {
  const t = e(Yi, Wi), r = t.domain;
  let o = 10, i, s;
  function a() {
    return i = Ad(o), s = Sd(o), r()[0] < 0 ? (i = Xi(i), s = Xi(s), e(Md, Cd)) : e(Yi, Wi), t;
  }
  return t.base = function(c) {
    return arguments.length ? (o = +c, a()) : o;
  }, t.domain = function(c) {
    return arguments.length ? (r(c), a()) : r();
  }, t.ticks = (c) => {
    const u = r();
    let l = u[0], h = u[u.length - 1];
    const f = h < l;
    f && ([l, h] = [h, l]);
    let d = i(l), p = i(h), m, g;
    const y = c == null ? 10 : +c;
    let b = [];
    if (!(o % 1) && p - d < y) {
      if (d = Math.floor(d), p = Math.ceil(p), l > 0) {
        for (; d <= p; ++d)
          for (m = 1; m < o; ++m)
            if (g = d < 0 ? m / s(-d) : m * s(d), !(g < l)) {
              if (g > h)
                break;
              b.push(g);
            }
      } else
        for (; d <= p; ++d)
          for (m = o - 1; m >= 1; --m)
            if (g = d > 0 ? m / s(-d) : m * s(d), !(g < l)) {
              if (g > h)
                break;
              b.push(g);
            }
      b.length * 2 < y && (b = Qr(l, h, y));
    } else
      b = Qr(d, p, Math.min(p - d, y)).map(s);
    return f ? b.reverse() : b;
  }, t.tickFormat = (c, u) => {
    if (c == null && (c = 10), u == null && (u = o === 10 ? "s" : ","), typeof u != "function" && (!(o % 1) && (u = Gt(u)).precision == null && (u.trim = !0), u = Co(u)), c === 1 / 0)
      return u;
    const l = Math.max(1, o * c / t.ticks().length);
    return (h) => {
      let f = h / s(Math.round(i(h)));
      return f * o < o - 0.5 && (f *= o), f <= l ? u(h) : "";
    };
  }, t.nice = () => r(ka(r(), {
    floor: (c) => s(Math.floor(i(c))),
    ceil: (c) => s(Math.ceil(i(c)))
  })), t;
}
function _a() {
  const e = Ed(vo()).domain([1, 10]);
  return e.copy = () => Qn(e, _a()).base(e.base()), Be.apply(e, arguments), e;
}
function Bi(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function Rd(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function jd(e) {
  return e < 0 ? -e * e : e * e;
}
function Pd(e) {
  var t = e(ge, ge), r = 1;
  function o() {
    return r === 1 ? e(ge, ge) : r === 0.5 ? e(Rd, jd) : e(Bi(r), Bi(1 / r));
  }
  return t.exponent = function(i) {
    return arguments.length ? (r = +i, o()) : r;
  }, Io(t);
}
function So() {
  var e = Pd(vo());
  return e.copy = function() {
    return Qn(e, So()).exponent(e.exponent());
  }, Be.apply(e, arguments), e;
}
function Nd() {
  return So.apply(null, arguments).exponent(0.5);
}
function wa() {
  var e = [0.5], t = [0, 1], r, o = 1;
  function i(s) {
    return s != null && s <= s ? t[fa(e, s, 0, o)] : r;
  }
  return i.domain = function(s) {
    return arguments.length ? (e = Array.from(s), o = Math.min(e.length, t.length - 1), i) : e.slice();
  }, i.range = function(s) {
    return arguments.length ? (t = Array.from(s), o = Math.min(e.length, t.length - 1), i) : t.slice();
  }, i.invertExtent = function(s) {
    var a = t.indexOf(s);
    return [e[a - 1], e[a]];
  }, i.unknown = function(s) {
    return arguments.length ? (r = s, i) : r;
  }, i.copy = function() {
    return wa().domain(e).range(t).unknown(r);
  }, Be.apply(i, arguments);
}
const jr = /* @__PURE__ */ new Date(), Pr = /* @__PURE__ */ new Date();
function ne(e, t, r, o) {
  function i(s) {
    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return i.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), i.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), i.round = (s) => {
    const a = i(s), c = i.ceil(s);
    return s - a < c - s ? a : c;
  }, i.offset = (s, a) => (t(s = /* @__PURE__ */ new Date(+s), a == null ? 1 : Math.floor(a)), s), i.range = (s, a, c) => {
    const u = [];
    if (s = i.ceil(s), c = c == null ? 1 : Math.floor(c), !(s < a) || !(c > 0))
      return u;
    let l;
    do
      u.push(l = /* @__PURE__ */ new Date(+s)), t(s, c), e(s);
    while (l < s && s < a);
    return u;
  }, i.filter = (s) => ne((a) => {
    if (a >= a)
      for (; e(a), !s(a); )
        a.setTime(a - 1);
  }, (a, c) => {
    if (a >= a)
      if (c < 0)
        for (; ++c <= 0; )
          for (; t(a, -1), !s(a); )
            ;
      else
        for (; --c >= 0; )
          for (; t(a, 1), !s(a); )
            ;
  }), r && (i.count = (s, a) => (jr.setTime(+s), Pr.setTime(+a), e(jr), e(Pr), Math.floor(r(jr, Pr))), i.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? i.filter(o ? (a) => o(a) % s === 0 : (a) => i.count(0, a) % s === 0) : i)), i;
}
const In = ne(() => {
}, (e, t) => {
  e.setTime(+e + t);
}, (e, t) => t - e);
In.every = (e) => (e = Math.floor(e), !isFinite(e) || !(e > 0) ? null : e > 1 ? ne((t) => {
  t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
  t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : In);
In.range;
const Ne = 1e3, ye = Ne * 60, $e = ye * 60, De = $e * 24, Ao = De * 7, Ki = De * 30, Nr = De * 365, Qe = ne((e) => {
  e.setTime(e - e.getMilliseconds());
}, (e, t) => {
  e.setTime(+e + t * Ne);
}, (e, t) => (t - e) / Ne, (e) => e.getUTCSeconds());
Qe.range;
const Eo = ne((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Ne);
}, (e, t) => {
  e.setTime(+e + t * ye);
}, (e, t) => (t - e) / ye, (e) => e.getMinutes());
Eo.range;
const Ro = ne((e) => {
  e.setUTCSeconds(0, 0);
}, (e, t) => {
  e.setTime(+e + t * ye);
}, (e, t) => (t - e) / ye, (e) => e.getUTCMinutes());
Ro.range;
const jo = ne((e) => {
  e.setTime(e - e.getMilliseconds() - e.getSeconds() * Ne - e.getMinutes() * ye);
}, (e, t) => {
  e.setTime(+e + t * $e);
}, (e, t) => (t - e) / $e, (e) => e.getHours());
jo.range;
const Po = ne((e) => {
  e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
  e.setTime(+e + t * $e);
}, (e, t) => (t - e) / $e, (e) => e.getUTCHours());
Po.range;
const Zt = ne(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * ye) / De,
  (e) => e.getDate() - 1
);
Zt.range;
const Jn = ne((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / De, (e) => e.getUTCDate() - 1);
Jn.range;
const va = ne((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / De, (e) => Math.floor(e / De));
va.range;
function it(e) {
  return ne((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, r) => {
    t.setDate(t.getDate() + r * 7);
  }, (t, r) => (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * ye) / Ao);
}
const er = it(0), Sn = it(1), $d = it(2), Ld = it(3), _t = it(4), Dd = it(5), qd = it(6);
er.range;
Sn.range;
$d.range;
Ld.range;
_t.range;
Dd.range;
qd.range;
function st(e) {
  return ne((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, r) => {
    t.setUTCDate(t.getUTCDate() + r * 7);
  }, (t, r) => (r - t) / Ao);
}
const tr = st(0), An = st(1), Fd = st(2), zd = st(3), wt = st(4), Ud = st(5), Hd = st(6);
tr.range;
An.range;
Fd.range;
zd.range;
wt.range;
Ud.range;
Hd.range;
const No = ne((e) => {
  e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
No.range;
const $o = ne((e) => {
  e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
$o.range;
const qe = ne((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
qe.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ne((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, r) => {
  t.setFullYear(t.getFullYear() + r * e);
});
qe.range;
const Fe = ne((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
Fe.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : ne((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, r) => {
  t.setUTCFullYear(t.getUTCFullYear() + r * e);
});
Fe.range;
function Ma(e, t, r, o, i, s) {
  const a = [
    [Qe, 1, Ne],
    [Qe, 5, 5 * Ne],
    [Qe, 15, 15 * Ne],
    [Qe, 30, 30 * Ne],
    [s, 1, ye],
    [s, 5, 5 * ye],
    [s, 15, 15 * ye],
    [s, 30, 30 * ye],
    [i, 1, $e],
    [i, 3, 3 * $e],
    [i, 6, 6 * $e],
    [i, 12, 12 * $e],
    [o, 1, De],
    [o, 2, 2 * De],
    [r, 1, Ao],
    [t, 1, Ki],
    [t, 3, 3 * Ki],
    [e, 1, Nr]
  ];
  function c(l, h, f) {
    const d = h < l;
    d && ([l, h] = [h, l]);
    const p = f && typeof f.range == "function" ? f : u(l, h, f), m = p ? p.range(l, +h + 1) : [];
    return d ? m.reverse() : m;
  }
  function u(l, h, f) {
    const d = Math.abs(h - l) / f, p = Oo(([, , y]) => y).right(a, d);
    if (p === a.length)
      return e.every(eo(l / Nr, h / Nr, f));
    if (p === 0)
      return In.every(Math.max(eo(l, h, f), 1));
    const [m, g] = a[d / a[p - 1][2] < a[p][2] / d ? p - 1 : p];
    return m.every(g);
  }
  return [c, u];
}
const [Vd, Gd] = Ma(Fe, $o, tr, va, Po, Ro), [Yd, Wd] = Ma(qe, No, er, Zt, jo, Eo);
function $r(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Lr(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function jt(e, t, r) {
  return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
}
function Xd(e) {
  var t = e.dateTime, r = e.date, o = e.time, i = e.periods, s = e.days, a = e.shortDays, c = e.months, u = e.shortMonths, l = Pt(i), h = Nt(i), f = Pt(s), d = Nt(s), p = Pt(a), m = Nt(a), g = Pt(c), y = Nt(c), b = Pt(u), O = Nt(u), x = {
    a: D,
    A: U,
    b: z,
    B: Z,
    c: null,
    d: ns,
    e: ns,
    f: yh,
    g: Ch,
    G: Sh,
    H: ph,
    I: mh,
    j: gh,
    L: Ca,
    m: bh,
    M: xh,
    p: re,
    q: he,
    Q: is,
    s: ss,
    S: Oh,
    u: Th,
    U: kh,
    V: _h,
    w: wh,
    W: vh,
    x: null,
    X: null,
    y: Mh,
    Y: Ih,
    Z: Ah,
    "%": os
  }, _ = {
    a: ae,
    A: te,
    b: ee,
    B: fe,
    c: null,
    d: rs,
    e: rs,
    f: Ph,
    g: Vh,
    G: Yh,
    H: Eh,
    I: Rh,
    j: jh,
    L: Sa,
    m: Nh,
    M: $h,
    p: de,
    q: Ce,
    Q: is,
    s: ss,
    S: Lh,
    u: Dh,
    U: qh,
    V: Fh,
    w: zh,
    W: Uh,
    x: null,
    X: null,
    y: Hh,
    Y: Gh,
    Z: Wh,
    "%": os
  }, M = {
    a: P,
    A: I,
    b: L,
    B: R,
    c: $,
    d: es,
    e: es,
    f: uh,
    g: Ji,
    G: Qi,
    H: ts,
    I: ts,
    j: sh,
    L: lh,
    m: ih,
    M: ah,
    p: C,
    q: oh,
    Q: dh,
    s: hh,
    S: ch,
    u: Jd,
    U: eh,
    V: th,
    w: Qd,
    W: nh,
    x: N,
    X: E,
    y: Ji,
    Y: Qi,
    Z: rh,
    "%": fh
  };
  x.x = T(r, x), x.X = T(o, x), x.c = T(t, x), _.x = T(r, _), _.X = T(o, _), _.c = T(t, _);
  function T(q, H) {
    return function(G) {
      var j = [], J = -1, W = 0, oe = q.length, ie, Te, Ie;
      for (G instanceof Date || (G = /* @__PURE__ */ new Date(+G)); ++J < oe; )
        q.charCodeAt(J) === 37 && (j.push(q.slice(W, J)), (Te = Zi[ie = q.charAt(++J)]) != null ? ie = q.charAt(++J) : Te = ie === "e" ? " " : "0", (Ie = H[ie]) && (ie = Ie(G, Te)), j.push(ie), W = J + 1);
      return j.push(q.slice(W, J)), j.join("");
    };
  }
  function v(q, H) {
    return function(G) {
      var j = jt(1900, void 0, 1), J = S(j, q, G += "", 0), W, oe;
      if (J != G.length)
        return null;
      if ("Q" in j)
        return new Date(j.Q);
      if ("s" in j)
        return new Date(j.s * 1e3 + ("L" in j ? j.L : 0));
      if (H && !("Z" in j) && (j.Z = 0), "p" in j && (j.H = j.H % 12 + j.p * 12), j.m === void 0 && (j.m = "q" in j ? j.q : 0), "V" in j) {
        if (j.V < 1 || j.V > 53)
          return null;
        "w" in j || (j.w = 1), "Z" in j ? (W = Lr(jt(j.y, 0, 1)), oe = W.getUTCDay(), W = oe > 4 || oe === 0 ? An.ceil(W) : An(W), W = Jn.offset(W, (j.V - 1) * 7), j.y = W.getUTCFullYear(), j.m = W.getUTCMonth(), j.d = W.getUTCDate() + (j.w + 6) % 7) : (W = $r(jt(j.y, 0, 1)), oe = W.getDay(), W = oe > 4 || oe === 0 ? Sn.ceil(W) : Sn(W), W = Zt.offset(W, (j.V - 1) * 7), j.y = W.getFullYear(), j.m = W.getMonth(), j.d = W.getDate() + (j.w + 6) % 7);
      } else
        ("W" in j || "U" in j) && ("w" in j || (j.w = "u" in j ? j.u % 7 : "W" in j ? 1 : 0), oe = "Z" in j ? Lr(jt(j.y, 0, 1)).getUTCDay() : $r(jt(j.y, 0, 1)).getDay(), j.m = 0, j.d = "W" in j ? (j.w + 6) % 7 + j.W * 7 - (oe + 5) % 7 : j.w + j.U * 7 - (oe + 6) % 7);
      return "Z" in j ? (j.H += j.Z / 100 | 0, j.M += j.Z % 100, Lr(j)) : $r(j);
    };
  }
  function S(q, H, G, j) {
    for (var J = 0, W = H.length, oe = G.length, ie, Te; J < W; ) {
      if (j >= oe)
        return -1;
      if (ie = H.charCodeAt(J++), ie === 37) {
        if (ie = H.charAt(J++), Te = M[ie in Zi ? H.charAt(J++) : ie], !Te || (j = Te(q, G, j)) < 0)
          return -1;
      } else if (ie != G.charCodeAt(j++))
        return -1;
    }
    return j;
  }
  function C(q, H, G) {
    var j = l.exec(H.slice(G));
    return j ? (q.p = h.get(j[0].toLowerCase()), G + j[0].length) : -1;
  }
  function P(q, H, G) {
    var j = p.exec(H.slice(G));
    return j ? (q.w = m.get(j[0].toLowerCase()), G + j[0].length) : -1;
  }
  function I(q, H, G) {
    var j = f.exec(H.slice(G));
    return j ? (q.w = d.get(j[0].toLowerCase()), G + j[0].length) : -1;
  }
  function L(q, H, G) {
    var j = b.exec(H.slice(G));
    return j ? (q.m = O.get(j[0].toLowerCase()), G + j[0].length) : -1;
  }
  function R(q, H, G) {
    var j = g.exec(H.slice(G));
    return j ? (q.m = y.get(j[0].toLowerCase()), G + j[0].length) : -1;
  }
  function $(q, H, G) {
    return S(q, t, H, G);
  }
  function N(q, H, G) {
    return S(q, r, H, G);
  }
  function E(q, H, G) {
    return S(q, o, H, G);
  }
  function D(q) {
    return a[q.getDay()];
  }
  function U(q) {
    return s[q.getDay()];
  }
  function z(q) {
    return u[q.getMonth()];
  }
  function Z(q) {
    return c[q.getMonth()];
  }
  function re(q) {
    return i[+(q.getHours() >= 12)];
  }
  function he(q) {
    return 1 + ~~(q.getMonth() / 3);
  }
  function ae(q) {
    return a[q.getUTCDay()];
  }
  function te(q) {
    return s[q.getUTCDay()];
  }
  function ee(q) {
    return u[q.getUTCMonth()];
  }
  function fe(q) {
    return c[q.getUTCMonth()];
  }
  function de(q) {
    return i[+(q.getUTCHours() >= 12)];
  }
  function Ce(q) {
    return 1 + ~~(q.getUTCMonth() / 3);
  }
  return {
    format: function(q) {
      var H = T(q += "", x);
      return H.toString = function() {
        return q;
      }, H;
    },
    parse: function(q) {
      var H = v(q += "", !1);
      return H.toString = function() {
        return q;
      }, H;
    },
    utcFormat: function(q) {
      var H = T(q += "", _);
      return H.toString = function() {
        return q;
      }, H;
    },
    utcParse: function(q) {
      var H = v(q += "", !0);
      return H.toString = function() {
        return q;
      }, H;
    }
  };
}
var Zi = { "-": "", _: " ", 0: "0" }, se = /^\s*\d+/, Bd = /^%/, Kd = /[\\^$*+?|[\]().{}]/g;
function X(e, t, r) {
  var o = e < 0 ? "-" : "", i = (o ? -e : e) + "", s = i.length;
  return o + (s < r ? new Array(r - s + 1).join(t) + i : i);
}
function Zd(e) {
  return e.replace(Kd, "\\$&");
}
function Pt(e) {
  return new RegExp("^(?:" + e.map(Zd).join("|") + ")", "i");
}
function Nt(e) {
  return new Map(e.map((t, r) => [t.toLowerCase(), r]));
}
function Qd(e, t, r) {
  var o = se.exec(t.slice(r, r + 1));
  return o ? (e.w = +o[0], r + o[0].length) : -1;
}
function Jd(e, t, r) {
  var o = se.exec(t.slice(r, r + 1));
  return o ? (e.u = +o[0], r + o[0].length) : -1;
}
function eh(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.U = +o[0], r + o[0].length) : -1;
}
function th(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.V = +o[0], r + o[0].length) : -1;
}
function nh(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.W = +o[0], r + o[0].length) : -1;
}
function Qi(e, t, r) {
  var o = se.exec(t.slice(r, r + 4));
  return o ? (e.y = +o[0], r + o[0].length) : -1;
}
function Ji(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.y = +o[0] + (+o[0] > 68 ? 1900 : 2e3), r + o[0].length) : -1;
}
function rh(e, t, r) {
  var o = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
  return o ? (e.Z = o[1] ? 0 : -(o[2] + (o[3] || "00")), r + o[0].length) : -1;
}
function oh(e, t, r) {
  var o = se.exec(t.slice(r, r + 1));
  return o ? (e.q = o[0] * 3 - 3, r + o[0].length) : -1;
}
function ih(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.m = o[0] - 1, r + o[0].length) : -1;
}
function es(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.d = +o[0], r + o[0].length) : -1;
}
function sh(e, t, r) {
  var o = se.exec(t.slice(r, r + 3));
  return o ? (e.m = 0, e.d = +o[0], r + o[0].length) : -1;
}
function ts(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.H = +o[0], r + o[0].length) : -1;
}
function ah(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.M = +o[0], r + o[0].length) : -1;
}
function ch(e, t, r) {
  var o = se.exec(t.slice(r, r + 2));
  return o ? (e.S = +o[0], r + o[0].length) : -1;
}
function lh(e, t, r) {
  var o = se.exec(t.slice(r, r + 3));
  return o ? (e.L = +o[0], r + o[0].length) : -1;
}
function uh(e, t, r) {
  var o = se.exec(t.slice(r, r + 6));
  return o ? (e.L = Math.floor(o[0] / 1e3), r + o[0].length) : -1;
}
function fh(e, t, r) {
  var o = Bd.exec(t.slice(r, r + 1));
  return o ? r + o[0].length : -1;
}
function dh(e, t, r) {
  var o = se.exec(t.slice(r));
  return o ? (e.Q = +o[0], r + o[0].length) : -1;
}
function hh(e, t, r) {
  var o = se.exec(t.slice(r));
  return o ? (e.s = +o[0], r + o[0].length) : -1;
}
function ns(e, t) {
  return X(e.getDate(), t, 2);
}
function ph(e, t) {
  return X(e.getHours(), t, 2);
}
function mh(e, t) {
  return X(e.getHours() % 12 || 12, t, 2);
}
function gh(e, t) {
  return X(1 + Zt.count(qe(e), e), t, 3);
}
function Ca(e, t) {
  return X(e.getMilliseconds(), t, 3);
}
function yh(e, t) {
  return Ca(e, t) + "000";
}
function bh(e, t) {
  return X(e.getMonth() + 1, t, 2);
}
function xh(e, t) {
  return X(e.getMinutes(), t, 2);
}
function Oh(e, t) {
  return X(e.getSeconds(), t, 2);
}
function Th(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function kh(e, t) {
  return X(er.count(qe(e) - 1, e), t, 2);
}
function Ia(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? _t(e) : _t.ceil(e);
}
function _h(e, t) {
  return e = Ia(e), X(_t.count(qe(e), e) + (qe(e).getDay() === 4), t, 2);
}
function wh(e) {
  return e.getDay();
}
function vh(e, t) {
  return X(Sn.count(qe(e) - 1, e), t, 2);
}
function Mh(e, t) {
  return X(e.getFullYear() % 100, t, 2);
}
function Ch(e, t) {
  return e = Ia(e), X(e.getFullYear() % 100, t, 2);
}
function Ih(e, t) {
  return X(e.getFullYear() % 1e4, t, 4);
}
function Sh(e, t) {
  var r = e.getDay();
  return e = r >= 4 || r === 0 ? _t(e) : _t.ceil(e), X(e.getFullYear() % 1e4, t, 4);
}
function Ah(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + X(t / 60 | 0, "0", 2) + X(t % 60, "0", 2);
}
function rs(e, t) {
  return X(e.getUTCDate(), t, 2);
}
function Eh(e, t) {
  return X(e.getUTCHours(), t, 2);
}
function Rh(e, t) {
  return X(e.getUTCHours() % 12 || 12, t, 2);
}
function jh(e, t) {
  return X(1 + Jn.count(Fe(e), e), t, 3);
}
function Sa(e, t) {
  return X(e.getUTCMilliseconds(), t, 3);
}
function Ph(e, t) {
  return Sa(e, t) + "000";
}
function Nh(e, t) {
  return X(e.getUTCMonth() + 1, t, 2);
}
function $h(e, t) {
  return X(e.getUTCMinutes(), t, 2);
}
function Lh(e, t) {
  return X(e.getUTCSeconds(), t, 2);
}
function Dh(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function qh(e, t) {
  return X(tr.count(Fe(e) - 1, e), t, 2);
}
function Aa(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? wt(e) : wt.ceil(e);
}
function Fh(e, t) {
  return e = Aa(e), X(wt.count(Fe(e), e) + (Fe(e).getUTCDay() === 4), t, 2);
}
function zh(e) {
  return e.getUTCDay();
}
function Uh(e, t) {
  return X(An.count(Fe(e) - 1, e), t, 2);
}
function Hh(e, t) {
  return X(e.getUTCFullYear() % 100, t, 2);
}
function Vh(e, t) {
  return e = Aa(e), X(e.getUTCFullYear() % 100, t, 2);
}
function Gh(e, t) {
  return X(e.getUTCFullYear() % 1e4, t, 4);
}
function Yh(e, t) {
  var r = e.getUTCDay();
  return e = r >= 4 || r === 0 ? wt(e) : wt.ceil(e), X(e.getUTCFullYear() % 1e4, t, 4);
}
function Wh() {
  return "+0000";
}
function os() {
  return "%";
}
function is(e) {
  return +e;
}
function ss(e) {
  return Math.floor(+e / 1e3);
}
var lt, Ea, Ra;
Xh({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function Xh(e) {
  return lt = Xd(e), Ea = lt.format, lt.parse, Ra = lt.utcFormat, lt.utcParse, lt;
}
function Bh(e) {
  return new Date(e);
}
function Kh(e) {
  return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Lo(e, t, r, o, i, s, a, c, u, l) {
  var h = ba(), f = h.invert, d = h.domain, p = l(".%L"), m = l(":%S"), g = l("%I:%M"), y = l("%I %p"), b = l("%a %d"), O = l("%b %d"), x = l("%B"), _ = l("%Y");
  function M(T) {
    return (u(T) < T ? p : c(T) < T ? m : a(T) < T ? g : s(T) < T ? y : o(T) < T ? i(T) < T ? b : O : r(T) < T ? x : _)(T);
  }
  return h.invert = function(T) {
    return new Date(f(T));
  }, h.domain = function(T) {
    return arguments.length ? d(Array.from(T, Kh)) : d().map(Bh);
  }, h.ticks = function(T) {
    var v = d();
    return e(v[0], v[v.length - 1], T ?? 10);
  }, h.tickFormat = function(T, v) {
    return v == null ? M : l(v);
  }, h.nice = function(T) {
    var v = d();
    return (!T || typeof T.range != "function") && (T = t(v[0], v[v.length - 1], T ?? 10)), T ? d(ka(v, T)) : h;
  }, h.copy = function() {
    return Qn(h, Lo(e, t, r, o, i, s, a, c, u, l));
  }, h;
}
function ja() {
  return Be.apply(Lo(Yd, Wd, qe, No, er, Zt, jo, Eo, Qe, Ea).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Zh() {
  return Be.apply(Lo(Vd, Gd, Fe, $o, tr, Jn, Po, Ro, Qe, Ra).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function Qh() {
  var e = 0, t = 1, r, o, i, s, a = ge, c = !1, u;
  function l(f) {
    return f == null || isNaN(f = +f) ? u : a(i === 0 ? 0.5 : (f = (s(f) - r) * i, c ? Math.max(0, Math.min(1, f)) : f));
  }
  l.domain = function(f) {
    return arguments.length ? ([e, t] = f, r = s(e = +e), o = s(t = +t), i = r === o ? 0 : 1 / (o - r), l) : [e, t];
  }, l.clamp = function(f) {
    return arguments.length ? (c = !!f, l) : c;
  }, l.interpolator = function(f) {
    return arguments.length ? (a = f, l) : a;
  };
  function h(f) {
    return function(d) {
      var p, m;
      return arguments.length ? ([p, m] = d, a = f(p, m), l) : [a(0), a(1)];
    };
  }
  return l.range = h(Zn), l.rangeRound = h(ya), l.unknown = function(f) {
    return arguments.length ? (u = f, l) : u;
  }, function(f) {
    return s = f, r = f(e), o = f(t), i = r === o ? 0 : 1 / (o - r), l;
  };
}
function Jh(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function Pa() {
  var e = Io(Qh()(ge));
  return e.copy = function() {
    return Jh(e, Pa());
  }, zf.apply(e, arguments);
}
function ep(e, t) {
  return function(o, i) {
    return i.location === "tick" ? i.scale.tickFormat(e)(o) : i.location === "zoom-slider-tooltip" ? t.tickFormat(2)(o) : `${o}`;
  };
}
function Na(e) {
  return e.scaleType === "band";
}
function $a(e) {
  return e.scaleType === "point";
}
function tp(e) {
  return e.type === "piecewise" ? wa(e.thresholds, e.colors) : Pa([e.min ?? 0, e.max ?? 100], e.color);
}
function vt(e) {
  return e.values ? wn(e.values, e.colors).unknown(e.unknownColor ?? null) : wn(e.colors.map((t, r) => r), e.colors).unknown(e.unknownColor ?? null);
}
function nt(e) {
  return e.type === "ordinal" ? vt(e) : tp(e);
}
function La(e) {
  const {
    tickMaxStep: t,
    tickMinStep: r,
    tickNumber: o,
    range: i,
    domain: s
  } = e, a = r === void 0 ? 999 : Math.floor(Math.abs(s[1] - s[0]) / r), c = t === void 0 ? 2 : Math.ceil(Math.abs(s[1] - s[0]) / t), u = o ?? Math.floor(Math.abs(i[1] - i[0]) / 50);
  return Math.min(a, Math.max(c, u));
}
function Da(e, t) {
  return t[1] - t[0] === 0 ? 1 : e / ((t[1] - t[0]) / 100);
}
function En(e, t, r) {
  switch (e) {
    case "log":
      return _a(t, r);
    case "pow":
      return So(t, r);
    case "sqrt":
      return Nd(t, r);
    case "time":
      return ja(t, r);
    case "utc":
      return Zh(t, r);
    default:
      return Ta(t, r);
  }
}
const Rn = (e) => (e == null ? void 0 : e[0]) instanceof Date;
function jn(e, t) {
  const r = ja(e.data, t);
  return (o, {
    location: i
  }) => i === "tick" ? r.tickFormat(e.tickNumber)(o) : `${o.toLocaleString()}`;
}
const Dr = (e, t) => {
  const r = e[1] - e[0], o = t[1] - t[0], i = e[0] - t[0] * r / o, s = e[1] + (100 - t[1]) * r / o;
  return [i, s];
};
let as, cs;
class np {
  constructor() {
    if (this.types = /* @__PURE__ */ new Set(), as)
      throw new Error("You can only create one instance!");
    as = this.types;
  }
  addType(t) {
    this.types.add(t);
  }
  getTypes() {
    return this.types;
  }
}
class rp {
  constructor() {
    if (this.types = /* @__PURE__ */ new Set(), cs)
      throw new Error("You can only create one instance!");
    cs = this.types;
  }
  addType(t) {
    this.types.add(t);
  }
  getTypes() {
    return this.types;
  }
}
const nr = new np();
nr.addType("bar");
nr.addType("line");
nr.addType("scatter");
const qa = new rp();
qa.addType("radar");
function Do(e) {
  return nr.getTypes().has(e);
}
const op = (e, t, r, o, i, s, a, c) => {
  var m;
  const u = o === "x" ? i[t].xExtremumGetter : i[t].yExtremumGetter, l = ((m = a[t]) == null ? void 0 : m.series) ?? {}, [h, f] = (u == null ? void 0 : u({
    series: l,
    axis: r,
    axisIndex: s,
    isDefaultAxis: s === 0,
    getFilters: c
  })) ?? [1 / 0, -1 / 0], [d, p] = e;
  return [Math.min(h, d), Math.max(f, p)];
}, Fa = (e, t, r, o, i, s) => {
  const c = Object.keys(r).filter(Do).reduce((u, l) => op(u, l, e, t, r, o, i, s), [1 / 0, -1 / 0]);
  return Number.isNaN(c[0]) || Number.isNaN(c[1]) ? [1 / 0, -1 / 0] : c;
}, ip = (e, t, r, o) => {
  const i = /* @__PURE__ */ new Set();
  return Object.keys(t).filter(Do).forEach((a) => {
    var l, h, f;
    const c = ((l = r[a]) == null ? void 0 : l.series) ?? {}, u = (f = (h = t[a]).axisTooltipGetter) == null ? void 0 : f.call(h, c);
    u !== void 0 && u.forEach(({
      axisId: d,
      direction: p
    }) => {
      p === e && i.add(d ?? o);
    });
  }), i;
};
function sp(e, t, r) {
  const o = t === "x" ? [e.left, e.left + e.width] : [e.top + e.height, e.top];
  return r.reverse ? [o[1], o[0]] : o;
}
const ap = 0.2, cp = 0.1;
function za({
  drawingArea: e,
  formattedSeries: t,
  axis: r,
  seriesConfig: o,
  axisDirection: i,
  zoomMap: s,
  zoomOptions: a,
  getFilters: c
}) {
  if (r === void 0)
    return {
      axis: {},
      axisIds: []
    };
  const u = ip(i, o, t, r[0].id), l = {};
  return r.forEach((h, f) => {
    const d = h, p = a == null ? void 0 : a[d.id], m = s == null ? void 0 : s.get(d.id), g = m ? [m.start, m.end] : [0, 100], y = sp(e, i, d), [b, O] = Fa(
      d,
      i,
      o,
      f,
      t,
      m === void 0 && !p ? c : void 0
      // Do not apply filtering if zoom is already defined.
    ), x = !d.ignoreTooltip && u.has(d.id), _ = d.data ?? [];
    if (Na(d)) {
      const E = d.categoryGapRatio ?? ap, D = d.barGapRatio ?? cp, U = i === "y" ? [y[1], y[0]] : y, z = Dr(U, g);
      if (l[d.id] = k({
        offset: 0,
        height: 0,
        categoryGapRatio: E,
        barGapRatio: D,
        triggerTooltip: x
      }, d, {
        data: _,
        scale: Kn(d.data, z).paddingInner(E).paddingOuter(E / 2),
        tickNumber: d.data.length,
        colorScale: d.colorMap && (d.colorMap.type === "ordinal" ? vt(k({
          values: d.data
        }, d.colorMap)) : nt(d.colorMap))
      }), Rn(d.data)) {
        const Z = jn(d, U);
        l[d.id].valueFormatter = d.valueFormatter ?? Z;
      }
    }
    if ($a(d)) {
      const E = i === "y" ? [...y].reverse() : y, D = Dr(E, g);
      if (l[d.id] = k({
        offset: 0,
        height: 0,
        triggerTooltip: x
      }, d, {
        data: _,
        scale: ha(d.data, D),
        tickNumber: d.data.length,
        colorScale: d.colorMap && (d.colorMap.type === "ordinal" ? vt(k({
          values: d.data
        }, d.colorMap)) : nt(d.colorMap))
      }), Rn(d.data)) {
        const U = jn(d, E);
        l[d.id].valueFormatter = d.valueFormatter ?? U;
      }
    }
    if (d.scaleType === "band" || d.scaleType === "point")
      return;
    const M = d.scaleType ?? "linear", T = d.domainLimit ?? "nice", v = [d.min ?? b, d.max ?? O];
    if (typeof T == "function") {
      const {
        min: E,
        max: D
      } = T(b, O);
      v[0] = E, v[1] = D;
    }
    const S = La(k({}, d, {
      range: y,
      domain: v
    })), C = Da(S, g), P = Dr(y, g), I = En(M, v, P), L = T === "nice" ? I.nice(S) : I, [R, $] = L.domain(), N = [d.min ?? R, d.max ?? $];
    l[d.id] = k({
      offset: 0,
      height: 0,
      triggerTooltip: x
    }, d, {
      data: _,
      scaleType: M,
      scale: L.domain(N),
      tickNumber: C,
      colorScale: d.colorMap && nt(d.colorMap),
      valueFormatter: d.valueFormatter ?? ep(C, En(M, y.map((E) => I.invert(E)), y))
    });
  }), {
    axis: l,
    axisIds: r.map(({
      id: h
    }) => h)
  };
}
function lp(e) {
  return e != null;
}
function Ua({
  zoomMap: e,
  zoomOptions: t,
  seriesConfig: r,
  formattedSeries: o,
  direction: i
}) {
  return (s, a) => {
    var y;
    const c = t[s.id];
    if (!c || c.filterMode !== "discard")
      return null;
    const u = e == null ? void 0 : e.get(s.id);
    if (u === void 0 || u.start <= 0 && u.end >= 100)
      return null;
    let l = [];
    const h = s.scaleType;
    h === "point" || h === "band" ? l = [0, (((y = s.data) == null ? void 0 : y.length) ?? 1) - 1] : l = Fa(s, i, r, a, o);
    let f, d;
    [f, d] = En(!h || h === "band" || h === "point" ? "linear" : h, l, [0, 100]).nice().domain(), f = f instanceof Date ? f.getTime() : f, d = d instanceof Date ? d.getTime() : d;
    const m = f + u.start * (d - f) / 100, g = f + u.end * (d - f) / 100;
    return (b, O) => {
      var _;
      const x = b[i] ?? ((_ = s.data) == null ? void 0 : _[O]);
      return x == null ? !0 : s.scaleType === "point" || s.scaleType === "band" || typeof x == "string" ? O >= m && O <= g : x >= m && x <= g;
    };
  };
}
const up = (e) => ({
  currentAxisId: t,
  seriesXAxisId: r,
  seriesYAxisId: o,
  isDefaultAxis: i
}) => (s, a) => {
  var l, h;
  return !(t === r ? o : r) || i ? ((h = (l = Object.values(e ?? {}))[0]) == null ? void 0 : h.call(l, s, a)) ?? !0 : [o, r].filter((f) => f !== t).map((f) => e[f ?? ""]).filter(lp).every((f) => f(s, a));
}, Ha = (e) => (t = []) => t.reduce((r, o) => {
  const {
    zoom: i,
    id: s
  } = o, a = xo(i, s, e);
  return a && (r[s] = a), r;
}, {}), fp = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((r) => {
    t.set(r.axisId, r);
  }), t;
}, Va = (e) => e.zoom, Ga = F(Va, (e) => e == null ? void 0 : e.isInteracting), rr = F(Va, (e) => (e == null ? void 0 : e.zoomData) && fp(e == null ? void 0 : e.zoomData)), dp = F(At, Ha("x")), hp = F(Bt, Ha("y")), or = F([dp, hp], (e, t) => k({}, e, t)), pp = F([rr, or, He, Ee], (e, t, r, o) => e && t && Ua({
  zoomMap: e,
  zoomOptions: t,
  seriesConfig: r,
  formattedSeries: o,
  direction: "x"
})), mp = F([rr, or, He, Ee], (e, t, r, o) => e && t && Ua({
  zoomMap: e,
  zoomOptions: t,
  seriesConfig: r,
  formattedSeries: o,
  direction: "y"
})), Ya = F([pp, mp, At, Bt], (e, t, r, o) => {
  if (e === void 0 || t === void 0)
    return;
  const i = r == null ? void 0 : r.reduce((a, c, u) => {
    const l = e(c, u);
    return l !== null && (a[c.id] = l), a;
  }, {}), s = o == null ? void 0 : o.reduce((a, c, u) => {
    const l = t(c, u);
    return l !== null && (a[c.id] = l), a;
  }, {});
  if (!(Object.keys(i ?? {}).length === 0 && Object.keys(s ?? {}).length === 0))
    return up(k({}, i, s));
}), at = F([At, Ue, Ee, He, rr, or, Ya], (e, t, r, o, i, s, a) => za({
  drawingArea: t,
  formattedSeries: r,
  axis: e,
  seriesConfig: o,
  axisDirection: "x",
  zoomMap: i,
  zoomOptions: s,
  getFilters: a
})), ct = F([Bt, Ue, Ee, He, rr, or, Ya], (e, t, r, o, i, s, a) => za({
  drawingArea: t,
  formattedSeries: r,
  axis: e,
  seriesConfig: o,
  axisDirection: "y",
  zoomMap: i,
  zoomOptions: s,
  getFilters: a
}));
function Me(e) {
  return e.bandwidth !== void 0;
}
function ut(e) {
  return e instanceof Date ? e.getTime() : e;
}
function Mt(e, t) {
  const {
    scale: r,
    data: o,
    reverse: i
  } = e;
  if (!Me(r)) {
    const a = r.invert(t);
    if (o === void 0)
      return -1;
    const c = ut(a);
    return o == null ? void 0 : o.findIndex((l, h) => {
      const f = ut(l);
      return f > c && (h === 0 || Math.abs(c - f) <= Math.abs(c - ut(o[h - 1]))) || f <= c && (h === o.length - 1 || Math.abs(ut(a) - f) < Math.abs(ut(a) - ut(o[h + 1])));
    });
  }
  const s = r.bandwidth() === 0 ? Math.floor((t - Math.min(...r.range()) + r.step() / 2) / r.step()) : Math.floor((t - Math.min(...r.range())) / r.step());
  return s < 0 || s >= o.length ? -1 : i ? o.length - 1 - s : s;
}
function ls(e, t, r) {
  const {
    scale: o,
    data: i
  } = e;
  if (!Me(o)) {
    const s = o.invert(t);
    return r < 0 ? s : i[r];
  }
  return r < 0 || r >= i.length ? null : i[r];
}
function oo(e, t) {
  const r = e.createSVGPoint();
  return r.x = t.clientX, r.y = t.clientY, r.matrixTransform(e.getScreenCTM().inverse());
}
function Ye(e) {
  const t = A.useRef(e);
  return Ae(() => {
    t.current = e;
  }), A.useRef((...r) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...r)
  )).current;
}
const gp = Object.is;
function Wa(e, t) {
  if (e === t)
    return !0;
  if (!(e instanceof Object) || !(t instanceof Object))
    return !1;
  let r = 0, o = 0;
  for (const i in e)
    if (r += 1, !gp(e[i], t[i]) || !(i in t))
      return !1;
  for (const i in t)
    o += 1;
  return r === o;
}
const Qt = ({
  store: e
}) => {
  const t = Ye(() => {
    e.update((s) => k({}, s, {
      interaction: {
        pointer: null,
        item: null
      }
    }));
  }), r = Ye((s) => {
    e.update((a) => {
      const c = a.interaction.item;
      return s ? c === null || Object.keys(s).some((u) => s[u] !== c[u]) ? a : k({}, a, {
        interaction: k({}, a.interaction, {
          item: null
        })
      }) : c === null ? a : k({}, a, {
        interaction: k({}, a.interaction, {
          item: null
        })
      });
    });
  }), o = Ye((s) => {
    e.update((a) => Wa(a.interaction.item, s) ? a : k({}, a, {
      interaction: k({}, a.interaction, {
        item: s
      })
    }));
  }), i = Ye((s) => {
    e.update((a) => k({}, a, {
      interaction: k({}, a.interaction, {
        pointer: s
      })
    }));
  });
  return {
    instance: {
      cleanInteraction: t,
      setItemInteraction: o,
      removeItemInteraction: r,
      setPointerCoordinate: i
    }
  };
};
Qt.getInitialState = () => ({
  interaction: {
    item: null,
    pointer: null
  }
});
Qt.params = {};
const qo = (e) => e.interaction, yp = F(qo, (e) => e !== void 0), Xa = F(qo, (e) => (e == null ? void 0 : e.item) ?? null), Ba = F(qo, (e) => (e == null ? void 0 : e.pointer) ?? null), ir = F(Ba, (e) => e && e.x), sr = F(Ba, (e) => e && e.y), bp = F(Xa, (e) => e !== null), Et = ({
  params: e,
  store: t,
  seriesConfig: r,
  svgRef: o,
  instance: i
}) => {
  const {
    xAxis: s,
    yAxis: a,
    dataset: c
  } = e;
  if ("production".NODE_ENV !== "production") {
    const O = [...s ?? [], ...a ?? []].filter((_) => _.id).map((_) => _.id), x = new Set(O.filter((_, M) => O.indexOf(_) !== M));
    x.size > 0 && rt([`MUI X Charts: The following axis ids are duplicated: ${Array.from(x).join(", ")}.`, "Please make sure that each axis has a unique id."].join(`
`), "error");
  }
  const u = V(t, Ue), l = V(t, Ee), h = V(t, yp), {
    axis: f,
    axisIds: d
  } = V(t, at), {
    axis: p,
    axisIds: m
  } = V(t, ct), g = A.useRef(!0);
  A.useEffect(() => {
    if (g.current) {
      g.current = !1;
      return;
    }
    t.update((O) => k({}, O, {
      cartesianAxis: k({}, O.cartesianAxis, {
        x: la(s, c),
        y: ua(a, c)
      })
    }));
  }, [r, u, s, a, c, t]);
  const y = d[0], b = m[0];
  return A.useEffect(() => {
    const O = o.current;
    if (!h || O === null || e.disableAxisListener)
      return () => {
      };
    const x = () => {
      var T;
      (T = i.cleanInteraction) == null || T.call(i);
    }, _ = (T) => {
      var C, P;
      const v = "targetTouches" in T ? T.targetTouches[0] : T, S = oo(O, v);
      if (!i.isPointInside(S.x, S.y, T.target)) {
        (C = i.cleanInteraction) == null || C.call(i);
        return;
      }
      (P = i.setPointerCoordinate) == null || P.call(i, S);
    }, M = (T) => {
      const v = T.currentTarget;
      v && "hasPointerCapture" in v && v.hasPointerCapture(T.pointerId) && v.releasePointerCapture(T.pointerId);
    };
    return O.addEventListener("pointerdown", M), O.addEventListener("pointermove", _), O.addEventListener("pointercancel", x), O.addEventListener("pointerleave", x), () => {
      O.removeEventListener("pointerdown", M), O.removeEventListener("pointermove", _), O.removeEventListener("pointercancel", x), O.removeEventListener("pointerleave", x);
    };
  }, [o, t, f, y, p, b, i, e.disableAxisListener, h]), A.useEffect(() => {
    const O = o.current, x = e.onAxisClick;
    if (O === null || !x)
      return () => {
      };
    const _ = (M) => {
      M.preventDefault();
      let T = null, v = !1;
      const S = oo(O, M), C = Mt(f[y], S.x);
      v = C !== -1, T = v ? C : Mt(p[b], S.y);
      const P = v ? d[0] : m[0];
      if (T == null || T === -1)
        return;
      const I = (v ? f : p)[P].data[T], L = {};
      Object.keys(l).filter((R) => ["bar", "line"].includes(R)).forEach((R) => {
        var $;
        ($ = l[R]) == null || $.seriesOrder.forEach((N) => {
          const E = l[R].series[N], D = E.xAxisId, U = E.yAxisId, z = v ? D : U;
          (z === void 0 || z === P) && (L[N] = E.data[T]);
        });
      }), x(M, {
        dataIndex: T,
        axisValue: I,
        seriesValues: L
      });
    };
    return O.addEventListener("click", _), () => {
      O.removeEventListener("click", _);
    };
  }, [e.onAxisClick, l, o, f, d, p, m, y, b]), {};
};
Et.params = {
  xAxis: !0,
  yAxis: !0,
  dataset: !0,
  onAxisClick: !0,
  disableAxisListener: !0
};
Et.getDefaultizedParams = ({
  params: e
}) => k({}, e, {
  colors: e.colors ?? sa,
  theme: e.theme ?? "light",
  defaultizedXAxis: la(e.xAxis, e.dataset),
  defaultizedYAxis: ua(e.yAxis, e.dataset)
});
Et.getInitialState = (e) => ({
  cartesianAxis: {
    x: e.defaultizedXAxis,
    y: e.defaultizedYAxis
  }
});
function bt(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor)
      return !1;
    if (Array.isArray(e)) {
      const i = e.length;
      if (i !== t.length)
        return !1;
      for (let s = 0; s < i; s += 1)
        if (!bt(e[s], t[s]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      const i = Array.from(e.entries());
      for (let s = 0; s < i.length; s += 1)
        if (!t.has(i[s][0]))
          return !1;
      for (let s = 0; s < i.length; s += 1) {
        const a = i[s];
        if (!bt(a[1], t.get(a[0])))
          return !1;
      }
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      const i = Array.from(e.entries());
      for (let s = 0; s < i.length; s += 1)
        if (!t.has(i[s][0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      const i = e.length;
      if (i !== t.length)
        return !1;
      for (let s = 0; s < i; s += 1)
        if (e[s] !== t[s])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    const r = Object.keys(e), o = r.length;
    if (o !== Object.keys(t).length)
      return !1;
    for (let i = 0; i < o; i += 1)
      if (!Object.prototype.hasOwnProperty.call(t, r[i]))
        return !1;
    for (let i = 0; i < o; i += 1) {
      const s = r[i];
      if (!bt(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
const ar = (e, t) => t;
function Ka(e, t, r = t.axisIds[0]) {
  return Array.isArray(r) ? r.map((o) => Mt(t.axis[o], e)) : Mt(t.axis[r], e);
}
const Fo = F([ir, at, ar], (e, t, r) => e === null ? null : Ka(e, t, r)), xp = F([sr, ct, ar], (e, t, r) => e === null ? null : Ka(e, t, r));
function Za(e, t, r, o = t.axisIds[0]) {
  return Array.isArray(o) ? o.map((i, s) => ls(t.axis[i], e, r[s])) : ls(t.axis[o], e, r);
}
const Op = F([ir, at, Fo, ar], (e, t, r, o) => e === null || r === null || t.axisIds.length === 0 ? null : Za(e, t, r, o)), Tp = F([sr, ct, xp, ar], (e, t, r, o) => e === null || r === null || t.axisIds.length === 0 ? null : Za(e, t, r, o)), Qa = F([ir, at], (e, t) => e === null ? [] : t.axisIds.filter((r) => t.axis[r].triggerTooltip).map((r) => ({
  axisId: r,
  dataIndex: Mt(t.axis[r], e)
})).filter(({
  dataIndex: r
}) => r >= 0), {
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: bt
  }
}), Ja = F([sr, ct], (e, t) => e === null ? [] : t.axisIds.filter((r) => t.axis[r].triggerTooltip).map((r) => ({
  axisId: r,
  dataIndex: Mt(t.axis[r], e)
})).filter(({
  dataIndex: r
}) => r >= 0), {
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: bt
  }
}), kp = F([Qa, Ja], (e, t) => e.length > 0 || t.length > 0);
function us(e, t) {
  return e.id !== void 0 ? e : k({
    id: t
  }, e);
}
function fs(e) {
  return e.colorMap ? k({}, e, {
    colorScale: e.colorMap.type === "ordinal" && e.data ? vt(k({
      values: e.data
    }, e.colorMap)) : nt(e.colorMap.type === "continuous" ? k({
      min: e.min,
      max: e.max
    }, e.colorMap) : e.colorMap)
  }) : e;
}
function ec(e, t) {
  if (!e || e.length === 0)
    return {
      axis: {},
      axisIds: []
    };
  const r = {}, o = [];
  return e.forEach((i, s) => {
    const a = i.dataKey, c = i.id ?? `defaultized-z-axis-${s}`;
    if (a === void 0 || i.data !== void 0) {
      r[c] = fs(us(i, c)), o.push(c);
      return;
    }
    if (t === void 0)
      throw new Error("MUI X Charts: z-axis uses `dataKey` but no `dataset` is provided.");
    r[c] = fs(us(k({}, i, {
      data: t.map((u) => u[a])
    }), c)), o.push(c);
  }), {
    axis: r,
    axisIds: o
  };
}
const Jt = ({
  params: e,
  store: t
}) => {
  const {
    zAxis: r,
    dataset: o
  } = e, i = A.useRef(!0);
  return A.useEffect(() => {
    if (i.current) {
      i.current = !1;
      return;
    }
    t.update((s) => k({}, s, {
      zAxis: ec(r, o)
    }));
  }, [r, o, t]), {};
};
Jt.params = {
  zAxis: !0,
  dataset: !0
};
Jt.getInitialState = (e) => ({
  zAxis: ec(e.zAxis, e.dataset)
});
const _p = (e) => e, wp = F([_p], (e) => e.zAxis);
function vp(e) {
  const {
    componentName: t,
    propName: r,
    controlled: o,
    defaultValue: i,
    warningPrefix: s = "MUI X"
  } = e, [{
    initialDefaultValue: a,
    isControlled: c
  }] = A.useState({
    initialDefaultValue: i,
    isControlled: o !== void 0
  });
  c !== (o !== void 0) && rt([`${s}: A component is changing the ${c ? "" : "un"}controlled ${r} state of ${t} to be ${c ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${r} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"], "error"), JSON.stringify(a) !== JSON.stringify(i) && rt([`${s}: A component is changing the default ${r} state of an uncontrolled ${t} after being initialized. To suppress this warning opt to use a controlled ${t}.`], "error");
}
const Mp = "production".NODE_ENV === "production" ? () => {
} : vp, Rt = ({
  store: e,
  params: t
}) => {
  Mp({
    warningPrefix: "MUI X Charts",
    componentName: "Chart",
    propName: "highlightedItem",
    controlled: t.highlightedItem,
    defaultValue: null
  }), Ae(() => {
    e.update((i) => i.highlight.item === t.highlightedItem ? i : k({}, i, {
      highlight: k({}, i.highlight, {
        item: t.highlightedItem
      })
    }));
  }, [e, t.highlightedItem]);
  const r = Ye(() => {
    var i;
    (i = t.onHighlightChange) == null || i.call(t, null), e.update((s) => k({}, s, {
      highlight: {
        item: null
      }
    }));
  }), o = Ye((i) => {
    var a;
    const s = e.getSnapshot().highlight.item;
    Wa(s, i) || ((a = t.onHighlightChange) == null || a.call(t, i), e.update((c) => k({}, c, {
      highlight: {
        item: i
      }
    })));
  });
  return {
    instance: {
      clearHighlight: r,
      setHighlight: o
    }
  };
};
Rt.getDefaultizedParams = ({
  params: e
}) => k({}, e, {
  highlightedItem: e.highlightedItem ?? null
});
Rt.getInitialState = (e) => ({
  highlight: {
    item: e.highlightedItem
  }
});
Rt.params = {
  highlightedItem: !0,
  onHighlightChange: !0
};
const ds = (e, t) => t === "x" ? {
  x: e,
  y: null
} : {
  x: null,
  y: e
}, tc = (e) => {
  var u;
  const {
    axis: t,
    getFilters: r,
    isDefaultAxis: o
  } = e, i = r == null ? void 0 : r({
    currentAxisId: t.id,
    isDefaultAxis: o
  }), s = i ? (u = t.data) == null ? void 0 : u.filter((l, h) => i({
    x: null,
    y: null
  }, h)) : t.data, a = Math.min(...s ?? []), c = Math.max(...s ?? []);
  return [a, c];
}, nc = (e) => (t) => {
  const {
    series: r,
    axis: o,
    getFilters: i,
    isDefaultAxis: s
  } = t;
  return Object.keys(r).filter((a) => {
    const c = e === "x" ? r[a].xAxisId : r[a].yAxisId;
    return c === o.id || s && c === void 0;
  }).reduce((a, c) => {
    const {
      stackedData: u
    } = r[c], l = i == null ? void 0 : i({
      currentAxisId: o.id,
      isDefaultAxis: s,
      seriesXAxisId: r[c].xAxisId,
      seriesYAxisId: r[c].yAxisId
    }), [h, f] = (u == null ? void 0 : u.reduce((d, p, m) => l && (!l(ds(p[0], e), m) || !l(ds(p[1], e), m)) ? d : [Math.min(...p, d[0]), Math.max(...p, d[1])], [1 / 0, -1 / 0])) ?? [1 / 0, -1 / 0];
    return [Math.min(h, a[0]), Math.max(f, a[1])];
  }, [1 / 0, -1 / 0]);
}, Cp = (e) => Object.keys(e.series).some((r) => e.series[r].layout === "horizontal") ? nc("x")(e) : tc(e), Ip = (e) => Object.keys(e.series).some((r) => e.series[r].layout === "horizontal") ? tc(e) : nc("y")(e), qr = {
  /**
   * Series order such that the earliest series (according to the maximum value) is at the bottom.
   * */
  appearance: Xs,
  /**
   *  Series order such that the smallest series (according to the sum of values) is at the bottom.
   * */
  ascending: Bs,
  /**
   * Series order such that the largest series (according to the sum of values) is at the bottom.
   */
  descending: au,
  /**
   * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked GraphsGeometry & Aesthetics by Byron & Wattenberg for more information.
   */
  insideOut: cu,
  /**
   * Given series order [0, 1,  n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
   */
  none: Ot,
  /**
   * Reverse of the given series order [n - 1, n - 2,  0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
   */
  reverse: lu
}, Fr = {
  /**
   * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
   * */
  expand: nu,
  /**
   * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
   * */
  diverging: ru,
  /**
   * Applies a zero baseline.
   * */
  none: xt,
  /**
   * Shifts the baseline down such that the center of the streamgraph is always at zero.
   * */
  silhouette: ou,
  /**
   * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked GraphsGeometry & Aesthetics by Bryon & Wattenberg for more information.
   * */
  wiggle: iu
}, rc = (e) => {
  const {
    series: t,
    seriesOrder: r,
    defaultStrategy: o
  } = e, i = [], s = {};
  return r.forEach((a) => {
    const {
      stack: c,
      stackOrder: u,
      stackOffset: l
    } = t[a];
    c === void 0 ? i.push({
      ids: [a],
      stackingOrder: qr.none,
      stackingOffset: Fr.none
    }) : s[c] === void 0 ? (s[c] = i.length, i.push({
      ids: [a],
      stackingOrder: qr[u ?? (o == null ? void 0 : o.stackOrder) ?? "none"],
      stackingOffset: Fr[l ?? (o == null ? void 0 : o.stackOffset) ?? "diverging"]
    })) : (i[s[c]].ids.push(a), u !== void 0 && (i[s[c]].stackingOrder = qr[u]), l !== void 0 && (i[s[c]].stackingOffset = Fr[l]));
  }), i;
};
function oc(e, t) {
  const r = {};
  return Object.keys(e).forEach((o) => {
    r[o] = k({}, e[o], {
      valueFormatter: e[o].valueFormatter ?? t
    });
  }), r;
}
const Sp = (e, t) => {
  const {
    seriesOrder: r,
    series: o
  } = e, i = rc(e), s = t ?? [];
  r.forEach((c) => {
    const u = o[c].data;
    if (u !== void 0)
      u.forEach((l, h) => {
        s.length <= h ? s.push({
          [c]: l
        }) : s[h][c] = l;
      });
    else if (t === void 0)
      throw new Error([`MUI X Charts: bar series with id='${c}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join(`
`));
  });
  const a = {};
  return i.forEach((c) => {
    const {
      ids: u,
      stackingOffset: l,
      stackingOrder: h
    } = c, f = Ws().keys(u.map((d) => {
      const p = o[d].dataKey;
      return o[d].data === void 0 && p !== void 0 ? p : d;
    })).value((d, p) => d[p] ?? 0).order(h).offset(l)(s);
    u.forEach((d, p) => {
      const m = o[d].dataKey;
      a[d] = k({
        layout: "vertical",
        labelMarkType: "square"
      }, o[d], {
        data: m ? t.map((g) => {
          const y = g[m];
          return typeof y != "number" ? ("production".NODE_ENV !== "production" && y !== null && rt([`MUI X Charts: your dataset key "${m}" is used for plotting bars, but contains nonnumerical elements.`, "Bar plots only support numbers and null values."]), null) : y;
        }) : o[d].data,
        stackedData: f[p].map(([g, y]) => [g, y])
      });
    });
  }), {
    seriesOrder: r,
    stackingGroups: i,
    series: oc(a, (c) => c == null ? "" : c.toLocaleString())
  };
}, Ap = Sp;
function we(e, t) {
  return typeof e == "function" ? e(t) : e;
}
const Ep = (e) => {
  const {
    seriesOrder: t,
    series: r
  } = e;
  return t.reduce((o, i) => {
    const s = we(r[i].label, "legend");
    return s === void 0 || o.push({
      markType: r[i].labelMarkType,
      id: i,
      seriesId: i,
      color: r[i].color,
      label: s
    }), o;
  }, []);
}, Rp = Ep, jp = (e, t, r) => {
  const o = e.layout === "vertical", i = o ? t == null ? void 0 : t.colorScale : r == null ? void 0 : r.colorScale, s = o ? r == null ? void 0 : r.colorScale : t == null ? void 0 : t.colorScale, a = o ? t == null ? void 0 : t.data : r == null ? void 0 : r.data;
  return s ? (c) => {
    if (c === void 0)
      return e.color;
    const u = e.data[c], l = u === null ? e.color : s(u);
    return l === null ? e.color : l;
  } : i && a ? (c) => {
    if (c === void 0)
      return e.color;
    const u = a[c], l = u === null ? e.color : i(u);
    return l === null ? e.color : l;
  } : () => e.color;
}, Pp = jp, Np = (e) => {
  const {
    series: t,
    getColor: r,
    identifier: o
  } = e;
  if (!o || o.dataIndex === void 0)
    return null;
  const i = we(t.label, "tooltip"), s = t.data[o.dataIndex];
  if (s == null)
    return null;
  const a = t.valueFormatter(s, {
    dataIndex: o.dataIndex
  });
  return {
    identifier: o,
    color: r(o.dataIndex),
    label: i,
    value: s,
    formattedValue: a,
    markType: t.labelMarkType
  };
}, $p = (e) => Object.values(e).map((t) => t.layout === "horizontal" ? {
  direction: "y",
  axisId: t.yAxisId
} : {
  direction: "x",
  axisId: t.xAxisId
}), Lp = Np, Dp = (e, t, r) => k({
  id: e.id ?? `auto-generated-id-${t}`,
  color: r[t % r.length]
}, e), qp = Dp, Fp = {
  seriesProcessor: Ap,
  colorProcessor: Pp,
  legendGetter: Rp,
  tooltipGetter: Lp,
  axisTooltipGetter: $p,
  xExtremumGetter: Cp,
  yExtremumGetter: Ip,
  getSeriesWithDefaultValues: qp
}, Pn = (e, t) => [t[0] === null ? e[0] : Math.min(e[0], t[0]), t[1] === null ? e[1] : Math.max(e[1], t[1])], zp = (e) => {
  const {
    series: t,
    axis: r,
    isDefaultAxis: o,
    getFilters: i
  } = e;
  return Object.keys(t).filter((s) => {
    const a = t[s].xAxisId;
    return a === r.id || a === void 0 && o;
  }).reduce((s, a) => {
    var l;
    const c = i == null ? void 0 : i({
      currentAxisId: r.id,
      isDefaultAxis: o,
      seriesXAxisId: t[a].xAxisId,
      seriesYAxisId: t[a].yAxisId
    }), u = (l = t[a].data) == null ? void 0 : l.reduce((h, f, d) => c && !c(f, d) ? h : Pn(h, [f.x, f.x]), [1 / 0, -1 / 0]);
    return Pn(s, u ?? [1 / 0, -1 / 0]);
  }, [1 / 0, -1 / 0]);
}, Up = (e) => {
  const {
    series: t,
    axis: r,
    isDefaultAxis: o,
    getFilters: i
  } = e;
  return Object.keys(t).filter((s) => {
    const a = t[s].yAxisId;
    return a === r.id || a === void 0 && o;
  }).reduce((s, a) => {
    var l;
    const c = i == null ? void 0 : i({
      currentAxisId: r.id,
      isDefaultAxis: o,
      seriesXAxisId: t[a].xAxisId,
      seriesYAxisId: t[a].yAxisId
    }), u = (l = t[a].data) == null ? void 0 : l.reduce((h, f, d) => c && !c(f, d) ? h : Pn(h, [f.y, f.y]), [1 / 0, -1 / 0]);
    return Pn(s, u ?? [1 / 0, -1 / 0]);
  }, [1 / 0, -1 / 0]);
}, Hp = ({
  series: e,
  seriesOrder: t
}, r) => ({
  series: Object.fromEntries(Object.entries(e).map(([i, s]) => {
    const a = s == null ? void 0 : s.datasetKeys, c = ["x", "y", "id"].filter((l) => typeof (a == null ? void 0 : a[l]) != "string");
    if (s != null && s.datasetKeys && c.length > 0)
      throw new Error([`MUI X Charts: scatter series with id='${i}' has incomplete datasetKeys.`, `Properties ${c.map((l) => `"${l}"`).join(", ")} are missing.`].join(`
`));
    const u = a ? (r == null ? void 0 : r.map((l) => ({
      x: l[a.x] ?? null,
      y: l[a.y] ?? null,
      z: a.z && l[a.z],
      id: a.id && l[a.id]
    }))) ?? [] : s.data ?? [];
    return [i, k({
      labelMarkType: "circle",
      markerSize: 4
    }, s, {
      data: u,
      valueFormatter: s.valueFormatter ?? ((l) => l && `(${l.x}, ${l.y})`)
    })];
  })),
  seriesOrder: t
}), Vp = Hp, Gp = (e, t, r, o) => {
  const i = o == null ? void 0 : o.colorScale, s = r == null ? void 0 : r.colorScale, a = t == null ? void 0 : t.colorScale;
  return i ? (c) => {
    var h, f;
    if (c === void 0)
      return e.color;
    if (((h = o == null ? void 0 : o.data) == null ? void 0 : h[c]) !== void 0) {
      const d = i((f = o == null ? void 0 : o.data) == null ? void 0 : f[c]);
      if (d !== null)
        return d;
    }
    const u = e.data[c], l = u === null ? e.color : i(u.z);
    return l === null ? e.color : l;
  } : s ? (c) => {
    if (c === void 0)
      return e.color;
    const u = e.data[c], l = u === null ? e.color : s(u.y);
    return l === null ? e.color : l;
  } : a ? (c) => {
    if (c === void 0)
      return e.color;
    const u = e.data[c], l = u === null ? e.color : a(u.x);
    return l === null ? e.color : l;
  } : () => e.color;
}, Yp = Gp, Wp = (e) => {
  const {
    seriesOrder: t,
    series: r
  } = e;
  return t.reduce((o, i) => {
    const s = we(r[i].label, "legend");
    return s === void 0 || o.push({
      markType: r[i].labelMarkType,
      id: i,
      seriesId: i,
      color: r[i].color,
      label: s
    }), o;
  }, []);
}, Xp = Wp, Bp = (e) => {
  const {
    series: t,
    getColor: r,
    identifier: o
  } = e;
  if (!o || o.dataIndex === void 0)
    return null;
  const i = we(t.label, "tooltip"), s = t.data[o.dataIndex], a = t.valueFormatter(s, {
    dataIndex: o.dataIndex
  });
  return {
    identifier: o,
    color: r(o.dataIndex),
    label: i,
    value: s,
    formattedValue: a,
    markType: t.labelMarkType
  };
}, Kp = Bp, Zp = (e, t, r) => k({
  id: e.id ?? `auto-generated-id-${t}`,
  color: r[t % r.length]
}, e), Qp = Zp, Jp = {
  seriesProcessor: Vp,
  colorProcessor: Yp,
  legendGetter: Xp,
  tooltipGetter: Kp,
  xExtremumGetter: zp,
  yExtremumGetter: Up,
  getSeriesWithDefaultValues: Qp
}, em = (e) => {
  const {
    axis: t
  } = e, r = Math.min(...t.data ?? []), o = Math.max(...t.data ?? []);
  return [r, o];
};
function tm(e, t, r, o) {
  return r.reduce((i, s, a) => {
    if (t[a] === null)
      return i;
    const [c, u] = e(s);
    return o && (!o({
      y: c,
      x: null
    }, a) || !o({
      y: u,
      x: null
    }, a)) ? i : [Math.min(c, u, i[0]), Math.max(c, u, i[1])];
  }, [1 / 0, -1 / 0]);
}
const nm = (e) => {
  const {
    series: t,
    axis: r,
    isDefaultAxis: o,
    getFilters: i
  } = e;
  return Object.keys(t).filter((s) => {
    const a = t[s].yAxisId;
    return a === r.id || o && a === void 0;
  }).reduce((s, a) => {
    const {
      area: c,
      stackedData: u,
      data: l
    } = t[a], h = c !== void 0, f = i == null ? void 0 : i({
      currentAxisId: r.id,
      isDefaultAxis: o,
      seriesXAxisId: t[a].xAxisId,
      seriesYAxisId: t[a].yAxisId
    }), d = h && r.scaleType !== "log" && typeof t[a].baseline != "string" ? (y) => y : (y) => [y[1], y[1]], p = tm(d, l, u, f), [m, g] = p;
    return [Math.min(m, s[0]), Math.max(g, s[1])];
  }, [1 / 0, -1 / 0]);
}, rm = (e, t) => {
  const {
    seriesOrder: r,
    series: o
  } = e, i = rc(k({}, e, {
    defaultStrategy: {
      stackOffset: "none"
    }
  })), s = t ?? [];
  r.forEach((c) => {
    const u = o[c].data;
    if (u !== void 0)
      u.forEach((l, h) => {
        s.length <= h ? s.push({
          [c]: l
        }) : s[h][c] = l;
      });
    else if (t === void 0 && "production".NODE_ENV !== "production")
      throw new Error([`MUI X Charts: line series with id='${c}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join(`
`));
  });
  const a = {};
  return i.forEach((c) => {
    const {
      ids: u,
      stackingOrder: l,
      stackingOffset: h
    } = c, f = Ws().keys(u.map((d) => {
      const p = o[d].dataKey;
      return o[d].data === void 0 && p !== void 0 ? p : d;
    })).value((d, p) => d[p] ?? 0).order(l).offset(h)(s);
    u.forEach((d, p) => {
      const m = o[d].dataKey;
      a[d] = k({
        labelMarkType: "line"
      }, o[d], {
        data: m ? t.map((g) => {
          const y = g[m];
          return typeof y != "number" ? ("production".NODE_ENV !== "production" && y !== null && rt([`MUI X Charts: Your dataset key "${m}" is used for plotting line, but contains nonnumerical elements.`, "Line plots only support numbers and null values."]), null) : y;
        }) : o[d].data,
        stackedData: f[p].map(([g, y]) => [g, y])
      });
    });
  }), {
    seriesOrder: r,
    stackingGroups: i,
    series: oc(a, (c) => c == null ? "" : c.toLocaleString())
  };
}, om = rm, im = (e, t, r) => {
  const o = r == null ? void 0 : r.colorScale, i = t == null ? void 0 : t.colorScale;
  return o ? (s) => {
    if (s === void 0)
      return e.color;
    const a = e.data[s], c = a === null ? e.color : o(a);
    return c === null ? e.color : c;
  } : i ? (s) => {
    var u;
    if (s === void 0)
      return e.color;
    const a = (u = t.data) == null ? void 0 : u[s], c = a === null ? e.color : i(a);
    return c === null ? e.color : c;
  } : () => e.color;
}, zo = im, sm = (e) => {
  const {
    seriesOrder: t,
    series: r
  } = e;
  return t.reduce((o, i) => {
    const s = we(r[i].label, "legend");
    return s === void 0 || o.push({
      markType: r[i].labelMarkType,
      id: i,
      seriesId: i,
      color: r[i].color,
      label: s
    }), o;
  }, []);
}, am = sm, cm = (e) => {
  const {
    series: t,
    getColor: r,
    identifier: o
  } = e;
  if (!o || o.dataIndex === void 0)
    return null;
  const i = we(t.label, "tooltip"), s = t.data[o.dataIndex], a = t.valueFormatter(s, {
    dataIndex: o.dataIndex
  });
  return {
    identifier: o,
    color: r(o.dataIndex),
    label: i,
    value: s,
    formattedValue: a,
    markType: t.labelMarkType
  };
}, lm = (e) => Object.values(e).map((t) => ({
  direction: "x",
  axisId: t.xAxisId
})), um = cm, fm = (e, t, r) => k({
  id: e.id ?? `auto-generated-id-${t}`,
  color: r[t % r.length]
}, e), dm = fm, hm = {
  colorProcessor: zo,
  seriesProcessor: om,
  legendGetter: am,
  tooltipGetter: um,
  axisTooltipGetter: lm,
  xExtremumGetter: em,
  yExtremumGetter: nm,
  getSeriesWithDefaultValues: dm
}, pm = (e = "none") => {
  if (typeof e == "function")
    return e;
  switch (e) {
    case "none":
      return null;
    case "desc":
      return (t, r) => r - t;
    case "asc":
      return (t, r) => t - r;
    default:
      return null;
  }
}, mm = (e) => {
  const {
    seriesOrder: t,
    series: r
  } = e, o = {};
  return t.forEach((i) => {
    const s = jl().startAngle(2 * Math.PI * (r[i].startAngle ?? 0) / 360).endAngle(2 * Math.PI * (r[i].endAngle ?? 360) / 360).padAngle(2 * Math.PI * (r[i].paddingAngle ?? 0) / 360).sortValues(pm(r[i].sortingValues ?? "none"))(r[i].data.map((a) => a.value));
    o[i] = k({
      labelMarkType: "circle",
      valueFormatter: (a) => a.value.toLocaleString()
    }, r[i], {
      data: r[i].data.map((a, c) => k({}, a, {
        id: a.id ?? `auto-generated-pie-id-${i}-${c}`
      }, s[c])).map((a, c) => {
        var u, l;
        return k({
          labelMarkType: "circle"
        }, a, {
          formattedValue: ((l = (u = r[i]).valueFormatter) == null ? void 0 : l.call(u, k({}, a, {
            label: we(a.label, "arc")
          }), {
            dataIndex: c
          })) ?? a.value.toLocaleString()
        });
      })
    });
  }), {
    seriesOrder: t,
    series: o
  };
}, gm = mm, ym = (e) => (t) => e.data[t].color, bm = ym, xm = (e) => {
  const {
    seriesOrder: t,
    series: r
  } = e;
  return t.reduce((o, i) => (r[i].data.forEach((s, a) => {
    const c = we(s.label, "legend");
    c !== void 0 && o.push({
      markType: s.labelMarkType ?? r[i].labelMarkType,
      id: s.id ?? a,
      seriesId: i,
      color: s.color,
      label: c,
      itemId: s.id ?? a
    });
  }), o), []);
}, Om = xm, Tm = (e) => {
  const {
    series: t,
    getColor: r,
    identifier: o
  } = e;
  if (!o || o.dataIndex === void 0)
    return null;
  const i = t.data[o.dataIndex];
  if (i == null)
    return null;
  const s = we(i.label, "tooltip"), a = k({}, i, {
    label: s
  }), c = t.valueFormatter(a, {
    dataIndex: o.dataIndex
  });
  return {
    identifier: o,
    color: r(o.dataIndex),
    label: s,
    value: a,
    formattedValue: c,
    markType: i.labelMarkType ?? t.labelMarkType
  };
}, km = Tm, _m = (e, t, r) => k({
  id: e.id ?? `auto-generated-id-${t}`
}, e, {
  data: e.data.map((o, i) => k({
    color: r[i % r.length]
  }, o))
}), wm = _m, vm = {
  colorProcessor: bm,
  seriesProcessor: gm,
  legendGetter: Om,
  tooltipGetter: km,
  getSeriesWithDefaultValues: wm
}, Mm = {
  bar: Fp,
  scatter: Jp,
  line: hm,
  pie: vm
}, Cm = [Jt, Et, Qt, Rt];
function Im(e) {
  const {
    children: t,
    plugins: r = Cm,
    pluginParams: o = {},
    seriesConfig: i = Mm
  } = e, {
    contextValue: s
  } = _f(r, o, i);
  return /* @__PURE__ */ w.jsx(bo.Provider, {
    value: s,
    children: t
  });
}
const Ve = () => {
  const e = A.useContext(bo);
  if (e == null)
    throw new Error(["MUI X Charts: Could not find the Chart context.", "It looks like you rendered your component outside of a ChartDataProvider.", "This can also happen if you are bundling multiple versions of the library."].join(`
`));
  return e;
}, Sm = (e) => {
  "hasPointerCapture" in e.currentTarget && e.currentTarget.hasPointerCapture(e.pointerId) && e.currentTarget.releasePointerCapture(e.pointerId);
}, cr = (e, t) => {
  const {
    instance: r
  } = Ve(), o = A.useRef(!1), i = A.useCallback(() => {
    o.current = !0, r.setItemInteraction({
      type: e.type,
      seriesId: e.seriesId,
      dataIndex: e.dataIndex
    }), r.setHighlight({
      seriesId: e.seriesId,
      dataIndex: e.dataIndex
    });
  }, [r, e.type, e.seriesId, e.dataIndex]), s = A.useCallback(() => {
    o.current = !1, r.removeItemInteraction({
      type: e.type,
      seriesId: e.seriesId,
      dataIndex: e.dataIndex
    }), r.clearHighlight();
  }, [r, e.type, e.seriesId, e.dataIndex]);
  return A.useEffect(() => () => {
    o.current && s();
  }, [s]), t ? {} : {
    onPointerEnter: i,
    onPointerLeave: s,
    onPointerDown: Sm
  };
};
function K() {
  const e = Ve();
  if (!e)
    throw new Error(["MUI X Charts: Could not find the charts context.", "It looks like you rendered your component outside of a ChartContainer parent component."].join(`
`));
  return e.store;
}
const ic = (e, t) => (r) => !e || !t || !r ? !1 : e.highlight === "series" ? r.seriesId === t.seriesId : e.highlight === "item" ? r.dataIndex === t.dataIndex && r.seriesId === t.seriesId : !1, sc = (e, t) => (r) => !e || !t || !r ? !1 : e.fade === "series" ? r.seriesId === t.seriesId && r.dataIndex !== t.dataIndex : e.fade === "global" ? r.seriesId !== t.seriesId || r.dataIndex !== t.dataIndex : !1, Am = (e) => e.highlight, Em = (e) => e.series, Rm = F(Em, (e) => {
  const t = /* @__PURE__ */ new Map();
  return Object.keys(e.processedSeries).forEach((r) => {
    const o = e.processedSeries[r];
    Object.keys((o == null ? void 0 : o.series) ?? {}).forEach((i) => {
      const s = o == null ? void 0 : o.series[i];
      t.set(i, s == null ? void 0 : s.highlightScope);
    });
  }), t;
}), en = F(Am, (e) => e.item), lr = F([Rm, en], (e, t) => {
  if (!t)
    return null;
  const r = e.get(t.seriesId);
  return r === void 0 ? null : r;
}), jm = F([lr, en], ic), Pm = F([lr, en], sc), Nm = F([lr, en, (e, t) => t], (e, t, r) => ic(e, t)(r)), $m = F([lr, en, (e, t) => t], (e, t, r) => sc(e, t)(r));
function ac(e) {
  const t = K(), r = V(t, Nm, e), o = V(t, $m, e);
  return {
    isHighlighted: r,
    isFaded: !r && o
  };
}
var Lm = 4, Dm = 1e-3, qm = 1e-7, Fm = 10, Dt = 11, hn = 1 / (Dt - 1), zm = typeof Float32Array == "function";
function cc(e, t) {
  return 1 - 3 * t + 3 * e;
}
function lc(e, t) {
  return 3 * t - 6 * e;
}
function uc(e) {
  return 3 * e;
}
function Nn(e, t, r) {
  return ((cc(t, r) * e + lc(t, r)) * e + uc(t)) * e;
}
function fc(e, t, r) {
  return 3 * cc(t, r) * e * e + 2 * lc(t, r) * e + uc(t);
}
function Um(e, t, r, o, i) {
  var s, a, c = 0;
  do
    a = t + (r - t) / 2, s = Nn(a, o, i) - e, s > 0 ? r = a : t = a;
  while (Math.abs(s) > qm && ++c < Fm);
  return a;
}
function Hm(e, t, r, o) {
  for (var i = 0; i < Lm; ++i) {
    var s = fc(t, r, o);
    if (s === 0)
      return t;
    var a = Nn(t, r, o) - e;
    t -= a / s;
  }
  return t;
}
function Vm(e) {
  return e;
}
var Gm = function(t, r, o, i) {
  if (!(0 <= t && t <= 1 && 0 <= o && o <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (t === r && o === i)
    return Vm;
  for (var s = zm ? new Float32Array(Dt) : new Array(Dt), a = 0; a < Dt; ++a)
    s[a] = Nn(a * hn, t, o);
  function c(u) {
    for (var l = 0, h = 1, f = Dt - 1; h !== f && s[h] <= u; ++h)
      l += hn;
    --h;
    var d = (u - s[h]) / (s[h + 1] - s[h]), p = l + d * hn, m = fc(p, t, o);
    return m >= Dm ? Hm(u, p, t, o) : m === 0 ? p : Um(u, l, l + hn, t, o);
  }
  return function(l) {
    return l === 0 ? 0 : l === 1 ? 1 : Nn(c(l), r, i);
  };
};
const Ym = /* @__PURE__ */ Ol(Gm), ur = 300, Uo = "cubic-bezier(0.66, 0, 0.34, 1)", Wm = Ym(0.66, 0, 0.34, 1);
var Ct = 0, qt = 0, $t = 0, dc = 1e3, $n, Ft, Ln = 0, ot = 0, fr = 0, Yt = typeof performance == "object" && performance.now ? performance : Date, hc = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Ho() {
  return ot || (hc(Xm), ot = Yt.now() + fr);
}
function Xm() {
  ot = 0;
}
function Dn() {
  this._call = this._time = this._next = null;
}
Dn.prototype = pc.prototype = {
  constructor: Dn,
  restart: function(e, t, r) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    r = (r == null ? Ho() : +r) + (t == null ? 0 : +t), !this._next && Ft !== this && (Ft ? Ft._next = this : $n = this, Ft = this), this._call = e, this._time = r, so();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, so());
  }
};
function pc(e, t, r) {
  var o = new Dn();
  return o.restart(e, t, r), o;
}
function io() {
  Ho(), ++Ct;
  for (var e = $n, t; e; )
    (t = ot - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Ct;
}
function hs() {
  ot = (Ln = Yt.now()) + fr, Ct = qt = 0;
  try {
    io();
  } finally {
    Ct = 0, Km(), ot = 0;
  }
}
function Bm() {
  var e = Yt.now(), t = e - Ln;
  t > dc && (fr -= t, Ln = e);
}
function Km() {
  for (var e, t = $n, r, o = 1 / 0; t; )
    t._call ? (o > t._time && (o = t._time), e = t, t = t._next) : (r = t._next, t._next = null, t = e ? e._next = r : $n = r);
  Ft = e, so(o);
}
function so(e) {
  if (!Ct) {
    qt && (qt = clearTimeout(qt));
    var t = e - ot;
    t > 24 ? (e < 1 / 0 && (qt = setTimeout(hs, e - Yt.now() - fr)), $t && ($t = clearInterval($t))) : ($t || (Ln = Yt.now(), $t = setInterval(Bm, dc)), Ct = 1, hc(hs));
  }
}
function Zm(e, t, r) {
  var o = new Dn();
  return t = t == null ? 0 : +t, o.restart((i) => {
    o.stop(), e(i + t);
  }, t, r), o;
}
class Qm {
  /**
   * Create a new ResumableTransition.
   * @param duration Duration in milliseconds
   * @param easingFn The easing function
   * @param onTick Callback function called on each animation frame with the eased time in range [0, 1].
   */
  constructor(t, r, o) {
    this.duration = void 0, this.elapsed = 0, this.easingFn = void 0, this.timer = null, this.onTickCallback = void 0, this.duration = t, this.easingFn = r, this.onTickCallback = o, this.resume();
  }
  get running() {
    return this.timer !== null;
  }
  timerCallback(t) {
    this.elapsed = Math.min(t, this.duration);
    const r = this.duration === 0 ? 1 : this.elapsed / this.duration, o = this.easingFn(r);
    this.onTickCallback(o), this.elapsed >= this.duration && this.stop();
  }
  /**
   * Resume the transition
   */
  resume() {
    if (this.running || this.elapsed >= this.duration)
      return this;
    const t = Ho() - this.elapsed;
    return this.timer = pc((r) => this.timerCallback(r), 0, t), io(), this;
  }
  /**
   * Stops the transition.
   */
  stop() {
    return this.running ? (this.timer && (this.timer.stop(), this.timer = null), this) : this;
  }
  /**
   * Immediately finishes the transition and calls the tick callback with the final value.
   */
  finish() {
    return this.stop(), Zm(() => this.timerCallback(this.duration)), io(), this;
  }
}
function Jm(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  const r = Object.keys(e), o = Object.keys(t);
  if (r.length !== o.length)
    return !1;
  for (let i = 0; i < r.length; i += 1) {
    const s = r[i];
    if (!Object.prototype.hasOwnProperty.call(t, s) || // @ts-ignore
    !Object.is(e[s], t[s]))
      return !1;
  }
  return !0;
}
function eg(e, {
  createInterpolator: t,
  applyProps: r,
  skip: o,
  initialProps: i = e
}) {
  const s = A.useRef(i), a = A.useRef(null), c = A.useRef(null), u = A.useRef(e);
  Ae(() => {
    u.current = e;
  }, [e]), Ae(() => {
    var f;
    o && ((f = a.current) == null || f.finish(), a.current = null, c.current = null, s.current = e);
  }, [e, o]);
  const l = A.useCallback((f) => {
    const d = s.current, p = t(d, e);
    a.current = new Qm(ur, Wm, (m) => {
      const g = p(m);
      s.current = g, r(f, g);
    });
  }, [r, t, e]);
  return A.useCallback((f) => {
    var p, m, g, y;
    if (f === null) {
      (p = a.current) == null || p.stop();
      return;
    }
    const d = c.current;
    if (d === f) {
      if (Jm(u.current, e)) {
        (m = a.current) == null || m.resume();
        return;
      }
      (g = a.current) == null || g.stop();
    }
    d && ((y = a.current) == null || y.stop()), c.current = f, (a.current || !o) && l(f);
  }, [l, e, o]);
}
function mc(e, {
  createInterpolator: t,
  transformProps: r,
  applyProps: o,
  skip: i,
  initialProps: s = e,
  ref: a
}) {
  const c = r ?? ((h) => h), u = eg(e, {
    initialProps: s,
    createInterpolator: t,
    applyProps: (h, f) => o(h, c(f)),
    skip: i
  });
  return k({}, r(i ? e : s), {
    ref: go(u, a)
  });
}
function tg(e) {
  return mc({
    d: e.d
  }, {
    createInterpolator: (t, r) => {
      const o = wo(t.d, r.d);
      return (i) => ({
        d: o(i)
      });
    },
    applyProps: (t, {
      d: r
    }) => t.setAttribute("d", r),
    transformProps: (t) => t,
    skip: e.skipAnimation,
    ref: e.ref
  });
}
function gc(e) {
  return e.replace(" ", "_");
}
function Re() {
  const e = K();
  return V(e, Ue);
}
function dr() {
  const e = K();
  return V(e, gf);
}
function Vo(e) {
  return qa.getTypes().has(e);
}
const ng = (e, t, r, o, i, s, a) => {
  var p;
  const c = o === "rotation" ? i[t].rotationExtremumGetter : i[t].radiusExtremumGetter, u = ((p = a[t]) == null ? void 0 : p.series) ?? {}, [l, h] = (c == null ? void 0 : c({
    series: u,
    axis: r,
    axisIndex: s,
    isDefaultAxis: s === 0
  })) ?? [1 / 0, -1 / 0], [f, d] = e;
  return [Math.min(l, f), Math.max(h, d)];
}, rg = (e, t, r, o, i) => {
  const a = Object.keys(r).filter(Vo).reduce((c, u) => ng(c, u, e, t, r, o, i), [1 / 0, -1 / 0]);
  return Number.isNaN(a[0]) || Number.isNaN(a[1]) ? [1 / 0, -1 / 0] : a;
}, zt = (e, t) => e === void 0 ? t : Math.PI * e / 180, og = (e, t, r, o) => {
  const i = /* @__PURE__ */ new Set();
  return Object.keys(t).filter(Vo).forEach((a) => {
    var l, h, f;
    const c = ((l = r[a]) == null ? void 0 : l.series) ?? {}, u = (f = (h = t[a]).axisTooltipGetter) == null ? void 0 : f.call(h, c);
    u !== void 0 && u.forEach(({
      axisId: d,
      direction: p
    }) => {
      p === e && i.add(d ?? o);
    });
  }), i;
};
function ig(e, t, r) {
  if (t === "rotation") {
    if (r.scaleType === "point") {
      const o = [zt(r.startAngle, 0), zt(r.endAngle, 2 * Math.PI)], i = o[1] - o[0];
      return i > Math.PI * 2 - 0.1 && (o[1] -= i / r.data.length), o;
    }
    return [zt(r.startAngle, 0), zt(r.endAngle, 2 * Math.PI)];
  }
  return [0, Math.min(e.height, e.width) / 2];
}
const sg = 0.2, ag = 0.1;
function yc({
  drawingArea: e,
  formattedSeries: t,
  axis: r,
  seriesConfig: o,
  axisDirection: i
}) {
  if (r === void 0)
    return {
      axis: {},
      axisIds: []
    };
  const s = og(i, o, t, r[0].id), a = {};
  return r.forEach((c, u) => {
    const l = c, h = ig(e, i, l), [f, d] = rg(l, i, o, u, t), p = !l.ignoreTooltip && s.has(l.id), m = l.data ?? [];
    if (Na(l)) {
      const C = l.categoryGapRatio ?? sg, P = l.barGapRatio ?? ag;
      if (a[l.id] = k({
        offset: 0,
        categoryGapRatio: C,
        barGapRatio: P,
        triggerTooltip: p
      }, l, {
        data: m,
        scale: Kn(l.data, h).paddingInner(C).paddingOuter(C / 2),
        tickNumber: l.data.length,
        colorScale: l.colorMap && (l.colorMap.type === "ordinal" ? vt(k({
          values: l.data
        }, l.colorMap)) : nt(l.colorMap))
      }), Rn(l.data)) {
        const I = jn(l, h);
        a[l.id].valueFormatter = l.valueFormatter ?? I;
      }
    }
    if ($a(l) && (a[l.id] = k({
      offset: 0,
      triggerTooltip: p
    }, l, {
      data: m,
      scale: ha(l.data, h),
      tickNumber: l.data.length,
      colorScale: l.colorMap && (l.colorMap.type === "ordinal" ? vt(k({
        values: l.data
      }, l.colorMap)) : nt(l.colorMap))
    }), Rn(l.data))) {
      const C = jn(l, h);
      a[l.id].valueFormatter = l.valueFormatter ?? C;
    }
    if (l.scaleType === "band" || l.scaleType === "point")
      return;
    const g = l.scaleType ?? "linear", y = l.domainLimit ?? "nice", b = [l.min ?? f, l.max ?? d];
    if (typeof y == "function") {
      const {
        min: C,
        max: P
      } = y(f, d);
      b[0] = C, b[1] = P;
    }
    const O = La(k({}, l, {
      range: h,
      domain: b
    })), x = Da(O, h), _ = En(g, b, h), M = y === "nice" ? _.nice(O) : _, [T, v] = M.domain(), S = [l.min ?? T, l.max ?? v];
    a[l.id] = k({
      offset: 0,
      triggerTooltip: p
    }, l, {
      data: m,
      scaleType: g,
      scale: M.domain(S),
      tickNumber: x,
      colorScale: l.colorMap && nt(l.colorMap)
    });
  }), {
    axis: a,
    axisIds: r.map(({
      id: c
    }) => c)
  };
}
const bc = (e) => e.polarAxis, xc = F(bc, (e) => e == null ? void 0 : e.rotation), cg = F(bc, (e) => e == null ? void 0 : e.radius), hr = F([xc, Ue, Ee, He], (e, t, r, o) => yc({
  drawingArea: t,
  formattedSeries: r,
  axis: e,
  seriesConfig: o,
  axisDirection: "rotation"
})), lg = F([cg, Ue, Ee, He], (e, t, r, o) => yc({
  drawingArea: t,
  formattedSeries: r,
  axis: e,
  seriesConfig: o,
  axisDirection: "radius"
})), ug = F([Ue], (e) => ({
  cx: e.left + e.width / 2,
  cy: e.top + e.height / 2
})), fg = (e) => (t, r) => Math.atan2(t - e.cx, e.cy - r);
function je() {
  const e = K(), {
    axis: t,
    axisIds: r
  } = V(e, at);
  return {
    xAxis: t,
    xAxisIds: r
  };
}
function Pe() {
  const e = K(), {
    axis: t,
    axisIds: r
  } = V(e, ct);
  return {
    yAxis: t,
    yAxisIds: r
  };
}
function Oc(e) {
  const t = K(), {
    axis: r,
    axisIds: o
  } = V(t, at), i = e ?? o[0];
  return r[i];
}
function Tc(e) {
  const t = K(), {
    axis: r,
    axisIds: o
  } = V(t, ct), i = e ?? o[0];
  return r[i];
}
function kc() {
  const e = K(), {
    axis: t,
    axisIds: r
  } = V(e, hr);
  return {
    rotationAxis: t,
    rotationAxisIds: r
  };
}
function dg() {
  const e = K(), {
    axis: t,
    axisIds: r
  } = V(e, lg);
  return {
    radiusAxis: t,
    radiusAxisIds: r
  };
}
function hg(e) {
  const t = K(), {
    axis: r,
    axisIds: o
  } = V(t, hr), i = typeof e == "string" ? e : o[e ?? 0];
  return r[i];
}
function Xe(e) {
  return Me(e) ? (t) => (e(t) ?? 0) + e.bandwidth() / 2 : (t) => e(t);
}
function pg(e) {
  return Oc(e).scale;
}
function mg(e) {
  return Tc(e).scale;
}
function Go() {
  const e = K(), {
    axis: t,
    axisIds: r
  } = V(e, wp) ?? {
    axis: {},
    axisIds: []
  };
  return {
    zAxis: t,
    zAxisIds: r
  };
}
function Yo() {
  const e = Ve();
  if (!e)
    throw new Error(["MUI X Charts: Could not find the svg ref context.", "It looks like you rendered your component outside of a ChartContainer parent component."].join(`
`));
  return e.svgRef;
}
function pr() {
  const e = K();
  return V(e, Ee);
}
function gg(e) {
  const t = F(Ee, (r) => r[e]);
  return () => {
    const r = K();
    return V(r, t);
  };
}
const yg = gg("line");
function mr() {
  return yg();
}
function bg() {
  const e = K(), t = V(e, jm), r = V(e, Pm);
  return {
    isHighlighted: t,
    isFaded: r
  };
}
function xg(e, t) {
  return Object.keys(e).flatMap((r) => {
    const o = t[r].legendGetter;
    return o === void 0 ? [] : o(e[r]);
  });
}
function Og() {
  const e = pr(), t = K(), r = V(t, He);
  return {
    items: xg(e, r)
  };
}
function Wo() {
  const e = dr();
  return A.useCallback((t) => `${e}-gradient-${t}`, [e]);
}
function Tg() {
  const e = dr();
  return A.useCallback((t) => `${e}-gradient-${t}-object-bound`, [e]);
}
function kg(e) {
  return mc({
    d: e.d
  }, {
    createInterpolator: (t, r) => {
      const o = wo(t.d, r.d);
      return (i) => ({
        d: o(i)
      });
    },
    applyProps: (t, {
      d: r
    }) => t.setAttribute("d", r),
    skip: e.skipAnimation,
    transformProps: (t) => t,
    ref: e.ref
  });
}
function _g() {
  return Ve().chartRootRef;
}
const wg = (e) => ({
  components: {
    MuiChartsLocalizationProvider: {
      defaultProps: {
        localeText: k({}, e)
      }
    }
  }
}), _c = {
  // Overlay
  loading: "Loading data",
  noData: "No data to display",
  zoomIn: "Zoom in",
  zoomOut: "Zoom out"
}, vg = _c;
wg(_c);
const Mg = ["localeText"], qn = /* @__PURE__ */ A.createContext(null);
"production".NODE_ENV !== "production" && (qn.displayName = "ChartsLocalizationContext");
function wc(e) {
  const {
    localeText: t
  } = e, r = B(e, Mg), {
    localeText: o
  } = A.useContext(qn) ?? {
    localeText: void 0
  }, i = ze({
    // We don't want to pass the `localeText` prop to the theme, that way it will always return the theme value,
    // We will then merge this theme value with our value manually
    props: r,
    name: "MuiChartsLocalizationProvider"
  }), {
    children: s,
    localeText: a
  } = i, c = A.useMemo(() => k({}, vg, a, o, t), [a, o, t]), u = A.useMemo(() => ({
    localeText: c
  }), [c]);
  return /* @__PURE__ */ w.jsx(qn.Provider, {
    value: u,
    children: s
  });
}
"production".NODE_ENV !== "production" && (wc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: n.node,
  /**
   * Localized text for chart components.
   */
  localeText: n.object
});
const vc = () => {
  const e = A.useContext(qn);
  if (e === null)
    throw new Error(["MUI X Charts: Can not find the charts localization context.", "It looks like you forgot to wrap your component in ChartsLocalizationProvider.", "This can also happen if you are bundling multiple versions of the `@mui/x-charts` package"].join(`
`));
  return e;
}, Mc = Oe("MuiAppearingMask", ["animate"]), Cg = Q("rect")({
  animationName: "animate-width",
  animationTimingFunction: Uo,
  animationDuration: "0s",
  [`&.${Mc.animate}`]: {
    animationDuration: `${ur}ms`
  },
  "@keyframes animate-width": {
    from: {
      width: 0
    }
  }
});
function Cc(e) {
  const t = Re(), r = dr(), o = gc(`${r}-${e.id}`);
  return /* @__PURE__ */ w.jsxs(A.Fragment, {
    children: [/* @__PURE__ */ w.jsx("clipPath", {
      id: o,
      children: /* @__PURE__ */ w.jsx(Cg, {
        className: e.skipAnimation ? "" : Mc.animate,
        x: 0,
        y: 0,
        width: t.left + t.width + t.right,
        height: t.top + t.height + t.bottom
      })
    }), /* @__PURE__ */ w.jsx("g", {
      clipPath: `url(#${o})`,
      children: e.children
    })]
  });
}
const Ig = ["skipAnimation", "ownerState"];
function Ic(e) {
  const {
    skipAnimation: t,
    ownerState: r
  } = e, o = B(e, Ig), i = tg(e);
  return /* @__PURE__ */ w.jsx(Cc, {
    skipAnimation: t,
    id: `${r.id}-area-clip`,
    children: /* @__PURE__ */ w.jsx("path", k({
      fill: r.gradientId ? `url(#${r.gradientId})` : r.color,
      filter: (
        // eslint-disable-next-line no-nested-ternary
        r.isHighlighted ? "brightness(140%)" : r.gradientId ? void 0 : "brightness(120%)"
      ),
      opacity: r.isFaded ? 0.3 : 1,
      stroke: "none"
    }, o, i))
  });
}
"production".NODE_ENV !== "production" && (Ic.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: n.string.isRequired,
  ownerState: n.shape({
    classes: n.object,
    color: n.string.isRequired,
    gradientId: n.string,
    id: n.oneOfType([n.number, n.string]).isRequired,
    isFaded: n.bool.isRequired,
    isHighlighted: n.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool
});
const Sg = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function Ag(e) {
  return xe("MuiAreaElement", e);
}
const Eg = Oe("MuiAreaElement", ["root", "highlighted", "faded", "series"]), Rg = (e) => {
  const {
    classes: t,
    id: r,
    isFaded: o,
    isHighlighted: i
  } = e, s = {
    root: ["root", `series-${r}`, i && "highlighted", o && "faded"]
  };
  return be(s, Ag, t);
};
function Sc(e) {
  const {
    id: t,
    classes: r,
    color: o,
    gradientId: i,
    slots: s,
    slotProps: a,
    onClick: c
  } = e, u = B(e, Sg), l = cr({
    type: "line",
    seriesId: t
  }), {
    isFaded: h,
    isHighlighted: f
  } = ac({
    seriesId: t
  }), d = {
    id: t,
    classes: r,
    color: o,
    gradientId: i,
    isFaded: h,
    isHighlighted: f
  }, p = Rg(d), m = (s == null ? void 0 : s.area) ?? Ic, g = We({
    elementType: m,
    externalSlotProps: a == null ? void 0 : a.area,
    additionalProps: k({}, l, {
      onClick: c,
      cursor: c ? "pointer" : "unset"
    }),
    className: p.root,
    ownerState: d
  });
  return /* @__PURE__ */ w.jsx(m, k({}, u, g));
}
"production".NODE_ENV !== "production" && (Sc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: n.object,
  color: n.string.isRequired,
  d: n.string.isRequired,
  gradientId: n.string,
  id: n.oneOfType([n.number, n.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object
});
function Ac(e) {
  switch (e) {
    case "catmullRom":
      return Xl.alpha(0.5);
    case "linear":
      return po;
    case "monotoneX":
      return ui;
    case "monotoneY":
      return Bl;
    case "natural":
      return Kl;
    case "step":
      return Zl;
    case "stepBefore":
      return Ql;
    case "stepAfter":
      return Jl;
    case "bumpY":
      return Nl;
    case "bumpX":
      return Pl;
    default:
      return ui;
  }
}
function Xo(e) {
  const t = K(), r = V(t, Hu);
  return e || r;
}
function Bo() {
  const e = K();
  return V(e, Ga);
}
const jg = ["slots", "slotProps", "onItemClick", "skipAnimation"], Pg = Q("g", {
  name: "MuiAreaPlot",
  slot: "Root"
})({
  [`& .${Eg.root}`]: {
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in"
  }
}), Ng = () => {
  const e = mr(), {
    xAxis: t,
    xAxisIds: r
  } = je(), {
    yAxis: o,
    yAxisIds: i
  } = Pe(), s = Wo();
  return A.useMemo(() => {
    if (e === void 0)
      return [];
    const {
      series: c,
      stackingGroups: u
    } = e, l = r[0], h = i[0];
    return u.flatMap(({
      ids: f
    }) => [...f].reverse().map((d) => {
      const {
        xAxisId: p = l,
        yAxisId: m = h,
        stackedData: g,
        data: y,
        connectNulls: b,
        baseline: O,
        curve: x,
        strictStepCurve: _
      } = c[d], M = t[p].scale, T = Xe(M), v = o[m].scale, S = t[p].data, C = o[m].colorScale && s(m) || t[p].colorScale && s(p) || void 0;
      if ("production".NODE_ENV !== "production") {
        if (S === void 0)
          throw new Error(`MUI X Charts: ${p === St ? "The first `xAxis`" : `The x-axis with id "${p}"`} should have data property to be able to display a line plot.`);
        if (S.length < g.length)
          throw new Error(`MUI X Charts: The data length of the x axis (${S.length} items) is lower than the length of series (${g.length} items).`);
      }
      const P = (x == null ? void 0 : x.includes("step")) && !_ && Me(M), I = (S == null ? void 0 : S.flatMap((N, E) => {
        const D = y[E] == null;
        if (P) {
          const U = [{
            x: N,
            y: g[E],
            nullData: D,
            isExtension: !1
          }];
          return !D && (E === 0 || y[E - 1] == null) && U.unshift({
            x: (M(N) ?? 0) - (M.step() - M.bandwidth()) / 2,
            y: g[E],
            nullData: D,
            isExtension: !0
          }), !D && (E === y.length - 1 || y[E + 1] == null) && U.push({
            x: (M(N) ?? 0) + (M.step() + M.bandwidth()) / 2,
            y: g[E],
            nullData: D,
            isExtension: !0
          }), U;
        }
        return {
          x: N,
          y: g[E],
          nullData: D
        };
      })) ?? [], L = b ? I.filter((N) => !N.nullData) : I, $ = Al().x((N) => N.isExtension ? N.x : T(N.x)).defined((N) => b || !N.nullData || !!N.isExtension).y0((N) => {
        if (typeof O == "number")
          return v(O);
        if (O === "max")
          return v.range()[1];
        if (O === "min")
          return v.range()[0];
        const E = N.y && v(N.y[0]);
        return Number.isNaN(E) ? v.range()[0] : E;
      }).y1((N) => N.y && v(N.y[1])).curve(Ac(x))(L) || "";
      return k({}, c[d], {
        gradientId: C,
        d: $,
        seriesId: d
      });
    }));
  }, [e, r, i, t, o, s]);
};
function Ec(e) {
  const {
    slots: t,
    slotProps: r,
    onItemClick: o,
    skipAnimation: i
  } = e, s = B(e, jg), a = Bo(), c = Xo(a || i), u = Ng();
  return /* @__PURE__ */ w.jsx(Pg, k({}, s, {
    children: u.map(({
      d: l,
      seriesId: h,
      color: f,
      area: d,
      gradientId: p
    }) => !!d && /* @__PURE__ */ w.jsx(Sc, {
      id: h,
      d: l,
      color: f,
      gradientId: p,
      slots: t,
      slotProps: r,
      onClick: o && ((m) => o(m, {
        type: "line",
        seriesId: h
      })),
      skipAnimation: c
    }, h))
  }));
}
"production".NODE_ENV !== "production" && (Ec.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line area item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: n.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object
});
const $g = ["skipAnimation", "ownerState"], Ko = /* @__PURE__ */ A.forwardRef(function(t, r) {
  const {
    skipAnimation: o,
    ownerState: i
  } = t, s = B(t, $g), a = kg(k({}, t, {
    ref: r
  }));
  return /* @__PURE__ */ w.jsx(Cc, {
    skipAnimation: o,
    id: `${i.id}-line-clip`,
    children: /* @__PURE__ */ w.jsx("path", k({
      stroke: i.gradientId ? `url(#${i.gradientId})` : i.color,
      strokeWidth: 2,
      strokeLinejoin: "round",
      fill: "none",
      filter: i.isHighlighted ? "brightness(120%)" : void 0,
      opacity: i.isFaded ? 0.3 : 1
    }, s, a))
  });
});
"production".NODE_ENV !== "production" && (Ko.displayName = "AnimatedLine");
"production".NODE_ENV !== "production" && (Ko.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  d: n.string.isRequired,
  ownerState: n.shape({
    classes: n.object,
    color: n.string.isRequired,
    gradientId: n.string,
    id: n.oneOfType([n.number, n.string]).isRequired,
    isFaded: n.bool.isRequired,
    isHighlighted: n.bool.isRequired
  }).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool
});
const Lg = ["id", "classes", "color", "gradientId", "slots", "slotProps", "onClick"];
function Dg(e) {
  return xe("MuiLineElement", e);
}
const qg = Oe("MuiLineElement", ["root", "highlighted", "faded", "series"]), Fg = (e) => {
  const {
    classes: t,
    id: r,
    isFaded: o,
    isHighlighted: i
  } = e, s = {
    root: ["root", `series-${r}`, i && "highlighted", o && "faded"]
  };
  return be(s, Dg, t);
};
function Rc(e) {
  const {
    id: t,
    classes: r,
    color: o,
    gradientId: i,
    slots: s,
    slotProps: a,
    onClick: c
  } = e, u = B(e, Lg), l = cr({
    type: "line",
    seriesId: t
  }), {
    isFaded: h,
    isHighlighted: f
  } = ac({
    seriesId: t
  }), d = {
    id: t,
    classes: r,
    color: o,
    gradientId: i,
    isFaded: h,
    isHighlighted: f
  }, p = Fg(d), m = (s == null ? void 0 : s.line) ?? Ko, g = We({
    elementType: m,
    externalSlotProps: a == null ? void 0 : a.line,
    additionalProps: k({}, l, {
      onClick: c,
      cursor: c ? "pointer" : "unset"
    }),
    className: p.root,
    ownerState: d
  });
  return /* @__PURE__ */ w.jsx(m, k({}, u, g));
}
"production".NODE_ENV !== "production" && (Rc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: n.object,
  color: n.string.isRequired,
  d: n.string.isRequired,
  gradientId: n.string,
  id: n.oneOfType([n.number, n.string]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object
});
const zg = ["slots", "slotProps", "skipAnimation", "onItemClick"], Ug = Q("g", {
  name: "MuiAreaPlot",
  slot: "Root"
})({
  [`& .${qg.root}`]: {
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in"
  }
}), Hg = () => {
  const e = mr(), {
    xAxis: t,
    xAxisIds: r
  } = je(), {
    yAxis: o,
    yAxisIds: i
  } = Pe(), s = Wo();
  return A.useMemo(() => {
    if (e === void 0)
      return [];
    const {
      series: c,
      stackingGroups: u
    } = e, l = r[0], h = i[0];
    return u.flatMap(({
      ids: f
    }) => f.flatMap((d) => {
      const {
        xAxisId: p = l,
        yAxisId: m = h,
        stackedData: g,
        data: y,
        connectNulls: b,
        curve: O,
        strictStepCurve: x
      } = c[d], _ = t[p].scale, M = Xe(_), T = o[m].scale, v = t[p].data, S = o[m].colorScale && s(m) || t[p].colorScale && s(p) || void 0;
      if ("production".NODE_ENV !== "production") {
        if (v === void 0)
          throw new Error(`MUI X Charts: ${p === St ? "The first `xAxis`" : `The x-axis with id "${p}"`} should have data property to be able to display a line plot.`);
        v.length < g.length && rt(`MUI X Charts: The data length of the x axis (${v.length} items) is lower than the length of series (${g.length} items).`, "error");
      }
      const C = (O == null ? void 0 : O.includes("step")) && !x && Me(_), P = (v == null ? void 0 : v.flatMap(($, N) => {
        const E = y[N] == null;
        if (C) {
          const D = [{
            x: $,
            y: g[N],
            nullData: E,
            isExtension: !1
          }];
          return !E && (N === 0 || y[N - 1] == null) && D.unshift({
            x: (_($) ?? 0) - (_.step() - _.bandwidth()) / 2,
            y: g[N],
            nullData: E,
            isExtension: !0
          }), !E && (N === y.length - 1 || y[N + 1] == null) && D.push({
            x: (_($) ?? 0) + (_.step() + _.bandwidth()) / 2,
            y: g[N],
            nullData: E,
            isExtension: !0
          }), D;
        }
        return {
          x: $,
          y: g[N],
          nullData: E
        };
      })) ?? [], I = b ? P.filter(($) => !$.nullData) : P, R = $s().x(($) => $.isExtension ? $.x : M($.x)).defined(($) => b || !$.nullData || !!$.isExtension).y(($) => T($.y[1])).curve(Ac(O))(I) || "";
      return k({}, c[d], {
        gradientId: S,
        d: R,
        seriesId: d
      });
    }));
  }, [e, r, i, t, o, s]);
};
function jc(e) {
  const {
    slots: t,
    slotProps: r,
    skipAnimation: o,
    onItemClick: i
  } = e, s = B(e, zg), a = Bo(), c = Xo(a || o), u = Hg();
  return /* @__PURE__ */ w.jsx(Ug, k({}, s, {
    children: u.map(({
      d: l,
      seriesId: h,
      color: f,
      gradientId: d
    }) => /* @__PURE__ */ w.jsx(Rc, {
      id: h,
      d: l,
      color: f,
      gradientId: d,
      skipAnimation: c,
      slots: t,
      slotProps: r,
      onClick: i && ((p) => i(p, {
        type: "line",
        seriesId: h
      }))
    }, h))
  }));
}
"production".NODE_ENV !== "production" && (jc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line item identifier.
   */
  onItemClick: n.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object
});
function Vg(e) {
  return xe("MuiMarkElement", e);
}
const Pc = Oe("MuiMarkElement", ["root", "highlighted", "faded", "animate", "series"]), Nc = (e) => {
  const {
    classes: t,
    id: r,
    isFaded: o,
    isHighlighted: i,
    skipAnimation: s
  } = e, a = {
    root: ["root", `series-${r}`, i && "highlighted", o && "faded", s ? void 0 : "animate"]
  };
  return be(a, Vg, t);
}, Gg = ["x", "y", "id", "classes", "color", "dataIndex", "onClick", "skipAnimation", "isFaded", "isHighlighted"], Yg = Q("circle")({
  [`&.${Pc.animate}`]: {
    transitionDuration: `${ur}ms`,
    transitionProperty: "cx, cy",
    transitionTimingFunction: Uo
  }
});
function $c(e) {
  const {
    x: t,
    y: r,
    id: o,
    classes: i,
    color: s,
    dataIndex: a,
    onClick: c,
    skipAnimation: u,
    isFaded: l = !1,
    isHighlighted: h = !1
  } = e, f = B(e, Gg), d = It(), p = cr({
    type: "line",
    seriesId: o,
    dataIndex: a
  }), g = Nc({
    id: o,
    classes: i,
    isHighlighted: h,
    isFaded: l,
    color: s,
    skipAnimation: u
  });
  return /* @__PURE__ */ w.jsx(Yg, k({}, f, {
    cx: t,
    cy: r,
    r: 5,
    fill: (d.vars || d).palette.background.paper,
    stroke: s,
    strokeWidth: 2,
    className: g.root,
    onClick: c,
    cursor: c ? "pointer" : "unset"
  }, p));
}
"production".NODE_ENV !== "production" && ($c.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: n.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: n.number.isRequired,
  id: n.oneOfType([n.number, n.string]).isRequired,
  /**
   * The shape of the marker.
   */
  shape: n.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool
});
function Lc(e) {
  switch (e) {
    case "circle":
      return 0;
    case "cross":
      return 1;
    case "diamond":
      return 2;
    case "square":
      return 3;
    case "star":
      return 4;
    case "triangle":
      return 5;
    case "wye":
      return 6;
    default:
      return 0;
  }
}
const Wg = ["x", "y", "id", "classes", "color", "shape", "dataIndex", "onClick", "skipAnimation", "isFaded", "isHighlighted"], Xg = Q("path", {
  name: "MuiMarkElement",
  slot: "Root"
})(({
  ownerState: e,
  theme: t
}) => ({
  fill: (t.vars || t).palette.background.paper,
  stroke: e.color,
  strokeWidth: 2,
  [`&.${Pc.animate}`]: {
    transitionDuration: `${ur}ms`,
    transitionProperty: "transform, transform-origin",
    transitionTimingFunction: Uo
  }
}));
function Dc(e) {
  const {
    x: t,
    y: r,
    id: o,
    classes: i,
    color: s,
    shape: a,
    dataIndex: c,
    onClick: u,
    skipAnimation: l,
    isFaded: h = !1,
    isHighlighted: f = !1
  } = e, d = B(e, Wg), p = cr({
    type: "line",
    seriesId: o,
    dataIndex: c
  }), m = {
    id: o,
    classes: i,
    isHighlighted: f,
    isFaded: h,
    color: s,
    skipAnimation: l
  }, g = Nc(m);
  return /* @__PURE__ */ w.jsx(Xg, k({}, d, {
    style: {
      transform: `translate(${t}px, ${r}px)`,
      transformOrigin: `${t}px ${r}px`
    },
    ownerState: m,
    className: g.root,
    d: Us(zs[Lc(a)])(),
    onClick: u,
    cursor: u ? "pointer" : "unset"
  }, p));
}
"production".NODE_ENV !== "production" && (Dc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: n.object,
  /**
   * The index to the element in the series' data array.
   */
  dataIndex: n.number.isRequired,
  id: n.oneOfType([n.number, n.string]).isRequired,
  /**
   * If `true`, the marker is faded.
   * @default false
   */
  isFaded: n.bool,
  /**
   * If `true`, the marker is highlighted.
   * @default false
   */
  isHighlighted: n.bool,
  /**
   * The shape of the marker.
   */
  shape: n.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired,
  /**
   * If `true`, animations are skipped.
   */
  skipAnimation: n.bool
});
const Bg = ["slots", "slotProps", "skipAnimation", "onItemClick"];
function qc(e) {
  const {
    slots: t,
    slotProps: r,
    skipAnimation: o,
    onItemClick: i
  } = e, s = B(e, Bg), a = Bo(), c = Xo(a || o), u = mr(), {
    xAxis: l,
    xAxisIds: h
  } = je(), {
    yAxis: f,
    yAxisIds: d
  } = Pe(), p = dr(), {
    instance: m,
    store: g
  } = Ve(), {
    isFaded: y,
    isHighlighted: b
  } = bg(), O = V(g, Fo);
  if (u === void 0)
    return null;
  const {
    series: x,
    stackingGroups: _
  } = u, M = h[0], T = d[0];
  return /* @__PURE__ */ w.jsx("g", k({}, s, {
    children: _.flatMap(({
      ids: v
    }) => v.map((S) => {
      const {
        xAxisId: C = M,
        yAxisId: P = T,
        stackedData: I,
        data: L,
        showMark: R = !0,
        shape: $ = "circle"
      } = x[S];
      if (R === !1)
        return null;
      const N = Xe(l[C].scale), E = f[P].scale, D = l[C].data;
      if (D === void 0)
        throw new Error(`MUI X Charts: ${C === St ? "The first `xAxis`" : `The x-axis with id "${C}"`} should have data property to be able to display a line plot.`);
      const U = gc(`${p}-${S}-line-clip`), z = zo(x[S], l[C], f[P]), Z = (t == null ? void 0 : t.mark) ?? ($ === "circle" ? $c : Dc), re = b({
        seriesId: S
      }), he = !re && y({
        seriesId: S
      });
      return /* @__PURE__ */ w.jsx("g", {
        clipPath: `url(#${U})`,
        children: D == null ? void 0 : D.map((ae, te) => {
          const ee = L[te] == null ? null : I[te][1];
          return {
            x: N(ae),
            y: ee === null ? null : E(ee),
            position: ae,
            value: ee,
            index: te
          };
        }).filter(({
          x: ae,
          y: te,
          index: ee,
          position: fe,
          value: de
        }) => de === null || te === null || !m.isPointInside(ae, te) ? !1 : R === !0 ? !0 : R({
          x: ae,
          y: te,
          index: ee,
          position: fe,
          value: de
        })).map(({
          x: ae,
          y: te,
          index: ee
        }) => /* @__PURE__ */ w.jsx(Z, k({
          id: S,
          dataIndex: ee,
          shape: $,
          color: z(ee),
          x: ae,
          y: te,
          skipAnimation: c,
          onClick: i && ((fe) => i(fe, {
            type: "line",
            seriesId: S,
            dataIndex: ee
          })),
          isHighlighted: O === ee || re,
          isFaded: he
        }, r == null ? void 0 : r.mark), `${S}-${ee}`))
      }, S);
    }))
  }));
}
"production".NODE_ENV !== "production" && (qc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a line mark item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {LineItemIdentifier} lineItemIdentifier The line mark item identifier.
   */
  onItemClick: n.func,
  /**
   * If `true`, animations are skipped.
   */
  skipAnimation: n.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object
});
function gr(e) {
  return (e % 360 + 360) % 360;
}
const zr = 2 * Math.PI;
function Kg(e) {
  return (e % zr + zr) % zr;
}
function Zo() {
  const [e, t] = A.useState(typeof window < "u" || "production".NODE_ENV === "test");
  return A.useEffect(() => {
    t(!0);
  }, []), e;
}
const Fc = typeof window < "u" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function Zg(e) {
  return e.length;
}
function Qg(e) {
  const t = Fc.segment(e);
  let r = 0;
  for (const o of t)
    r += 1;
  return r;
}
const Jg = Fc ? Qg : Zg;
function ey(e) {
  return e * (Math.PI / 180);
}
const zc = typeof window < "u" && "Intl" in window && "Segmenter" in Intl ? new Intl.Segmenter(void 0, {
  granularity: "grapheme"
}) : null;
function ty(e, t) {
  return e.slice(0, t);
}
function ny(e, t) {
  const r = zc.segment(e);
  let o = "", i = 0;
  for (const s of r)
    if (o += s.segment, i += 1, i >= t)
      break;
  return o;
}
const ry = zc ? ny : ty, ps = "";
function Uc(e, t) {
  const {
    width: r,
    height: o,
    measureText: i
  } = t, s = ey(t.angle), a = i(e), c = Math.abs(a.width * Math.cos(s)) + Math.abs(a.height * Math.sin(s)), u = Math.abs(a.width * Math.sin(s)) + Math.abs(a.height * Math.cos(s));
  return c <= r && u <= o;
}
function Hc(e, t) {
  if (t(e))
    return e;
  let r = e, o = 1, i = 1 / 2;
  const s = Jg(e);
  let a = s, c = s, u = null;
  do {
    if (c = a, a = Math.floor(s * i), a === 0)
      break;
    r = ry(e, a).trim();
    const l = t(r + ps);
    o += 1, l ? (u = r, i += 1 / 2 ** o) : i -= 1 / 2 ** o;
  } while (Math.abs(a - c) !== 1);
  return u ? u + ps : "";
}
function oy() {
  return typeof window > "u";
}
const pn = /* @__PURE__ */ new Map(), iy = 2e3, sy = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
}, ay = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"], ms = "mui_measurement_span";
function Vc(e, t) {
  return ay.indexOf(e) >= 0 && t === +t ? `${t}px` : t;
}
function Gc(e) {
  return e.split("").reduce((o, i) => i === i.toUpperCase() ? [...o, "-", i.toLowerCase()] : [...o, i], []).join("");
}
const cy = (e) => Object.keys(e).sort().reduce((t, r) => `${t}${Gc(r)}:${Vc(r, e[r])};`, "");
let Ur;
const tn = (e, t = {}) => {
  if (e == null || oy())
    return {
      width: 0,
      height: 0
    };
  const r = `${e}`, o = cy(t), i = `${r}-${o}`, s = pn.get(i);
  if (s)
    return s;
  try {
    let a = document.getElementById(ms);
    a === null && (a = document.createElement("span"), a.setAttribute("id", ms), a.setAttribute("aria-hidden", "true"), document.body.appendChild(a));
    const c = k({}, sy, t);
    Object.keys(c).map((h) => (a.style[Gc(h)] = Vc(h, c[h]), h)), a.textContent = r;
    const u = a.getBoundingClientRect(), l = {
      width: u.width,
      height: u.height
    };
    return pn.set(i, l), pn.size + 1 > iy && pn.clear(), "production".NODE_ENV === "test" ? a.textContent = "" : (Ur && clearTimeout(Ur), Ur = setTimeout(() => {
      a.textContent = "";
    }, 0)), l;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
};
function Qo(e) {
  return typeof e == "number" && !Number.isFinite(e);
}
const Hr = {
  start: 0,
  extremities: 0,
  end: 1,
  middle: 0.5
};
function yr(e) {
  const {
    scale: t,
    tickNumber: r,
    valueFormatter: o,
    tickInterval: i,
    tickPlacement: s = "extremities",
    tickLabelPlacement: a,
    direction: c
  } = e, {
    instance: u
  } = Ve();
  return A.useMemo(() => {
    if (Me(t)) {
      const p = t.domain(), m = a ?? "middle";
      return t.bandwidth() > 0 ? [...(typeof i == "function" && p.filter(i) || typeof i == "object" && i || p).map((b) => ({
        value: b,
        formattedValue: (o == null ? void 0 : o(b, {
          location: "tick",
          scale: t
        })) ?? `${b}`,
        offset: t(b) - (t.step() - t.bandwidth()) / 2 + Hr[s] * t.step(),
        labelOffset: m === "tick" ? 0 : t.step() * (Hr[m] - Hr[s])
      })), ...s === "extremities" ? [{
        formattedValue: void 0,
        offset: t.range()[1],
        labelOffset: 0
      }] : []] : (typeof i == "function" && p.filter(i) || typeof i == "object" && i || p).map((y) => ({
        value: y,
        formattedValue: (o == null ? void 0 : o(y, {
          location: "tick",
          scale: t
        })) ?? `${y}`,
        offset: t(y),
        labelOffset: 0
      }));
    }
    if (t.domain().some(Qo))
      return [];
    const h = a, f = typeof i == "object" ? i : t.ticks(r), d = [];
    for (let p = 0; p < f.length; p += 1) {
      const m = f[p], g = t(m);
      (c === "x" ? u.isXInside(g) : u.isYInside(g)) && d.push({
        value: m,
        formattedValue: (o == null ? void 0 : o(m, {
          location: "tick",
          scale: t
        })) ?? t.tickFormat(r)(m),
        offset: g,
        // Allowing the label to be placed in the middle of a continuous scale is weird.
        // But it is useful in some cases, like funnel categories with a linear scale.
        labelOffset: h === "middle" ? t(f[p - 1] ?? 0) - (g + t(f[p - 1] ?? 0)) / 2 : 0
      });
    }
    return d;
  }, [t, a, i, r, s, o, c, u]);
}
function Yc(e) {
  return xe("MuiChartsAxis", e);
}
const mn = Oe("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right", "id"]), Wc = Q("g", {
  name: "MuiChartsAxis",
  slot: "Root"
})(({
  theme: e
}) => ({
  [`& .${mn.tickLabel}`]: k({}, e.typography.caption, {
    fill: (e.vars || e).palette.text.primary
  }),
  [`& .${mn.label}`]: {
    fill: (e.vars || e).palette.text.primary
  },
  [`& .${mn.line}`]: {
    stroke: (e.vars || e).palette.text.primary,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  },
  [`& .${mn.tick}`]: {
    stroke: (e.vars || e).palette.text.primary,
    shapeRendering: "crispEdges"
  }
}));
function Xc({
  style: e,
  needsComputation: t,
  text: r
}) {
  return r.split(`
`).map((o) => k({
    text: o
  }, t ? tn(o, e) : {
    width: 0,
    height: 0
  }));
}
const ly = ["x", "y", "style", "text", "ownerState"], uy = ["angle", "textAnchor", "dominantBaseline"];
function Wt(e) {
  const {
    x: t,
    y: r,
    style: o,
    text: i
  } = e, s = B(e, ly), a = o ?? {}, {
    angle: c,
    textAnchor: u,
    dominantBaseline: l
  } = a, h = B(a, uy), f = Zo(), d = A.useMemo(() => Xc({
    style: h,
    needsComputation: f && i.includes(`
`),
    text: i
  }), [h, i, f]);
  let p;
  switch (l) {
    case "hanging":
    case "text-before-edge":
      p = 0;
      break;
    case "central":
      p = (d.length - 1) / 2 * -d[0].height;
      break;
    default:
      p = (d.length - 1) * -d[0].height;
      break;
  }
  return /* @__PURE__ */ w.jsx("text", k({}, s, {
    transform: c ? `rotate(${c}, ${t}, ${r})` : void 0,
    x: t,
    y: r,
    textAnchor: u,
    dominantBaseline: l,
    style: h,
    children: d.map((m, g) => /* @__PURE__ */ w.jsx("tspan", {
      x: t,
      dy: `${g === 0 ? p : d[0].height}px`,
      dominantBaseline: l,
      children: m.text
    }, g))
  }));
}
"production".NODE_ENV !== "production" && (Wt.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Height of a text line (in `em`).
   */
  lineHeight: n.number,
  /**
   * If `true`, the line width is computed.
   * @default false
   */
  needsComputation: n.bool,
  ownerState: n.any,
  /**
   * Style applied to text elements.
   */
  style: n.object,
  /**
   * Text displayed.
   */
  text: n.string.isRequired
});
const gs = 5;
function fy(e, t, r = 0) {
  "production".NODE_ENV !== "production" && r > 90 && r < -90 && rt(["MUI X Charts: It seems you applied an angle larger than 90 or smaller than -90 to an axis text.", "This could cause some text overlapping.", "If you encounter a use case where it's needed, please open an issue."]);
  const o = Math.min(Math.abs(r) % 180, Math.abs(Math.abs(r) % 180 - 180) % 180);
  if (o < gs)
    return e;
  if (o > 90 - gs)
    return t;
  const i = zt(o), s = Math.atan2(t, e);
  return i < s ? e / Math.cos(i) : t / Math.sin(i);
}
function dy(e = !1) {
  const [t, r] = A.useState(!1);
  return Ae(() => {
    e || r(!0);
  }, [e]), A.useEffect(() => {
    e && r(!0);
  }, [e]), t;
}
function Bc(e) {
  const t = gr(e);
  return t <= 30 || t >= 330 || t <= 210 && t >= 150 ? "middle" : t <= 180 ? "end" : "start";
}
function Kc(e) {
  const t = gr(e);
  return t <= 30 || t >= 330 ? "hanging" : t <= 210 && t >= 150 ? "auto" : "central";
}
function Zc(e) {
  switch (e) {
    case "start":
      return "end";
    case "end":
      return "start";
    default:
      return e;
  }
}
const hy = ["scale", "tickNumber", "reverse"], py = (e) => {
  const {
    classes: t,
    position: r,
    id: o
  } = e, i = {
    root: ["root", "directionX", r, `id-${o}`],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return be(i, Yc, t);
}, ys = 3, my = 4;
function gy(e, {
  tickLabelStyle: t,
  tickLabelInterval: r,
  tickLabelMinGap: o,
  reverse: i,
  isMounted: s,
  isXInside: a
}) {
  const c = (h) => {
    if (!s || h.formattedValue === void 0)
      return {
        width: 0,
        height: 0
      };
    const f = Xc({
      style: t,
      needsComputation: !0,
      text: h.formattedValue
    });
    return {
      width: Math.max(...f.map((d) => d.width)),
      height: Math.max(f.length * f[0].height)
    };
  };
  if (typeof r == "function")
    return new Set(e.filter((h, f) => r(h.value, f)));
  let u = 0;
  const l = i ? -1 : 1;
  return new Set(e.filter((h, f) => {
    const {
      offset: d,
      labelOffset: p
    } = h, m = d + p;
    if (f > 0 && l * m < l * (u + o) || !a(m))
      return !1;
    const {
      width: g,
      height: y
    } = c(h), b = fy(g, y, t == null ? void 0 : t.angle), O = m - l * b / 2;
    return f > 0 && l * O < l * (u + o) ? !1 : (u = m + l * b / 2, !0);
  }));
}
function yy(e, t, r, o, i) {
  const s = /* @__PURE__ */ new Map(), a = gr((i == null ? void 0 : i.angle) ?? 0);
  let c = 1, u = 1;
  (i == null ? void 0 : i.textAnchor) === "start" ? (c = 1 / 0, u = 1) : (i == null ? void 0 : i.textAnchor) === "end" ? (c = 1, u = 1 / 0) : (c = 2, u = 2), a > 90 && a < 270 && ([c, u] = [u, c]), o && ([c, u] = [u, c]);
  for (const l of e)
    if (l.formattedValue) {
      const h = Math.min((l.offset + l.labelOffset) * c, (t.left + t.width + t.right - l.offset - l.labelOffset) * u), f = (d) => Uc(d, {
        width: h,
        height: r,
        angle: a,
        measureText: (p) => tn(p, i)
      });
      s.set(l, Hc(l.formattedValue.toString(), f));
    }
  return s;
}
const by = Q(Wc, {
  name: "MuiChartsXAxis",
  slot: "Root"
})({}), xy = {
  disableLine: !1,
  disableTicks: !1,
  tickSize: 6,
  tickLabelMinGap: 4
};
function Qc(e) {
  const {
    xAxis: t,
    xAxisIds: r
  } = je(), o = t[e.axisId ?? r[0]], {
    scale: i,
    tickNumber: s,
    reverse: a
  } = o, c = B(o, hy), u = dy(), l = ze({
    props: k({}, c, e),
    name: "MuiChartsXAxis"
  }), h = k({}, xy, l), {
    position: f,
    disableLine: d,
    disableTicks: p,
    tickLabelStyle: m,
    label: g,
    labelStyle: y,
    tickSize: b,
    valueFormatter: O,
    slots: x,
    slotProps: _,
    tickInterval: M,
    tickLabelInterval: T,
    tickPlacement: v,
    tickLabelPlacement: S,
    tickLabelMinGap: C,
    sx: P,
    offset: I,
    height: L
  } = h, R = It(), $ = As(), N = py(h), E = Re(), {
    left: D,
    top: U,
    width: z,
    height: Z
  } = E, {
    instance: re
  } = Ve(), he = Zo(), ae = p ? 4 : b, te = f === "bottom" ? 1 : -1, ee = (x == null ? void 0 : x.axisLine) ?? "line", fe = (x == null ? void 0 : x.axisTick) ?? "line", de = (x == null ? void 0 : x.axisTickLabel) ?? Wt, Ce = (x == null ? void 0 : x.axisLabel) ?? Wt, q = Bc((f === "bottom" ? 0 : 180) - ((m == null ? void 0 : m.angle) ?? 0)), H = Kc((f === "bottom" ? 0 : 180) - ((m == null ? void 0 : m.angle) ?? 0)), G = We({
    elementType: de,
    externalSlotProps: _ == null ? void 0 : _.axisTickLabel,
    additionalProps: {
      style: k({}, R.typography.caption, {
        fontSize: 12,
        lineHeight: 1.25,
        textAnchor: $ ? Zc(q) : q,
        dominantBaseline: H
      }, m)
    },
    className: N.tickLabel,
    ownerState: {}
  }), j = yr({
    scale: i,
    tickNumber: s,
    valueFormatter: O,
    tickInterval: M,
    tickPlacement: v,
    tickLabelPlacement: S,
    direction: "x"
  }), J = gy(j, {
    tickLabelStyle: G.style,
    tickLabelInterval: T,
    tickLabelMinGap: C,
    reverse: a,
    isMounted: u,
    isXInside: re.isXInside
  }), W = We({
    elementType: Ce,
    externalSlotProps: _ == null ? void 0 : _.axisLabel,
    additionalProps: {
      style: k({}, R.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        textAnchor: "middle",
        dominantBaseline: f === "bottom" ? "text-after-edge" : "text-before-edge"
      }, y)
    },
    ownerState: {}
  }), oe = i.domain(), ie = Me(i);
  if (ie && oe.length === 0 || !ie && oe.some(Qo) || f === "none")
    return null;
  const Te = g ? tn(g, W.style).height : 0, Ie = {
    x: D + z / 2,
    y: te * L
  }, rn = Math.max(0, L - (g ? Te + my : 0) - ae - ys), on = he ? yy(J, E, rn, $, G.style) : new Map(Array.from(J).map((Ge) => [Ge, Ge.formattedValue]));
  return /* @__PURE__ */ w.jsxs(by, {
    transform: `translate(0, ${f === "bottom" ? U + Z + I : U - I})`,
    className: N.root,
    sx: P,
    children: [!d && /* @__PURE__ */ w.jsx(ee, k({
      x1: D,
      x2: D + z,
      className: N.line
    }, _ == null ? void 0 : _.axisLine)), j.map((Ge, Or) => {
      const {
        offset: sn,
        labelOffset: Tr
      } = Ge, kr = Tr ?? 0, _r = te * (ae + ys), an = re.isXInside(sn), oi = on.get(Ge), xl = J.has(Ge);
      return /* @__PURE__ */ w.jsxs("g", {
        transform: `translate(${sn}, 0)`,
        className: N.tickContainer,
        children: [!p && an && /* @__PURE__ */ w.jsx(fe, k({
          y2: te * ae,
          className: N.tick
        }, _ == null ? void 0 : _.axisTick)), oi !== void 0 && xl && /* @__PURE__ */ w.jsx(de, k({
          x: kr,
          y: _r
        }, G, {
          text: oi
        }))]
      }, Or);
    }), g && /* @__PURE__ */ w.jsx("g", {
      className: N.label,
      children: /* @__PURE__ */ w.jsx(Ce, k({}, Ie, W, {
        text: g
      }))
    })]
  });
}
"production".NODE_ENV !== "production" && (Qc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: n.oneOf(["x"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: n.oneOfType([n.number, n.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: n.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: n.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: n.string,
  /**
   * The label of the axis.
   */
  label: n.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: n.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: n.string,
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
  /**
   * The minimum gap in pixels between two tick labels.
   * If two tick labels are closer than this minimum gap, one of them will be hidden.
   * @default 4
   */
  tickLabelMinGap: n.number,
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: n.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: n.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: n.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: n.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: n.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: n.number
});
const Oy = ["scale", "tickNumber"], Ty = (e) => {
  const {
    classes: t,
    position: r,
    id: o
  } = e, i = {
    root: ["root", "directionY", r, `id-${o}`],
    line: ["line"],
    tickContainer: ["tickContainer"],
    tick: ["tick"],
    tickLabel: ["tickLabel"],
    label: ["label"]
  };
  return be(i, Yc, t);
}, bs = 2, ky = 2;
function _y(e, t, r, o, i) {
  const s = /* @__PURE__ */ new Map(), a = gr((i == null ? void 0 : i.angle) ?? 0);
  let c = 1, u = 1;
  (i == null ? void 0 : i.textAnchor) === "start" ? (c = 1 / 0, u = 1) : (i == null ? void 0 : i.textAnchor) === "end" ? (c = 1, u = 1 / 0) : (c = 2, u = 2), a > 180 && ([c, u] = [u, c]), o && ([c, u] = [u, c]);
  for (const l of e)
    if (l.formattedValue) {
      const h = Math.min((l.offset + l.labelOffset) * c, (t.top + t.height + t.bottom - l.offset - l.labelOffset) * u), f = (d) => Uc(d, {
        width: r,
        height: h,
        angle: a,
        measureText: (p) => tn(p, i)
      });
      s.set(l, Hc(l.formattedValue.toString(), f));
    }
  return s;
}
const wy = Q(Wc, {
  name: "MuiChartsYAxis",
  slot: "Root"
})({}), vy = {
  disableLine: !1,
  disableTicks: !1,
  tickSize: 6
};
function Jc(e) {
  const {
    yAxisIds: t,
    yAxis: r
  } = Pe(), o = r[e.axisId ?? t[0]], {
    scale: i,
    tickNumber: s
  } = o, a = B(o, Oy), c = ze({
    props: k({}, a, e),
    name: "MuiChartsYAxis"
  }), u = k({}, vy, c), {
    position: l,
    disableLine: h,
    disableTicks: f,
    label: d,
    labelStyle: p,
    tickLabelStyle: m,
    tickSize: g,
    valueFormatter: y,
    slots: b,
    slotProps: O,
    tickPlacement: x,
    tickLabelPlacement: _,
    tickInterval: M,
    tickLabelInterval: T,
    sx: v,
    offset: S,
    width: C
  } = u, P = It(), I = As(), L = Zo(), R = Ty(u), {
    instance: $
  } = Ve(), N = Re(), {
    left: E,
    top: D,
    width: U,
    height: z
  } = N, Z = f ? 4 : g, re = yr({
    scale: i,
    tickNumber: s,
    valueFormatter: y,
    tickPlacement: x,
    tickLabelPlacement: _,
    tickInterval: M,
    direction: "y"
  }), he = l === "right" ? 1 : -1, ae = typeof (m == null ? void 0 : m.fontSize) == "number" ? m.fontSize : 12, te = (b == null ? void 0 : b.axisLine) ?? "line", ee = (b == null ? void 0 : b.axisTick) ?? "line", fe = (b == null ? void 0 : b.axisTickLabel) ?? Wt, de = (b == null ? void 0 : b.axisLabel) ?? Wt, Ce = Bc((l === "right" ? -90 : 90) - ((m == null ? void 0 : m.angle) ?? 0)), q = Kc((l === "right" ? -90 : 90) - ((m == null ? void 0 : m.angle) ?? 0)), H = We({
    elementType: fe,
    externalSlotProps: O == null ? void 0 : O.axisTickLabel,
    additionalProps: {
      style: k({}, P.typography.caption, {
        fontSize: ae,
        textAnchor: I ? Zc(Ce) : Ce,
        dominantBaseline: q
      }, m)
    },
    className: R.tickLabel,
    ownerState: {}
  }), G = We({
    elementType: de,
    externalSlotProps: O == null ? void 0 : O.axisLabel,
    additionalProps: {
      style: k({}, P.typography.body1, {
        lineHeight: 1,
        fontSize: 14,
        angle: he * 90,
        textAnchor: "middle",
        dominantBaseline: "text-before-edge"
      }, p)
    },
    ownerState: {}
  }), j = We({
    elementType: te,
    externalSlotProps: O == null ? void 0 : O.axisLine,
    additionalProps: {
      strokeLinecap: "square"
    },
    ownerState: {}
  }), J = i.domain(), W = Me(i);
  if (W && J.length === 0 || !W && J.some(Qo) || l === "none")
    return null;
  const oe = {
    x: he * C,
    y: D + z / 2
  }, ie = Math.max(0, C - (d ? tn(d, G.style).height + ky : 0) - Z - bs), Te = L ? _y(re, N, ie, I, H.style) : new Map(Array.from(re).map((Ie) => [Ie, Ie.formattedValue]));
  return /* @__PURE__ */ w.jsxs(wy, {
    transform: `translate(${l === "right" ? E + U + S : E - S}, 0)`,
    className: R.root,
    sx: v,
    children: [!h && /* @__PURE__ */ w.jsx(te, k({
      y1: D,
      y2: D + z,
      className: R.line
    }, j)), re.map((Ie, rn) => {
      const {
        offset: on,
        labelOffset: Ge,
        value: Or
      } = Ie, sn = he * (Z + bs), Tr = Ge, kr = typeof T == "function" && !(T != null && T(Or, rn)), _r = $.isYInside(on), an = Te.get(Ie);
      return _r ? /* @__PURE__ */ w.jsxs("g", {
        transform: `translate(0, ${on})`,
        className: R.tickContainer,
        children: [!f && /* @__PURE__ */ w.jsx(ee, k({
          x2: he * Z,
          className: R.tick
        }, O == null ? void 0 : O.axisTick)), an !== void 0 && !kr && /* @__PURE__ */ w.jsx(fe, k({
          x: sn,
          y: Tr,
          text: an
        }, H))]
      }, rn) : null;
    }), d && L && /* @__PURE__ */ w.jsx("g", {
      className: R.label,
      children: /* @__PURE__ */ w.jsx(de, k({}, oe, G, {
        text: d
      }))
    })]
  });
}
"production".NODE_ENV !== "production" && (Jc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  axis: n.oneOf(["y"]),
  /**
   * The id of the axis to render.
   * If undefined, it will be the first defined axis.
   */
  axisId: n.oneOfType([n.number, n.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  /**
   * If true, the axis line is disabled.
   * @default false
   */
  disableLine: n.bool,
  /**
   * If true, the ticks are disabled.
   * @default false
   */
  disableTicks: n.bool,
  /**
   * The fill color of the axis text.
   * @default 'currentColor'
   */
  fill: n.string,
  /**
   * The label of the axis.
   */
  label: n.string,
  /**
   * The style applied to the axis label.
   */
  labelStyle: n.object,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object,
  /**
   * The stroke color of the axis line.
   * @default 'currentColor'
   */
  stroke: n.string,
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
  /**
   * Defines which ticks are displayed.
   * Its value can be:
   * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
   * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
   * - an array containing the values where ticks should be displayed.
   * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
   * @default 'auto'
   */
  tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
  /**
   * Defines which ticks get its label displayed. Its value can be:
   * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
   * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
   * @default 'auto'
   */
  tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
  /**
   * The placement of ticks label. Can be the middle of the band, or the tick position.
   * Only used if scale is 'band'.
   * @default 'middle'
   */
  tickLabelPlacement: n.oneOf(["middle", "tick"]),
  /**
   * The style applied to ticks text.
   */
  tickLabelStyle: n.object,
  /**
   * Maximal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMaxStep: n.number,
  /**
   * Minimal step between two ticks.
   * When using time data, the value is assumed to be in ms.
   * Not supported by categorical axis (band, points).
   */
  tickMinStep: n.number,
  /**
   * The number of ticks. This number is not guaranteed.
   * Not supported by categorical axis (band, points).
   */
  tickNumber: n.number,
  /**
   * The placement of ticks in regard to the band interval.
   * Only used if scale is 'band'.
   * @default 'extremities'
   */
  tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
  /**
   * The size of the ticks.
   * @default 6
   */
  tickSize: n.number
});
function el(e) {
  const {
    slots: t,
    slotProps: r
  } = e, {
    xAxisIds: o,
    xAxis: i
  } = je(), {
    yAxisIds: s,
    yAxis: a
  } = Pe();
  return /* @__PURE__ */ w.jsxs(A.Fragment, {
    children: [o.map((c) => !i[c].position || i[c].position === "none" ? null : /* @__PURE__ */ w.jsx(Qc, {
      slots: t,
      slotProps: r,
      axisId: c
    }, c)), s.map((c) => !a[c].position || a[c].position === "none" ? null : /* @__PURE__ */ w.jsx(Jc, {
      slots: t,
      slotProps: r,
      axisId: c
    }, c))]
  });
}
"production".NODE_ENV !== "production" && (el.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object
});
function tl(e, t, r, o, i) {
  if ("production".NODE_ENV === "production")
    return null;
  const s = e[t], a = i || t;
  return s == null ? null : s && s.nodeType !== 1 ? new Error(`Invalid ${o} \`${a}\` supplied to \`${r}\`. Expected an HTMLElement.`) : null;
}
function My(e) {
  return xe("MuiChartsTooltip", e);
}
const pt = Oe("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markContainer", "labelCell", "valueCell", "axisValueCell"]), br = (e) => be({
  root: ["root"],
  paper: ["paper"],
  table: ["table"],
  row: ["row"],
  cell: ["cell"],
  mark: ["mark"],
  markContainer: ["markContainer"],
  labelCell: ["labelCell"],
  valueCell: ["valueCell"],
  axisValueCell: ["axisValueCell"]
}, My, e);
function Cy() {
  var T, v, S;
  const e = K(), t = V(e, Xa), r = V(e, He), o = pr(), {
    xAxis: i,
    xAxisIds: s
  } = je(), {
    yAxis: a,
    yAxisIds: c
  } = Pe(), {
    zAxis: u,
    zAxisIds: l
  } = Go(), {
    rotationAxis: h,
    rotationAxisIds: f
  } = kc(), {
    radiusAxis: d,
    radiusAxisIds: p
  } = dg(), m = o.xAxisId ?? s[0], g = o.yAxisId ?? c[0], y = o.zAxisId ?? l[0], b = o.rotationAxisId ?? f[0], O = o.radiusAxisId ?? p[0];
  if (!t)
    return null;
  const x = (T = o[t.type]) == null ? void 0 : T.series[t.seriesId];
  if (!x)
    return null;
  const _ = ((S = (v = r[x.type]).colorProcessor) == null ? void 0 : S.call(v, x, m && i[m], g && a[g], y && u[y])) ?? (() => ""), M = {};
  return m !== void 0 && (M.x = i[m]), g !== void 0 && (M.y = a[g]), b !== void 0 && (M.rotation = h[b]), O !== void 0 && (M.radius = d[O]), r[x.type].tooltipGetter({
    series: x,
    axesConfig: M,
    getColor: _,
    identifier: t
  });
}
const ao = Q("div", {
  name: "MuiChartsTooltip",
  slot: "Container",
  overridesResolver: (e, t) => t.paper
  // FIXME: Inconsistent naming with slot
})(({
  theme: e
}) => {
  var t;
  return {
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    borderRadius: (t = (e.vars || e).shape) == null ? void 0 : t.borderRadius,
    border: `solid ${(e.vars || e).palette.divider} 1px`
  };
}), co = Q("table", {
  name: "MuiChartsTooltip",
  slot: "Table"
})(({
  theme: e
}) => ({
  borderSpacing: 0,
  [`& .${pt.markContainer}`]: {
    display: "inline-block",
    width: `calc(20px + ${e.spacing(1.5)})`,
    verticalAlign: "middle"
  },
  "& caption": {
    borderBottom: `solid ${(e.vars || e).palette.divider} 1px`,
    padding: e.spacing(0.5, 1.5),
    textAlign: "start",
    whiteSpace: "nowrap",
    "& span": {
      marginRight: e.spacing(1.5)
    }
  }
})), lo = Q("tr", {
  name: "MuiChartsTooltip",
  slot: "Row"
})(({
  theme: e
}) => ({
  "tr:first-of-type& td": {
    paddingTop: e.spacing(0.5)
  },
  "tr:last-of-type& td": {
    paddingBottom: e.spacing(0.5)
  }
})), mt = Q(fo, {
  name: "MuiChartsTooltip",
  slot: "Cell"
})(({
  theme: e
}) => ({
  verticalAlign: "middle",
  color: (e.vars || e).palette.text.secondary,
  textAlign: "start",
  [`&.${pt.cell}`]: {
    paddingLeft: e.spacing(1),
    paddingRight: e.spacing(1)
  },
  [`&.${pt.labelCell}`]: {
    fontWeight: e.typography.fontWeightRegular
  },
  [`&.${pt.valueCell}, &.${pt.axisValueCell}`]: {
    color: (e.vars || e).palette.text.primary,
    fontWeight: e.typography.fontWeightMedium
  },
  [`&.${pt.valueCell}`]: {
    paddingLeft: e.spacing(1.5),
    paddingRight: e.spacing(1.5)
  },
  "td:first-of-type&, th:first-of-type&": {
    paddingLeft: e.spacing(1.5)
  },
  "td:last-of-type&, th:last-of-type&": {
    paddingRight: e.spacing(1.5)
  }
}));
function Iy(e) {
  return xe("MuiChartsLabelMark", e);
}
const ft = Oe("MuiChartsLabelMark", ["root", "line", "square", "circle", "mask", "fill"]), Sy = (e) => {
  const {
    type: t
  } = e;
  return be({
    root: typeof t == "function" ? ["root"] : ["root", t],
    mask: ["mask"],
    fill: ["fill"]
  }, Iy, e.classes);
};
function Jo(e, t) {
  const r = {
    ...t
  };
  for (const o in e)
    if (Object.prototype.hasOwnProperty.call(e, o)) {
      const i = o;
      if (i === "components" || i === "slots")
        r[i] = {
          ...e[i],
          ...r[i]
        };
      else if (i === "componentsProps" || i === "slotProps") {
        const s = e[i], a = t[i];
        if (!a)
          r[i] = s || {};
        else if (!s)
          r[i] = a;
        else {
          r[i] = {
            ...a
          };
          for (const c in s)
            if (Object.prototype.hasOwnProperty.call(s, c)) {
              const u = c;
              r[i][u] = Jo(s[u], a[u]);
            }
        }
      } else
        r[i] === void 0 && (r[i] = e[i]);
    }
  return r;
}
const ei = (e, t, r) => /* @__PURE__ */ A.forwardRef(function(i, s) {
  var d;
  const a = ze({
    props: i,
    // eslint-disable-next-line material-ui/mui-name-matches-component-name
    name: e
  }), c = typeof t.defaultProps == "function" ? t.defaultProps(a) : t.defaultProps ?? {}, u = Jo(c, a), l = It(), h = (d = t.classesResolver) == null ? void 0 : d.call(t, u, l), f = /* @__PURE__ */ A.forwardRef(r);
  return "production".NODE_ENV !== "production" && (f.displayName = "OutComponent"), "production".NODE_ENV !== "production" && (f.displayName = `consumeThemeProps(${e})`), /* @__PURE__ */ w.jsx(f, k({}, u, {
    classes: h,
    ref: s
  }));
});
"production".NODE_ENV !== "production" && (ei.displayName = "consumeThemeProps");
const Ay = ["type", "color", "className", "classes"], Ey = Q("div", {
  name: "MuiChartsLabelMark",
  slot: "Root"
})(() => ({
  display: "flex",
  width: 14,
  height: 14,
  [`&.${ft.line}`]: {
    width: 16,
    height: "unset",
    alignItems: "center",
    [`.${ft.mask}`]: {
      height: 4,
      width: "100%",
      borderRadius: 1,
      overflow: "hidden"
    }
  },
  [`&.${ft.square}`]: {
    height: 13,
    width: 13,
    borderRadius: 2,
    overflow: "hidden"
  },
  [`&.${ft.circle}`]: {
    height: 15,
    width: 15
  },
  svg: {
    display: "block"
  },
  [`& .${ft.mask} > *`]: {
    height: "100%",
    width: "100%"
  },
  [`& .${ft.mask}`]: {
    height: "100%",
    width: "100%"
  }
})), Xt = ei("MuiChartsLabelMark", {
  defaultProps: {
    type: "square"
  },
  classesResolver: Sy
}, function(t, r) {
  const {
    type: o,
    color: i,
    className: s,
    classes: a
  } = t, c = B(t, Ay), u = o;
  return /* @__PURE__ */ w.jsx(Ey, k({
    className: _e(a == null ? void 0 : a.root, s),
    ownerState: t,
    "aria-hidden": "true",
    ref: r
  }, c, {
    children: /* @__PURE__ */ w.jsx("div", {
      className: a == null ? void 0 : a.mask,
      children: typeof u == "function" ? /* @__PURE__ */ w.jsx(u, {
        className: a == null ? void 0 : a.fill,
        color: i
      }) : /* @__PURE__ */ w.jsx("svg", {
        viewBox: "0 0 24 24",
        preserveAspectRatio: o === "line" ? "none" : void 0,
        children: o === "circle" ? /* @__PURE__ */ w.jsx("circle", {
          className: a == null ? void 0 : a.fill,
          r: "12",
          cx: "12",
          cy: "12",
          fill: i
        }) : /* @__PURE__ */ w.jsx("rect", {
          className: a == null ? void 0 : a.fill,
          width: "24",
          height: "24",
          fill: i
        })
      })
    })
  }));
});
"production".NODE_ENV !== "production" && (Xt.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  /**
   * The color of the mark.
   */
  color: n.string,
  /**
   * The type of the mark.
   * @default 'square'
   */
  type: n.oneOf(["circle", "line", "square"])
});
function nl(e) {
  const {
    classes: t,
    sx: r
  } = e, o = Cy(), i = br(t);
  if (!o)
    return null;
  if ("values" in o) {
    const {
      label: l,
      color: h,
      markType: f
    } = o;
    return /* @__PURE__ */ w.jsx(ao, {
      sx: r,
      className: i.paper,
      children: /* @__PURE__ */ w.jsxs(co, {
        className: i.table,
        children: [/* @__PURE__ */ w.jsxs(fo, {
          component: "caption",
          children: [/* @__PURE__ */ w.jsx("div", {
            className: i.markContainer,
            children: /* @__PURE__ */ w.jsx(Xt, {
              type: f,
              color: h,
              className: i.mark
            })
          }), l]
        }), /* @__PURE__ */ w.jsx("tbody", {
          children: o.values.map(({
            formattedValue: d,
            label: p
          }) => /* @__PURE__ */ w.jsxs(lo, {
            className: i.row,
            children: [/* @__PURE__ */ w.jsx(mt, {
              className: _e(i.labelCell, i.cell),
              component: "th",
              children: p
            }), /* @__PURE__ */ w.jsx(mt, {
              className: _e(i.valueCell, i.cell),
              component: "td",
              children: d
            })]
          }, p))
        })]
      })
    });
  }
  const {
    color: s,
    label: a,
    formattedValue: c,
    markType: u
  } = o;
  return /* @__PURE__ */ w.jsx(ao, {
    sx: r,
    className: i.paper,
    children: /* @__PURE__ */ w.jsx(co, {
      className: i.table,
      children: /* @__PURE__ */ w.jsx("tbody", {
        children: /* @__PURE__ */ w.jsxs(lo, {
          className: i.row,
          children: [/* @__PURE__ */ w.jsxs(mt, {
            className: _e(i.labelCell, i.cell),
            component: "th",
            children: [/* @__PURE__ */ w.jsx("div", {
              className: i.markContainer,
              children: /* @__PURE__ */ w.jsx(Xt, {
                type: u,
                color: s,
                className: i.mark
              })
            }), a]
          }), /* @__PURE__ */ w.jsx(mt, {
            className: _e(i.valueCell, i.cell),
            component: "td",
            children: c
          })]
        })
      })
    })
  });
}
"production".NODE_ENV !== "production" && (nl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object])
});
function Ry(e) {
  const t = K(), r = V(t, He), o = A.useMemo(() => {
    const i = {};
    return Object.keys(r).forEach((s) => {
      i[s] = r[s].colorProcessor;
    }), i;
  }, [r]);
  return e ? o[e] : o;
}
function jy() {
  const e = Yo(), [t, r] = A.useState(null);
  return A.useEffect(() => {
    const o = e.current;
    if (o === null)
      return () => {
      };
    const i = (a) => {
      a.pointerType !== "mouse" && r(null);
    }, s = (a) => {
      r({
        pointerType: a.pointerType
      });
    };
    return o.addEventListener("pointerenter", s), o.addEventListener("pointerup", i), () => {
      o.removeEventListener("pointerenter", s), o.removeEventListener("pointerup", i);
    };
  }, [e]), t;
}
function Py(e) {
  return e instanceof Date ? e.toUTCString() : e.toLocaleString();
}
const Ny = "@media (pointer: fine)", $y = () => vl(Ny, {
  defaultMatches: !0
});
function xs(e, t) {
  const {
    scale: r,
    data: o,
    reverse: i
  } = e;
  if (!Me(r))
    throw new Error("MUI X Charts: getAxisValue is not implemented for polare continuous axes.");
  if (!o)
    return -1;
  const s = Kg(t - Math.min(...r.range())), a = r.bandwidth() === 0 ? Math.floor((s + r.step() / 2) / r.step()) % o.length : Math.floor(s / r.step());
  return a < 0 || a >= o.length ? -1 : i ? o.length - 1 - a : a;
}
const Ly = (e, t) => t;
function Dy(e, t, r) {
  return Array.isArray(r) ? r.map((o) => xs(t.axis[o], e)) : xs(t.axis[r], e);
}
const qy = F([ir, sr, ug], (e, t, r) => e === null || t === null ? null : fg(r)(e, t)), Fy = F([qy, hr, Ly], (e, t, r = t.axisIds) => e === null ? null : Dy(e, t, r)), rl = F([Fy, hr], (e, t) => e === null ? [] : t.axisIds.map((r, o) => ({
  axisId: r,
  dataIndex: e[o]
})).filter(({
  axisId: r,
  dataIndex: o
}) => t.axis[r].triggerTooltip && o >= 0), {
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: bt
  }
}), zy = F([rl], (e) => e.length > 0);
function Vr(e, t, r) {
  var a;
  const o = ((a = e.data) == null ? void 0 : a[t]) ?? null, s = (e.valueFormatter ?? ((c) => e.scaleType === "utc" ? Py(c) : c.toLocaleString()))(o, {
    location: "tooltip",
    scale: e.scale
  });
  return {
    axisDirection: r,
    axisId: e.id,
    mainAxis: e,
    dataIndex: t,
    axisValue: o,
    axisFormattedValue: s,
    seriesItems: []
  };
}
function Uy(e = {}) {
  const {
    multipleAxes: t,
    directions: r
  } = e, o = Oc(), i = Tc(), s = hg(), a = K(), c = V(a, Qa), u = V(a, Ja), l = V(a, rl), h = pr(), {
    xAxis: f
  } = je(), {
    yAxis: d
  } = Pe(), {
    zAxis: p,
    zAxisIds: m
  } = Go(), {
    rotationAxis: g
  } = kc(), y = Ry();
  if (c.length === 0 && u.length === 0 && l.length === 0)
    return null;
  const b = [];
  return (r === void 0 || r.includes("x")) && c.forEach(({
    axisId: O,
    dataIndex: x
  }) => {
    !t && b.length > 1 || b.push(Vr(f[O], x, "x"));
  }), (r === void 0 || r.includes("y")) && u.forEach(({
    axisId: O,
    dataIndex: x
  }) => {
    !t && b.length > 1 || b.push(Vr(d[O], x, "y"));
  }), (r === void 0 || r.includes("rotation")) && l.forEach(({
    axisId: O,
    dataIndex: x
  }) => {
    !t && b.length > 1 || b.push(Vr(g[O], x, "rotation"));
  }), Object.keys(h).filter(Do).forEach((O) => {
    const x = h[O];
    return x ? x.seriesOrder.forEach((_) => {
      var C;
      const M = x.series[_], T = M.xAxisId ?? o.id, v = M.yAxisId ?? i.id, S = b.findIndex(({
        axisDirection: P,
        axisId: I
      }) => P === "x" && I === T || P === "y" && I === v);
      if (S >= 0) {
        const P = "zAxisId" in M ? M.zAxisId : m[0], {
          dataIndex: I
        } = b[S], L = ((C = y[O]) == null ? void 0 : C.call(y, M, f[T], d[v], P ? p[P] : void 0)(I)) ?? "", R = M.data[I] ?? null, $ = M.valueFormatter(R, {
          dataIndex: I
        }), N = we(M.label, "tooltip") ?? null;
        b[S].seriesItems.push({
          seriesId: _,
          color: L,
          value: R,
          formattedValue: $,
          formattedLabel: N,
          markType: M.labelMarkType
        });
      }
    }) : [];
  }), Object.keys(h).filter(Vo).forEach((O) => {
    const x = h[O];
    return x ? x.seriesOrder.forEach((_) => {
      var S;
      const M = x.series[_], T = (
        // @ts-expect-error Should be fixed when we introduce a polar series with a rotationAxisId
        M.rotationAxisId ?? (s == null ? void 0 : s.id)
      ), v = b.findIndex(({
        axisDirection: C,
        axisId: P
      }) => C === "rotation" && P === T);
      if (v >= 0) {
        const {
          dataIndex: C
        } = b[v], P = ((S = y[O]) == null ? void 0 : S.call(y, M)(C)) ?? "", I = M.data[C] ?? null, L = M.valueFormatter(I, {
          dataIndex: C
        }), R = we(M.label, "tooltip") ?? null;
        b[v].seriesItems.push({
          seriesId: _,
          color: P,
          value: I,
          formattedValue: L,
          formattedLabel: R,
          markType: M.labelMarkType
        });
      }
    }) : [];
  }), t ? b : b.length === 0 ? b[0] : null;
}
function Hy(e) {
  return Uy(k({}, e, {
    multipleAxes: !0
  }));
}
function ol(e) {
  const t = br(e.classes), r = Hy();
  return r === null ? null : /* @__PURE__ */ w.jsx(ao, {
    sx: e.sx,
    className: t.paper,
    children: r.map(({
      axisId: o,
      mainAxis: i,
      axisValue: s,
      axisFormattedValue: a,
      seriesItems: c
    }) => /* @__PURE__ */ w.jsxs(co, {
      className: t.table,
      children: [s != null && !i.hideTooltip && /* @__PURE__ */ w.jsx(fo, {
        component: "caption",
        children: a
      }), /* @__PURE__ */ w.jsx("tbody", {
        children: c.map(({
          seriesId: u,
          color: l,
          formattedValue: h,
          formattedLabel: f,
          markType: d
        }) => h == null ? null : /* @__PURE__ */ w.jsxs(lo, {
          className: t.row,
          children: [/* @__PURE__ */ w.jsxs(mt, {
            className: _e(t.labelCell, t.cell),
            component: "th",
            children: [/* @__PURE__ */ w.jsx("div", {
              className: t.markContainer,
              children: /* @__PURE__ */ w.jsx(Xt, {
                type: d,
                color: l,
                className: t.mark
              })
            }), f || null]
          }), /* @__PURE__ */ w.jsx(mt, {
            className: _e(t.valueCell, t.cell),
            component: "td",
            children: h
          })]
        }, u))
      })]
    }, o))
  });
}
"production".NODE_ENV !== "production" && (ol.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object])
});
const Os = {};
function Vy(e, t) {
  const r = A.useRef(Os);
  return r.current === Os && (r.current = e(t)), r;
}
function Gy() {
  const e = K(), t = V(e, xc), r = V(e, At);
  return t !== void 0 ? "polar" : r !== void 0 ? "cartesian" : "none";
}
const Yy = ["trigger", "classes", "children"], Wy = () => !1, Xy = Q(Tl, {
  name: "MuiChartsTooltip",
  slot: "Root"
})(({
  theme: e
}) => ({
  pointerEvents: "none",
  zIndex: e.zIndex.modal
}));
function il(e) {
  const t = ze({
    props: e,
    name: "MuiChartsTooltipContainer"
  }), {
    trigger: r = "axis",
    classes: o,
    children: i
  } = t, s = B(t, Yy), a = br(o), c = Yo(), u = jy(), l = $y(), h = A.useRef(null), f = Vy(() => ({
    x: 0,
    y: 0
  })), d = Gy(), p = K(), m = V(p, r === "axis" ? d === "polar" && zy || d === "cartesian" && kp || Wy : bp);
  A.useEffect(() => {
    const x = c.current;
    if (x === null)
      return () => {
      };
    const _ = (M) => {
      var T;
      f.current = {
        x: M.clientX,
        y: M.clientY
      }, (T = h.current) == null || T.update();
    };
    return x.addEventListener("pointerdown", _), x.addEventListener("pointermove", _), () => {
      x.removeEventListener("pointerdown", _), x.removeEventListener("pointermove", _);
    };
  }, [c, f]);
  const g = A.useMemo(() => ({
    getBoundingClientRect: () => ({
      x: f.current.x,
      y: f.current.y,
      top: f.current.y,
      left: f.current.x,
      right: f.current.x,
      bottom: f.current.y,
      width: 0,
      height: 0,
      toJSON: () => ""
    })
  }), [f]), y = (u == null ? void 0 : u.pointerType) === "mouse" || l, b = (u == null ? void 0 : u.pointerType) === "touch" || !l, O = A.useMemo(() => [
    {
      name: "offset",
      options: {
        offset: () => b ? [0, 64] : [0, 8]
      }
    },
    ...y ? [] : [{
      name: "flip",
      options: {
        fallbackPlacements: ["top-end", "top-start", "bottom-end", "bottom"]
      }
    }]
    // Keep default behavior
  ], [y, b]);
  return r === "none" ? null : /* @__PURE__ */ w.jsx(Ml, {
    children: m && /* @__PURE__ */ w.jsx(Xy, k({
      className: a == null ? void 0 : a.root,
      open: m,
      placement: y ? "right-start" : "top",
      popperRef: h,
      anchorEl: g,
      modifiers: O
    }, s, {
      children: i
    }))
  });
}
"production".NODE_ENV !== "production" && (il.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: n.oneOfType([tl, n.object, n.func]),
  /**
   * Popper render function or node.
   */
  children: n.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: n.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: n.shape({
    Root: n.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: n.shape({
    root: n.oneOfType([n.func, n.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: n.oneOfType([(e, t) => e[t] == null ? new Error(`Prop '${t}' is required but wasn't specified`) : typeof e[t] != "object" || e[t].nodeType !== 1 ? new Error(`Expected prop '${t}' to be of type Element`) : null, n.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: n.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: n.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: n.arrayOf(n.shape({
    data: n.object,
    effect: n.func,
    enabled: n.bool,
    fn: n.func,
    name: n.any,
    options: n.object,
    phase: n.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: n.arrayOf(n.string),
    requiresIfExists: n.arrayOf(n.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: n.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: n.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: n.shape({
    modifiers: n.array,
    onFirstUpdate: n.func,
    placement: n.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: n.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: n.oneOfType([n.func, n.shape({
    current: n.shape({
      destroy: n.func.isRequired,
      forceUpdate: n.func.isRequired,
      setOptions: n.func.isRequired,
      state: n.shape({
        attributes: n.object.isRequired,
        elements: n.object.isRequired,
        modifiersData: n.object.isRequired,
        options: n.object.isRequired,
        orderedModifiers: n.arrayOf(n.object).isRequired,
        placement: n.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: n.object.isRequired,
        reset: n.bool.isRequired,
        scrollParents: n.object.isRequired,
        strategy: n.oneOf(["absolute", "fixed"]).isRequired,
        styles: n.object.isRequired
      }).isRequired,
      update: n.func.isRequired
    })
  })]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: n.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: n.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: n.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'axis'
   */
  trigger: n.oneOf(["axis", "item", "none"])
});
function sl(e) {
  const {
    classes: t,
    trigger: r = "axis"
  } = e, o = br(t);
  return /* @__PURE__ */ w.jsx(il, k({}, e, {
    classes: t,
    children: r === "axis" ? /* @__PURE__ */ w.jsx(ol, {
      classes: o
    }) : /* @__PURE__ */ w.jsx(nl, {
      classes: o
    })
  }));
}
"production".NODE_ENV !== "production" && (sl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: n.oneOfType([tl, n.object, n.func]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: n.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: n.shape({
    Root: n.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: n.shape({
    root: n.oneOfType([n.func, n.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: n.oneOfType([(e, t) => e[t] == null ? new Error(`Prop '${t}' is required but wasn't specified`) : typeof e[t] != "object" || e[t].nodeType !== 1 ? new Error(`Expected prop '${t}' to be of type Element`) : null, n.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: n.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: n.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: n.arrayOf(n.shape({
    data: n.object,
    effect: n.func,
    enabled: n.bool,
    fn: n.func,
    name: n.any,
    options: n.object,
    phase: n.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: n.arrayOf(n.string),
    requiresIfExists: n.arrayOf(n.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: n.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: n.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: n.shape({
    modifiers: n.array,
    onFirstUpdate: n.func,
    placement: n.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: n.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: n.oneOfType([n.func, n.shape({
    current: n.shape({
      destroy: n.func.isRequired,
      forceUpdate: n.func.isRequired,
      setOptions: n.func.isRequired,
      state: n.shape({
        attributes: n.object.isRequired,
        elements: n.object.isRequired,
        modifiersData: n.object.isRequired,
        options: n.object.isRequired,
        orderedModifiers: n.arrayOf(n.object).isRequired,
        placement: n.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: n.object.isRequired,
        reset: n.bool.isRequired,
        scrollParents: n.object.isRequired,
        strategy: n.oneOf(["absolute", "fixed"]).isRequired,
        styles: n.object.isRequired
      }).isRequired,
      update: n.func.isRequired
    })
  })]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: n.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: n.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: n.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse.
   * - 'axis': Shows values associated with the hovered x value
   * - 'none': Does not display tooltip
   * @default 'axis'
   */
  trigger: n.oneOf(["axis", "item", "none"])
});
const By = (e) => ({
  type: "series",
  color: e.color,
  label: e.label,
  seriesId: e.seriesId,
  itemId: e.itemId
});
function Ky(e) {
  return xe("MuiChartsLegend", e);
}
const Zy = (e) => {
  const {
    classes: t,
    direction: r
  } = e;
  return be({
    root: ["root", r],
    mark: ["mark"],
    label: ["label"],
    series: ["series"]
  }, Ky, t);
}, Ts = Oe("MuiChartsLegend", ["root", "series", "mark", "label", "vertical", "horizontal"]), Qy = ["slots", "slotProps"], Jy = ["ownerState"], al = (e, t, r, o) => {
  function i(s, a) {
    var M;
    const c = ze({
      props: s,
      // eslint-disable-next-line material-ui/mui-name-matches-component-name
      name: e
    }), u = typeof r.defaultProps == "function" ? r.defaultProps(c) : r.defaultProps ?? {}, l = Jo(u, c), h = l, {
      slots: f,
      slotProps: d
    } = h, p = B(h, Qy), m = It(), g = (M = r.classesResolver) == null ? void 0 : M.call(r, l, m), y = (f == null ? void 0 : f[t]) ?? o, b = r.propagateSlots && !(f != null && f[t]), O = We({
      elementType: y,
      externalSlotProps: d == null ? void 0 : d[t],
      additionalProps: k({}, p, {
        classes: g
      }, b && {
        slots: f,
        slotProps: d
      }),
      ownerState: {}
    }), x = B(O, Jy), _ = k({}, x);
    for (const T of r.omitProps ?? [])
      delete _[T];
    return "production".NODE_ENV !== "production" && (y.displayName = `${e}.slots.${t}`), /* @__PURE__ */ w.jsx(y, k({}, _, {
      ref: a
    }));
  }
  return /* @__PURE__ */ A.forwardRef(i);
};
"production".NODE_ENV !== "production" && (al.displayName = "consumeSlots");
function e0(e) {
  return xe("MuiChartsLabel", e);
}
Oe("MuiChartsLabel", ["root"]);
const t0 = (e) => be({
  root: ["root"]
}, e0, e.classes), n0 = ["children", "className", "classes"], cl = ei("MuiChartsLabel", {
  classesResolver: t0
}, function(t, r) {
  const {
    children: o,
    className: i,
    classes: s
  } = t, a = B(t, n0);
  return /* @__PURE__ */ w.jsx("span", k({
    className: _e(s == null ? void 0 : s.root, i),
    ref: r
  }, a, {
    children: o
  }));
});
"production".NODE_ENV !== "production" && (cl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: n.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object
});
const r0 = ["direction", "onItemClick", "className", "classes"], o0 = Q("ul", {
  name: "MuiChartsLegend",
  slot: "Root"
})(({
  ownerState: e,
  theme: t
}) => k({}, t.typography.caption, {
  color: (t.vars || t).palette.text.primary,
  lineHeight: "100%",
  display: "flex",
  flexDirection: e.direction === "vertical" ? "column" : "row",
  alignItems: e.direction === "vertical" ? void 0 : "center",
  flexShrink: 0,
  gap: t.spacing(2),
  listStyleType: "none",
  paddingInlineStart: 0,
  marginBlock: t.spacing(1),
  marginInline: t.spacing(1),
  flexWrap: "wrap",
  li: {
    display: e.direction === "horizontal" ? "inline-flex" : void 0
  },
  [`button.${Ts.series}`]: {
    // Reset button styles
    background: "none",
    border: "none",
    padding: 0,
    fontFamily: "inherit",
    fontWeight: "inherit",
    fontSize: "inherit",
    letterSpacing: "inherit",
    color: "inherit"
  },
  [`& .${Ts.series}`]: {
    display: e.direction === "vertical" ? "flex" : "inline-flex",
    alignItems: "center",
    gap: t.spacing(1)
  }
})), ti = al("MuiChartsLegend", "legend", {
  defaultProps: {
    direction: "horizontal"
  },
  // @ts-expect-error position is used only in the slots, but it is passed to the SVG wrapper.
  // We omit it here to avoid passing to slots.
  omitProps: ["position"],
  classesResolver: Zy
}, /* @__PURE__ */ A.forwardRef(function(t, r) {
  const o = Og(), {
    onItemClick: i,
    className: s,
    classes: a
  } = t, c = B(t, r0);
  if (o.items.length === 0)
    return null;
  const u = i ? "button" : "div";
  return /* @__PURE__ */ w.jsx(o0, k({
    className: _e(a == null ? void 0 : a.root, s),
    ref: r
  }, c, {
    ownerState: t,
    children: o.items.map((l, h) => /* @__PURE__ */ w.jsx("li", {
      children: /* @__PURE__ */ w.jsxs(u, {
        className: a == null ? void 0 : a.series,
        role: i ? "button" : void 0,
        type: i ? "button" : void 0,
        onClick: i ? (
          // @ts-ignore onClick is only attached to a button
          (f) => i(f, By(l), h)
        ) : void 0,
        children: [/* @__PURE__ */ w.jsx(Xt, {
          className: a == null ? void 0 : a.mark,
          color: l.color,
          type: l.markType
        }), /* @__PURE__ */ w.jsx(cl, {
          className: a == null ? void 0 : a.label,
          children: l.label
        })]
      })
    }, l.id))
  }));
}));
"production".NODE_ENV !== "production" && (ti.displayName = "ChartsLegend");
"production".NODE_ENV !== "production" && (ti.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  className: n.string,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: n.oneOf(["horizontal", "vertical"]),
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<HTMLButtonElement, MouseEvent>} event The click event.
   * @param {SeriesLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: n.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object,
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object])
});
function i0(e) {
  return xe("MuiChartsAxisHighlight", e);
}
Oe("MuiChartsAxisHighlight", ["root"]);
const Fn = Q("path", {
  name: "MuiChartsAxisHighlight",
  slot: "Root"
})(({
  theme: e
}) => ({
  pointerEvents: "none",
  variants: [{
    props: {
      axisHighlight: "band"
    },
    style: k({
      fill: "white",
      fillOpacity: 0.1
    }, e.applyStyles("light", {
      fill: "gray"
    }))
  }, {
    props: {
      axisHighlight: "line"
    },
    style: k({
      strokeDasharray: "5 2",
      stroke: "#ffffff"
    }, e.applyStyles("light", {
      stroke: "#000000"
    }))
  }]
}));
function s0(e) {
  const {
    type: t,
    classes: r
  } = e, {
    left: o,
    width: i
  } = Re(), s = mg(), a = K(), c = V(a, Tp), u = Xe(s), l = t === "band" && c !== null && Me(s);
  return "production".NODE_ENV !== "production" && l && s(c) === void 0 && console.error(["MUI X Charts: The position value provided for the axis is not valid for the current scale.", "This probably means something is wrong with the data passed to the chart.", "The ChartsAxisHighlight component will not be displayed."].join(`
`)), /* @__PURE__ */ w.jsxs(A.Fragment, {
    children: [l && s(c) !== void 0 && /* @__PURE__ */ w.jsx(Fn, {
      d: `M ${o} ${// @ts-expect-error, yScale value is checked in the statement above
      s(c) - (s.step() - s.bandwidth()) / 2} l 0 ${s.step()} l ${i} 0 l 0 ${-s.step()} Z`,
      className: r.root,
      ownerState: {
        axisHighlight: "band"
      }
    }), t === "line" && c !== null && /* @__PURE__ */ w.jsx(Fn, {
      d: `M ${o} ${u(c)} L ${o + i} ${u(c)}`,
      className: r.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}
function a0(e) {
  const {
    type: t,
    classes: r
  } = e, {
    top: o,
    height: i
  } = Re(), s = pg(), a = K(), c = V(a, Op), u = Xe(s), l = t === "band" && c !== null && Me(s);
  return "production".NODE_ENV !== "production" && l && s(c) === void 0 && console.error(["MUI X Charts: The position value provided for the axis is not valid for the current scale.", "This probably means something is wrong with the data passed to the chart.", "The ChartsAxisHighlight component will not be displayed."].join(`
`)), /* @__PURE__ */ w.jsxs(A.Fragment, {
    children: [l && s(c) !== void 0 && /* @__PURE__ */ w.jsx(
      Fn,
      {
        d: `M ${s(c) - (s.step() - s.bandwidth()) / 2} ${o} l ${s.step()} 0 l 0 ${i} l ${-s.step()} 0 Z`,
        className: r.root,
        ownerState: {
          axisHighlight: "band"
        }
      }
    ), t === "line" && c !== null && /* @__PURE__ */ w.jsx(Fn, {
      d: `M ${u(c)} ${o} L ${u(c)} ${o + i}`,
      className: r.root,
      ownerState: {
        axisHighlight: "line"
      }
    })]
  });
}
const c0 = () => be({
  root: ["root"]
}, i0);
function ll(e) {
  const {
    x: t,
    y: r
  } = e, o = c0();
  return /* @__PURE__ */ w.jsxs(A.Fragment, {
    children: [t && /* @__PURE__ */ w.jsx(a0, {
      type: t,
      classes: o
    }), r && /* @__PURE__ */ w.jsx(s0, {
      type: r,
      classes: o
    })]
  });
}
"production".NODE_ENV !== "production" && (ll.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  x: n.oneOf(["band", "line", "none"]),
  y: n.oneOf(["band", "line", "none"])
});
function ul(e) {
  const {
    id: t,
    offset: r
  } = e, {
    left: o,
    top: i,
    width: s,
    height: a
  } = Re(), c = k({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, r);
  return /* @__PURE__ */ w.jsx("clipPath", {
    id: t,
    children: /* @__PURE__ */ w.jsx("rect", {
      x: o - c.left,
      y: i - c.top,
      width: s + c.left + c.right,
      height: a + c.top + c.bottom
    })
  });
}
"production".NODE_ENV !== "production" && (ul.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The id of the clip path.
   */
  id: n.string.isRequired,
  /**
   * Offset, in pixels, of the clip path rectangle from the drawing area.
   *
   * A positive value will move the rectangle outside the drawing area.
   */
  offset: n.shape({
    bottom: n.number,
    left: n.number,
    right: n.number,
    top: n.number
  })
});
const l0 = parseInt(A.version, 10), u0 = ["x", "y", "id", "classes", "color", "shape"];
function f0(e) {
  return xe("MuiHighlightElement", e);
}
Oe("MuiHighlightElement", ["root"]);
const d0 = (e) => {
  const {
    classes: t,
    id: r
  } = e, o = {
    root: ["root", `series-${r}`]
  };
  return be(o, f0, t);
};
function fl(e) {
  const {
    x: t,
    y: r,
    color: o,
    shape: i
  } = e, s = B(e, u0), a = d0(e), c = i === "circle" ? "circle" : "path", u = i === "circle" ? {
    cx: 0,
    cy: 0,
    r: s.r === void 0 ? 5 : s.r
  } : {
    d: Us(zs[Lc(i)])()
  }, l = l0 > 18 ? {
    transformOrigin: `${t} ${r}`
  } : {
    "transform-origin": `${t} ${r}`
  };
  return /* @__PURE__ */ w.jsx(c, k({
    pointerEvents: "none",
    className: a.root,
    transform: `translate(${t} ${r})`,
    fill: o
  }, l, u, s));
}
"production".NODE_ENV !== "production" && (fl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: n.object,
  id: n.oneOfType([n.number, n.string]).isRequired,
  shape: n.oneOf(["circle", "cross", "diamond", "square", "star", "triangle", "wye"]).isRequired
});
const h0 = ["slots", "slotProps"];
function dl(e) {
  const {
    slots: t,
    slotProps: r
  } = e, o = B(e, h0), i = mr(), {
    xAxis: s,
    xAxisIds: a
  } = je(), {
    yAxis: c,
    yAxisIds: u
  } = Pe(), {
    instance: l
  } = Ve(), h = K(), f = V(h, Fo);
  if (f === null || i === void 0)
    return null;
  const {
    series: d,
    stackingGroups: p
  } = i, m = a[0], g = u[0], y = (t == null ? void 0 : t.lineHighlight) ?? fl;
  return /* @__PURE__ */ w.jsx("g", k({}, o, {
    children: p.flatMap(({
      ids: b
    }) => b.flatMap((O) => {
      const {
        xAxisId: x = m,
        yAxisId: _ = g,
        stackedData: M,
        data: T,
        disableHighlight: v,
        shape: S = "circle"
      } = d[O];
      if (v || T[f] == null)
        return null;
      const C = Xe(s[x].scale), P = c[_].scale, I = s[x].data;
      if (I === void 0)
        throw new Error(`MUI X Charts: ${x === St ? "The first `xAxis`" : `The x-axis with id "${x}"`} should have data property to be able to display a line plot.`);
      const L = C(I[f]), R = P(M[f][1]);
      if (!l.isPointInside(L, R))
        return null;
      const $ = zo(d[O], s[x], c[_]);
      return /* @__PURE__ */ w.jsx(y, k({
        id: O,
        color: $(f),
        x: L,
        y: R,
        shape: S
      }, r == null ? void 0 : r.lineHighlight), `${O}`);
    }))
  }));
}
"production".NODE_ENV !== "production" && (dl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object
});
function p0(e) {
  return xe("MuiChartsGrid", e);
}
const ks = Oe("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]), m0 = Q("g", {
  name: "MuiChartsGrid",
  slot: "Root",
  overridesResolver: (e, t) => [{
    [`&.${ks.verticalLine}`]: t.verticalLine
  }, {
    [`&.${ks.horizontalLine}`]: t.horizontalLine
  }, t.root]
})({}), hl = Q("line", {
  name: "MuiChartsGrid",
  slot: "Line"
})(({
  theme: e
}) => ({
  stroke: (e.vars || e).palette.divider,
  shapeRendering: "crispEdges",
  strokeWidth: 1
}));
function g0(e) {
  const {
    axis: t,
    start: r,
    end: o,
    classes: i
  } = e, {
    scale: s,
    tickNumber: a,
    tickInterval: c
  } = t, u = yr({
    scale: s,
    tickNumber: a,
    tickInterval: c,
    direction: "x"
  });
  return /* @__PURE__ */ w.jsx(A.Fragment, {
    children: u.map(({
      value: l,
      offset: h
    }) => {
      var f;
      return /* @__PURE__ */ w.jsx(hl, {
        y1: r,
        y2: o,
        x1: h,
        x2: h,
        className: i.verticalLine
      }, `vertical-${((f = l == null ? void 0 : l.getTime) == null ? void 0 : f.call(l)) ?? l}`);
    })
  });
}
function y0(e) {
  const {
    axis: t,
    start: r,
    end: o,
    classes: i
  } = e, {
    scale: s,
    tickNumber: a,
    tickInterval: c
  } = t, u = yr({
    scale: s,
    tickNumber: a,
    tickInterval: c,
    direction: "y"
  });
  return /* @__PURE__ */ w.jsx(A.Fragment, {
    children: u.map(({
      value: l,
      offset: h
    }) => {
      var f;
      return /* @__PURE__ */ w.jsx(hl, {
        y1: h,
        y2: h,
        x1: r,
        x2: o,
        className: i.horizontalLine
      }, `horizontal-${((f = l == null ? void 0 : l.getTime) == null ? void 0 : f.call(l)) ?? l}`);
    })
  });
}
const b0 = ["vertical", "horizontal"], x0 = ({
  classes: e
}) => be({
  root: ["root"],
  verticalLine: ["line", "verticalLine"],
  horizontalLine: ["line", "horizontalLine"]
}, p0, e);
function pl(e) {
  const t = ze({
    props: e,
    name: "MuiChartsGrid"
  }), r = Re(), {
    vertical: o,
    horizontal: i
  } = t, s = B(t, b0), {
    xAxis: a,
    xAxisIds: c
  } = je(), {
    yAxis: u,
    yAxisIds: l
  } = Pe(), h = x0(t), f = u[l[0]], d = a[c[0]];
  return /* @__PURE__ */ w.jsxs(m0, k({}, s, {
    className: h.root,
    children: [o && /* @__PURE__ */ w.jsx(g0, {
      axis: d,
      start: r.top,
      end: r.height + r.top,
      classes: h
    }), i && /* @__PURE__ */ w.jsx(y0, {
      axis: f,
      start: r.left,
      end: r.width + r.left,
      classes: h
    })]
  }));
}
"production".NODE_ENV !== "production" && (pl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: n.object,
  /**
   * Displays horizontal grid.
   */
  horizontal: n.bool,
  /**
   * Displays vertical grid.
   */
  vertical: n.bool
});
const O0 = ["message"], T0 = Q("text")(({
  theme: e
}) => k({}, e.typography.body2, {
  stroke: "none",
  fill: (e.vars || e).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function k0(e) {
  const {
    message: t
  } = e, r = B(e, O0), {
    top: o,
    left: i,
    height: s,
    width: a
  } = Re(), {
    localeText: c
  } = vc();
  return /* @__PURE__ */ w.jsx(T0, k({
    x: i + a / 2,
    y: o + s / 2
  }, r, {
    children: t ?? c.loading
  }));
}
const _0 = ["message"], w0 = Q("text")(({
  theme: e
}) => k({}, e.typography.body2, {
  stroke: "none",
  fill: (e.vars || e).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function v0(e) {
  const {
    message: t
  } = e, r = B(e, _0), {
    top: o,
    left: i,
    height: s,
    width: a
  } = Re(), {
    localeText: c
  } = vc();
  return /* @__PURE__ */ w.jsx(w0, k({
    x: i + a / 2,
    y: o + s / 2
  }, r, {
    children: t ?? c.noData
  }));
}
function M0() {
  const e = pr();
  return Object.values(e).every((t) => {
    if (!t)
      return !0;
    const {
      series: r,
      seriesOrder: o
    } = t;
    return o.every((i) => r[i].data.length === 0);
  });
}
function C0(e) {
  var r, o, i, s;
  const t = M0();
  if (e.loading) {
    const a = ((r = e.slots) == null ? void 0 : r.loadingOverlay) ?? k0;
    return /* @__PURE__ */ w.jsx(a, k({}, (o = e.slotProps) == null ? void 0 : o.loadingOverlay));
  }
  if (t) {
    const a = ((i = e.slots) == null ? void 0 : i.noDataOverlay) ?? v0;
    return /* @__PURE__ */ w.jsx(a, k({}, (s = e.slotProps) == null ? void 0 : s.noDataOverlay));
  }
  return null;
}
const I0 = [Jt, Et, Qt, Rt], S0 = ["xAxis", "yAxis", "series", "width", "height", "margin", "colors", "dataset", "sx", "onAreaClick", "onLineClick", "onMarkClick", "axisHighlight", "disableLineItemHighlight", "hideLegend", "grid", "children", "slots", "slotProps", "skipAnimation", "loading", "highlightedItem", "onHighlightChange", "className", "showToolbar"], A0 = (e) => {
  var ee, fe, de, Ce, q;
  const {
    xAxis: t,
    yAxis: r,
    series: o,
    width: i,
    height: s,
    margin: a,
    colors: c,
    dataset: u,
    sx: l,
    onAreaClick: h,
    onLineClick: f,
    onMarkClick: d,
    axisHighlight: p,
    disableLineItemHighlight: m,
    grid: g,
    children: y,
    slots: b,
    slotProps: O,
    skipAnimation: x,
    loading: _,
    highlightedItem: M,
    onHighlightChange: T,
    className: v
  } = e, S = B(e, S0), P = `${Zs()}-clip-path`, I = A.useMemo(() => o.map((H) => k({
    disableHighlight: !!m,
    type: "line"
  }, H)), [m, o]), L = k({}, S, {
    series: I,
    width: i,
    height: s,
    margin: a,
    colors: c,
    dataset: u,
    xAxis: t ?? [{
      id: St,
      scaleType: "point",
      data: Array.from({
        length: Math.max(...o.map((H) => (H.data ?? u ?? []).length))
      }, (H, G) => G)
    }],
    yAxis: r,
    highlightedItem: M,
    onHighlightChange: T,
    disableAxisListener: ((ee = O == null ? void 0 : O.tooltip) == null ? void 0 : ee.trigger) !== "axis" && (p == null ? void 0 : p.x) === "none" && (p == null ? void 0 : p.y) === "none",
    className: v,
    skipAnimation: x,
    plugins: I0
  }), R = {
    vertical: g == null ? void 0 : g.vertical,
    horizontal: g == null ? void 0 : g.horizontal
  }, $ = {
    clipPath: `url(#${P})`
  }, N = {
    id: P
  }, E = {
    slots: b,
    slotProps: O,
    onItemClick: h
  }, D = {
    slots: b,
    slotProps: O,
    onItemClick: f
  }, U = {
    slots: b,
    slotProps: O,
    onItemClick: d,
    skipAnimation: x
  }, z = {
    slots: b,
    slotProps: O,
    loading: _
  }, Z = {
    slots: b,
    slotProps: O
  }, re = k({
    x: "line"
  }, p), he = {
    slots: b,
    slotProps: O
  }, ae = {
    slots: b,
    slotProps: O
  };
  return {
    chartsWrapperProps: {
      sx: l,
      legendPosition: (de = (fe = e.slotProps) == null ? void 0 : fe.legend) == null ? void 0 : de.position,
      legendDirection: (q = (Ce = e.slotProps) == null ? void 0 : Ce.legend) == null ? void 0 : q.direction
    },
    chartContainerProps: L,
    gridProps: R,
    clipPathProps: N,
    clipPathGroupProps: $,
    areaPlotProps: E,
    linePlotProps: D,
    markPlotProps: U,
    overlayProps: z,
    chartsAxisProps: Z,
    axisHighlightProps: re,
    lineHighlightPlotProps: he,
    legendProps: ae,
    children: y
  };
}, Le = 11102230246251565e-32, ce = 134217729, E0 = (3 + 8 * Le) * Le;
function Gr(e, t, r, o, i) {
  let s, a, c, u, l = t[0], h = o[0], f = 0, d = 0;
  h > l == h > -l ? (s = l, l = t[++f]) : (s = h, h = o[++d]);
  let p = 0;
  if (f < e && d < r)
    for (h > l == h > -l ? (a = l + s, c = s - (a - l), l = t[++f]) : (a = h + s, c = s - (a - h), h = o[++d]), s = a, c !== 0 && (i[p++] = c); f < e && d < r; )
      h > l == h > -l ? (a = s + l, u = a - s, c = s - (a - u) + (l - u), l = t[++f]) : (a = s + h, u = a - s, c = s - (a - u) + (h - u), h = o[++d]), s = a, c !== 0 && (i[p++] = c);
  for (; f < e; )
    a = s + l, u = a - s, c = s - (a - u) + (l - u), l = t[++f], s = a, c !== 0 && (i[p++] = c);
  for (; d < r; )
    a = s + h, u = a - s, c = s - (a - u) + (h - u), h = o[++d], s = a, c !== 0 && (i[p++] = c);
  return (s !== 0 || p === 0) && (i[p++] = s), p;
}
function R0(e, t) {
  let r = t[0];
  for (let o = 1; o < e; o++)
    r += t[o];
  return r;
}
function nn(e) {
  return new Float64Array(e);
}
const j0 = (3 + 16 * Le) * Le, P0 = (2 + 12 * Le) * Le, N0 = (9 + 64 * Le) * Le * Le, dt = nn(4), _s = nn(8), ws = nn(12), vs = nn(16), le = nn(4);
function $0(e, t, r, o, i, s, a) {
  let c, u, l, h, f, d, p, m, g, y, b, O, x, _, M, T, v, S;
  const C = e - i, P = r - i, I = t - s, L = o - s;
  _ = C * L, d = ce * C, p = d - (d - C), m = C - p, d = ce * L, g = d - (d - L), y = L - g, M = m * y - (_ - p * g - m * g - p * y), T = I * P, d = ce * I, p = d - (d - I), m = I - p, d = ce * P, g = d - (d - P), y = P - g, v = m * y - (T - p * g - m * g - p * y), b = M - v, f = M - b, dt[0] = M - (b + f) + (f - v), O = _ + b, f = O - _, x = _ - (O - f) + (b - f), b = x - T, f = x - b, dt[1] = x - (b + f) + (f - T), S = O + b, f = S - O, dt[2] = O - (S - f) + (b - f), dt[3] = S;
  let R = R0(4, dt), $ = P0 * a;
  if (R >= $ || -R >= $ || (f = e - C, c = e - (C + f) + (f - i), f = r - P, l = r - (P + f) + (f - i), f = t - I, u = t - (I + f) + (f - s), f = o - L, h = o - (L + f) + (f - s), c === 0 && u === 0 && l === 0 && h === 0) || ($ = N0 * a + E0 * Math.abs(R), R += C * h + L * c - (I * l + P * u), R >= $ || -R >= $))
    return R;
  _ = c * L, d = ce * c, p = d - (d - c), m = c - p, d = ce * L, g = d - (d - L), y = L - g, M = m * y - (_ - p * g - m * g - p * y), T = u * P, d = ce * u, p = d - (d - u), m = u - p, d = ce * P, g = d - (d - P), y = P - g, v = m * y - (T - p * g - m * g - p * y), b = M - v, f = M - b, le[0] = M - (b + f) + (f - v), O = _ + b, f = O - _, x = _ - (O - f) + (b - f), b = x - T, f = x - b, le[1] = x - (b + f) + (f - T), S = O + b, f = S - O, le[2] = O - (S - f) + (b - f), le[3] = S;
  const N = Gr(4, dt, 4, le, _s);
  _ = C * h, d = ce * C, p = d - (d - C), m = C - p, d = ce * h, g = d - (d - h), y = h - g, M = m * y - (_ - p * g - m * g - p * y), T = I * l, d = ce * I, p = d - (d - I), m = I - p, d = ce * l, g = d - (d - l), y = l - g, v = m * y - (T - p * g - m * g - p * y), b = M - v, f = M - b, le[0] = M - (b + f) + (f - v), O = _ + b, f = O - _, x = _ - (O - f) + (b - f), b = x - T, f = x - b, le[1] = x - (b + f) + (f - T), S = O + b, f = S - O, le[2] = O - (S - f) + (b - f), le[3] = S;
  const E = Gr(N, _s, 4, le, ws);
  _ = c * h, d = ce * c, p = d - (d - c), m = c - p, d = ce * h, g = d - (d - h), y = h - g, M = m * y - (_ - p * g - m * g - p * y), T = u * l, d = ce * u, p = d - (d - u), m = u - p, d = ce * l, g = d - (d - l), y = l - g, v = m * y - (T - p * g - m * g - p * y), b = M - v, f = M - b, le[0] = M - (b + f) + (f - v), O = _ + b, f = O - _, x = _ - (O - f) + (b - f), b = x - T, f = x - b, le[1] = x - (b + f) + (f - T), S = O + b, f = S - O, le[2] = O - (S - f) + (b - f), le[3] = S;
  const D = Gr(E, ws, 4, le, vs);
  return vs[D - 1];
}
function gn(e, t, r, o, i, s) {
  const a = (t - s) * (r - i), c = (e - i) * (o - s), u = a - c, l = Math.abs(a + c);
  return Math.abs(u) >= j0 * l ? u : -$0(e, t, r, o, i, s, l);
}
const Ms = Math.pow(2, -52), yn = new Uint32Array(512);
class zn {
  static from(t, r = z0, o = U0) {
    const i = t.length, s = new Float64Array(i * 2);
    for (let a = 0; a < i; a++) {
      const c = t[a];
      s[2 * a] = r(c), s[2 * a + 1] = o(c);
    }
    return new zn(s);
  }
  constructor(t) {
    const r = t.length >> 1;
    if (r > 0 && typeof t[0] != "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = t;
    const o = Math.max(2 * r - 5, 0);
    this._triangles = new Uint32Array(o * 3), this._halfedges = new Int32Array(o * 3), this._hashSize = Math.ceil(Math.sqrt(r)), this._hullPrev = new Uint32Array(r), this._hullNext = new Uint32Array(r), this._hullTri = new Uint32Array(r), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(r), this._dists = new Float64Array(r), this.update();
  }
  update() {
    const { coords: t, _hullPrev: r, _hullNext: o, _hullTri: i, _hullHash: s } = this, a = t.length >> 1;
    let c = 1 / 0, u = 1 / 0, l = -1 / 0, h = -1 / 0;
    for (let C = 0; C < a; C++) {
      const P = t[2 * C], I = t[2 * C + 1];
      P < c && (c = P), I < u && (u = I), P > l && (l = P), I > h && (h = I), this._ids[C] = C;
    }
    const f = (c + l) / 2, d = (u + h) / 2;
    let p, m, g;
    for (let C = 0, P = 1 / 0; C < a; C++) {
      const I = Yr(f, d, t[2 * C], t[2 * C + 1]);
      I < P && (p = C, P = I);
    }
    const y = t[2 * p], b = t[2 * p + 1];
    for (let C = 0, P = 1 / 0; C < a; C++) {
      if (C === p)
        continue;
      const I = Yr(y, b, t[2 * C], t[2 * C + 1]);
      I < P && I > 0 && (m = C, P = I);
    }
    let O = t[2 * m], x = t[2 * m + 1], _ = 1 / 0;
    for (let C = 0; C < a; C++) {
      if (C === p || C === m)
        continue;
      const P = q0(y, b, O, x, t[2 * C], t[2 * C + 1]);
      P < _ && (g = C, _ = P);
    }
    let M = t[2 * g], T = t[2 * g + 1];
    if (_ === 1 / 0) {
      for (let I = 0; I < a; I++)
        this._dists[I] = t[2 * I] - t[0] || t[2 * I + 1] - t[1];
      gt(this._ids, this._dists, 0, a - 1);
      const C = new Uint32Array(a);
      let P = 0;
      for (let I = 0, L = -1 / 0; I < a; I++) {
        const R = this._ids[I], $ = this._dists[R];
        $ > L && (C[P++] = R, L = $);
      }
      this.hull = C.subarray(0, P), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (gn(y, b, O, x, M, T) < 0) {
      const C = m, P = O, I = x;
      m = g, O = M, x = T, g = C, M = P, T = I;
    }
    const v = F0(y, b, O, x, M, T);
    this._cx = v.x, this._cy = v.y;
    for (let C = 0; C < a; C++)
      this._dists[C] = Yr(t[2 * C], t[2 * C + 1], v.x, v.y);
    gt(this._ids, this._dists, 0, a - 1), this._hullStart = p;
    let S = 3;
    o[p] = r[g] = m, o[m] = r[p] = g, o[g] = r[m] = p, i[p] = 0, i[m] = 1, i[g] = 2, s.fill(-1), s[this._hashKey(y, b)] = p, s[this._hashKey(O, x)] = m, s[this._hashKey(M, T)] = g, this.trianglesLen = 0, this._addTriangle(p, m, g, -1, -1, -1);
    for (let C = 0, P, I; C < this._ids.length; C++) {
      const L = this._ids[C], R = t[2 * L], $ = t[2 * L + 1];
      if (C > 0 && Math.abs(R - P) <= Ms && Math.abs($ - I) <= Ms || (P = R, I = $, L === p || L === m || L === g))
        continue;
      let N = 0;
      for (let Z = 0, re = this._hashKey(R, $); Z < this._hashSize && (N = s[(re + Z) % this._hashSize], !(N !== -1 && N !== o[N])); Z++)
        ;
      N = r[N];
      let E = N, D;
      for (; D = o[E], gn(R, $, t[2 * E], t[2 * E + 1], t[2 * D], t[2 * D + 1]) >= 0; )
        if (E = D, E === N) {
          E = -1;
          break;
        }
      if (E === -1)
        continue;
      let U = this._addTriangle(E, L, o[E], -1, -1, i[E]);
      i[L] = this._legalize(U + 2), i[E] = U, S++;
      let z = o[E];
      for (; D = o[z], gn(R, $, t[2 * z], t[2 * z + 1], t[2 * D], t[2 * D + 1]) < 0; )
        U = this._addTriangle(z, L, D, i[L], -1, i[z]), i[L] = this._legalize(U + 2), o[z] = z, S--, z = D;
      if (E === N)
        for (; D = r[E], gn(R, $, t[2 * D], t[2 * D + 1], t[2 * E], t[2 * E + 1]) < 0; )
          U = this._addTriangle(D, L, E, -1, i[E], i[D]), this._legalize(U + 2), i[D] = U, o[E] = E, S--, E = D;
      this._hullStart = r[L] = E, o[E] = r[z] = L, o[L] = z, s[this._hashKey(R, $)] = L, s[this._hashKey(t[2 * E], t[2 * E + 1])] = E;
    }
    this.hull = new Uint32Array(S);
    for (let C = 0, P = this._hullStart; C < S; C++)
      this.hull[C] = P, P = o[P];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(t, r) {
    return Math.floor(L0(t - this._cx, r - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(t) {
    const { _triangles: r, _halfedges: o, coords: i } = this;
    let s = 0, a = 0;
    for (; ; ) {
      const c = o[t], u = t - t % 3;
      if (a = u + (t + 2) % 3, c === -1) {
        if (s === 0)
          break;
        t = yn[--s];
        continue;
      }
      const l = c - c % 3, h = u + (t + 1) % 3, f = l + (c + 2) % 3, d = r[a], p = r[t], m = r[h], g = r[f];
      if (D0(
        i[2 * d],
        i[2 * d + 1],
        i[2 * p],
        i[2 * p + 1],
        i[2 * m],
        i[2 * m + 1],
        i[2 * g],
        i[2 * g + 1]
      )) {
        r[t] = g, r[c] = d;
        const b = o[f];
        if (b === -1) {
          let x = this._hullStart;
          do {
            if (this._hullTri[x] === f) {
              this._hullTri[x] = t;
              break;
            }
            x = this._hullPrev[x];
          } while (x !== this._hullStart);
        }
        this._link(t, b), this._link(c, o[a]), this._link(a, f);
        const O = l + (c + 1) % 3;
        s < yn.length && (yn[s++] = O);
      } else {
        if (s === 0)
          break;
        t = yn[--s];
      }
    }
    return a;
  }
  _link(t, r) {
    this._halfedges[t] = r, r !== -1 && (this._halfedges[r] = t);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(t, r, o, i, s, a) {
    const c = this.trianglesLen;
    return this._triangles[c] = t, this._triangles[c + 1] = r, this._triangles[c + 2] = o, this._link(c, i), this._link(c + 1, s), this._link(c + 2, a), this.trianglesLen += 3, c;
  }
}
function L0(e, t) {
  const r = e / (Math.abs(e) + Math.abs(t));
  return (t > 0 ? 3 - r : 1 + r) / 4;
}
function Yr(e, t, r, o) {
  const i = e - r, s = t - o;
  return i * i + s * s;
}
function D0(e, t, r, o, i, s, a, c) {
  const u = e - a, l = t - c, h = r - a, f = o - c, d = i - a, p = s - c, m = u * u + l * l, g = h * h + f * f, y = d * d + p * p;
  return u * (f * y - g * p) - l * (h * y - g * d) + m * (h * p - f * d) < 0;
}
function q0(e, t, r, o, i, s) {
  const a = r - e, c = o - t, u = i - e, l = s - t, h = a * a + c * c, f = u * u + l * l, d = 0.5 / (a * l - c * u), p = (l * h - c * f) * d, m = (a * f - u * h) * d;
  return p * p + m * m;
}
function F0(e, t, r, o, i, s) {
  const a = r - e, c = o - t, u = i - e, l = s - t, h = a * a + c * c, f = u * u + l * l, d = 0.5 / (a * l - c * u), p = e + (l * h - c * f) * d, m = t + (a * f - u * h) * d;
  return { x: p, y: m };
}
function gt(e, t, r, o) {
  if (o - r <= 20)
    for (let i = r + 1; i <= o; i++) {
      const s = e[i], a = t[s];
      let c = i - 1;
      for (; c >= r && t[e[c]] > a; )
        e[c + 1] = e[c--];
      e[c + 1] = s;
    }
  else {
    const i = r + o >> 1;
    let s = r + 1, a = o;
    Lt(e, i, s), t[e[r]] > t[e[o]] && Lt(e, r, o), t[e[s]] > t[e[o]] && Lt(e, s, o), t[e[r]] > t[e[s]] && Lt(e, r, s);
    const c = e[s], u = t[c];
    for (; ; ) {
      do
        s++;
      while (t[e[s]] < u);
      do
        a--;
      while (t[e[a]] > u);
      if (a < s)
        break;
      Lt(e, s, a);
    }
    e[r + 1] = e[a], e[a] = c, o - s + 1 >= a - r ? (gt(e, t, s, o), gt(e, t, r, a - 1)) : (gt(e, t, r, a - 1), gt(e, t, s, o));
  }
}
function Lt(e, t, r) {
  const o = e[t];
  e[t] = e[r], e[r] = o;
}
function z0(e) {
  return e[0];
}
function U0(e) {
  return e[1];
}
const Cs = 1e-6;
class Je {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(t, r) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(t, r) {
    this._ += `L${this._x1 = +t},${this._y1 = +r}`;
  }
  arc(t, r, o) {
    t = +t, r = +r, o = +o;
    const i = t + o, s = r;
    if (o < 0)
      throw new Error("negative radius");
    this._x1 === null ? this._ += `M${i},${s}` : (Math.abs(this._x1 - i) > Cs || Math.abs(this._y1 - s) > Cs) && (this._ += "L" + i + "," + s), o && (this._ += `A${o},${o},0,1,1,${t - o},${r}A${o},${o},0,1,1,${this._x1 = i},${this._y1 = s}`);
  }
  rect(t, r, o, i) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +r}h${+o}v${+i}h${-o}Z`;
  }
  value() {
    return this._ || null;
  }
}
class uo {
  constructor() {
    this._ = [];
  }
  moveTo(t, r) {
    this._.push([t, r]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, r) {
    this._.push([t, r]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
class H0 {
  constructor(t, [r, o, i, s] = [0, 0, 960, 500]) {
    if (!((i = +i) >= (r = +r)) || !((s = +s) >= (o = +o)))
      throw new Error("invalid bounds");
    this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = i, this.xmin = r, this.ymax = s, this.ymin = o, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: t, hull: r, triangles: o }, vectors: i } = this;
    let s, a;
    const c = this.circumcenters = this._circumcenters.subarray(0, o.length / 3 * 2);
    for (let g = 0, y = 0, b = o.length, O, x; g < b; g += 3, y += 2) {
      const _ = o[g] * 2, M = o[g + 1] * 2, T = o[g + 2] * 2, v = t[_], S = t[_ + 1], C = t[M], P = t[M + 1], I = t[T], L = t[T + 1], R = C - v, $ = P - S, N = I - v, E = L - S, D = (R * E - $ * N) * 2;
      if (Math.abs(D) < 1e-9) {
        if (s === void 0) {
          s = a = 0;
          for (const z of r)
            s += t[z * 2], a += t[z * 2 + 1];
          s /= r.length, a /= r.length;
        }
        const U = 1e9 * Math.sign((s - v) * E - (a - S) * N);
        O = (v + I) / 2 - U * E, x = (S + L) / 2 + U * N;
      } else {
        const U = 1 / D, z = R * R + $ * $, Z = N * N + E * E;
        O = v + (E * z - $ * Z) * U, x = S + (R * Z - N * z) * U;
      }
      c[y] = O, c[y + 1] = x;
    }
    let u = r[r.length - 1], l, h = u * 4, f, d = t[2 * u], p, m = t[2 * u + 1];
    i.fill(0);
    for (let g = 0; g < r.length; ++g)
      u = r[g], l = h, f = d, p = m, h = u * 4, d = t[2 * u], m = t[2 * u + 1], i[l + 2] = i[h] = p - m, i[l + 3] = i[h + 1] = d - f;
  }
  render(t) {
    const r = t == null ? t = new Je() : void 0, { delaunay: { halfedges: o, inedges: i, hull: s }, circumcenters: a, vectors: c } = this;
    if (s.length <= 1)
      return null;
    for (let h = 0, f = o.length; h < f; ++h) {
      const d = o[h];
      if (d < h)
        continue;
      const p = Math.floor(h / 3) * 2, m = Math.floor(d / 3) * 2, g = a[p], y = a[p + 1], b = a[m], O = a[m + 1];
      this._renderSegment(g, y, b, O, t);
    }
    let u, l = s[s.length - 1];
    for (let h = 0; h < s.length; ++h) {
      u = l, l = s[h];
      const f = Math.floor(i[l] / 3) * 2, d = a[f], p = a[f + 1], m = u * 4, g = this._project(d, p, c[m + 2], c[m + 3]);
      g && this._renderSegment(d, p, g[0], g[1], t);
    }
    return r && r.value();
  }
  renderBounds(t) {
    const r = t == null ? t = new Je() : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), r && r.value();
  }
  renderCell(t, r) {
    const o = r == null ? r = new Je() : void 0, i = this._clip(t);
    if (i === null || !i.length)
      return;
    r.moveTo(i[0], i[1]);
    let s = i.length;
    for (; i[0] === i[s - 2] && i[1] === i[s - 1] && s > 1; )
      s -= 2;
    for (let a = 2; a < s; a += 2)
      (i[a] !== i[a - 2] || i[a + 1] !== i[a - 1]) && r.lineTo(i[a], i[a + 1]);
    return r.closePath(), o && o.value();
  }
  *cellPolygons() {
    const { delaunay: { points: t } } = this;
    for (let r = 0, o = t.length / 2; r < o; ++r) {
      const i = this.cellPolygon(r);
      i && (i.index = r, yield i);
    }
  }
  cellPolygon(t) {
    const r = new uo();
    return this.renderCell(t, r), r.value();
  }
  _renderSegment(t, r, o, i, s) {
    let a;
    const c = this._regioncode(t, r), u = this._regioncode(o, i);
    c === 0 && u === 0 ? (s.moveTo(t, r), s.lineTo(o, i)) : (a = this._clipSegment(t, r, o, i, c, u)) && (s.moveTo(a[0], a[1]), s.lineTo(a[2], a[3]));
  }
  contains(t, r, o) {
    return r = +r, r !== r || (o = +o, o !== o) ? !1 : this.delaunay._step(t, r, o) === t;
  }
  *neighbors(t) {
    const r = this._clip(t);
    if (r)
      for (const o of this.delaunay.neighbors(t)) {
        const i = this._clip(o);
        if (i) {
          e:
            for (let s = 0, a = r.length; s < a; s += 2)
              for (let c = 0, u = i.length; c < u; c += 2)
                if (r[s] === i[c] && r[s + 1] === i[c + 1] && r[(s + 2) % a] === i[(c + u - 2) % u] && r[(s + 3) % a] === i[(c + u - 1) % u]) {
                  yield o;
                  break e;
                }
        }
      }
  }
  _cell(t) {
    const { circumcenters: r, delaunay: { inedges: o, halfedges: i, triangles: s } } = this, a = o[t];
    if (a === -1)
      return null;
    const c = [];
    let u = a;
    do {
      const l = Math.floor(u / 3);
      if (c.push(r[l * 2], r[l * 2 + 1]), u = u % 3 === 2 ? u - 2 : u + 1, s[u] !== t)
        break;
      u = i[u];
    } while (u !== a && u !== -1);
    return c;
  }
  _clip(t) {
    if (t === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const r = this._cell(t);
    if (r === null)
      return null;
    const { vectors: o } = this, i = t * 4;
    return this._simplify(o[i] || o[i + 1] ? this._clipInfinite(t, r, o[i], o[i + 1], o[i + 2], o[i + 3]) : this._clipFinite(t, r));
  }
  _clipFinite(t, r) {
    const o = r.length;
    let i = null, s, a, c = r[o - 2], u = r[o - 1], l, h = this._regioncode(c, u), f, d = 0;
    for (let p = 0; p < o; p += 2)
      if (s = c, a = u, c = r[p], u = r[p + 1], l = h, h = this._regioncode(c, u), l === 0 && h === 0)
        f = d, d = 0, i ? i.push(c, u) : i = [c, u];
      else {
        let m, g, y, b, O;
        if (l === 0) {
          if ((m = this._clipSegment(s, a, c, u, l, h)) === null)
            continue;
          [g, y, b, O] = m;
        } else {
          if ((m = this._clipSegment(c, u, s, a, h, l)) === null)
            continue;
          [b, O, g, y] = m, f = d, d = this._edgecode(g, y), f && d && this._edge(t, f, d, i, i.length), i ? i.push(g, y) : i = [g, y];
        }
        f = d, d = this._edgecode(b, O), f && d && this._edge(t, f, d, i, i.length), i ? i.push(b, O) : i = [b, O];
      }
    if (i)
      f = d, d = this._edgecode(i[0], i[1]), f && d && this._edge(t, f, d, i, i.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return i;
  }
  _clipSegment(t, r, o, i, s, a) {
    const c = s < a;
    for (c && ([t, r, o, i, s, a] = [o, i, t, r, a, s]); ; ) {
      if (s === 0 && a === 0)
        return c ? [o, i, t, r] : [t, r, o, i];
      if (s & a)
        return null;
      let u, l, h = s || a;
      h & 8 ? (u = t + (o - t) * (this.ymax - r) / (i - r), l = this.ymax) : h & 4 ? (u = t + (o - t) * (this.ymin - r) / (i - r), l = this.ymin) : h & 2 ? (l = r + (i - r) * (this.xmax - t) / (o - t), u = this.xmax) : (l = r + (i - r) * (this.xmin - t) / (o - t), u = this.xmin), s ? (t = u, r = l, s = this._regioncode(t, r)) : (o = u, i = l, a = this._regioncode(o, i));
    }
  }
  _clipInfinite(t, r, o, i, s, a) {
    let c = Array.from(r), u;
    if ((u = this._project(c[0], c[1], o, i)) && c.unshift(u[0], u[1]), (u = this._project(c[c.length - 2], c[c.length - 1], s, a)) && c.push(u[0], u[1]), c = this._clipFinite(t, c))
      for (let l = 0, h = c.length, f, d = this._edgecode(c[h - 2], c[h - 1]); l < h; l += 2)
        f = d, d = this._edgecode(c[l], c[l + 1]), f && d && (l = this._edge(t, f, d, c, l), h = c.length);
    else
      this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (c = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return c;
  }
  _edge(t, r, o, i, s) {
    for (; r !== o; ) {
      let a, c;
      switch (r) {
        case 5:
          r = 4;
          continue;
        case 4:
          r = 6, a = this.xmax, c = this.ymin;
          break;
        case 6:
          r = 2;
          continue;
        case 2:
          r = 10, a = this.xmax, c = this.ymax;
          break;
        case 10:
          r = 8;
          continue;
        case 8:
          r = 9, a = this.xmin, c = this.ymax;
          break;
        case 9:
          r = 1;
          continue;
        case 1:
          r = 5, a = this.xmin, c = this.ymin;
          break;
      }
      (i[s] !== a || i[s + 1] !== c) && this.contains(t, a, c) && (i.splice(s, 0, a, c), s += 2);
    }
    return s;
  }
  _project(t, r, o, i) {
    let s = 1 / 0, a, c, u;
    if (i < 0) {
      if (r <= this.ymin)
        return null;
      (a = (this.ymin - r) / i) < s && (u = this.ymin, c = t + (s = a) * o);
    } else if (i > 0) {
      if (r >= this.ymax)
        return null;
      (a = (this.ymax - r) / i) < s && (u = this.ymax, c = t + (s = a) * o);
    }
    if (o > 0) {
      if (t >= this.xmax)
        return null;
      (a = (this.xmax - t) / o) < s && (c = this.xmax, u = r + (s = a) * i);
    } else if (o < 0) {
      if (t <= this.xmin)
        return null;
      (a = (this.xmin - t) / o) < s && (c = this.xmin, u = r + (s = a) * i);
    }
    return [c, u];
  }
  _edgecode(t, r) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (r === this.ymin ? 4 : r === this.ymax ? 8 : 0);
  }
  _regioncode(t, r) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (r < this.ymin ? 4 : r > this.ymax ? 8 : 0);
  }
  _simplify(t) {
    if (t && t.length > 4) {
      for (let r = 0; r < t.length; r += 2) {
        const o = (r + 2) % t.length, i = (r + 4) % t.length;
        (t[r] === t[o] && t[o] === t[i] || t[r + 1] === t[o + 1] && t[o + 1] === t[i + 1]) && (t.splice(o, 2), r -= 2);
      }
      t.length || (t = null);
    }
    return t;
  }
}
const V0 = 2 * Math.PI, ht = Math.pow;
function G0(e) {
  return e[0];
}
function Y0(e) {
  return e[1];
}
function W0(e) {
  const { triangles: t, coords: r } = e;
  for (let o = 0; o < t.length; o += 3) {
    const i = 2 * t[o], s = 2 * t[o + 1], a = 2 * t[o + 2];
    if ((r[a] - r[i]) * (r[s + 1] - r[i + 1]) - (r[s] - r[i]) * (r[a + 1] - r[i + 1]) > 1e-10)
      return !1;
  }
  return !0;
}
function X0(e, t, r) {
  return [e + Math.sin(e + t) * r, t + Math.cos(e - t) * r];
}
class ni {
  static from(t, r = G0, o = Y0, i) {
    return new ni("length" in t ? B0(t, r, o, i) : Float64Array.from(K0(t, r, o, i)));
  }
  constructor(t) {
    this._delaunator = new zn(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator, r = this.points;
    if (t.hull && t.hull.length > 2 && W0(t)) {
      this.collinear = Int32Array.from({ length: r.length / 2 }, (d, p) => p).sort((d, p) => r[2 * d] - r[2 * p] || r[2 * d + 1] - r[2 * p + 1]);
      const u = this.collinear[0], l = this.collinear[this.collinear.length - 1], h = [r[2 * u], r[2 * u + 1], r[2 * l], r[2 * l + 1]], f = 1e-8 * Math.hypot(h[3] - h[1], h[2] - h[0]);
      for (let d = 0, p = r.length / 2; d < p; ++d) {
        const m = X0(r[2 * d], r[2 * d + 1], f);
        r[2 * d] = m[0], r[2 * d + 1] = m[1];
      }
      this._delaunator = new zn(r);
    } else
      delete this.collinear;
    const o = this.halfedges = this._delaunator.halfedges, i = this.hull = this._delaunator.hull, s = this.triangles = this._delaunator.triangles, a = this.inedges.fill(-1), c = this._hullIndex.fill(-1);
    for (let u = 0, l = o.length; u < l; ++u) {
      const h = s[u % 3 === 2 ? u - 2 : u + 1];
      (o[u] === -1 || a[h] === -1) && (a[h] = u);
    }
    for (let u = 0, l = i.length; u < l; ++u)
      c[i[u]] = u;
    i.length <= 2 && i.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = i[0], a[i[0]] = 1, i.length === 2 && (a[i[1]] = 0, this.triangles[1] = i[1], this.triangles[2] = i[1]));
  }
  voronoi(t) {
    return new H0(this, t);
  }
  *neighbors(t) {
    const { inedges: r, hull: o, _hullIndex: i, halfedges: s, triangles: a, collinear: c } = this;
    if (c) {
      const f = c.indexOf(t);
      f > 0 && (yield c[f - 1]), f < c.length - 1 && (yield c[f + 1]);
      return;
    }
    const u = r[t];
    if (u === -1)
      return;
    let l = u, h = -1;
    do {
      if (yield h = a[l], l = l % 3 === 2 ? l - 2 : l + 1, a[l] !== t)
        return;
      if (l = s[l], l === -1) {
        const f = o[(i[t] + 1) % o.length];
        f !== h && (yield f);
        return;
      }
    } while (l !== u);
  }
  find(t, r, o = 0) {
    if (t = +t, t !== t || (r = +r, r !== r))
      return -1;
    const i = o;
    let s;
    for (; (s = this._step(o, t, r)) >= 0 && s !== o && s !== i; )
      o = s;
    return s;
  }
  _step(t, r, o) {
    const { inedges: i, hull: s, _hullIndex: a, halfedges: c, triangles: u, points: l } = this;
    if (i[t] === -1 || !l.length)
      return (t + 1) % (l.length >> 1);
    let h = t, f = ht(r - l[t * 2], 2) + ht(o - l[t * 2 + 1], 2);
    const d = i[t];
    let p = d;
    do {
      let m = u[p];
      const g = ht(r - l[m * 2], 2) + ht(o - l[m * 2 + 1], 2);
      if (g < f && (f = g, h = m), p = p % 3 === 2 ? p - 2 : p + 1, u[p] !== t)
        break;
      if (p = c[p], p === -1) {
        if (p = s[(a[t] + 1) % s.length], p !== m && ht(r - l[p * 2], 2) + ht(o - l[p * 2 + 1], 2) < f)
          return p;
        break;
      }
    } while (p !== d);
    return h;
  }
  render(t) {
    const r = t == null ? t = new Je() : void 0, { points: o, halfedges: i, triangles: s } = this;
    for (let a = 0, c = i.length; a < c; ++a) {
      const u = i[a];
      if (u < a)
        continue;
      const l = s[a] * 2, h = s[u] * 2;
      t.moveTo(o[l], o[l + 1]), t.lineTo(o[h], o[h + 1]);
    }
    return this.renderHull(t), r && r.value();
  }
  renderPoints(t, r) {
    r === void 0 && (!t || typeof t.moveTo != "function") && (r = t, t = null), r = r == null ? 2 : +r;
    const o = t == null ? t = new Je() : void 0, { points: i } = this;
    for (let s = 0, a = i.length; s < a; s += 2) {
      const c = i[s], u = i[s + 1];
      t.moveTo(c + r, u), t.arc(c, u, r, 0, V0);
    }
    return o && o.value();
  }
  renderHull(t) {
    const r = t == null ? t = new Je() : void 0, { hull: o, points: i } = this, s = o[0] * 2, a = o.length;
    t.moveTo(i[s], i[s + 1]);
    for (let c = 1; c < a; ++c) {
      const u = 2 * o[c];
      t.lineTo(i[u], i[u + 1]);
    }
    return t.closePath(), r && r.value();
  }
  hullPolygon() {
    const t = new uo();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, r) {
    const o = r == null ? r = new Je() : void 0, { points: i, triangles: s } = this, a = s[t *= 3] * 2, c = s[t + 1] * 2, u = s[t + 2] * 2;
    return r.moveTo(i[a], i[a + 1]), r.lineTo(i[c], i[c + 1]), r.lineTo(i[u], i[u + 1]), r.closePath(), o && o.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let r = 0, o = t.length / 3; r < o; ++r)
      yield this.trianglePolygon(r);
  }
  trianglePolygon(t) {
    const r = new uo();
    return this.renderTriangle(t, r), r.value();
  }
}
function B0(e, t, r, o) {
  const i = e.length, s = new Float64Array(i * 2);
  for (let a = 0; a < i; ++a) {
    const c = e[a];
    s[a * 2] = t.call(o, c, a, e), s[a * 2 + 1] = r.call(o, c, a, e);
  }
  return s;
}
function* K0(e, t, r, o) {
  let i = 0;
  for (const s of e)
    yield t.call(o, s, i, e), yield r.call(o, s, i, e), ++i;
}
const xr = ({
  svgRef: e,
  params: t,
  store: r,
  instance: o
}) => {
  var T;
  const {
    disableVoronoi: i,
    voronoiMaxRadius: s,
    onItemClick: a
  } = t, c = V(r, Ue), {
    axis: u,
    axisIds: l
  } = V(r, at), {
    axis: h,
    axisIds: f
  } = V(r, ct), d = V(r, Ga), {
    series: p,
    seriesOrder: m
  } = ((T = V(r, Ee)) == null ? void 0 : T.scatter) ?? {}, g = A.useRef({}), y = A.useRef(void 0), b = A.useRef(void 0), O = l[0], x = f[0];
  Ae(() => {
    r.update((v) => v.voronoi.isVoronoiEnabled === !i ? v : k({}, v, {
      voronoi: {
        isVoronoiEnabled: !i
      }
    }));
  }, [r, i]), Ae(() => {
    if (d || m === void 0 || p === void 0 || i)
      return;
    g.current = {};
    let v = [];
    m.forEach((S) => {
      const {
        data: C,
        xAxisId: P,
        yAxisId: I
      } = p[S], L = u[P ?? O].scale, R = h[I ?? x].scale, $ = Xe(L), N = Xe(R), E = C.flatMap(({
        x: D,
        y: U
      }) => {
        const z = $(D), Z = N(U);
        return o.isPointInside(z, Z) ? [z, Z] : [-c.width, -c.height];
      });
      g.current[S] = {
        seriesId: S,
        startIndex: v.length,
        endIndex: v.length + E.length
      }, v = v.concat(E);
    }), y.current = new ni(v), b.current = void 0;
  }, [d, O, x, p, m, u, h, c, o, i]), A.useEffect(() => {
    if (e.current === null || i)
      return;
    const v = e.current;
    function S(L) {
      const R = oo(v, L);
      if (!o.isPointInside(R.x, R.y))
        return b.current = void 0, "outside-chart";
      if (!y.current)
        return "no-point-found";
      const $ = y.current.find(R.x, R.y, b.current);
      if ($ === void 0)
        return "no-point-found";
      b.current = $;
      const N = Object.values(g.current).find((D) => 2 * $ >= D.startIndex && 2 * $ < D.endIndex);
      if (N === void 0)
        return "no-point-found";
      const E = (2 * $ - g.current[N.seriesId].startIndex) / 2;
      if (s !== void 0) {
        const D = y.current.points[2 * $], U = y.current.points[2 * $ + 1];
        if ((D - R.x) ** 2 + (U - R.y) ** 2 > s ** 2)
          return "outside-voronoi-max-radius";
      }
      return {
        seriesId: N.seriesId,
        dataIndex: E
      };
    }
    const C = () => {
      var L, R;
      (L = o.cleanInteraction) == null || L.call(o), (R = o.clearHighlight) == null || R.call(o);
    }, P = (L) => {
      var E, D, U, z, Z, re;
      const R = S(L);
      if (R === "outside-chart") {
        (E = o.cleanInteraction) == null || E.call(o), (D = o.clearHighlight) == null || D.call(o);
        return;
      }
      if (R === "outside-voronoi-max-radius" || R === "no-point-found") {
        (U = o.removeItemInteraction) == null || U.call(o), (z = o.clearHighlight) == null || z.call(o);
        return;
      }
      const {
        seriesId: $,
        dataIndex: N
      } = R;
      (Z = o.setItemInteraction) == null || Z.call(o, {
        type: "scatter",
        seriesId: $,
        dataIndex: N
      }), (re = o.setHighlight) == null || re.call(o, {
        seriesId: $,
        dataIndex: N
      });
    }, I = (L) => {
      if (!a)
        return;
      const R = S(L);
      if (typeof R == "string")
        return;
      const {
        seriesId: $,
        dataIndex: N
      } = R;
      a(L, {
        type: "scatter",
        seriesId: $,
        dataIndex: N
      });
    };
    return v.addEventListener("pointerleave", C), v.addEventListener("pointermove", P), v.addEventListener("click", I), () => {
      v.removeEventListener("pointerleave", C), v.removeEventListener("pointermove", P), v.removeEventListener("click", I);
    };
  }, [e, h, u, s, a, i, c, o]);
  const _ = Ye(() => {
    r.update((v) => k({}, v, {
      voronoi: k({}, v.voronoi, {
        isVoronoiEnabled: !0
      })
    }));
  }), M = Ye(() => {
    r.update((v) => k({}, v, {
      voronoi: k({}, v.voronoi, {
        isVoronoiEnabled: !1
      })
    }));
  });
  return {
    instance: {
      enableVoronoi: _,
      disableVoronoi: M
    }
  };
};
xr.getDefaultizedParams = ({
  params: e
}) => k({}, e, {
  disableVoronoi: e.disableVoronoi ?? !e.series.some((t) => t.type === "scatter")
});
xr.getInitialState = (e) => ({
  voronoi: {
    isVoronoiEnabled: !e.disableVoronoi
  }
});
xr.params = {
  disableVoronoi: !0,
  voronoiMaxRadius: !0,
  onItemClick: !0
};
const ml = [Jt, Et, Qt, Rt, xr], Z0 = ["width", "height", "margin", "children", "series", "colors", "dataset", "desc", "onAxisClick", "disableVoronoi", "voronoiMaxRadius", "onItemClick", "disableAxisListener", "highlightedItem", "onHighlightChange", "sx", "title", "xAxis", "yAxis", "zAxis", "rotationAxis", "radiusAxis", "skipAnimation", "seriesConfig", "plugins", "localeText", "slots", "slotProps"], Q0 = (e, t) => {
  const r = e, {
    width: o,
    height: i,
    margin: s,
    children: a,
    series: c,
    colors: u,
    dataset: l,
    desc: h,
    onAxisClick: f,
    disableVoronoi: d,
    voronoiMaxRadius: p,
    onItemClick: m,
    disableAxisListener: g,
    highlightedItem: y,
    onHighlightChange: b,
    sx: O,
    title: x,
    xAxis: _,
    yAxis: M,
    zAxis: T,
    rotationAxis: v,
    radiusAxis: S,
    skipAnimation: C,
    seriesConfig: P,
    plugins: I,
    localeText: L,
    slots: R,
    slotProps: $
  } = r, N = B(r, Z0), E = k({
    title: x,
    desc: h,
    sx: O,
    ref: t
  }, N);
  return {
    chartDataProviderProps: {
      margin: s,
      series: c,
      colors: u,
      dataset: l,
      disableAxisListener: g,
      highlightedItem: y,
      onHighlightChange: b,
      onAxisClick: f,
      disableVoronoi: d,
      voronoiMaxRadius: p,
      onItemClick: m,
      xAxis: _,
      yAxis: M,
      zAxis: T,
      rotationAxis: v,
      radiusAxis: S,
      skipAnimation: C,
      width: o,
      height: i,
      localeText: L,
      seriesConfig: P,
      plugins: I ?? ml,
      slots: R,
      slotProps: $
    },
    chartsSurfaceProps: E,
    children: a
  };
}, J0 = {
  baseButton: kl,
  baseIconButton: _l
}, eb = {}, tb = k({}, J0, eb), gl = /* @__PURE__ */ A.createContext(null);
"production".NODE_ENV !== "production" && (gl.displayName = "ChartsSlotsContext");
function nb(e) {
  const {
    slots: t,
    slotProps: r = {},
    defaultSlots: o,
    children: i
  } = e, s = A.useMemo(() => ({
    slots: k({}, o, t),
    slotProps: r
  }), [o, t, r]);
  return /* @__PURE__ */ w.jsx(gl.Provider, {
    value: s,
    children: i
  });
}
const rb = ["children", "localeText", "plugins", "seriesConfig", "slots", "slotProps"], ob = (e) => {
  const {
    children: t,
    localeText: r,
    plugins: o = ml,
    seriesConfig: i,
    slots: s,
    slotProps: a
  } = e, c = B(e, rb), u = It(), l = {
    plugins: o,
    seriesConfig: i,
    pluginParams: k({
      theme: u.palette.mode
    }, c)
  };
  return {
    children: t,
    localeText: r,
    chartProviderProps: l,
    slots: s,
    slotProps: a
  };
};
function yl(e) {
  const {
    children: t,
    localeText: r,
    chartProviderProps: o,
    slots: i,
    slotProps: s
  } = ob(e);
  return /* @__PURE__ */ w.jsx(Im, k({}, o, {
    children: /* @__PURE__ */ w.jsx(wc, {
      localeText: r,
      children: /* @__PURE__ */ w.jsx(nb, {
        slots: i,
        slotProps: s,
        defaultSlots: tb,
        children: t
      })
    })
  }));
}
"production".NODE_ENV !== "production" && (yl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: n.shape({
    current: n.any
  }),
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: n.oneOfType([n.arrayOf(n.string), n.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: n.arrayOf(n.object),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: n.number,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: n.string,
  /**
   * Localized text for chart components.
   */
  localeText: n.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: n.oneOfType([n.number, n.shape({
    bottom: n.number,
    left: n.number,
    right: n.number,
    top: n.number
  })]),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: n.arrayOf(n.object),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: n.bool,
  /**
   * The props for the slots.
   */
  slotProps: n.object,
  /**
   * Slots to customize charts' components.
   */
  slots: n.object,
  theme: n.oneOf(["dark", "light"]),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: n.number
});
function Is(e) {
  const {
    isReversed: t,
    gradientId: r,
    size: o,
    direction: i,
    scale: s,
    colorMap: a
  } = e;
  return o <= 0 ? null : /* @__PURE__ */ w.jsx("linearGradient", {
    id: r,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${i}${t ? 1 : 2}`]: `${o}px`,
    gradientUnits: "userSpaceOnUse",
    children: a.thresholds.map((c, u) => {
      const l = s(c);
      if (l === void 0)
        return null;
      const h = t ? 1 - l / o : l / o;
      return Number.isNaN(h) ? null : /* @__PURE__ */ w.jsxs(A.Fragment, {
        children: [/* @__PURE__ */ w.jsx("stop", {
          offset: h,
          stopColor: a.colors[u],
          stopOpacity: 1
        }), /* @__PURE__ */ w.jsx("stop", {
          offset: h,
          stopColor: a.colors[u + 1],
          stopOpacity: 1
        })]
      }, c.toString() + u);
    })
  });
}
const ib = 10;
function Ss(e) {
  const {
    gradientUnits: t,
    isReversed: r,
    gradientId: o,
    size: i,
    direction: s,
    scale: a,
    colorScale: c,
    colorMap: u
  } = e, l = [u.min ?? 0, u.max ?? 100], h = l.map(a).filter((m) => m !== void 0);
  if (h.length !== 2)
    return null;
  const f = typeof l[0] == "number" ? Tt(l[0], l[1]) : _o(l[0], l[1]), d = Math.round((Math.max(...h) - Math.min(...h)) / ib), p = `${l[0]}-${l[1]}-`;
  return /* @__PURE__ */ w.jsx("linearGradient", {
    id: o,
    x1: "0",
    x2: "0",
    y1: "0",
    y2: "0",
    [`${s}${r ? 1 : 2}`]: t === "objectBoundingBox" ? 1 : `${i}px`,
    gradientUnits: t ?? "userSpaceOnUse",
    children: Array.from({
      length: d + 1
    }, (m, g) => {
      const y = f(g / d);
      if (y === void 0)
        return null;
      const b = a(y);
      if (b === void 0)
        return null;
      const O = r ? 1 - b / i : b / i, x = c(y);
      return x === null ? null : /* @__PURE__ */ w.jsx("stop", {
        offset: O,
        stopColor: x,
        stopOpacity: 1
      }, p + g);
    })
  });
}
const sb = 10, ab = (e) => e ? {
  x1: "1",
  x2: "0",
  y1: "0",
  y2: "0"
} : {
  x1: "0",
  x2: "1",
  y1: "0",
  y2: "0"
};
function Wr(e) {
  const {
    isReversed: t,
    gradientId: r,
    colorScale: o,
    colorMap: i
  } = e, s = [i.min ?? 0, i.max ?? 100], a = typeof s[0] == "number" ? Tt(s[0], s[1]) : _o(s[0], s[1]), c = sb, u = `${s[0]}-${s[1]}-`;
  return /* @__PURE__ */ w.jsx("linearGradient", k({
    id: r
  }, ab(t), {
    gradientUnits: "objectBoundingBox",
    children: Array.from({
      length: c + 1
    }, (l, h) => {
      const f = h / c, d = a(f);
      if (d === void 0)
        return null;
      const p = o(d);
      return p === null ? null : /* @__PURE__ */ w.jsx("stop", {
        offset: f,
        stopColor: p,
        stopOpacity: 1
      }, u + h);
    })
  }));
}
function cb() {
  const {
    top: e,
    height: t,
    bottom: r,
    left: o,
    width: i,
    right: s
  } = Re(), a = e + t + r, c = o + i + s, u = Wo(), l = Tg(), {
    xAxis: h,
    xAxisIds: f
  } = je(), {
    yAxis: d,
    yAxisIds: p
  } = Pe(), {
    zAxis: m,
    zAxisIds: g
  } = Go(), y = p.filter((x) => d[x].colorMap !== void 0), b = f.filter((x) => h[x].colorMap !== void 0), O = g.filter((x) => m[x].colorMap !== void 0);
  return y.length === 0 && b.length === 0 && O.length === 0 ? null : /* @__PURE__ */ w.jsxs("defs", {
    children: [y.map((x) => {
      const _ = u(x), M = l(x), {
        colorMap: T,
        scale: v,
        colorScale: S,
        reverse: C
      } = d[x];
      return (T == null ? void 0 : T.type) === "piecewise" ? /* @__PURE__ */ w.jsx(Is, {
        isReversed: !C,
        scale: v,
        colorMap: T,
        size: a,
        gradientId: _,
        direction: "y"
      }, _) : (T == null ? void 0 : T.type) === "continuous" ? /* @__PURE__ */ w.jsxs(A.Fragment, {
        children: [/* @__PURE__ */ w.jsx(Ss, {
          isReversed: !C,
          scale: v,
          colorScale: S,
          colorMap: T,
          size: a,
          gradientId: _,
          direction: "y"
        }), /* @__PURE__ */ w.jsx(Wr, {
          isReversed: C,
          colorScale: S,
          colorMap: T,
          gradientId: M
        })]
      }, _) : null;
    }), b.map((x) => {
      const _ = u(x), M = l(x), {
        colorMap: T,
        scale: v,
        reverse: S,
        colorScale: C
      } = h[x];
      return (T == null ? void 0 : T.type) === "piecewise" ? /* @__PURE__ */ w.jsx(Is, {
        isReversed: S,
        scale: v,
        colorMap: T,
        size: c,
        gradientId: _,
        direction: "x"
      }, _) : (T == null ? void 0 : T.type) === "continuous" ? /* @__PURE__ */ w.jsxs(A.Fragment, {
        children: [/* @__PURE__ */ w.jsx(Ss, {
          isReversed: S,
          scale: v,
          colorScale: C,
          colorMap: T,
          size: c,
          gradientId: _,
          direction: "x"
        }), /* @__PURE__ */ w.jsx(Wr, {
          isReversed: S,
          colorScale: C,
          colorMap: T,
          gradientId: M
        })]
      }, _) : null;
    }), O.map((x) => {
      const _ = l(x), {
        colorMap: M,
        colorScale: T
      } = m[x];
      return (M == null ? void 0 : M.type) === "continuous" ? /* @__PURE__ */ w.jsx(Wr, {
        colorScale: T,
        colorMap: M,
        gradientId: _
      }, _) : null;
    })]
  });
}
const lb = ["children", "className", "title", "desc"], ub = Q("svg", {
  name: "MuiChartsSurface",
  slot: "Root"
})(({
  ownerState: e
}) => ({
  width: e.width ?? "100%",
  height: e.height ?? "100%",
  display: "flex",
  position: "relative",
  flexDirection: "column",
  alignItems: "center",
  justifyContent: "center",
  overflow: "hidden",
  // This prevents default touch actions when using the svg on mobile devices.
  // For example, prevent page scroll & zoom.
  touchAction: "none"
})), ri = /* @__PURE__ */ A.forwardRef(function(t, r) {
  const o = K(), {
    width: i,
    height: s
  } = V(o, ff), {
    width: a,
    height: c
  } = V(o, ia), u = Yo(), l = go(u, r), h = ze({
    props: t,
    name: "MuiChartsSurface"
  }), {
    children: f,
    className: d,
    title: p,
    desc: m
  } = h, g = B(h, lb), y = s > 0 && i > 0;
  return /* @__PURE__ */ w.jsxs(ub, k({
    ownerState: {
      width: a,
      height: c
    },
    viewBox: `0 0 ${i} ${s}`,
    className: d
  }, g, {
    ref: l,
    children: [p && /* @__PURE__ */ w.jsx("title", {
      children: p
    }), m && /* @__PURE__ */ w.jsx("desc", {
      children: m
    }), /* @__PURE__ */ w.jsx(cb, {}), y && f]
  }));
});
"production".NODE_ENV !== "production" && (ri.displayName = "ChartsSurface");
"production".NODE_ENV !== "production" && (ri.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: n.node,
  className: n.string,
  desc: n.string,
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
  title: n.string
});
const fb = (e, t) => e === "vertical" ? (t == null ? void 0 : t.horizontal) === "start" ? "row" : "row-reverse" : (t == null ? void 0 : t.vertical) === "bottom" ? "column-reverse" : "column", db = (e, t) => {
  if (e === "vertical") {
    if ((t == null ? void 0 : t.vertical) === "top")
      return "flex-start";
    if ((t == null ? void 0 : t.vertical) === "bottom")
      return "flex-end";
  }
  if (e === "horizontal") {
    if ((t == null ? void 0 : t.horizontal) === "start")
      return "flex-start";
    if ((t == null ? void 0 : t.horizontal) === "end")
      return "flex-end";
  }
  return "center";
}, hb = Q("div", {
  name: "MuiChartsWrapper",
  slot: "Root",
  shouldForwardProp: (e) => wl(e) && e !== "extendVertically"
})(({
  ownerState: e
}) => ({
  display: "flex",
  flexDirection: fb(e.legendDirection, e.legendPosition),
  flex: 1,
  justifyContent: "center",
  alignItems: db(e.legendDirection, e.legendPosition),
  variants: [{
    props: {
      extendVertically: !0
    },
    style: {
      height: "100%"
    }
  }]
}));
function pb(e) {
  const {
    children: t,
    sx: r,
    extendVertically: o
  } = e, i = _g(), s = K(), {
    height: a
  } = V(s, ia);
  return /* @__PURE__ */ w.jsx(hb, {
    ref: i,
    ownerState: e,
    sx: r,
    extendVertically: o ?? a === void 0,
    children: t
  });
}
const bl = /* @__PURE__ */ A.forwardRef(function(t, r) {
  var T, v, S, C;
  const o = ze({
    props: t,
    name: "MuiLineChart"
  }), {
    chartsWrapperProps: i,
    chartContainerProps: s,
    gridProps: a,
    clipPathProps: c,
    clipPathGroupProps: u,
    areaPlotProps: l,
    linePlotProps: h,
    markPlotProps: f,
    overlayProps: d,
    chartsAxisProps: p,
    axisHighlightProps: m,
    lineHighlightPlotProps: g,
    legendProps: y,
    children: b
  } = A0(o), {
    chartDataProviderProps: O,
    chartsSurfaceProps: x
  } = Q0(s, r), _ = ((T = o.slots) == null ? void 0 : T.tooltip) ?? sl, M = (v = o.slots) == null ? void 0 : v.toolbar;
  return /* @__PURE__ */ w.jsx(yl, k({}, O, {
    children: /* @__PURE__ */ w.jsxs(pb, k({}, i, {
      children: [o.showToolbar && M ? /* @__PURE__ */ w.jsx(M, k({}, (S = o.slotProps) == null ? void 0 : S.toolbar)) : null, !o.hideLegend && /* @__PURE__ */ w.jsx(ti, k({}, y)), /* @__PURE__ */ w.jsxs(ri, k({}, x, {
        children: [/* @__PURE__ */ w.jsx(pl, k({}, a)), /* @__PURE__ */ w.jsxs("g", k({}, u, {
          children: [/* @__PURE__ */ w.jsx(Ec, k({}, l)), /* @__PURE__ */ w.jsx(jc, k({}, h)), /* @__PURE__ */ w.jsx(C0, k({}, d)), /* @__PURE__ */ w.jsx(ll, k({}, m))]
        })), /* @__PURE__ */ w.jsx(el, k({}, p)), /* @__PURE__ */ w.jsx("g", {
          "data-drawing-container": !0,
          children: /* @__PURE__ */ w.jsx(qc, k({}, f))
        }), /* @__PURE__ */ w.jsx(dl, k({}, g)), /* @__PURE__ */ w.jsx(ul, k({}, c)), b]
      })), !o.loading && /* @__PURE__ */ w.jsx(_, k({}, (C = o.slotProps) == null ? void 0 : C.tooltip))]
    }))
  }));
});
"production".NODE_ENV !== "production" && (bl.displayName = "LineChart");
"production".NODE_ENV !== "production" && (bl.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: n.shape({
    current: n.object
  }),
  /**
   * The configuration of axes highlight.
   * @see See {@link https://mui.com/x/react-charts/highlighting/ highlighting docs} for more details.
   * @default { x: 'line' }
   */
  axisHighlight: n.shape({
    x: n.oneOf(["band", "line", "none"]),
    y: n.oneOf(["band", "line", "none"])
  }),
  children: n.node,
  className: n.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: n.oneOfType([n.arrayOf(n.string), n.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: n.arrayOf(n.object),
  desc: n.string,
  /**
   * If `true`, the charts will not listen to the mouse move event.
   * It might break interactive features, but will improve performance.
   * @default false
   */
  disableAxisListener: n.bool,
  /**
   * If `true`, render the line highlight item.
   */
  disableLineItemHighlight: n.bool,
  /**
   * Option to display a cartesian grid in the background.
   */
  grid: n.shape({
    horizontal: n.bool,
    vertical: n.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: n.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: n.bool,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: n.shape({
    dataIndex: n.number,
    seriesId: n.oneOfType([n.number, n.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: n.string,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: n.bool,
  /**
   * Localized text for chart components.
   */
  localeText: n.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: n.oneOfType([n.number, n.shape({
    bottom: n.number,
    left: n.number,
    right: n.number,
    top: n.number
  })]),
  /**
   * Callback fired when an area element is clicked.
   */
  onAreaClick: n.func,
  /**
   * The function called for onClick events.
   * The second argument contains information about all line/bar elements at the current mouse position.
   * @param {MouseEvent} event The mouse event recorded on the `<svg/>` element.
   * @param {null | ChartsAxisData} data The data about the clicked axis and items associated with it.
   */
  onAxisClick: n.func,
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: n.func,
  /**
   * Callback fired when a line element is clicked.
   */
  onLineClick: n.func,
  /**
   * Callback fired when a mark element is clicked.
   */
  onMarkClick: n.func,
  /**
   * The series to display in the line chart.
   * An array of [[LineSeriesType]] objects.
   */
  series: n.arrayOf(n.object).isRequired,
  /**
   * If true, shows the default chart toolbar.
   * @default false
   */
  showToolbar: n.bool,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: n.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: n.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: n.object,
  sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
  theme: n.oneOf(["dark", "light"]),
  title: n.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: n.number,
  /**
   * The configuration of the x-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  xAxis: n.arrayOf(n.oneOfType([n.shape({
    axis: n.oneOf(["x"]),
    barGapRatio: n.number,
    categoryGapRatio: n.number,
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      colors: n.arrayOf(n.string).isRequired,
      type: n.oneOf(["ordinal"]).isRequired,
      unknownColor: n.string,
      values: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number, n.string]).isRequired)
    }), n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["band"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  }), n.shape({
    axis: n.oneOf(["x"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      colors: n.arrayOf(n.string).isRequired,
      type: n.oneOf(["ordinal"]).isRequired,
      unknownColor: n.string,
      values: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number, n.string]).isRequired)
    }), n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["point"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  }), n.shape({
    axis: n.oneOf(["x"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["log"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  }), n.shape({
    axis: n.oneOf(["x"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["pow"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  }), n.shape({
    axis: n.oneOf(["x"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["sqrt"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  }), n.shape({
    axis: n.oneOf(["x"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["time"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  }), n.shape({
    axis: n.oneOf(["x"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["utc"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  }), n.shape({
    axis: n.oneOf(["x"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    height: n.number,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["bottom", "none", "top"]),
    reverse: n.bool,
    scaleType: n.oneOf(["linear"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelMinGap: n.number,
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func
  })]).isRequired),
  /**
   * The configuration of the y-axes.
   * If not provided, a default axis config is used.
   * An array of [[AxisConfig]] objects.
   */
  yAxis: n.arrayOf(n.oneOfType([n.shape({
    axis: n.oneOf(["y"]),
    barGapRatio: n.number,
    categoryGapRatio: n.number,
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      colors: n.arrayOf(n.string).isRequired,
      type: n.oneOf(["ordinal"]).isRequired,
      unknownColor: n.string,
      values: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number, n.string]).isRequired)
    }), n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["band"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  }), n.shape({
    axis: n.oneOf(["y"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      colors: n.arrayOf(n.string).isRequired,
      type: n.oneOf(["ordinal"]).isRequired,
      unknownColor: n.string,
      values: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number, n.string]).isRequired)
    }), n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["point"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  }), n.shape({
    axis: n.oneOf(["y"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["log"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  }), n.shape({
    axis: n.oneOf(["y"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["pow"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  }), n.shape({
    axis: n.oneOf(["y"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["sqrt"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  }), n.shape({
    axis: n.oneOf(["y"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["time"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  }), n.shape({
    axis: n.oneOf(["y"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["utc"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  }), n.shape({
    axis: n.oneOf(["y"]),
    classes: n.object,
    colorMap: n.oneOfType([n.shape({
      color: n.oneOfType([n.arrayOf(n.string.isRequired), n.func]).isRequired,
      max: n.oneOfType([n.instanceOf(Date), n.number]),
      min: n.oneOfType([n.instanceOf(Date), n.number]),
      type: n.oneOf(["continuous"]).isRequired
    }), n.shape({
      colors: n.arrayOf(n.string).isRequired,
      thresholds: n.arrayOf(n.oneOfType([n.instanceOf(Date), n.number]).isRequired).isRequired,
      type: n.oneOf(["piecewise"]).isRequired
    })]),
    data: n.array,
    dataKey: n.string,
    disableLine: n.bool,
    disableTicks: n.bool,
    domainLimit: n.oneOfType([n.oneOf(["nice", "strict"]), n.func]),
    fill: n.string,
    hideTooltip: n.bool,
    id: n.oneOfType([n.number, n.string]),
    ignoreTooltip: n.bool,
    label: n.string,
    labelStyle: n.object,
    max: n.oneOfType([n.instanceOf(Date), n.number]),
    min: n.oneOfType([n.instanceOf(Date), n.number]),
    offset: n.number,
    position: n.oneOf(["left", "none", "right"]),
    reverse: n.bool,
    scaleType: n.oneOf(["linear"]),
    slotProps: n.object,
    slots: n.object,
    stroke: n.string,
    sx: n.oneOfType([n.arrayOf(n.oneOfType([n.func, n.object, n.bool])), n.func, n.object]),
    tickInterval: n.oneOfType([n.oneOf(["auto"]), n.array, n.func]),
    tickLabelInterval: n.oneOfType([n.oneOf(["auto"]), n.func]),
    tickLabelPlacement: n.oneOf(["middle", "tick"]),
    tickLabelStyle: n.object,
    tickMaxStep: n.number,
    tickMinStep: n.number,
    tickNumber: n.number,
    tickPlacement: n.oneOf(["end", "extremities", "middle", "start"]),
    tickSize: n.number,
    valueFormatter: n.func,
    width: n.number
  })]).isRequired)
});
export {
  bl as PuiLineChart
};
//# sourceMappingURL=charts.js.map
