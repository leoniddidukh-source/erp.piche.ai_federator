var Jy = Object.defineProperty;
var t0 = (l, e, t) => e in l ? Jy(l, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : l[e] = t;
var vt = (l, e, t) => (t0(l, typeof e != "symbol" ? e + "" : e, t), t), cf = (l, e, t) => {
  if (!e.has(l))
    throw TypeError("Cannot " + t);
};
var o = (l, e, t) => (cf(l, e, "read from private field"), t ? t.call(l) : e.get(l)), y = (l, e, t) => {
  if (e.has(l))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(l) : e.set(l, t);
}, E = (l, e, t, s) => (cf(l, e, "write to private field"), s ? s.call(l, t) : e.set(l, t), t);
var Te = (l, e, t, s) => ({
  set _(i) {
    E(l, e, i, t);
  },
  get _() {
    return o(l, e, s);
  }
}), x = (l, e, t) => (cf(l, e, "access private method"), t);
import { Z as Lo, V as Wp, j as rt, P as Jt, a6 as e0, h as Xu, E as qu, s as s0 } from "./Button-518a0ca9.js";
import { useRef as _s, useState as Mi, useEffect as Pt, forwardRef as lm, createContext as hm, useReducer as i0, useImperativeHandle as r0, useCallback as Si, useMemo as ns, useContext as cm, useLayoutEffect as n0 } from "react";
import { hA as Kc, z as Be, P as a0, hC as pg, V as Zc, Q as o0, x as l0, a2 as h0, W as gg, B as dm, D as ur, l as c0 } from "./utils-98f79634.js";
import { d as d0, a as $p, b as u0, e as f0, f as mg, P as bg, c as p0, g as g0 } from "./VideoPlayer-3d0be307.js";
import "react-dom";
var Vt = /* @__PURE__ */ ((l) => (l.Image = "image", l.Pdf = "pdf", l.Video = "video", l.Doc = "doc", l.Csv = "csv", l.General = "general", l))(Vt || {}), Qu = /* @__PURE__ */ ((l) => (l.Small = "small", l.Medium = "medium", l.Large = "large", l))(Qu || {});
const yg = {
  webp: Vt.Image,
  png: Vt.Image,
  jpg: Vt.Image,
  jpeg: Vt.Image,
  svg: Vt.Image,
  pdf: Vt.Pdf,
  mp4: Vt.Video,
  webm: Vt.Video,
  ogg: Vt.Video,
  doc: Vt.Doc,
  docx: Vt.Doc,
  csv: Vt.Csv
}, m0 = (l) => {
  var t;
  const e = (t = l.split(".").pop()) == null ? void 0 : t.toLowerCase();
  return e && e in yg ? yg[e] : Vt.General;
};
var um = { exports: {} };
/* @license
Papa Parse
v5.5.2
https://github.com/mholt/PapaParse
License: MIT
*/
(function(l, e) {
  ((t, s) => {
    l.exports = s();
  })(Lo, function t() {
    var s = typeof self < "u" ? self : typeof window < "u" ? window : s !== void 0 ? s : {}, i, r = !s.document && !!s.postMessage, n = s.IS_PAPA_WORKER || !1, a = {}, h = 0, c = {};
    function d(M) {
      this._handle = null, this._finished = !1, this._completed = !1, this._halted = !1, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = !0, this._completeResults = { data: [], errors: [], meta: {} }, (function(S) {
        var L = N(S);
        L.chunkSize = parseInt(L.chunkSize), S.step || S.chunk || (L.chunkSize = null), this._handle = new g(L), (this._handle.streamer = this)._config = L;
      }).call(this, M), this.parseChunk = function(S, L) {
        var H = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && 0 < H) {
          let F = this._config.newline;
          F || (I = this._config.quoteChar || '"', F = this._handle.guessLineEndings(S, I)), S = [...S.split(F).slice(H)].join(F);
        }
        this.isFirstChunk && P(this._config.beforeFirstChunk) && (I = this._config.beforeFirstChunk(S)) !== void 0 && (S = I), this.isFirstChunk = !1, this._halted = !1;
        var H = this._partialLine + S, I = (this._partialLine = "", this._handle.parse(H, this._baseIndex, !this._finished));
        if (!this._handle.paused() && !this._handle.aborted()) {
          if (S = I.meta.cursor, H = (this._finished || (this._partialLine = H.substring(S - this._baseIndex), this._baseIndex = S), I && I.data && (this._rowCount += I.data.length), this._finished || this._config.preview && this._rowCount >= this._config.preview), n)
            s.postMessage({ results: I, workerId: c.WORKER_ID, finished: H });
          else if (P(this._config.chunk) && !L) {
            if (this._config.chunk(I, this._handle), this._handle.paused() || this._handle.aborted())
              return void (this._halted = !0);
            this._completeResults = I = void 0;
          }
          return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(I.data), this._completeResults.errors = this._completeResults.errors.concat(I.errors), this._completeResults.meta = I.meta), this._completed || !H || !P(this._config.complete) || I && I.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = !0), H || I && I.meta.paused || this._nextChunk(), I;
        }
        this._halted = !0;
      }, this._sendError = function(S) {
        P(this._config.error) ? this._config.error(S) : n && this._config.error && s.postMessage({ workerId: c.WORKER_ID, error: S, finished: !1 });
      };
    }
    function u(M) {
      var S;
      (M = M || {}).chunkSize || (M.chunkSize = c.RemoteChunkSize), d.call(this, M), this._nextChunk = r ? function() {
        this._readChunk(), this._chunkLoaded();
      } : function() {
        this._readChunk();
      }, this.stream = function(L) {
        this._input = L, this._nextChunk();
      }, this._readChunk = function() {
        if (this._finished)
          this._chunkLoaded();
        else {
          if (S = new XMLHttpRequest(), this._config.withCredentials && (S.withCredentials = this._config.withCredentials), r || (S.onload = R(this._chunkLoaded, this), S.onerror = R(this._chunkError, this)), S.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !r), this._config.downloadRequestHeaders) {
            var L, H = this._config.downloadRequestHeaders;
            for (L in H)
              S.setRequestHeader(L, H[L]);
          }
          var I;
          this._config.chunkSize && (I = this._start + this._config.chunkSize - 1, S.setRequestHeader("Range", "bytes=" + this._start + "-" + I));
          try {
            S.send(this._config.downloadRequestBody);
          } catch (F) {
            this._chunkError(F.message);
          }
          r && S.status === 0 && this._chunkError();
        }
      }, this._chunkLoaded = function() {
        S.readyState === 4 && (S.status < 200 || 400 <= S.status ? this._chunkError() : (this._start += this._config.chunkSize || S.responseText.length, this._finished = !this._config.chunkSize || this._start >= ((L) => (L = L.getResponseHeader("Content-Range")) !== null ? parseInt(L.substring(L.lastIndexOf("/") + 1)) : -1)(S), this.parseChunk(S.responseText)));
      }, this._chunkError = function(L) {
        L = S.statusText || L, this._sendError(new Error(L));
      };
    }
    function f(M) {
      (M = M || {}).chunkSize || (M.chunkSize = c.LocalChunkSize), d.call(this, M);
      var S, L, H = typeof FileReader < "u";
      this.stream = function(I) {
        this._input = I, L = I.slice || I.webkitSlice || I.mozSlice, H ? ((S = new FileReader()).onload = R(this._chunkLoaded, this), S.onerror = R(this._chunkError, this)) : S = new FileReaderSync(), this._nextChunk();
      }, this._nextChunk = function() {
        this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
      }, this._readChunk = function() {
        var I = this._input, F = (this._config.chunkSize && (F = Math.min(this._start + this._config.chunkSize, this._input.size), I = L.call(I, this._start, F)), S.readAsText(I, this._config.encoding));
        H || this._chunkLoaded({ target: { result: F } });
      }, this._chunkLoaded = function(I) {
        this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(I.target.result);
      }, this._chunkError = function() {
        this._sendError(S.error);
      };
    }
    function p(M) {
      var S;
      d.call(this, M = M || {}), this.stream = function(L) {
        return S = L, this._nextChunk();
      }, this._nextChunk = function() {
        var L, H;
        if (!this._finished)
          return L = this._config.chunkSize, S = L ? (H = S.substring(0, L), S.substring(L)) : (H = S, ""), this._finished = !S, this.parseChunk(H);
      };
    }
    function m(M) {
      d.call(this, M = M || {});
      var S = [], L = !0, H = !1;
      this.pause = function() {
        d.prototype.pause.apply(this, arguments), this._input.pause();
      }, this.resume = function() {
        d.prototype.resume.apply(this, arguments), this._input.resume();
      }, this.stream = function(I) {
        this._input = I, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
      }, this._checkIsFinished = function() {
        H && S.length === 1 && (this._finished = !0);
      }, this._nextChunk = function() {
        this._checkIsFinished(), S.length ? this.parseChunk(S.shift()) : L = !0;
      }, this._streamData = R(function(I) {
        try {
          S.push(typeof I == "string" ? I : I.toString(this._config.encoding)), L && (L = !1, this._checkIsFinished(), this.parseChunk(S.shift()));
        } catch (F) {
          this._streamError(F);
        }
      }, this), this._streamError = R(function(I) {
        this._streamCleanUp(), this._sendError(I);
      }, this), this._streamEnd = R(function() {
        this._streamCleanUp(), H = !0, this._streamData("");
      }, this), this._streamCleanUp = R(function() {
        this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
      }, this);
    }
    function g(M) {
      var S, L, H, I, F = Math.pow(2, 53), A = -F, G = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, et = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, z = this, K = 0, Y = 0, ot = !1, B = !1, O = [], q = { data: [], errors: [], meta: {} };
      function tt(at) {
        return M.skipEmptyLines === "greedy" ? at.join("").trim() === "" : at.length === 1 && at[0].length === 0;
      }
      function J() {
        if (q && H && (ft("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + c.DefaultDelimiter + "'"), H = !1), M.skipEmptyLines && (q.data = q.data.filter(function(ct) {
          return !tt(ct);
        })), ut()) {
          let ct = function(Et, gt) {
            P(M.transformHeader) && (Et = M.transformHeader(Et, gt)), O.push(Et);
          };
          if (q)
            if (Array.isArray(q.data[0])) {
              for (var at = 0; ut() && at < q.data.length; at++)
                q.data[at].forEach(ct);
              q.data.splice(0, 1);
            } else
              q.data.forEach(ct);
        }
        function lt(ct, Et) {
          for (var gt = M.header ? {} : [], v = 0; v < ct.length; v++) {
            var V = v, U = ct[v], U = ((D, T) => ((j) => (M.dynamicTypingFunction && M.dynamicTyping[j] === void 0 && (M.dynamicTyping[j] = M.dynamicTypingFunction(j)), (M.dynamicTyping[j] || M.dynamicTyping) === !0))(D) ? T === "true" || T === "TRUE" || T !== "false" && T !== "FALSE" && (((j) => {
              if (G.test(j) && (j = parseFloat(j), A < j && j < F))
                return 1;
            })(T) ? parseFloat(T) : et.test(T) ? new Date(T) : T === "" ? null : T) : T)(V = M.header ? v >= O.length ? "__parsed_extra" : O[v] : V, U = M.transform ? M.transform(U, V) : U);
            V === "__parsed_extra" ? (gt[V] = gt[V] || [], gt[V].push(U)) : gt[V] = U;
          }
          return M.header && (v > O.length ? ft("FieldMismatch", "TooManyFields", "Too many fields: expected " + O.length + " fields but parsed " + v, Y + Et) : v < O.length && ft("FieldMismatch", "TooFewFields", "Too few fields: expected " + O.length + " fields but parsed " + v, Y + Et)), gt;
        }
        var dt;
        q && (M.header || M.dynamicTyping || M.transform) && (dt = 1, !q.data.length || Array.isArray(q.data[0]) ? (q.data = q.data.map(lt), dt = q.data.length) : q.data = lt(q.data, 0), M.header && q.meta && (q.meta.fields = O), Y += dt);
      }
      function ut() {
        return M.header && O.length === 0;
      }
      function ft(at, lt, dt, ct) {
        at = { type: at, code: lt, message: dt }, ct !== void 0 && (at.row = ct), q.errors.push(at);
      }
      P(M.step) && (I = M.step, M.step = function(at) {
        q = at, ut() ? J() : (J(), q.data.length !== 0 && (K += at.data.length, M.preview && K > M.preview ? L.abort() : (q.data = q.data[0], I(q, z))));
      }), this.parse = function(at, lt, dt) {
        var ct = M.quoteChar || '"', ct = (M.newline || (M.newline = this.guessLineEndings(at, ct)), H = !1, M.delimiter ? P(M.delimiter) && (M.delimiter = M.delimiter(at), q.meta.delimiter = M.delimiter) : ((ct = ((Et, gt, v, V, U) => {
          var D, T, j, Q;
          U = U || [",", "	", "|", ";", c.RECORD_SEP, c.UNIT_SEP];
          for (var Z = 0; Z < U.length; Z++) {
            for (var $, it = U[Z], nt = 0, st = 0, ht = 0, yt = (j = void 0, new b({ comments: V, delimiter: it, newline: gt, preview: 10 }).parse(Et)), bt = 0; bt < yt.data.length; bt++)
              v && tt(yt.data[bt]) ? ht++ : ($ = yt.data[bt].length, st += $, j === void 0 ? j = $ : 0 < $ && (nt += Math.abs($ - j), j = $));
            0 < yt.data.length && (st /= yt.data.length - ht), (T === void 0 || nt <= T) && (Q === void 0 || Q < st) && 1.99 < st && (T = nt, D = it, Q = st);
          }
          return { successful: !!(M.delimiter = D), bestDelimiter: D };
        })(at, M.newline, M.skipEmptyLines, M.comments, M.delimitersToGuess)).successful ? M.delimiter = ct.bestDelimiter : (H = !0, M.delimiter = c.DefaultDelimiter), q.meta.delimiter = M.delimiter), N(M));
        return M.preview && M.header && ct.preview++, S = at, L = new b(ct), q = L.parse(S, lt, dt), J(), ot ? { meta: { paused: !0 } } : q || { meta: { paused: !1 } };
      }, this.paused = function() {
        return ot;
      }, this.pause = function() {
        ot = !0, L.abort(), S = P(M.chunk) ? "" : S.substring(L.getCharIndex());
      }, this.resume = function() {
        z.streamer._halted ? (ot = !1, z.streamer.parseChunk(S, !0)) : setTimeout(z.resume, 3);
      }, this.aborted = function() {
        return B;
      }, this.abort = function() {
        B = !0, L.abort(), q.meta.aborted = !0, P(M.complete) && M.complete(q), S = "";
      }, this.guessLineEndings = function(Et, ct) {
        Et = Et.substring(0, 1048576);
        var ct = new RegExp(w(ct) + "([^]*?)" + w(ct), "gm"), dt = (Et = Et.replace(ct, "")).split("\r"), ct = Et.split(`
`), Et = 1 < ct.length && ct[0].length < dt[0].length;
        if (dt.length === 1 || Et)
          return `
`;
        for (var gt = 0, v = 0; v < dt.length; v++)
          dt[v][0] === `
` && gt++;
        return gt >= dt.length / 2 ? `\r
` : "\r";
      };
    }
    function w(M) {
      return M.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function b(M) {
      var S = (M = M || {}).delimiter, L = M.newline, H = M.comments, I = M.step, F = M.preview, A = M.fastMode, G = null, et = !1, z = M.quoteChar == null ? '"' : M.quoteChar, K = z;
      if (M.escapeChar !== void 0 && (K = M.escapeChar), (typeof S != "string" || -1 < c.BAD_DELIMITERS.indexOf(S)) && (S = ","), H === S)
        throw new Error("Comment character same as delimiter");
      H === !0 ? H = "#" : (typeof H != "string" || -1 < c.BAD_DELIMITERS.indexOf(H)) && (H = !1), L !== `
` && L !== "\r" && L !== `\r
` && (L = `
`);
      var Y = 0, ot = !1;
      this.parse = function(B, O, q) {
        if (typeof B != "string")
          throw new Error("Input must be a string");
        var tt = B.length, J = S.length, ut = L.length, ft = H.length, at = P(I), lt = [], dt = [], ct = [], Et = Y = 0;
        if (!B)
          return nt();
        if (A || A !== !1 && B.indexOf(z) === -1) {
          for (var gt = B.split(L), v = 0; v < gt.length; v++) {
            if (ct = gt[v], Y += ct.length, v !== gt.length - 1)
              Y += L.length;
            else if (q)
              return nt();
            if (!H || ct.substring(0, ft) !== H) {
              if (at) {
                if (lt = [], Q(ct.split(S)), st(), ot)
                  return nt();
              } else
                Q(ct.split(S));
              if (F && F <= v)
                return lt = lt.slice(0, F), nt(!0);
            }
          }
          return nt();
        }
        for (var V = B.indexOf(S, Y), U = B.indexOf(L, Y), D = new RegExp(w(K) + w(z), "g"), T = B.indexOf(z, Y); ; )
          if (B[Y] === z)
            for (T = Y, Y++; ; ) {
              if ((T = B.indexOf(z, T + 1)) === -1)
                return q || dt.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: lt.length, index: Y }), $();
              if (T === tt - 1)
                return $(B.substring(Y, T).replace(D, z));
              if (z === K && B[T + 1] === K)
                T++;
              else if (z === K || T === 0 || B[T - 1] !== K) {
                V !== -1 && V < T + 1 && (V = B.indexOf(S, T + 1));
                var j = Z((U = U !== -1 && U < T + 1 ? B.indexOf(L, T + 1) : U) === -1 ? V : Math.min(V, U));
                if (B.substr(T + 1 + j, J) === S) {
                  ct.push(B.substring(Y, T).replace(D, z)), B[Y = T + 1 + j + J] !== z && (T = B.indexOf(z, Y)), V = B.indexOf(S, Y), U = B.indexOf(L, Y);
                  break;
                }
                if (j = Z(U), B.substring(T + 1 + j, T + 1 + j + ut) === L) {
                  if (ct.push(B.substring(Y, T).replace(D, z)), it(T + 1 + j + ut), V = B.indexOf(S, Y), T = B.indexOf(z, Y), at && (st(), ot))
                    return nt();
                  if (F && lt.length >= F)
                    return nt(!0);
                  break;
                }
                dt.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: lt.length, index: Y }), T++;
              }
            }
          else if (H && ct.length === 0 && B.substring(Y, Y + ft) === H) {
            if (U === -1)
              return nt();
            Y = U + ut, U = B.indexOf(L, Y), V = B.indexOf(S, Y);
          } else if (V !== -1 && (V < U || U === -1))
            ct.push(B.substring(Y, V)), Y = V + J, V = B.indexOf(S, Y);
          else {
            if (U === -1)
              break;
            if (ct.push(B.substring(Y, U)), it(U + ut), at && (st(), ot))
              return nt();
            if (F && lt.length >= F)
              return nt(!0);
          }
        return $();
        function Q(ht) {
          lt.push(ht), Et = Y;
        }
        function Z(ht) {
          var yt = 0;
          return yt = ht !== -1 && (ht = B.substring(T + 1, ht)) && ht.trim() === "" ? ht.length : yt;
        }
        function $(ht) {
          return q || (ht === void 0 && (ht = B.substring(Y)), ct.push(ht), Y = tt, Q(ct), at && st()), nt();
        }
        function it(ht) {
          Y = ht, Q(ct), ct = [], U = B.indexOf(L, Y);
        }
        function nt(ht) {
          if (M.header && !O && lt.length && !et) {
            var yt = lt[0], bt = {}, Xt = new Set(yt);
            let Ze = !1;
            for (let pe = 0; pe < yt.length; pe++) {
              let we = yt[pe];
              if (bt[we = P(M.transformHeader) ? M.transformHeader(we, pe) : we]) {
                let Lt, br = bt[we];
                for (; Lt = we + "_" + br, br++, Xt.has(Lt); )
                  ;
                Xt.add(Lt), yt[pe] = Lt, bt[we]++, Ze = !0, (G = G === null ? {} : G)[Lt] = we;
              } else
                bt[we] = 1, yt[pe] = we;
              Xt.add(we);
            }
            Ze && console.warn("Duplicate headers found and renamed."), et = !0;
          }
          return { data: lt, errors: dt, meta: { delimiter: S, linebreak: L, aborted: ot, truncated: !!ht, cursor: Et + (O || 0), renamedHeaders: G } };
        }
        function st() {
          I(nt()), lt = [], dt = [];
        }
      }, this.abort = function() {
        ot = !0;
      }, this.getCharIndex = function() {
        return Y;
      };
    }
    function _(M) {
      var S = M.data, L = a[S.workerId], H = !1;
      if (S.error)
        L.userError(S.error, S.file);
      else if (S.results && S.results.data) {
        var I = { abort: function() {
          H = !0, k(S.workerId, { data: [], errors: [], meta: { aborted: !0 } });
        }, pause: C, resume: C };
        if (P(L.userStep)) {
          for (var F = 0; F < S.results.data.length && (L.userStep({ data: S.results.data[F], errors: S.results.errors, meta: S.results.meta }, I), !H); F++)
            ;
          delete S.results;
        } else
          P(L.userChunk) && (L.userChunk(S.results, I, S.file), delete S.results);
      }
      S.finished && !H && k(S.workerId, S.results);
    }
    function k(M, S) {
      var L = a[M];
      P(L.userComplete) && L.userComplete(S), L.terminate(), delete a[M];
    }
    function C() {
      throw new Error("Not implemented.");
    }
    function N(M) {
      if (typeof M != "object" || M === null)
        return M;
      var S, L = Array.isArray(M) ? [] : {};
      for (S in M)
        L[S] = N(M[S]);
      return L;
    }
    function R(M, S) {
      return function() {
        M.apply(S, arguments);
      };
    }
    function P(M) {
      return typeof M == "function";
    }
    return c.parse = function(M, S) {
      var L = (S = S || {}).dynamicTyping || !1;
      if (P(L) && (S.dynamicTypingFunction = L, L = {}), S.dynamicTyping = L, S.transform = !!P(S.transform) && S.transform, !S.worker || !c.WORKERS_SUPPORTED)
        return L = null, c.NODE_STREAM_INPUT, typeof M == "string" ? (M = ((H) => H.charCodeAt(0) !== 65279 ? H : H.slice(1))(M), L = new (S.download ? u : p)(S)) : M.readable === !0 && P(M.read) && P(M.on) ? L = new m(S) : (s.File && M instanceof File || M instanceof Object) && (L = new f(S)), L.stream(M);
      (L = (() => {
        var H;
        return !!c.WORKERS_SUPPORTED && (H = (() => {
          var I = s.URL || s.webkitURL || null, F = t.toString();
          return c.BLOB_URL || (c.BLOB_URL = I.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", F, ")();"], { type: "text/javascript" })));
        })(), (H = new s.Worker(H)).onmessage = _, H.id = h++, a[H.id] = H);
      })()).userStep = S.step, L.userChunk = S.chunk, L.userComplete = S.complete, L.userError = S.error, S.step = P(S.step), S.chunk = P(S.chunk), S.complete = P(S.complete), S.error = P(S.error), delete S.worker, L.postMessage({ input: M, config: S, workerId: L.id });
    }, c.unparse = function(M, S) {
      var L = !1, H = !0, I = ",", F = `\r
`, A = '"', G = A + A, et = !1, z = null, K = !1, Y = ((() => {
        if (typeof S == "object") {
          if (typeof S.delimiter != "string" || c.BAD_DELIMITERS.filter(function(O) {
            return S.delimiter.indexOf(O) !== -1;
          }).length || (I = S.delimiter), typeof S.quotes != "boolean" && typeof S.quotes != "function" && !Array.isArray(S.quotes) || (L = S.quotes), typeof S.skipEmptyLines != "boolean" && typeof S.skipEmptyLines != "string" || (et = S.skipEmptyLines), typeof S.newline == "string" && (F = S.newline), typeof S.quoteChar == "string" && (A = S.quoteChar), typeof S.header == "boolean" && (H = S.header), Array.isArray(S.columns)) {
            if (S.columns.length === 0)
              throw new Error("Option columns is empty");
            z = S.columns;
          }
          S.escapeChar !== void 0 && (G = S.escapeChar + A), S.escapeFormulae instanceof RegExp ? K = S.escapeFormulae : typeof S.escapeFormulae == "boolean" && S.escapeFormulae && (K = /^[=+\-@\t\r].*$/);
        }
      })(), new RegExp(w(A), "g"));
      if (typeof M == "string" && (M = JSON.parse(M)), Array.isArray(M)) {
        if (!M.length || Array.isArray(M[0]))
          return ot(null, M, et);
        if (typeof M[0] == "object")
          return ot(z || Object.keys(M[0]), M, et);
      } else if (typeof M == "object")
        return typeof M.data == "string" && (M.data = JSON.parse(M.data)), Array.isArray(M.data) && (M.fields || (M.fields = M.meta && M.meta.fields || z), M.fields || (M.fields = Array.isArray(M.data[0]) ? M.fields : typeof M.data[0] == "object" ? Object.keys(M.data[0]) : []), Array.isArray(M.data[0]) || typeof M.data[0] == "object" || (M.data = [M.data])), ot(M.fields || [], M.data || [], et);
      throw new Error("Unable to serialize unrecognized input");
      function ot(O, q, tt) {
        var J = "", ut = (typeof O == "string" && (O = JSON.parse(O)), typeof q == "string" && (q = JSON.parse(q)), Array.isArray(O) && 0 < O.length), ft = !Array.isArray(q[0]);
        if (ut && H) {
          for (var at = 0; at < O.length; at++)
            0 < at && (J += I), J += B(O[at], at);
          0 < q.length && (J += F);
        }
        for (var lt = 0; lt < q.length; lt++) {
          var dt = (ut ? O : q[lt]).length, ct = !1, Et = ut ? Object.keys(q[lt]).length === 0 : q[lt].length === 0;
          if (tt && !ut && (ct = tt === "greedy" ? q[lt].join("").trim() === "" : q[lt].length === 1 && q[lt][0].length === 0), tt === "greedy" && ut) {
            for (var gt = [], v = 0; v < dt; v++) {
              var V = ft ? O[v] : v;
              gt.push(q[lt][V]);
            }
            ct = gt.join("").trim() === "";
          }
          if (!ct) {
            for (var U = 0; U < dt; U++) {
              0 < U && !Et && (J += I);
              var D = ut && ft ? O[U] : U;
              J += B(q[lt][D], U);
            }
            lt < q.length - 1 && (!tt || 0 < dt && !Et) && (J += F);
          }
        }
        return J;
      }
      function B(O, q) {
        var tt, J;
        return O == null ? "" : O.constructor === Date ? JSON.stringify(O).slice(1, 25) : (J = !1, K && typeof O == "string" && K.test(O) && (O = "'" + O, J = !0), tt = O.toString().replace(Y, G), (J = J || L === !0 || typeof L == "function" && L(O, q) || Array.isArray(L) && L[q] || ((ut, ft) => {
          for (var at = 0; at < ft.length; at++)
            if (-1 < ut.indexOf(ft[at]))
              return !0;
          return !1;
        })(tt, c.BAD_DELIMITERS) || -1 < tt.indexOf(I) || tt.charAt(0) === " " || tt.charAt(tt.length - 1) === " ") ? A + tt + A : tt);
      }
    }, c.RECORD_SEP = String.fromCharCode(30), c.UNIT_SEP = String.fromCharCode(31), c.BYTE_ORDER_MARK = "\uFEFF", c.BAD_DELIMITERS = ["\r", `
`, '"', c.BYTE_ORDER_MARK], c.WORKERS_SUPPORTED = !r && !!s.Worker, c.NODE_STREAM_INPUT = 1, c.LocalChunkSize = 10485760, c.RemoteChunkSize = 5242880, c.DefaultDelimiter = ",", c.Parser = b, c.ParserHandle = g, c.NetworkStreamer = u, c.FileStreamer = f, c.StringStreamer = p, c.ReadableStreamStreamer = m, s.jQuery && ((i = s.jQuery).fn.parse = function(M) {
      var S = M.config || {}, L = [];
      return this.each(function(F) {
        if (!(i(this).prop("tagName").toUpperCase() === "INPUT" && i(this).attr("type").toLowerCase() === "file" && s.FileReader) || !this.files || this.files.length === 0)
          return !0;
        for (var A = 0; A < this.files.length; A++)
          L.push({ file: this.files[A], inputElem: this, instanceConfig: i.extend({}, S) });
      }), H(), this;
      function H() {
        if (L.length === 0)
          P(M.complete) && M.complete();
        else {
          var F, A, G, et, z = L[0];
          if (P(M.before)) {
            var K = M.before(z.file, z.inputElem);
            if (typeof K == "object") {
              if (K.action === "abort")
                return F = "AbortError", A = z.file, G = z.inputElem, et = K.reason, void (P(M.error) && M.error({ name: F }, A, G, et));
              if (K.action === "skip")
                return void I();
              typeof K.config == "object" && (z.instanceConfig = i.extend(z.instanceConfig, K.config));
            } else if (K === "skip")
              return void I();
          }
          var Y = z.instanceConfig.complete;
          z.instanceConfig.complete = function(ot) {
            P(Y) && Y(ot, z.file, z.inputElem), I();
          }, c.parse(z.file, z.instanceConfig);
        }
      }
      function I() {
        L.splice(0, 1), H();
      }
    }), n && (s.onmessage = function(M) {
      M = M.data, c.WORKER_ID === void 0 && M && (c.WORKER_ID = M.workerId), typeof M.input == "string" ? s.postMessage({ workerId: c.WORKER_ID, results: c.parse(M.input, M.config), finished: !0 }) : (s.File && M.input instanceof File || M.input instanceof Object) && (M = c.parse(M.input, M.config)) && s.postMessage({ workerId: c.WORKER_ID, results: M, finished: !0 });
    }), (u.prototype = Object.create(d.prototype)).constructor = u, (f.prototype = Object.create(d.prototype)).constructor = f, (p.prototype = Object.create(p.prototype)).constructor = p, (m.prototype = Object.create(d.prototype)).constructor = m, c;
  });
})(um);
var b0 = um.exports;
const y0 = /* @__PURE__ */ Wp(b0), v0 = 180, w0 = (l) => {
  const e = _s(null), [t, s] = Mi({ x: 0, y: 0 }), [i, r] = Mi(!1);
  return Pt(() => {
    l === 1 && s({
      x: 0,
      y: 0
    });
  }, [l]), Pt(() => {
    const n = e.current;
    if (!n)
      return;
    const a = () => {
      r(!0);
    }, h = () => {
      r(!1);
    }, c = (w) => {
      i && s((b) => ({
        x: b.x + w.movementX / l,
        y: b.y + w.movementY / l
      }));
    }, d = () => {
      r(!0);
    };
    let u = null;
    const f = (w) => {
      if (!i || w.touches.length !== 1)
        return;
      const b = w.touches[0];
      if (u) {
        const _ = b.clientX - u.clientX, k = b.clientY - u.clientY;
        s((C) => ({
          x: C.x + _ / l,
          y: C.y + k / l
        }));
      }
      u = b;
    }, p = () => {
      r(!1), u = null;
    }, m = new AbortController(), { signal: g } = m;
    return n.addEventListener("mousemove", c, { signal: g }), n.addEventListener("mousedown", a, { signal: g }), n.addEventListener("mouseup", h, { signal: g }), n.addEventListener("touchstart", d, { passive: !1, signal: g }), n.addEventListener("touchmove", f, { passive: !1, signal: g }), n.addEventListener("touchend", p, { signal: g }), () => {
      m.abort();
    };
  }, [i, l]), {
    overlayRef: e,
    position: t,
    setPosition: s,
    isMoving: i,
    setIsMoving: r
  };
}, A0 = ({ blob: l, rotate: e, scale: t }) => {
  const { overlayRef: s, position: i, isMoving: r } = w0(t);
  return /* @__PURE__ */ rt.jsxs(E0, { children: [
    /* @__PURE__ */ rt.jsx(
      x0,
      {
        isMoving: r,
        onDragStart: () => !1,
        draggable: !1,
        alt: "viewer",
        src: URL.createObjectURL(l),
        style: { transform: `rotate(${e}deg) scale(${t}) translate(${i.x}px, ${i.y}px)` },
        className: Kc({ rotated: e % v0 !== 0 })
      }
    ),
    /* @__PURE__ */ rt.jsx(
      I0,
      {
        draggable: !1,
        ref: s,
        isMoving: r
      }
    )
  ] });
}, _0 = lm(({ ...l }, e) => /* @__PURE__ */ rt.jsx(
  "div",
  {
    ref: e,
    ...l
  }
)), E0 = Jt(Be)(() => ({
  width: "100vw",
  height: "100vh",
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  justifyContent: "center"
})), x0 = Jt("img")(({ isMoving: l }) => ({
  width: "auto",
  height: "auto",
  maxWidth: "100vw",
  maxHeight: "100vh",
  objectFit: "contain",
  transformOrigin: "center",
  transition: l ? "" : "transform 0.3s ease, max-width 0.3s ease, max-height 0.3s ease",
  "&.rotated": { maxWidth: "100vh", maxHeight: "100vw" }
})), S0 = Jt(Be)(({ loaded: l }) => ({
  height: "calc(100vh - 70px)",
  overflow: "scroll",
  msOverflowStyle: "none",
  display: l ? "flex" : "none",
  alignItems: "center",
  zIndex: 1,
  "&.multi-page": {
    alignItems: "start"
  }
})), k0 = Jt(Be)(() => ({
  "&.multi-page": {
    marginBottom: "16px"
  }
})), M0 = Jt(Be)(() => ({
  width: "100vw",
  height: "100vh",
  display: "flex",
  overflow: "hidden",
  alignItems: "center",
  justifyContent: "center"
})), fm = Jt(Be)(() => ({
  width: "100vw",
  height: "100vh",
  display: "flex",
  overflow: "hidden",
  justifyContent: "center",
  alignItems: "center"
})), C0 = Jt(Be)(({ loaded: l }) => ({
  height: "calc(100vh - 70px)",
  overflowY: "scroll",
  overflowX: "auto",
  msOverflowStyle: "none",
  background: "#fff",
  display: l ? "block" : "none"
})), T0 = Jt(d0)(() => ({
  margin: "68px 76px 70px"
})), I0 = e0(
  _0,
  {
    shouldForwardProp: (l) => l !== "isMoving"
  }
)(({ isMoving: l }) => ({
  position: "fixed",
  top: "0",
  left: "0",
  height: "100vh",
  width: "100vw",
  zIndex: l ? 10 : 1,
  cursor: l ? "move" : ""
})), N0 = (l) => y0.parse(l, { skipEmptyLines: !0 }).data.map((t) => ({
  id: pg(),
  cells: t.map((s) => ({
    id: pg(),
    value: s
  }))
})), D0 = ({ blob: l }) => {
  var r;
  const [e, t] = Mi([]), s = (r = e[0]) == null ? void 0 : r.cells, i = e.slice(1);
  return Pt(() => {
    (async () => {
      const a = await l.text(), h = N0(a);
      t(h);
    })();
  }, [l]), e.length === 0 ? /* @__PURE__ */ rt.jsx($p, { size: 128 }) : /* @__PURE__ */ rt.jsx(fm, { children: /* @__PURE__ */ rt.jsx(T0, { component: a0, children: /* @__PURE__ */ rt.jsxs(
    u0,
    {
      size: "small",
      stickyHeader: !0,
      children: [
        /* @__PURE__ */ rt.jsx(f0, { children: /* @__PURE__ */ rt.jsx(mg, { children: s.map((n) => /* @__PURE__ */ rt.jsx(bg, { children: n.value }, n.id)) }) }),
        /* @__PURE__ */ rt.jsx(p0, { children: i.map((n) => /* @__PURE__ */ rt.jsx(
          mg,
          {
            hover: !0,
            children: n.cells.map((a) => /* @__PURE__ */ rt.jsx(bg, { children: a.value }, a.id))
          },
          n.id
        )) })
      ]
    }
  ) }) });
};
function uc(l) {
  throw new Error('Could not dynamically require "' + l + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pm = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(l, e) {
  (function(t) {
    l.exports = t();
  })(function() {
    return function t(s, i, r) {
      function n(c, d) {
        if (!i[c]) {
          if (!s[c]) {
            var u = typeof uc == "function" && uc;
            if (!d && u)
              return u(c, !0);
            if (a)
              return a(c, !0);
            var f = new Error("Cannot find module '" + c + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var p = i[c] = { exports: {} };
          s[c][0].call(p.exports, function(m) {
            var g = s[c][1][m];
            return n(g || m);
          }, p, p.exports, t, s, i, r);
        }
        return i[c].exports;
      }
      for (var a = typeof uc == "function" && uc, h = 0; h < r.length; h++)
        n(r[h]);
      return n;
    }({ 1: [function(t, s, i) {
      var r = t("./utils"), n = t("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(h) {
        for (var c, d, u, f, p, m, g, w = [], b = 0, _ = h.length, k = _, C = r.getTypeOf(h) !== "string"; b < h.length; )
          k = _ - b, u = C ? (c = h[b++], d = b < _ ? h[b++] : 0, b < _ ? h[b++] : 0) : (c = h.charCodeAt(b++), d = b < _ ? h.charCodeAt(b++) : 0, b < _ ? h.charCodeAt(b++) : 0), f = c >> 2, p = (3 & c) << 4 | d >> 4, m = 1 < k ? (15 & d) << 2 | u >> 6 : 64, g = 2 < k ? 63 & u : 64, w.push(a.charAt(f) + a.charAt(p) + a.charAt(m) + a.charAt(g));
        return w.join("");
      }, i.decode = function(h) {
        var c, d, u, f, p, m, g = 0, w = 0, b = "data:";
        if (h.substr(0, b.length) === b)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var _, k = 3 * (h = h.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (h.charAt(h.length - 1) === a.charAt(64) && k--, h.charAt(h.length - 2) === a.charAt(64) && k--, k % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (_ = n.uint8array ? new Uint8Array(0 | k) : new Array(0 | k); g < h.length; )
          c = a.indexOf(h.charAt(g++)) << 2 | (f = a.indexOf(h.charAt(g++))) >> 4, d = (15 & f) << 4 | (p = a.indexOf(h.charAt(g++))) >> 2, u = (3 & p) << 6 | (m = a.indexOf(h.charAt(g++))), _[w++] = c, p !== 64 && (_[w++] = d), m !== 64 && (_[w++] = u);
        return _;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, s, i) {
      var r = t("./external"), n = t("./stream/DataWorker"), a = t("./stream/Crc32Probe"), h = t("./stream/DataLengthProbe");
      function c(d, u, f, p, m) {
        this.compressedSize = d, this.uncompressedSize = u, this.crc32 = f, this.compression = p, this.compressedContent = m;
      }
      c.prototype = { getContentWorker: function() {
        var d = new n(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new h("data_length")), u = this;
        return d.on("end", function() {
          if (this.streamInfo.data_length !== u.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), d;
      }, getCompressedWorker: function() {
        return new n(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(d, u, f) {
        return d.pipe(new a()).pipe(new h("uncompressedSize")).pipe(u.compressWorker(f)).pipe(new h("compressedSize")).withStreamInfo("compression", u);
      }, s.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, s, i) {
      var r = t("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new r("STORE compression");
      }, uncompressWorker: function() {
        return new r("STORE decompression");
      } }, i.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, s, i) {
      var r = t("./utils"), n = function() {
        for (var a, h = [], c = 0; c < 256; c++) {
          a = c;
          for (var d = 0; d < 8; d++)
            a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          h[c] = a;
        }
        return h;
      }();
      s.exports = function(a, h) {
        return a !== void 0 && a.length ? r.getTypeOf(a) !== "string" ? function(c, d, u, f) {
          var p = n, m = f + u;
          c ^= -1;
          for (var g = f; g < m; g++)
            c = c >>> 8 ^ p[255 & (c ^ d[g])];
          return -1 ^ c;
        }(0 | h, a, a.length, 0) : function(c, d, u, f) {
          var p = n, m = f + u;
          c ^= -1;
          for (var g = f; g < m; g++)
            c = c >>> 8 ^ p[255 & (c ^ d.charCodeAt(g))];
          return -1 ^ c;
        }(0 | h, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, s, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(t, s, i) {
      var r = null;
      r = typeof Promise < "u" ? Promise : t("lie"), s.exports = { Promise: r };
    }, { lie: 37 }], 7: [function(t, s, i) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", n = t("pako"), a = t("./utils"), h = t("./stream/GenericWorker"), c = r ? "uint8array" : "array";
      function d(u, f) {
        h.call(this, "FlateWorker/" + u), this._pako = null, this._pakoAction = u, this._pakoOptions = f, this.meta = {};
      }
      i.magic = "\b\0", a.inherits(d, h), d.prototype.processChunk = function(u) {
        this.meta = u.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(c, u.data), !1);
      }, d.prototype.flush = function() {
        h.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, d.prototype.cleanUp = function() {
        h.prototype.cleanUp.call(this), this._pako = null;
      }, d.prototype._createPako = function() {
        this._pako = new n[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var u = this;
        this._pako.onData = function(f) {
          u.push({ data: f, meta: u.meta });
        };
      }, i.compressWorker = function(u) {
        return new d("Deflate", u);
      }, i.uncompressWorker = function() {
        return new d("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, s, i) {
      function r(p, m) {
        var g, w = "";
        for (g = 0; g < m; g++)
          w += String.fromCharCode(255 & p), p >>>= 8;
        return w;
      }
      function n(p, m, g, w, b, _) {
        var k, C, N = p.file, R = p.compression, P = _ !== c.utf8encode, M = a.transformTo("string", _(N.name)), S = a.transformTo("string", c.utf8encode(N.name)), L = N.comment, H = a.transformTo("string", _(L)), I = a.transformTo("string", c.utf8encode(L)), F = S.length !== N.name.length, A = I.length !== L.length, G = "", et = "", z = "", K = N.dir, Y = N.date, ot = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        m && !g || (ot.crc32 = p.crc32, ot.compressedSize = p.compressedSize, ot.uncompressedSize = p.uncompressedSize);
        var B = 0;
        m && (B |= 8), P || !F && !A || (B |= 2048);
        var O = 0, q = 0;
        K && (O |= 16), b === "UNIX" ? (q = 798, O |= function(J, ut) {
          var ft = J;
          return J || (ft = ut ? 16893 : 33204), (65535 & ft) << 16;
        }(N.unixPermissions, K)) : (q = 20, O |= function(J) {
          return 63 & (J || 0);
        }(N.dosPermissions)), k = Y.getUTCHours(), k <<= 6, k |= Y.getUTCMinutes(), k <<= 5, k |= Y.getUTCSeconds() / 2, C = Y.getUTCFullYear() - 1980, C <<= 4, C |= Y.getUTCMonth() + 1, C <<= 5, C |= Y.getUTCDate(), F && (et = r(1, 1) + r(d(M), 4) + S, G += "up" + r(et.length, 2) + et), A && (z = r(1, 1) + r(d(H), 4) + I, G += "uc" + r(z.length, 2) + z);
        var tt = "";
        return tt += `
\0`, tt += r(B, 2), tt += R.magic, tt += r(k, 2), tt += r(C, 2), tt += r(ot.crc32, 4), tt += r(ot.compressedSize, 4), tt += r(ot.uncompressedSize, 4), tt += r(M.length, 2), tt += r(G.length, 2), { fileRecord: u.LOCAL_FILE_HEADER + tt + M + G, dirRecord: u.CENTRAL_FILE_HEADER + r(q, 2) + tt + r(H.length, 2) + "\0\0\0\0" + r(O, 4) + r(w, 4) + M + G + H };
      }
      var a = t("../utils"), h = t("../stream/GenericWorker"), c = t("../utf8"), d = t("../crc32"), u = t("../signature");
      function f(p, m, g, w) {
        h.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = m, this.zipPlatform = g, this.encodeFileName = w, this.streamFiles = p, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(f, h), f.prototype.push = function(p) {
        var m = p.meta.percent || 0, g = this.entriesCount, w = this._sources.length;
        this.accumulate ? this.contentBuffer.push(p) : (this.bytesWritten += p.data.length, h.prototype.push.call(this, { data: p.data, meta: { currentFile: this.currentFile, percent: g ? (m + 100 * (g - w - 1)) / g : 100 } }));
      }, f.prototype.openedSource = function(p) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = p.file.name;
        var m = this.streamFiles && !p.file.dir;
        if (m) {
          var g = n(p, m, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: g.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, f.prototype.closedSource = function(p) {
        this.accumulate = !1;
        var m = this.streamFiles && !p.file.dir, g = n(p, m, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), m)
          this.push({ data: function(w) {
            return u.DATA_DESCRIPTOR + r(w.crc32, 4) + r(w.compressedSize, 4) + r(w.uncompressedSize, 4);
          }(p), meta: { percent: 100 } });
        else
          for (this.push({ data: g.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, f.prototype.flush = function() {
        for (var p = this.bytesWritten, m = 0; m < this.dirRecords.length; m++)
          this.push({ data: this.dirRecords[m], meta: { percent: 100 } });
        var g = this.bytesWritten - p, w = function(b, _, k, C, N) {
          var R = a.transformTo("string", N(C));
          return u.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(b, 2) + r(b, 2) + r(_, 4) + r(k, 4) + r(R.length, 2) + R;
        }(this.dirRecords.length, g, p, this.zipComment, this.encodeFileName);
        this.push({ data: w, meta: { percent: 100 } });
      }, f.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, f.prototype.registerPrevious = function(p) {
        this._sources.push(p);
        var m = this;
        return p.on("data", function(g) {
          m.processChunk(g);
        }), p.on("end", function() {
          m.closedSource(m.previous.streamInfo), m._sources.length ? m.prepareNextSource() : m.end();
        }), p.on("error", function(g) {
          m.error(g);
        }), this;
      }, f.prototype.resume = function() {
        return !!h.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, f.prototype.error = function(p) {
        var m = this._sources;
        if (!h.prototype.error.call(this, p))
          return !1;
        for (var g = 0; g < m.length; g++)
          try {
            m[g].error(p);
          } catch {
          }
        return !0;
      }, f.prototype.lock = function() {
        h.prototype.lock.call(this);
        for (var p = this._sources, m = 0; m < p.length; m++)
          p[m].lock();
      }, s.exports = f;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, s, i) {
      var r = t("../compressions"), n = t("./ZipFileWorker");
      i.generateWorker = function(a, h, c) {
        var d = new n(h.streamFiles, c, h.platform, h.encodeFileName), u = 0;
        try {
          a.forEach(function(f, p) {
            u++;
            var m = function(_, k) {
              var C = _ || k, N = r[C];
              if (!N)
                throw new Error(C + " is not a valid compression method !");
              return N;
            }(p.options.compression, h.compression), g = p.options.compressionOptions || h.compressionOptions || {}, w = p.dir, b = p.date;
            p._compressWorker(m, g).withStreamInfo("file", { name: f, dir: w, date: b, comment: p.comment || "", unixPermissions: p.unixPermissions, dosPermissions: p.dosPermissions }).pipe(d);
          }), d.entriesCount = u;
        } catch (f) {
          d.error(f);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, s, i) {
      function r() {
        if (!(this instanceof r))
          return new r();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var n = new r();
          for (var a in this)
            typeof this[a] != "function" && (n[a] = this[a]);
          return n;
        };
      }
      (r.prototype = t("./object")).loadAsync = t("./load"), r.support = t("./support"), r.defaults = t("./defaults"), r.version = "3.10.1", r.loadAsync = function(n, a) {
        return new r().loadAsync(n, a);
      }, r.external = t("./external"), s.exports = r;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, s, i) {
      var r = t("./utils"), n = t("./external"), a = t("./utf8"), h = t("./zipEntries"), c = t("./stream/Crc32Probe"), d = t("./nodejsUtils");
      function u(f) {
        return new n.Promise(function(p, m) {
          var g = f.decompressed.getContentWorker().pipe(new c());
          g.on("error", function(w) {
            m(w);
          }).on("end", function() {
            g.streamInfo.crc32 !== f.decompressed.crc32 ? m(new Error("Corrupted zip : CRC32 mismatch")) : p();
          }).resume();
        });
      }
      s.exports = function(f, p) {
        var m = this;
        return p = r.extend(p || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), d.isNode && d.isStream(f) ? n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", f, !0, p.optimizedBinaryString, p.base64).then(function(g) {
          var w = new h(p);
          return w.load(g), w;
        }).then(function(g) {
          var w = [n.Promise.resolve(g)], b = g.files;
          if (p.checkCRC32)
            for (var _ = 0; _ < b.length; _++)
              w.push(u(b[_]));
          return n.Promise.all(w);
        }).then(function(g) {
          for (var w = g.shift(), b = w.files, _ = 0; _ < b.length; _++) {
            var k = b[_], C = k.fileNameStr, N = r.resolve(k.fileNameStr);
            m.file(N, k.decompressed, { binary: !0, optimizedBinaryString: !0, date: k.date, dir: k.dir, comment: k.fileCommentStr.length ? k.fileCommentStr : null, unixPermissions: k.unixPermissions, dosPermissions: k.dosPermissions, createFolders: p.createFolders }), k.dir || (m.file(N).unsafeOriginalName = C);
          }
          return w.zipComment.length && (m.comment = w.zipComment), m;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, s, i) {
      var r = t("../utils"), n = t("../stream/GenericWorker");
      function a(h, c) {
        n.call(this, "Nodejs stream input adapter for " + h), this._upstreamEnded = !1, this._bindStream(c);
      }
      r.inherits(a, n), a.prototype._bindStream = function(h) {
        var c = this;
        (this._stream = h).pause(), h.on("data", function(d) {
          c.push({ data: d, meta: { percent: 0 } });
        }).on("error", function(d) {
          c.isPaused ? this.generatedError = d : c.error(d);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, a.prototype.pause = function() {
        return !!n.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!n.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, s.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, s, i) {
      var r = t("readable-stream").Readable;
      function n(a, h, c) {
        r.call(this, h), this._helper = a;
        var d = this;
        a.on("data", function(u, f) {
          d.push(u) || d._helper.pause(), c && c(f);
        }).on("error", function(u) {
          d.emit("error", u);
        }).on("end", function() {
          d.push(null);
        });
      }
      t("../utils").inherits(n, r), n.prototype._read = function() {
        this._helper.resume();
      }, s.exports = n;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, s, i) {
      s.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(r, n) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(r, n);
        if (typeof r == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(r, n);
      }, allocBuffer: function(r) {
        if (Buffer.alloc)
          return Buffer.alloc(r);
        var n = new Buffer(r);
        return n.fill(0), n;
      }, isBuffer: function(r) {
        return Buffer.isBuffer(r);
      }, isStream: function(r) {
        return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
      } };
    }, {}], 15: [function(t, s, i) {
      function r(N, R, P) {
        var M, S = a.getTypeOf(R), L = a.extend(P || {}, d);
        L.date = L.date || /* @__PURE__ */ new Date(), L.compression !== null && (L.compression = L.compression.toUpperCase()), typeof L.unixPermissions == "string" && (L.unixPermissions = parseInt(L.unixPermissions, 8)), L.unixPermissions && 16384 & L.unixPermissions && (L.dir = !0), L.dosPermissions && 16 & L.dosPermissions && (L.dir = !0), L.dir && (N = b(N)), L.createFolders && (M = w(N)) && _.call(this, M, !0);
        var H = S === "string" && L.binary === !1 && L.base64 === !1;
        P && P.binary !== void 0 || (L.binary = !H), (R instanceof u && R.uncompressedSize === 0 || L.dir || !R || R.length === 0) && (L.base64 = !1, L.binary = !0, R = "", L.compression = "STORE", S = "string");
        var I = null;
        I = R instanceof u || R instanceof h ? R : m.isNode && m.isStream(R) ? new g(N, R) : a.prepareContent(N, R, L.binary, L.optimizedBinaryString, L.base64);
        var F = new f(N, I, L);
        this.files[N] = F;
      }
      var n = t("./utf8"), a = t("./utils"), h = t("./stream/GenericWorker"), c = t("./stream/StreamHelper"), d = t("./defaults"), u = t("./compressedObject"), f = t("./zipObject"), p = t("./generate"), m = t("./nodejsUtils"), g = t("./nodejs/NodejsStreamInputAdapter"), w = function(N) {
        N.slice(-1) === "/" && (N = N.substring(0, N.length - 1));
        var R = N.lastIndexOf("/");
        return 0 < R ? N.substring(0, R) : "";
      }, b = function(N) {
        return N.slice(-1) !== "/" && (N += "/"), N;
      }, _ = function(N, R) {
        return R = R !== void 0 ? R : d.createFolders, N = b(N), this.files[N] || r.call(this, N, null, { dir: !0, createFolders: R }), this.files[N];
      };
      function k(N) {
        return Object.prototype.toString.call(N) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(N) {
        var R, P, M;
        for (R in this.files)
          M = this.files[R], (P = R.slice(this.root.length, R.length)) && R.slice(0, this.root.length) === this.root && N(P, M);
      }, filter: function(N) {
        var R = [];
        return this.forEach(function(P, M) {
          N(P, M) && R.push(M);
        }), R;
      }, file: function(N, R, P) {
        if (arguments.length !== 1)
          return N = this.root + N, r.call(this, N, R, P), this;
        if (k(N)) {
          var M = N;
          return this.filter(function(L, H) {
            return !H.dir && M.test(L);
          });
        }
        var S = this.files[this.root + N];
        return S && !S.dir ? S : null;
      }, folder: function(N) {
        if (!N)
          return this;
        if (k(N))
          return this.filter(function(S, L) {
            return L.dir && N.test(S);
          });
        var R = this.root + N, P = _.call(this, R), M = this.clone();
        return M.root = P.name, M;
      }, remove: function(N) {
        N = this.root + N;
        var R = this.files[N];
        if (R || (N.slice(-1) !== "/" && (N += "/"), R = this.files[N]), R && !R.dir)
          delete this.files[N];
        else
          for (var P = this.filter(function(S, L) {
            return L.name.slice(0, N.length) === N;
          }), M = 0; M < P.length; M++)
            delete this.files[P[M].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(N) {
        var R, P = {};
        try {
          if ((P = a.extend(N || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: n.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type)
            throw new Error("No output type specified.");
          a.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var M = P.comment || this.comment || "";
          R = p.generateWorker(this, P, M);
        } catch (S) {
          (R = new h("error")).error(S);
        }
        return new c(R, P.type || "string", P.mimeType);
      }, generateAsync: function(N, R) {
        return this.generateInternalStream(N).accumulate(R);
      }, generateNodeStream: function(N, R) {
        return (N = N || {}).type || (N.type = "nodebuffer"), this.generateInternalStream(N).toNodejsStream(R);
      } };
      s.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, s, i) {
      s.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, s, i) {
      var r = t("./DataReader");
      function n(a) {
        r.call(this, a);
        for (var h = 0; h < this.data.length; h++)
          a[h] = 255 & a[h];
      }
      t("../utils").inherits(n, r), n.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, n.prototype.lastIndexOfSignature = function(a) {
        for (var h = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), u = a.charCodeAt(3), f = this.length - 4; 0 <= f; --f)
          if (this.data[f] === h && this.data[f + 1] === c && this.data[f + 2] === d && this.data[f + 3] === u)
            return f - this.zero;
        return -1;
      }, n.prototype.readAndCheckSignature = function(a) {
        var h = a.charCodeAt(0), c = a.charCodeAt(1), d = a.charCodeAt(2), u = a.charCodeAt(3), f = this.readData(4);
        return h === f[0] && c === f[1] && d === f[2] && u === f[3];
      }, n.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return [];
        var h = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, h;
      }, s.exports = n;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, s, i) {
      var r = t("../utils");
      function n(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      n.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var h, c = 0;
        for (this.checkOffset(a), h = this.index + a - 1; h >= this.index; h--)
          c = (c << 8) + this.byteAt(h);
        return this.index += a, c;
      }, readString: function(a) {
        return r.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, s.exports = n;
    }, { "../utils": 32 }], 19: [function(t, s, i) {
      var r = t("./Uint8ArrayReader");
      function n(a) {
        r.call(this, a);
      }
      t("../utils").inherits(n, r), n.prototype.readData = function(a) {
        this.checkOffset(a);
        var h = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, h;
      }, s.exports = n;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, s, i) {
      var r = t("./DataReader");
      function n(a) {
        r.call(this, a);
      }
      t("../utils").inherits(n, r), n.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, n.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, n.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, n.prototype.readData = function(a) {
        this.checkOffset(a);
        var h = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, h;
      }, s.exports = n;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, s, i) {
      var r = t("./ArrayReader");
      function n(a) {
        r.call(this, a);
      }
      t("../utils").inherits(n, r), n.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return new Uint8Array(0);
        var h = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, h;
      }, s.exports = n;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, s, i) {
      var r = t("../utils"), n = t("../support"), a = t("./ArrayReader"), h = t("./StringReader"), c = t("./NodeBufferReader"), d = t("./Uint8ArrayReader");
      s.exports = function(u) {
        var f = r.getTypeOf(u);
        return r.checkSupport(f), f !== "string" || n.uint8array ? f === "nodebuffer" ? new c(u) : n.uint8array ? new d(r.transformTo("uint8array", u)) : new a(r.transformTo("array", u)) : new h(u);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, s, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, s, i) {
      var r = t("./GenericWorker"), n = t("../utils");
      function a(h) {
        r.call(this, "ConvertWorker to " + h), this.destType = h;
      }
      n.inherits(a, r), a.prototype.processChunk = function(h) {
        this.push({ data: n.transformTo(this.destType, h.data), meta: h.meta });
      }, s.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, s, i) {
      var r = t("./GenericWorker"), n = t("../crc32");
      function a() {
        r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(a, r), a.prototype.processChunk = function(h) {
        this.streamInfo.crc32 = n(h.data, this.streamInfo.crc32 || 0), this.push(h);
      }, s.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, s, i) {
      var r = t("../utils"), n = t("./GenericWorker");
      function a(h) {
        n.call(this, "DataLengthProbe for " + h), this.propName = h, this.withStreamInfo(h, 0);
      }
      r.inherits(a, n), a.prototype.processChunk = function(h) {
        if (h) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + h.data.length;
        }
        n.prototype.processChunk.call(this, h);
      }, s.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, s, i) {
      var r = t("../utils"), n = t("./GenericWorker");
      function a(h) {
        n.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, h.then(function(d) {
          c.dataIsReady = !0, c.data = d, c.max = d && d.length || 0, c.type = r.getTypeOf(d), c.isPaused || c._tickAndRepeat();
        }, function(d) {
          c.error(d);
        });
      }
      r.inherits(a, n), a.prototype.cleanUp = function() {
        n.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!n.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, r.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var h = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            h = this.data.substring(this.index, c);
            break;
          case "uint8array":
            h = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            h = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: h, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, s.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, s, i) {
      function r(n) {
        this.name = n || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      r.prototype = { push: function(n) {
        this.emit("data", n);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (n) {
          this.emit("error", n);
        }
        return !0;
      }, error: function(n) {
        return !this.isFinished && (this.isPaused ? this.generatedError = n : (this.isFinished = !0, this.emit("error", n), this.previous && this.previous.error(n), this.cleanUp()), !0);
      }, on: function(n, a) {
        return this._listeners[n].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(n, a) {
        if (this._listeners[n])
          for (var h = 0; h < this._listeners[n].length; h++)
            this._listeners[n][h].call(this, a);
      }, pipe: function(n) {
        return n.registerPrevious(this);
      }, registerPrevious: function(n) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = n.streamInfo, this.mergeStreamInfo(), this.previous = n;
        var a = this;
        return n.on("data", function(h) {
          a.processChunk(h);
        }), n.on("end", function() {
          a.end();
        }), n.on("error", function(h) {
          a.error(h);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var n = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), n = !0), this.previous && this.previous.resume(), !n;
      }, flush: function() {
      }, processChunk: function(n) {
        this.push(n);
      }, withStreamInfo: function(n, a) {
        return this.extraStreamInfo[n] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var n in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, n) && (this.streamInfo[n] = this.extraStreamInfo[n]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var n = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + n : n;
      } }, s.exports = r;
    }, {}], 29: [function(t, s, i) {
      var r = t("../utils"), n = t("./ConvertWorker"), a = t("./GenericWorker"), h = t("../base64"), c = t("../support"), d = t("../external"), u = null;
      if (c.nodestream)
        try {
          u = t("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function f(m, g) {
        return new d.Promise(function(w, b) {
          var _ = [], k = m._internalType, C = m._outputType, N = m._mimeType;
          m.on("data", function(R, P) {
            _.push(R), g && g(P);
          }).on("error", function(R) {
            _ = [], b(R);
          }).on("end", function() {
            try {
              var R = function(P, M, S) {
                switch (P) {
                  case "blob":
                    return r.newBlob(r.transformTo("arraybuffer", M), S);
                  case "base64":
                    return h.encode(M);
                  default:
                    return r.transformTo(P, M);
                }
              }(C, function(P, M) {
                var S, L = 0, H = null, I = 0;
                for (S = 0; S < M.length; S++)
                  I += M[S].length;
                switch (P) {
                  case "string":
                    return M.join("");
                  case "array":
                    return Array.prototype.concat.apply([], M);
                  case "uint8array":
                    for (H = new Uint8Array(I), S = 0; S < M.length; S++)
                      H.set(M[S], L), L += M[S].length;
                    return H;
                  case "nodebuffer":
                    return Buffer.concat(M);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(k, _), N);
              w(R);
            } catch (P) {
              b(P);
            }
            _ = [];
          }).resume();
        });
      }
      function p(m, g, w) {
        var b = g;
        switch (g) {
          case "blob":
          case "arraybuffer":
            b = "uint8array";
            break;
          case "base64":
            b = "string";
        }
        try {
          this._internalType = b, this._outputType = g, this._mimeType = w, r.checkSupport(b), this._worker = m.pipe(new n(b)), m.lock();
        } catch (_) {
          this._worker = new a("error"), this._worker.error(_);
        }
      }
      p.prototype = { accumulate: function(m) {
        return f(this, m);
      }, on: function(m, g) {
        var w = this;
        return m === "data" ? this._worker.on(m, function(b) {
          g.call(w, b.data, b.meta);
        }) : this._worker.on(m, function() {
          r.delay(g, arguments, w);
        }), this;
      }, resume: function() {
        return r.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(m) {
        if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new u(this, { objectMode: this._outputType !== "nodebuffer" }, m);
      } }, s.exports = p;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, s, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var r = new ArrayBuffer(0);
        try {
          i.blob = new Blob([r], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            n.append(r), i.blob = n.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!t("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(t, s, i) {
      for (var r = t("./utils"), n = t("./support"), a = t("./nodejsUtils"), h = t("./stream/GenericWorker"), c = new Array(256), d = 0; d < 256; d++)
        c[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      c[254] = c[254] = 1;
      function u() {
        h.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function f() {
        h.call(this, "utf-8 encode");
      }
      i.utf8encode = function(p) {
        return n.nodebuffer ? a.newBufferFrom(p, "utf-8") : function(m) {
          var g, w, b, _, k, C = m.length, N = 0;
          for (_ = 0; _ < C; _++)
            (64512 & (w = m.charCodeAt(_))) == 55296 && _ + 1 < C && (64512 & (b = m.charCodeAt(_ + 1))) == 56320 && (w = 65536 + (w - 55296 << 10) + (b - 56320), _++), N += w < 128 ? 1 : w < 2048 ? 2 : w < 65536 ? 3 : 4;
          for (g = n.uint8array ? new Uint8Array(N) : new Array(N), _ = k = 0; k < N; _++)
            (64512 & (w = m.charCodeAt(_))) == 55296 && _ + 1 < C && (64512 & (b = m.charCodeAt(_ + 1))) == 56320 && (w = 65536 + (w - 55296 << 10) + (b - 56320), _++), w < 128 ? g[k++] = w : (w < 2048 ? g[k++] = 192 | w >>> 6 : (w < 65536 ? g[k++] = 224 | w >>> 12 : (g[k++] = 240 | w >>> 18, g[k++] = 128 | w >>> 12 & 63), g[k++] = 128 | w >>> 6 & 63), g[k++] = 128 | 63 & w);
          return g;
        }(p);
      }, i.utf8decode = function(p) {
        return n.nodebuffer ? r.transformTo("nodebuffer", p).toString("utf-8") : function(m) {
          var g, w, b, _, k = m.length, C = new Array(2 * k);
          for (g = w = 0; g < k; )
            if ((b = m[g++]) < 128)
              C[w++] = b;
            else if (4 < (_ = c[b]))
              C[w++] = 65533, g += _ - 1;
            else {
              for (b &= _ === 2 ? 31 : _ === 3 ? 15 : 7; 1 < _ && g < k; )
                b = b << 6 | 63 & m[g++], _--;
              1 < _ ? C[w++] = 65533 : b < 65536 ? C[w++] = b : (b -= 65536, C[w++] = 55296 | b >> 10 & 1023, C[w++] = 56320 | 1023 & b);
            }
          return C.length !== w && (C.subarray ? C = C.subarray(0, w) : C.length = w), r.applyFromCharCode(C);
        }(p = r.transformTo(n.uint8array ? "uint8array" : "array", p));
      }, r.inherits(u, h), u.prototype.processChunk = function(p) {
        var m = r.transformTo(n.uint8array ? "uint8array" : "array", p.data);
        if (this.leftOver && this.leftOver.length) {
          if (n.uint8array) {
            var g = m;
            (m = new Uint8Array(g.length + this.leftOver.length)).set(this.leftOver, 0), m.set(g, this.leftOver.length);
          } else
            m = this.leftOver.concat(m);
          this.leftOver = null;
        }
        var w = function(_, k) {
          var C;
          for ((k = k || _.length) > _.length && (k = _.length), C = k - 1; 0 <= C && (192 & _[C]) == 128; )
            C--;
          return C < 0 || C === 0 ? k : C + c[_[C]] > k ? C : k;
        }(m), b = m;
        w !== m.length && (n.uint8array ? (b = m.subarray(0, w), this.leftOver = m.subarray(w, m.length)) : (b = m.slice(0, w), this.leftOver = m.slice(w, m.length))), this.push({ data: i.utf8decode(b), meta: p.meta });
      }, u.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = u, r.inherits(f, h), f.prototype.processChunk = function(p) {
        this.push({ data: i.utf8encode(p.data), meta: p.meta });
      }, i.Utf8EncodeWorker = f;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, s, i) {
      var r = t("./support"), n = t("./base64"), a = t("./nodejsUtils"), h = t("./external");
      function c(g) {
        return g;
      }
      function d(g, w) {
        for (var b = 0; b < g.length; ++b)
          w[b] = 255 & g.charCodeAt(b);
        return w;
      }
      t("setimmediate"), i.newBlob = function(g, w) {
        i.checkSupport("blob");
        try {
          return new Blob([g], { type: w });
        } catch {
          try {
            var b = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return b.append(g), b.getBlob(w);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var u = { stringifyByChunk: function(g, w, b) {
        var _ = [], k = 0, C = g.length;
        if (C <= b)
          return String.fromCharCode.apply(null, g);
        for (; k < C; )
          w === "array" || w === "nodebuffer" ? _.push(String.fromCharCode.apply(null, g.slice(k, Math.min(k + b, C)))) : _.push(String.fromCharCode.apply(null, g.subarray(k, Math.min(k + b, C)))), k += b;
        return _.join("");
      }, stringifyByChar: function(g) {
        for (var w = "", b = 0; b < g.length; b++)
          w += String.fromCharCode(g[b]);
        return w;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return r.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function f(g) {
        var w = 65536, b = i.getTypeOf(g), _ = !0;
        if (b === "uint8array" ? _ = u.applyCanBeUsed.uint8array : b === "nodebuffer" && (_ = u.applyCanBeUsed.nodebuffer), _)
          for (; 1 < w; )
            try {
              return u.stringifyByChunk(g, b, w);
            } catch {
              w = Math.floor(w / 2);
            }
        return u.stringifyByChar(g);
      }
      function p(g, w) {
        for (var b = 0; b < g.length; b++)
          w[b] = g[b];
        return w;
      }
      i.applyFromCharCode = f;
      var m = {};
      m.string = { string: c, array: function(g) {
        return d(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return m.string.uint8array(g).buffer;
      }, uint8array: function(g) {
        return d(g, new Uint8Array(g.length));
      }, nodebuffer: function(g) {
        return d(g, a.allocBuffer(g.length));
      } }, m.array = { string: f, array: c, arraybuffer: function(g) {
        return new Uint8Array(g).buffer;
      }, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return a.newBufferFrom(g);
      } }, m.arraybuffer = { string: function(g) {
        return f(new Uint8Array(g));
      }, array: function(g) {
        return p(new Uint8Array(g), new Array(g.byteLength));
      }, arraybuffer: c, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return a.newBufferFrom(new Uint8Array(g));
      } }, m.uint8array = { string: f, array: function(g) {
        return p(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return g.buffer;
      }, uint8array: c, nodebuffer: function(g) {
        return a.newBufferFrom(g);
      } }, m.nodebuffer = { string: f, array: function(g) {
        return p(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return m.nodebuffer.uint8array(g).buffer;
      }, uint8array: function(g) {
        return p(g, new Uint8Array(g.length));
      }, nodebuffer: c }, i.transformTo = function(g, w) {
        if (w = w || "", !g)
          return w;
        i.checkSupport(g);
        var b = i.getTypeOf(w);
        return m[b][g](w);
      }, i.resolve = function(g) {
        for (var w = g.split("/"), b = [], _ = 0; _ < w.length; _++) {
          var k = w[_];
          k === "." || k === "" && _ !== 0 && _ !== w.length - 1 || (k === ".." ? b.pop() : b.push(k));
        }
        return b.join("/");
      }, i.getTypeOf = function(g) {
        return typeof g == "string" ? "string" : Object.prototype.toString.call(g) === "[object Array]" ? "array" : r.nodebuffer && a.isBuffer(g) ? "nodebuffer" : r.uint8array && g instanceof Uint8Array ? "uint8array" : r.arraybuffer && g instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(g) {
        if (!r[g.toLowerCase()])
          throw new Error(g + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(g) {
        var w, b, _ = "";
        for (b = 0; b < (g || "").length; b++)
          _ += "\\x" + ((w = g.charCodeAt(b)) < 16 ? "0" : "") + w.toString(16).toUpperCase();
        return _;
      }, i.delay = function(g, w, b) {
        setImmediate(function() {
          g.apply(b || null, w || []);
        });
      }, i.inherits = function(g, w) {
        function b() {
        }
        b.prototype = w.prototype, g.prototype = new b();
      }, i.extend = function() {
        var g, w, b = {};
        for (g = 0; g < arguments.length; g++)
          for (w in arguments[g])
            Object.prototype.hasOwnProperty.call(arguments[g], w) && b[w] === void 0 && (b[w] = arguments[g][w]);
        return b;
      }, i.prepareContent = function(g, w, b, _, k) {
        return h.Promise.resolve(w).then(function(C) {
          return r.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new h.Promise(function(N, R) {
            var P = new FileReader();
            P.onload = function(M) {
              N(M.target.result);
            }, P.onerror = function(M) {
              R(M.target.error);
            }, P.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var N = i.getTypeOf(C);
          return N ? (N === "arraybuffer" ? C = i.transformTo("uint8array", C) : N === "string" && (k ? C = n.decode(C) : b && _ !== !0 && (C = function(R) {
            return d(R, r.uint8array ? new Uint8Array(R.length) : new Array(R.length));
          }(C))), C) : h.Promise.reject(new Error("Can't read the data of '" + g + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, s, i) {
      var r = t("./reader/readerFor"), n = t("./utils"), a = t("./signature"), h = t("./zipEntry"), c = t("./support");
      function d(u) {
        this.files = [], this.loadOptions = u;
      }
      d.prototype = { checkSignature: function(u) {
        if (!this.reader.readAndCheckSignature(u)) {
          this.reader.index -= 4;
          var f = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + n.pretty(f) + ", expected " + n.pretty(u) + ")");
        }
      }, isSignature: function(u, f) {
        var p = this.reader.index;
        this.reader.setIndex(u);
        var m = this.reader.readString(4) === f;
        return this.reader.setIndex(p), m;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var u = this.reader.readData(this.zipCommentLength), f = c.uint8array ? "uint8array" : "array", p = n.transformTo(f, u);
        this.zipComment = this.loadOptions.decodeFileName(p);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var u, f, p, m = this.zip64EndOfCentralSize - 44; 0 < m; )
          u = this.reader.readInt(2), f = this.reader.readInt(4), p = this.reader.readData(f), this.zip64ExtensibleData[u] = { id: u, length: f, value: p };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var u, f;
        for (u = 0; u < this.files.length; u++)
          f = this.files[u], this.reader.setIndex(f.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), f.readLocalPart(this.reader), f.handleUTF8(), f.processAttributes();
      }, readCentralDir: function() {
        var u;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
          (u = new h({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(u);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var u = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (u < 0)
          throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(u);
        var f = u;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === n.MAX_VALUE_16BITS || this.diskWithCentralDirStart === n.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === n.MAX_VALUE_16BITS || this.centralDirRecords === n.MAX_VALUE_16BITS || this.centralDirSize === n.MAX_VALUE_32BITS || this.centralDirOffset === n.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (u = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(u), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var p = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (p += 20, p += 12 + this.zip64EndOfCentralSize);
        var m = f - p;
        if (0 < m)
          this.isSignature(f, a.CENTRAL_FILE_HEADER) || (this.reader.zero = m);
        else if (m < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(m) + " bytes.");
      }, prepareReader: function(u) {
        this.reader = r(u);
      }, load: function(u) {
        this.prepareReader(u), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, s.exports = d;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, s, i) {
      var r = t("./reader/readerFor"), n = t("./utils"), a = t("./compressedObject"), h = t("./crc32"), c = t("./utf8"), d = t("./compressions"), u = t("./support");
      function f(p, m) {
        this.options = p, this.loadOptions = m;
      }
      f.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(p) {
        var m, g;
        if (p.skip(22), this.fileNameLength = p.readInt(2), g = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((m = function(w) {
          for (var b in d)
            if (Object.prototype.hasOwnProperty.call(d, b) && d[b].magic === w)
              return d[b];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + n.pretty(this.compressionMethod) + " unknown (inner file : " + n.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, m, p.readData(this.compressedSize));
      }, readCentralPart: function(p) {
        this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
        var m = p.readInt(2);
        if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        p.skip(m), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var p = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), p == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), p == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var p = r(this.extraFields[1].value);
          this.uncompressedSize === n.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === n.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === n.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === n.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
        }
      }, readExtraFields: function(p) {
        var m, g, w, b = p.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); p.index + 4 < b; )
          m = p.readInt(2), g = p.readInt(2), w = p.readData(g), this.extraFields[m] = { id: m, length: g, value: w };
        p.setIndex(b);
      }, handleUTF8: function() {
        var p = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var m = this.findExtraFieldUnicodePath();
          if (m !== null)
            this.fileNameStr = m;
          else {
            var g = n.transformTo(p, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(g);
          }
          var w = this.findExtraFieldUnicodeComment();
          if (w !== null)
            this.fileCommentStr = w;
          else {
            var b = n.transformTo(p, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(b);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var p = this.extraFields[28789];
        if (p) {
          var m = r(p.value);
          return m.readInt(1) !== 1 || h(this.fileName) !== m.readInt(4) ? null : c.utf8decode(m.readData(p.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var p = this.extraFields[25461];
        if (p) {
          var m = r(p.value);
          return m.readInt(1) !== 1 || h(this.fileComment) !== m.readInt(4) ? null : c.utf8decode(m.readData(p.length - 5));
        }
        return null;
      } }, s.exports = f;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, s, i) {
      function r(m, g, w) {
        this.name = m, this.dir = w.dir, this.date = w.date, this.comment = w.comment, this.unixPermissions = w.unixPermissions, this.dosPermissions = w.dosPermissions, this._data = g, this._dataBinary = w.binary, this.options = { compression: w.compression, compressionOptions: w.compressionOptions };
      }
      var n = t("./stream/StreamHelper"), a = t("./stream/DataWorker"), h = t("./utf8"), c = t("./compressedObject"), d = t("./stream/GenericWorker");
      r.prototype = { internalStream: function(m) {
        var g = null, w = "string";
        try {
          if (!m)
            throw new Error("No output type specified.");
          var b = (w = m.toLowerCase()) === "string" || w === "text";
          w !== "binarystring" && w !== "text" || (w = "string"), g = this._decompressWorker();
          var _ = !this._dataBinary;
          _ && !b && (g = g.pipe(new h.Utf8EncodeWorker())), !_ && b && (g = g.pipe(new h.Utf8DecodeWorker()));
        } catch (k) {
          (g = new d("error")).error(k);
        }
        return new n(g, w, "");
      }, async: function(m, g) {
        return this.internalStream(m).accumulate(g);
      }, nodeStream: function(m, g) {
        return this.internalStream(m || "nodebuffer").toNodejsStream(g);
      }, _compressWorker: function(m, g) {
        if (this._data instanceof c && this._data.compression.magic === m.magic)
          return this._data.getCompressedWorker();
        var w = this._decompressWorker();
        return this._dataBinary || (w = w.pipe(new h.Utf8EncodeWorker())), c.createWorkerFrom(w, m, g);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof d ? this._data : new a(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, p = 0; p < u.length; p++)
        r.prototype[u[p]] = f;
      s.exports = r;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, s, i) {
      (function(r) {
        var n, a, h = r.MutationObserver || r.WebKitMutationObserver;
        if (h) {
          var c = 0, d = new h(m), u = r.document.createTextNode("");
          d.observe(u, { characterData: !0 }), n = function() {
            u.data = c = ++c % 2;
          };
        } else if (r.setImmediate || r.MessageChannel === void 0)
          n = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
            var g = r.document.createElement("script");
            g.onreadystatechange = function() {
              m(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
            }, r.document.documentElement.appendChild(g);
          } : function() {
            setTimeout(m, 0);
          };
        else {
          var f = new r.MessageChannel();
          f.port1.onmessage = m, n = function() {
            f.port2.postMessage(0);
          };
        }
        var p = [];
        function m() {
          var g, w;
          a = !0;
          for (var b = p.length; b; ) {
            for (w = p, p = [], g = -1; ++g < b; )
              w[g]();
            b = p.length;
          }
          a = !1;
        }
        s.exports = function(g) {
          p.push(g) !== 1 || a || n();
        };
      }).call(this, typeof Lo < "u" ? Lo : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(t, s, i) {
      var r = t("immediate");
      function n() {
      }
      var a = {}, h = ["REJECTED"], c = ["FULFILLED"], d = ["PENDING"];
      function u(b) {
        if (typeof b != "function")
          throw new TypeError("resolver must be a function");
        this.state = d, this.queue = [], this.outcome = void 0, b !== n && g(this, b);
      }
      function f(b, _, k) {
        this.promise = b, typeof _ == "function" && (this.onFulfilled = _, this.callFulfilled = this.otherCallFulfilled), typeof k == "function" && (this.onRejected = k, this.callRejected = this.otherCallRejected);
      }
      function p(b, _, k) {
        r(function() {
          var C;
          try {
            C = _(k);
          } catch (N) {
            return a.reject(b, N);
          }
          C === b ? a.reject(b, new TypeError("Cannot resolve promise with itself")) : a.resolve(b, C);
        });
      }
      function m(b) {
        var _ = b && b.then;
        if (b && (typeof b == "object" || typeof b == "function") && typeof _ == "function")
          return function() {
            _.apply(b, arguments);
          };
      }
      function g(b, _) {
        var k = !1;
        function C(P) {
          k || (k = !0, a.reject(b, P));
        }
        function N(P) {
          k || (k = !0, a.resolve(b, P));
        }
        var R = w(function() {
          _(N, C);
        });
        R.status === "error" && C(R.value);
      }
      function w(b, _) {
        var k = {};
        try {
          k.value = b(_), k.status = "success";
        } catch (C) {
          k.status = "error", k.value = C;
        }
        return k;
      }
      (s.exports = u).prototype.finally = function(b) {
        if (typeof b != "function")
          return this;
        var _ = this.constructor;
        return this.then(function(k) {
          return _.resolve(b()).then(function() {
            return k;
          });
        }, function(k) {
          return _.resolve(b()).then(function() {
            throw k;
          });
        });
      }, u.prototype.catch = function(b) {
        return this.then(null, b);
      }, u.prototype.then = function(b, _) {
        if (typeof b != "function" && this.state === c || typeof _ != "function" && this.state === h)
          return this;
        var k = new this.constructor(n);
        return this.state !== d ? p(k, this.state === c ? b : _, this.outcome) : this.queue.push(new f(k, b, _)), k;
      }, f.prototype.callFulfilled = function(b) {
        a.resolve(this.promise, b);
      }, f.prototype.otherCallFulfilled = function(b) {
        p(this.promise, this.onFulfilled, b);
      }, f.prototype.callRejected = function(b) {
        a.reject(this.promise, b);
      }, f.prototype.otherCallRejected = function(b) {
        p(this.promise, this.onRejected, b);
      }, a.resolve = function(b, _) {
        var k = w(m, _);
        if (k.status === "error")
          return a.reject(b, k.value);
        var C = k.value;
        if (C)
          g(b, C);
        else {
          b.state = c, b.outcome = _;
          for (var N = -1, R = b.queue.length; ++N < R; )
            b.queue[N].callFulfilled(_);
        }
        return b;
      }, a.reject = function(b, _) {
        b.state = h, b.outcome = _;
        for (var k = -1, C = b.queue.length; ++k < C; )
          b.queue[k].callRejected(_);
        return b;
      }, u.resolve = function(b) {
        return b instanceof this ? b : a.resolve(new this(n), b);
      }, u.reject = function(b) {
        var _ = new this(n);
        return a.reject(_, b);
      }, u.all = function(b) {
        var _ = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var k = b.length, C = !1;
        if (!k)
          return this.resolve([]);
        for (var N = new Array(k), R = 0, P = -1, M = new this(n); ++P < k; )
          S(b[P], P);
        return M;
        function S(L, H) {
          _.resolve(L).then(function(I) {
            N[H] = I, ++R !== k || C || (C = !0, a.resolve(M, N));
          }, function(I) {
            C || (C = !0, a.reject(M, I));
          });
        }
      }, u.race = function(b) {
        var _ = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var k = b.length, C = !1;
        if (!k)
          return this.resolve([]);
        for (var N = -1, R = new this(n); ++N < k; )
          P = b[N], _.resolve(P).then(function(M) {
            C || (C = !0, a.resolve(R, M));
          }, function(M) {
            C || (C = !0, a.reject(R, M));
          });
        var P;
        return R;
      };
    }, { immediate: 36 }], 38: [function(t, s, i) {
      var r = {};
      (0, t("./lib/utils/common").assign)(r, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), s.exports = r;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, s, i) {
      var r = t("./zlib/deflate"), n = t("./utils/common"), a = t("./utils/strings"), h = t("./zlib/messages"), c = t("./zlib/zstream"), d = Object.prototype.toString, u = 0, f = -1, p = 0, m = 8;
      function g(b) {
        if (!(this instanceof g))
          return new g(b);
        this.options = n.assign({ level: f, method: m, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, b || {});
        var _ = this.options;
        _.raw && 0 < _.windowBits ? _.windowBits = -_.windowBits : _.gzip && 0 < _.windowBits && _.windowBits < 16 && (_.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var k = r.deflateInit2(this.strm, _.level, _.method, _.windowBits, _.memLevel, _.strategy);
        if (k !== u)
          throw new Error(h[k]);
        if (_.header && r.deflateSetHeader(this.strm, _.header), _.dictionary) {
          var C;
          if (C = typeof _.dictionary == "string" ? a.string2buf(_.dictionary) : d.call(_.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(_.dictionary) : _.dictionary, (k = r.deflateSetDictionary(this.strm, C)) !== u)
            throw new Error(h[k]);
          this._dict_set = !0;
        }
      }
      function w(b, _) {
        var k = new g(_);
        if (k.push(b, !0), k.err)
          throw k.msg || h[k.err];
        return k.result;
      }
      g.prototype.push = function(b, _) {
        var k, C, N = this.strm, R = this.options.chunkSize;
        if (this.ended)
          return !1;
        C = _ === ~~_ ? _ : _ === !0 ? 4 : 0, typeof b == "string" ? N.input = a.string2buf(b) : d.call(b) === "[object ArrayBuffer]" ? N.input = new Uint8Array(b) : N.input = b, N.next_in = 0, N.avail_in = N.input.length;
        do {
          if (N.avail_out === 0 && (N.output = new n.Buf8(R), N.next_out = 0, N.avail_out = R), (k = r.deflate(N, C)) !== 1 && k !== u)
            return this.onEnd(k), !(this.ended = !0);
          N.avail_out !== 0 && (N.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(n.shrinkBuf(N.output, N.next_out))) : this.onData(n.shrinkBuf(N.output, N.next_out)));
        } while ((0 < N.avail_in || N.avail_out === 0) && k !== 1);
        return C === 4 ? (k = r.deflateEnd(this.strm), this.onEnd(k), this.ended = !0, k === u) : C !== 2 || (this.onEnd(u), !(N.avail_out = 0));
      }, g.prototype.onData = function(b) {
        this.chunks.push(b);
      }, g.prototype.onEnd = function(b) {
        b === u && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = n.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, i.Deflate = g, i.deflate = w, i.deflateRaw = function(b, _) {
        return (_ = _ || {}).raw = !0, w(b, _);
      }, i.gzip = function(b, _) {
        return (_ = _ || {}).gzip = !0, w(b, _);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, s, i) {
      var r = t("./zlib/inflate"), n = t("./utils/common"), a = t("./utils/strings"), h = t("./zlib/constants"), c = t("./zlib/messages"), d = t("./zlib/zstream"), u = t("./zlib/gzheader"), f = Object.prototype.toString;
      function p(g) {
        if (!(this instanceof p))
          return new p(g);
        this.options = n.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
        var w = this.options;
        w.raw && 0 <= w.windowBits && w.windowBits < 16 && (w.windowBits = -w.windowBits, w.windowBits === 0 && (w.windowBits = -15)), !(0 <= w.windowBits && w.windowBits < 16) || g && g.windowBits || (w.windowBits += 32), 15 < w.windowBits && w.windowBits < 48 && !(15 & w.windowBits) && (w.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var b = r.inflateInit2(this.strm, w.windowBits);
        if (b !== h.Z_OK)
          throw new Error(c[b]);
        this.header = new u(), r.inflateGetHeader(this.strm, this.header);
      }
      function m(g, w) {
        var b = new p(w);
        if (b.push(g, !0), b.err)
          throw b.msg || c[b.err];
        return b.result;
      }
      p.prototype.push = function(g, w) {
        var b, _, k, C, N, R, P = this.strm, M = this.options.chunkSize, S = this.options.dictionary, L = !1;
        if (this.ended)
          return !1;
        _ = w === ~~w ? w : w === !0 ? h.Z_FINISH : h.Z_NO_FLUSH, typeof g == "string" ? P.input = a.binstring2buf(g) : f.call(g) === "[object ArrayBuffer]" ? P.input = new Uint8Array(g) : P.input = g, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new n.Buf8(M), P.next_out = 0, P.avail_out = M), (b = r.inflate(P, h.Z_NO_FLUSH)) === h.Z_NEED_DICT && S && (R = typeof S == "string" ? a.string2buf(S) : f.call(S) === "[object ArrayBuffer]" ? new Uint8Array(S) : S, b = r.inflateSetDictionary(this.strm, R)), b === h.Z_BUF_ERROR && L === !0 && (b = h.Z_OK, L = !1), b !== h.Z_STREAM_END && b !== h.Z_OK)
            return this.onEnd(b), !(this.ended = !0);
          P.next_out && (P.avail_out !== 0 && b !== h.Z_STREAM_END && (P.avail_in !== 0 || _ !== h.Z_FINISH && _ !== h.Z_SYNC_FLUSH) || (this.options.to === "string" ? (k = a.utf8border(P.output, P.next_out), C = P.next_out - k, N = a.buf2string(P.output, k), P.next_out = C, P.avail_out = M - C, C && n.arraySet(P.output, P.output, k, C, 0), this.onData(N)) : this.onData(n.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (L = !0);
        } while ((0 < P.avail_in || P.avail_out === 0) && b !== h.Z_STREAM_END);
        return b === h.Z_STREAM_END && (_ = h.Z_FINISH), _ === h.Z_FINISH ? (b = r.inflateEnd(this.strm), this.onEnd(b), this.ended = !0, b === h.Z_OK) : _ !== h.Z_SYNC_FLUSH || (this.onEnd(h.Z_OK), !(P.avail_out = 0));
      }, p.prototype.onData = function(g) {
        this.chunks.push(g);
      }, p.prototype.onEnd = function(g) {
        g === h.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = n.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, i.Inflate = p, i.inflate = m, i.inflateRaw = function(g, w) {
        return (w = w || {}).raw = !0, m(g, w);
      }, i.ungzip = m;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, s, i) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(h) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var d = c.shift();
          if (d) {
            if (typeof d != "object")
              throw new TypeError(d + "must be non-object");
            for (var u in d)
              d.hasOwnProperty(u) && (h[u] = d[u]);
          }
        }
        return h;
      }, i.shrinkBuf = function(h, c) {
        return h.length === c ? h : h.subarray ? h.subarray(0, c) : (h.length = c, h);
      };
      var n = { arraySet: function(h, c, d, u, f) {
        if (c.subarray && h.subarray)
          h.set(c.subarray(d, d + u), f);
        else
          for (var p = 0; p < u; p++)
            h[f + p] = c[d + p];
      }, flattenChunks: function(h) {
        var c, d, u, f, p, m;
        for (c = u = 0, d = h.length; c < d; c++)
          u += h[c].length;
        for (m = new Uint8Array(u), c = f = 0, d = h.length; c < d; c++)
          p = h[c], m.set(p, f), f += p.length;
        return m;
      } }, a = { arraySet: function(h, c, d, u, f) {
        for (var p = 0; p < u; p++)
          h[f + p] = c[d + p];
      }, flattenChunks: function(h) {
        return [].concat.apply([], h);
      } };
      i.setTyped = function(h) {
        h ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, n)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, a));
      }, i.setTyped(r);
    }, {}], 42: [function(t, s, i) {
      var r = t("./common"), n = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        n = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var h = new r.Buf8(256), c = 0; c < 256; c++)
        h[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function d(u, f) {
        if (f < 65537 && (u.subarray && a || !u.subarray && n))
          return String.fromCharCode.apply(null, r.shrinkBuf(u, f));
        for (var p = "", m = 0; m < f; m++)
          p += String.fromCharCode(u[m]);
        return p;
      }
      h[254] = h[254] = 1, i.string2buf = function(u) {
        var f, p, m, g, w, b = u.length, _ = 0;
        for (g = 0; g < b; g++)
          (64512 & (p = u.charCodeAt(g))) == 55296 && g + 1 < b && (64512 & (m = u.charCodeAt(g + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), g++), _ += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
        for (f = new r.Buf8(_), g = w = 0; w < _; g++)
          (64512 & (p = u.charCodeAt(g))) == 55296 && g + 1 < b && (64512 & (m = u.charCodeAt(g + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (m - 56320), g++), p < 128 ? f[w++] = p : (p < 2048 ? f[w++] = 192 | p >>> 6 : (p < 65536 ? f[w++] = 224 | p >>> 12 : (f[w++] = 240 | p >>> 18, f[w++] = 128 | p >>> 12 & 63), f[w++] = 128 | p >>> 6 & 63), f[w++] = 128 | 63 & p);
        return f;
      }, i.buf2binstring = function(u) {
        return d(u, u.length);
      }, i.binstring2buf = function(u) {
        for (var f = new r.Buf8(u.length), p = 0, m = f.length; p < m; p++)
          f[p] = u.charCodeAt(p);
        return f;
      }, i.buf2string = function(u, f) {
        var p, m, g, w, b = f || u.length, _ = new Array(2 * b);
        for (p = m = 0; p < b; )
          if ((g = u[p++]) < 128)
            _[m++] = g;
          else if (4 < (w = h[g]))
            _[m++] = 65533, p += w - 1;
          else {
            for (g &= w === 2 ? 31 : w === 3 ? 15 : 7; 1 < w && p < b; )
              g = g << 6 | 63 & u[p++], w--;
            1 < w ? _[m++] = 65533 : g < 65536 ? _[m++] = g : (g -= 65536, _[m++] = 55296 | g >> 10 & 1023, _[m++] = 56320 | 1023 & g);
          }
        return d(_, m);
      }, i.utf8border = function(u, f) {
        var p;
        for ((f = f || u.length) > u.length && (f = u.length), p = f - 1; 0 <= p && (192 & u[p]) == 128; )
          p--;
        return p < 0 || p === 0 ? f : p + h[u[p]] > f ? p : f;
      };
    }, { "./common": 41 }], 43: [function(t, s, i) {
      s.exports = function(r, n, a, h) {
        for (var c = 65535 & r | 0, d = r >>> 16 & 65535 | 0, u = 0; a !== 0; ) {
          for (a -= u = 2e3 < a ? 2e3 : a; d = d + (c = c + n[h++] | 0) | 0, --u; )
            ;
          c %= 65521, d %= 65521;
        }
        return c | d << 16 | 0;
      };
    }, {}], 44: [function(t, s, i) {
      s.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, s, i) {
      var r = function() {
        for (var n, a = [], h = 0; h < 256; h++) {
          n = h;
          for (var c = 0; c < 8; c++)
            n = 1 & n ? 3988292384 ^ n >>> 1 : n >>> 1;
          a[h] = n;
        }
        return a;
      }();
      s.exports = function(n, a, h, c) {
        var d = r, u = c + h;
        n ^= -1;
        for (var f = c; f < u; f++)
          n = n >>> 8 ^ d[255 & (n ^ a[f])];
        return -1 ^ n;
      };
    }, {}], 46: [function(t, s, i) {
      var r, n = t("../utils/common"), a = t("./trees"), h = t("./adler32"), c = t("./crc32"), d = t("./messages"), u = 0, f = 4, p = 0, m = -2, g = -1, w = 4, b = 2, _ = 8, k = 9, C = 286, N = 30, R = 19, P = 2 * C + 1, M = 15, S = 3, L = 258, H = L + S + 1, I = 42, F = 113, A = 1, G = 2, et = 3, z = 4;
      function K(v, V) {
        return v.msg = d[V], V;
      }
      function Y(v) {
        return (v << 1) - (4 < v ? 9 : 0);
      }
      function ot(v) {
        for (var V = v.length; 0 <= --V; )
          v[V] = 0;
      }
      function B(v) {
        var V = v.state, U = V.pending;
        U > v.avail_out && (U = v.avail_out), U !== 0 && (n.arraySet(v.output, V.pending_buf, V.pending_out, U, v.next_out), v.next_out += U, V.pending_out += U, v.total_out += U, v.avail_out -= U, V.pending -= U, V.pending === 0 && (V.pending_out = 0));
      }
      function O(v, V) {
        a._tr_flush_block(v, 0 <= v.block_start ? v.block_start : -1, v.strstart - v.block_start, V), v.block_start = v.strstart, B(v.strm);
      }
      function q(v, V) {
        v.pending_buf[v.pending++] = V;
      }
      function tt(v, V) {
        v.pending_buf[v.pending++] = V >>> 8 & 255, v.pending_buf[v.pending++] = 255 & V;
      }
      function J(v, V) {
        var U, D, T = v.max_chain_length, j = v.strstart, Q = v.prev_length, Z = v.nice_match, $ = v.strstart > v.w_size - H ? v.strstart - (v.w_size - H) : 0, it = v.window, nt = v.w_mask, st = v.prev, ht = v.strstart + L, yt = it[j + Q - 1], bt = it[j + Q];
        v.prev_length >= v.good_match && (T >>= 2), Z > v.lookahead && (Z = v.lookahead);
        do
          if (it[(U = V) + Q] === bt && it[U + Q - 1] === yt && it[U] === it[j] && it[++U] === it[j + 1]) {
            j += 2, U++;
            do
              ;
            while (it[++j] === it[++U] && it[++j] === it[++U] && it[++j] === it[++U] && it[++j] === it[++U] && it[++j] === it[++U] && it[++j] === it[++U] && it[++j] === it[++U] && it[++j] === it[++U] && j < ht);
            if (D = L - (ht - j), j = ht - L, Q < D) {
              if (v.match_start = V, Z <= (Q = D))
                break;
              yt = it[j + Q - 1], bt = it[j + Q];
            }
          }
        while ((V = st[V & nt]) > $ && --T != 0);
        return Q <= v.lookahead ? Q : v.lookahead;
      }
      function ut(v) {
        var V, U, D, T, j, Q, Z, $, it, nt, st = v.w_size;
        do {
          if (T = v.window_size - v.lookahead - v.strstart, v.strstart >= st + (st - H)) {
            for (n.arraySet(v.window, v.window, st, st, 0), v.match_start -= st, v.strstart -= st, v.block_start -= st, V = U = v.hash_size; D = v.head[--V], v.head[V] = st <= D ? D - st : 0, --U; )
              ;
            for (V = U = st; D = v.prev[--V], v.prev[V] = st <= D ? D - st : 0, --U; )
              ;
            T += st;
          }
          if (v.strm.avail_in === 0)
            break;
          if (Q = v.strm, Z = v.window, $ = v.strstart + v.lookahead, it = T, nt = void 0, nt = Q.avail_in, it < nt && (nt = it), U = nt === 0 ? 0 : (Q.avail_in -= nt, n.arraySet(Z, Q.input, Q.next_in, nt, $), Q.state.wrap === 1 ? Q.adler = h(Q.adler, Z, nt, $) : Q.state.wrap === 2 && (Q.adler = c(Q.adler, Z, nt, $)), Q.next_in += nt, Q.total_in += nt, nt), v.lookahead += U, v.lookahead + v.insert >= S)
            for (j = v.strstart - v.insert, v.ins_h = v.window[j], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[j + 1]) & v.hash_mask; v.insert && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[j + S - 1]) & v.hash_mask, v.prev[j & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = j, j++, v.insert--, !(v.lookahead + v.insert < S)); )
              ;
        } while (v.lookahead < H && v.strm.avail_in !== 0);
      }
      function ft(v, V) {
        for (var U, D; ; ) {
          if (v.lookahead < H) {
            if (ut(v), v.lookahead < H && V === u)
              return A;
            if (v.lookahead === 0)
              break;
          }
          if (U = 0, v.lookahead >= S && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + S - 1]) & v.hash_mask, U = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), U !== 0 && v.strstart - U <= v.w_size - H && (v.match_length = J(v, U)), v.match_length >= S)
            if (D = a._tr_tally(v, v.strstart - v.match_start, v.match_length - S), v.lookahead -= v.match_length, v.match_length <= v.max_lazy_match && v.lookahead >= S) {
              for (v.match_length--; v.strstart++, v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + S - 1]) & v.hash_mask, U = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart, --v.match_length != 0; )
                ;
              v.strstart++;
            } else
              v.strstart += v.match_length, v.match_length = 0, v.ins_h = v.window[v.strstart], v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + 1]) & v.hash_mask;
          else
            D = a._tr_tally(v, 0, v.window[v.strstart]), v.lookahead--, v.strstart++;
          if (D && (O(v, !1), v.strm.avail_out === 0))
            return A;
        }
        return v.insert = v.strstart < S - 1 ? v.strstart : S - 1, V === f ? (O(v, !0), v.strm.avail_out === 0 ? et : z) : v.last_lit && (O(v, !1), v.strm.avail_out === 0) ? A : G;
      }
      function at(v, V) {
        for (var U, D, T; ; ) {
          if (v.lookahead < H) {
            if (ut(v), v.lookahead < H && V === u)
              return A;
            if (v.lookahead === 0)
              break;
          }
          if (U = 0, v.lookahead >= S && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + S - 1]) & v.hash_mask, U = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), v.prev_length = v.match_length, v.prev_match = v.match_start, v.match_length = S - 1, U !== 0 && v.prev_length < v.max_lazy_match && v.strstart - U <= v.w_size - H && (v.match_length = J(v, U), v.match_length <= 5 && (v.strategy === 1 || v.match_length === S && 4096 < v.strstart - v.match_start) && (v.match_length = S - 1)), v.prev_length >= S && v.match_length <= v.prev_length) {
            for (T = v.strstart + v.lookahead - S, D = a._tr_tally(v, v.strstart - 1 - v.prev_match, v.prev_length - S), v.lookahead -= v.prev_length - 1, v.prev_length -= 2; ++v.strstart <= T && (v.ins_h = (v.ins_h << v.hash_shift ^ v.window[v.strstart + S - 1]) & v.hash_mask, U = v.prev[v.strstart & v.w_mask] = v.head[v.ins_h], v.head[v.ins_h] = v.strstart), --v.prev_length != 0; )
              ;
            if (v.match_available = 0, v.match_length = S - 1, v.strstart++, D && (O(v, !1), v.strm.avail_out === 0))
              return A;
          } else if (v.match_available) {
            if ((D = a._tr_tally(v, 0, v.window[v.strstart - 1])) && O(v, !1), v.strstart++, v.lookahead--, v.strm.avail_out === 0)
              return A;
          } else
            v.match_available = 1, v.strstart++, v.lookahead--;
        }
        return v.match_available && (D = a._tr_tally(v, 0, v.window[v.strstart - 1]), v.match_available = 0), v.insert = v.strstart < S - 1 ? v.strstart : S - 1, V === f ? (O(v, !0), v.strm.avail_out === 0 ? et : z) : v.last_lit && (O(v, !1), v.strm.avail_out === 0) ? A : G;
      }
      function lt(v, V, U, D, T) {
        this.good_length = v, this.max_lazy = V, this.nice_length = U, this.max_chain = D, this.func = T;
      }
      function dt() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = _, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n.Buf16(2 * P), this.dyn_dtree = new n.Buf16(2 * (2 * N + 1)), this.bl_tree = new n.Buf16(2 * (2 * R + 1)), ot(this.dyn_ltree), ot(this.dyn_dtree), ot(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n.Buf16(M + 1), this.heap = new n.Buf16(2 * C + 1), ot(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n.Buf16(2 * C + 1), ot(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function ct(v) {
        var V;
        return v && v.state ? (v.total_in = v.total_out = 0, v.data_type = b, (V = v.state).pending = 0, V.pending_out = 0, V.wrap < 0 && (V.wrap = -V.wrap), V.status = V.wrap ? I : F, v.adler = V.wrap === 2 ? 0 : 1, V.last_flush = u, a._tr_init(V), p) : K(v, m);
      }
      function Et(v) {
        var V = ct(v);
        return V === p && function(U) {
          U.window_size = 2 * U.w_size, ot(U.head), U.max_lazy_match = r[U.level].max_lazy, U.good_match = r[U.level].good_length, U.nice_match = r[U.level].nice_length, U.max_chain_length = r[U.level].max_chain, U.strstart = 0, U.block_start = 0, U.lookahead = 0, U.insert = 0, U.match_length = U.prev_length = S - 1, U.match_available = 0, U.ins_h = 0;
        }(v.state), V;
      }
      function gt(v, V, U, D, T, j) {
        if (!v)
          return m;
        var Q = 1;
        if (V === g && (V = 6), D < 0 ? (Q = 0, D = -D) : 15 < D && (Q = 2, D -= 16), T < 1 || k < T || U !== _ || D < 8 || 15 < D || V < 0 || 9 < V || j < 0 || w < j)
          return K(v, m);
        D === 8 && (D = 9);
        var Z = new dt();
        return (v.state = Z).strm = v, Z.wrap = Q, Z.gzhead = null, Z.w_bits = D, Z.w_size = 1 << Z.w_bits, Z.w_mask = Z.w_size - 1, Z.hash_bits = T + 7, Z.hash_size = 1 << Z.hash_bits, Z.hash_mask = Z.hash_size - 1, Z.hash_shift = ~~((Z.hash_bits + S - 1) / S), Z.window = new n.Buf8(2 * Z.w_size), Z.head = new n.Buf16(Z.hash_size), Z.prev = new n.Buf16(Z.w_size), Z.lit_bufsize = 1 << T + 6, Z.pending_buf_size = 4 * Z.lit_bufsize, Z.pending_buf = new n.Buf8(Z.pending_buf_size), Z.d_buf = 1 * Z.lit_bufsize, Z.l_buf = 3 * Z.lit_bufsize, Z.level = V, Z.strategy = j, Z.method = U, Et(v);
      }
      r = [new lt(0, 0, 0, 0, function(v, V) {
        var U = 65535;
        for (U > v.pending_buf_size - 5 && (U = v.pending_buf_size - 5); ; ) {
          if (v.lookahead <= 1) {
            if (ut(v), v.lookahead === 0 && V === u)
              return A;
            if (v.lookahead === 0)
              break;
          }
          v.strstart += v.lookahead, v.lookahead = 0;
          var D = v.block_start + U;
          if ((v.strstart === 0 || v.strstart >= D) && (v.lookahead = v.strstart - D, v.strstart = D, O(v, !1), v.strm.avail_out === 0) || v.strstart - v.block_start >= v.w_size - H && (O(v, !1), v.strm.avail_out === 0))
            return A;
        }
        return v.insert = 0, V === f ? (O(v, !0), v.strm.avail_out === 0 ? et : z) : (v.strstart > v.block_start && (O(v, !1), v.strm.avail_out), A);
      }), new lt(4, 4, 8, 4, ft), new lt(4, 5, 16, 8, ft), new lt(4, 6, 32, 32, ft), new lt(4, 4, 16, 16, at), new lt(8, 16, 32, 32, at), new lt(8, 16, 128, 128, at), new lt(8, 32, 128, 256, at), new lt(32, 128, 258, 1024, at), new lt(32, 258, 258, 4096, at)], i.deflateInit = function(v, V) {
        return gt(v, V, _, 15, 8, 0);
      }, i.deflateInit2 = gt, i.deflateReset = Et, i.deflateResetKeep = ct, i.deflateSetHeader = function(v, V) {
        return v && v.state ? v.state.wrap !== 2 ? m : (v.state.gzhead = V, p) : m;
      }, i.deflate = function(v, V) {
        var U, D, T, j;
        if (!v || !v.state || 5 < V || V < 0)
          return v ? K(v, m) : m;
        if (D = v.state, !v.output || !v.input && v.avail_in !== 0 || D.status === 666 && V !== f)
          return K(v, v.avail_out === 0 ? -5 : m);
        if (D.strm = v, U = D.last_flush, D.last_flush = V, D.status === I)
          if (D.wrap === 2)
            v.adler = 0, q(D, 31), q(D, 139), q(D, 8), D.gzhead ? (q(D, (D.gzhead.text ? 1 : 0) + (D.gzhead.hcrc ? 2 : 0) + (D.gzhead.extra ? 4 : 0) + (D.gzhead.name ? 8 : 0) + (D.gzhead.comment ? 16 : 0)), q(D, 255 & D.gzhead.time), q(D, D.gzhead.time >> 8 & 255), q(D, D.gzhead.time >> 16 & 255), q(D, D.gzhead.time >> 24 & 255), q(D, D.level === 9 ? 2 : 2 <= D.strategy || D.level < 2 ? 4 : 0), q(D, 255 & D.gzhead.os), D.gzhead.extra && D.gzhead.extra.length && (q(D, 255 & D.gzhead.extra.length), q(D, D.gzhead.extra.length >> 8 & 255)), D.gzhead.hcrc && (v.adler = c(v.adler, D.pending_buf, D.pending, 0)), D.gzindex = 0, D.status = 69) : (q(D, 0), q(D, 0), q(D, 0), q(D, 0), q(D, 0), q(D, D.level === 9 ? 2 : 2 <= D.strategy || D.level < 2 ? 4 : 0), q(D, 3), D.status = F);
          else {
            var Q = _ + (D.w_bits - 8 << 4) << 8;
            Q |= (2 <= D.strategy || D.level < 2 ? 0 : D.level < 6 ? 1 : D.level === 6 ? 2 : 3) << 6, D.strstart !== 0 && (Q |= 32), Q += 31 - Q % 31, D.status = F, tt(D, Q), D.strstart !== 0 && (tt(D, v.adler >>> 16), tt(D, 65535 & v.adler)), v.adler = 1;
          }
        if (D.status === 69)
          if (D.gzhead.extra) {
            for (T = D.pending; D.gzindex < (65535 & D.gzhead.extra.length) && (D.pending !== D.pending_buf_size || (D.gzhead.hcrc && D.pending > T && (v.adler = c(v.adler, D.pending_buf, D.pending - T, T)), B(v), T = D.pending, D.pending !== D.pending_buf_size)); )
              q(D, 255 & D.gzhead.extra[D.gzindex]), D.gzindex++;
            D.gzhead.hcrc && D.pending > T && (v.adler = c(v.adler, D.pending_buf, D.pending - T, T)), D.gzindex === D.gzhead.extra.length && (D.gzindex = 0, D.status = 73);
          } else
            D.status = 73;
        if (D.status === 73)
          if (D.gzhead.name) {
            T = D.pending;
            do {
              if (D.pending === D.pending_buf_size && (D.gzhead.hcrc && D.pending > T && (v.adler = c(v.adler, D.pending_buf, D.pending - T, T)), B(v), T = D.pending, D.pending === D.pending_buf_size)) {
                j = 1;
                break;
              }
              j = D.gzindex < D.gzhead.name.length ? 255 & D.gzhead.name.charCodeAt(D.gzindex++) : 0, q(D, j);
            } while (j !== 0);
            D.gzhead.hcrc && D.pending > T && (v.adler = c(v.adler, D.pending_buf, D.pending - T, T)), j === 0 && (D.gzindex = 0, D.status = 91);
          } else
            D.status = 91;
        if (D.status === 91)
          if (D.gzhead.comment) {
            T = D.pending;
            do {
              if (D.pending === D.pending_buf_size && (D.gzhead.hcrc && D.pending > T && (v.adler = c(v.adler, D.pending_buf, D.pending - T, T)), B(v), T = D.pending, D.pending === D.pending_buf_size)) {
                j = 1;
                break;
              }
              j = D.gzindex < D.gzhead.comment.length ? 255 & D.gzhead.comment.charCodeAt(D.gzindex++) : 0, q(D, j);
            } while (j !== 0);
            D.gzhead.hcrc && D.pending > T && (v.adler = c(v.adler, D.pending_buf, D.pending - T, T)), j === 0 && (D.status = 103);
          } else
            D.status = 103;
        if (D.status === 103 && (D.gzhead.hcrc ? (D.pending + 2 > D.pending_buf_size && B(v), D.pending + 2 <= D.pending_buf_size && (q(D, 255 & v.adler), q(D, v.adler >> 8 & 255), v.adler = 0, D.status = F)) : D.status = F), D.pending !== 0) {
          if (B(v), v.avail_out === 0)
            return D.last_flush = -1, p;
        } else if (v.avail_in === 0 && Y(V) <= Y(U) && V !== f)
          return K(v, -5);
        if (D.status === 666 && v.avail_in !== 0)
          return K(v, -5);
        if (v.avail_in !== 0 || D.lookahead !== 0 || V !== u && D.status !== 666) {
          var Z = D.strategy === 2 ? function($, it) {
            for (var nt; ; ) {
              if ($.lookahead === 0 && (ut($), $.lookahead === 0)) {
                if (it === u)
                  return A;
                break;
              }
              if ($.match_length = 0, nt = a._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++, nt && (O($, !1), $.strm.avail_out === 0))
                return A;
            }
            return $.insert = 0, it === f ? (O($, !0), $.strm.avail_out === 0 ? et : z) : $.last_lit && (O($, !1), $.strm.avail_out === 0) ? A : G;
          }(D, V) : D.strategy === 3 ? function($, it) {
            for (var nt, st, ht, yt, bt = $.window; ; ) {
              if ($.lookahead <= L) {
                if (ut($), $.lookahead <= L && it === u)
                  return A;
                if ($.lookahead === 0)
                  break;
              }
              if ($.match_length = 0, $.lookahead >= S && 0 < $.strstart && (st = bt[ht = $.strstart - 1]) === bt[++ht] && st === bt[++ht] && st === bt[++ht]) {
                yt = $.strstart + L;
                do
                  ;
                while (st === bt[++ht] && st === bt[++ht] && st === bt[++ht] && st === bt[++ht] && st === bt[++ht] && st === bt[++ht] && st === bt[++ht] && st === bt[++ht] && ht < yt);
                $.match_length = L - (yt - ht), $.match_length > $.lookahead && ($.match_length = $.lookahead);
              }
              if ($.match_length >= S ? (nt = a._tr_tally($, 1, $.match_length - S), $.lookahead -= $.match_length, $.strstart += $.match_length, $.match_length = 0) : (nt = a._tr_tally($, 0, $.window[$.strstart]), $.lookahead--, $.strstart++), nt && (O($, !1), $.strm.avail_out === 0))
                return A;
            }
            return $.insert = 0, it === f ? (O($, !0), $.strm.avail_out === 0 ? et : z) : $.last_lit && (O($, !1), $.strm.avail_out === 0) ? A : G;
          }(D, V) : r[D.level].func(D, V);
          if (Z !== et && Z !== z || (D.status = 666), Z === A || Z === et)
            return v.avail_out === 0 && (D.last_flush = -1), p;
          if (Z === G && (V === 1 ? a._tr_align(D) : V !== 5 && (a._tr_stored_block(D, 0, 0, !1), V === 3 && (ot(D.head), D.lookahead === 0 && (D.strstart = 0, D.block_start = 0, D.insert = 0))), B(v), v.avail_out === 0))
            return D.last_flush = -1, p;
        }
        return V !== f ? p : D.wrap <= 0 ? 1 : (D.wrap === 2 ? (q(D, 255 & v.adler), q(D, v.adler >> 8 & 255), q(D, v.adler >> 16 & 255), q(D, v.adler >> 24 & 255), q(D, 255 & v.total_in), q(D, v.total_in >> 8 & 255), q(D, v.total_in >> 16 & 255), q(D, v.total_in >> 24 & 255)) : (tt(D, v.adler >>> 16), tt(D, 65535 & v.adler)), B(v), 0 < D.wrap && (D.wrap = -D.wrap), D.pending !== 0 ? p : 1);
      }, i.deflateEnd = function(v) {
        var V;
        return v && v.state ? (V = v.state.status) !== I && V !== 69 && V !== 73 && V !== 91 && V !== 103 && V !== F && V !== 666 ? K(v, m) : (v.state = null, V === F ? K(v, -3) : p) : m;
      }, i.deflateSetDictionary = function(v, V) {
        var U, D, T, j, Q, Z, $, it, nt = V.length;
        if (!v || !v.state || (j = (U = v.state).wrap) === 2 || j === 1 && U.status !== I || U.lookahead)
          return m;
        for (j === 1 && (v.adler = h(v.adler, V, nt, 0)), U.wrap = 0, nt >= U.w_size && (j === 0 && (ot(U.head), U.strstart = 0, U.block_start = 0, U.insert = 0), it = new n.Buf8(U.w_size), n.arraySet(it, V, nt - U.w_size, U.w_size, 0), V = it, nt = U.w_size), Q = v.avail_in, Z = v.next_in, $ = v.input, v.avail_in = nt, v.next_in = 0, v.input = V, ut(U); U.lookahead >= S; ) {
          for (D = U.strstart, T = U.lookahead - (S - 1); U.ins_h = (U.ins_h << U.hash_shift ^ U.window[D + S - 1]) & U.hash_mask, U.prev[D & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = D, D++, --T; )
            ;
          U.strstart = D, U.lookahead = S - 1, ut(U);
        }
        return U.strstart += U.lookahead, U.block_start = U.strstart, U.insert = U.lookahead, U.lookahead = 0, U.match_length = U.prev_length = S - 1, U.match_available = 0, v.next_in = Z, v.input = $, v.avail_in = Q, U.wrap = j, p;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, s, i) {
      s.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(t, s, i) {
      s.exports = function(r, n) {
        var a, h, c, d, u, f, p, m, g, w, b, _, k, C, N, R, P, M, S, L, H, I, F, A, G;
        a = r.state, h = r.next_in, A = r.input, c = h + (r.avail_in - 5), d = r.next_out, G = r.output, u = d - (n - r.avail_out), f = d + (r.avail_out - 257), p = a.dmax, m = a.wsize, g = a.whave, w = a.wnext, b = a.window, _ = a.hold, k = a.bits, C = a.lencode, N = a.distcode, R = (1 << a.lenbits) - 1, P = (1 << a.distbits) - 1;
        t:
          do {
            k < 15 && (_ += A[h++] << k, k += 8, _ += A[h++] << k, k += 8), M = C[_ & R];
            e:
              for (; ; ) {
                if (_ >>>= S = M >>> 24, k -= S, (S = M >>> 16 & 255) === 0)
                  G[d++] = 65535 & M;
                else {
                  if (!(16 & S)) {
                    if (!(64 & S)) {
                      M = C[(65535 & M) + (_ & (1 << S) - 1)];
                      continue e;
                    }
                    if (32 & S) {
                      a.mode = 12;
                      break t;
                    }
                    r.msg = "invalid literal/length code", a.mode = 30;
                    break t;
                  }
                  L = 65535 & M, (S &= 15) && (k < S && (_ += A[h++] << k, k += 8), L += _ & (1 << S) - 1, _ >>>= S, k -= S), k < 15 && (_ += A[h++] << k, k += 8, _ += A[h++] << k, k += 8), M = N[_ & P];
                  s:
                    for (; ; ) {
                      if (_ >>>= S = M >>> 24, k -= S, !(16 & (S = M >>> 16 & 255))) {
                        if (!(64 & S)) {
                          M = N[(65535 & M) + (_ & (1 << S) - 1)];
                          continue s;
                        }
                        r.msg = "invalid distance code", a.mode = 30;
                        break t;
                      }
                      if (H = 65535 & M, k < (S &= 15) && (_ += A[h++] << k, (k += 8) < S && (_ += A[h++] << k, k += 8)), p < (H += _ & (1 << S) - 1)) {
                        r.msg = "invalid distance too far back", a.mode = 30;
                        break t;
                      }
                      if (_ >>>= S, k -= S, (S = d - u) < H) {
                        if (g < (S = H - S) && a.sane) {
                          r.msg = "invalid distance too far back", a.mode = 30;
                          break t;
                        }
                        if (F = b, (I = 0) === w) {
                          if (I += m - S, S < L) {
                            for (L -= S; G[d++] = b[I++], --S; )
                              ;
                            I = d - H, F = G;
                          }
                        } else if (w < S) {
                          if (I += m + w - S, (S -= w) < L) {
                            for (L -= S; G[d++] = b[I++], --S; )
                              ;
                            if (I = 0, w < L) {
                              for (L -= S = w; G[d++] = b[I++], --S; )
                                ;
                              I = d - H, F = G;
                            }
                          }
                        } else if (I += w - S, S < L) {
                          for (L -= S; G[d++] = b[I++], --S; )
                            ;
                          I = d - H, F = G;
                        }
                        for (; 2 < L; )
                          G[d++] = F[I++], G[d++] = F[I++], G[d++] = F[I++], L -= 3;
                        L && (G[d++] = F[I++], 1 < L && (G[d++] = F[I++]));
                      } else {
                        for (I = d - H; G[d++] = G[I++], G[d++] = G[I++], G[d++] = G[I++], 2 < (L -= 3); )
                          ;
                        L && (G[d++] = G[I++], 1 < L && (G[d++] = G[I++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (h < c && d < f);
        h -= L = k >> 3, _ &= (1 << (k -= L << 3)) - 1, r.next_in = h, r.next_out = d, r.avail_in = h < c ? c - h + 5 : 5 - (h - c), r.avail_out = d < f ? f - d + 257 : 257 - (d - f), a.hold = _, a.bits = k;
      };
    }, {}], 49: [function(t, s, i) {
      var r = t("../utils/common"), n = t("./adler32"), a = t("./crc32"), h = t("./inffast"), c = t("./inftrees"), d = 1, u = 2, f = 0, p = -2, m = 1, g = 852, w = 592;
      function b(I) {
        return (I >>> 24 & 255) + (I >>> 8 & 65280) + ((65280 & I) << 8) + ((255 & I) << 24);
      }
      function _() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function k(I) {
        var F;
        return I && I.state ? (F = I.state, I.total_in = I.total_out = F.total = 0, I.msg = "", F.wrap && (I.adler = 1 & F.wrap), F.mode = m, F.last = 0, F.havedict = 0, F.dmax = 32768, F.head = null, F.hold = 0, F.bits = 0, F.lencode = F.lendyn = new r.Buf32(g), F.distcode = F.distdyn = new r.Buf32(w), F.sane = 1, F.back = -1, f) : p;
      }
      function C(I) {
        var F;
        return I && I.state ? ((F = I.state).wsize = 0, F.whave = 0, F.wnext = 0, k(I)) : p;
      }
      function N(I, F) {
        var A, G;
        return I && I.state ? (G = I.state, F < 0 ? (A = 0, F = -F) : (A = 1 + (F >> 4), F < 48 && (F &= 15)), F && (F < 8 || 15 < F) ? p : (G.window !== null && G.wbits !== F && (G.window = null), G.wrap = A, G.wbits = F, C(I))) : p;
      }
      function R(I, F) {
        var A, G;
        return I ? (G = new _(), (I.state = G).window = null, (A = N(I, F)) !== f && (I.state = null), A) : p;
      }
      var P, M, S = !0;
      function L(I) {
        if (S) {
          var F;
          for (P = new r.Buf32(512), M = new r.Buf32(32), F = 0; F < 144; )
            I.lens[F++] = 8;
          for (; F < 256; )
            I.lens[F++] = 9;
          for (; F < 280; )
            I.lens[F++] = 7;
          for (; F < 288; )
            I.lens[F++] = 8;
          for (c(d, I.lens, 0, 288, P, 0, I.work, { bits: 9 }), F = 0; F < 32; )
            I.lens[F++] = 5;
          c(u, I.lens, 0, 32, M, 0, I.work, { bits: 5 }), S = !1;
        }
        I.lencode = P, I.lenbits = 9, I.distcode = M, I.distbits = 5;
      }
      function H(I, F, A, G) {
        var et, z = I.state;
        return z.window === null && (z.wsize = 1 << z.wbits, z.wnext = 0, z.whave = 0, z.window = new r.Buf8(z.wsize)), G >= z.wsize ? (r.arraySet(z.window, F, A - z.wsize, z.wsize, 0), z.wnext = 0, z.whave = z.wsize) : (G < (et = z.wsize - z.wnext) && (et = G), r.arraySet(z.window, F, A - G, et, z.wnext), (G -= et) ? (r.arraySet(z.window, F, A - G, G, 0), z.wnext = G, z.whave = z.wsize) : (z.wnext += et, z.wnext === z.wsize && (z.wnext = 0), z.whave < z.wsize && (z.whave += et))), 0;
      }
      i.inflateReset = C, i.inflateReset2 = N, i.inflateResetKeep = k, i.inflateInit = function(I) {
        return R(I, 15);
      }, i.inflateInit2 = R, i.inflate = function(I, F) {
        var A, G, et, z, K, Y, ot, B, O, q, tt, J, ut, ft, at, lt, dt, ct, Et, gt, v, V, U, D, T = 0, j = new r.Buf8(4), Q = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!I || !I.state || !I.output || !I.input && I.avail_in !== 0)
          return p;
        (A = I.state).mode === 12 && (A.mode = 13), K = I.next_out, et = I.output, ot = I.avail_out, z = I.next_in, G = I.input, Y = I.avail_in, B = A.hold, O = A.bits, q = Y, tt = ot, V = f;
        t:
          for (; ; )
            switch (A.mode) {
              case m:
                if (A.wrap === 0) {
                  A.mode = 13;
                  break;
                }
                for (; O < 16; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                if (2 & A.wrap && B === 35615) {
                  j[A.check = 0] = 255 & B, j[1] = B >>> 8 & 255, A.check = a(A.check, j, 2, 0), O = B = 0, A.mode = 2;
                  break;
                }
                if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & B) << 8) + (B >> 8)) % 31) {
                  I.msg = "incorrect header check", A.mode = 30;
                  break;
                }
                if ((15 & B) != 8) {
                  I.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (O -= 4, v = 8 + (15 & (B >>>= 4)), A.wbits === 0)
                  A.wbits = v;
                else if (v > A.wbits) {
                  I.msg = "invalid window size", A.mode = 30;
                  break;
                }
                A.dmax = 1 << v, I.adler = A.check = 1, A.mode = 512 & B ? 10 : 12, O = B = 0;
                break;
              case 2:
                for (; O < 16; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                if (A.flags = B, (255 & A.flags) != 8) {
                  I.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (57344 & A.flags) {
                  I.msg = "unknown header flags set", A.mode = 30;
                  break;
                }
                A.head && (A.head.text = B >> 8 & 1), 512 & A.flags && (j[0] = 255 & B, j[1] = B >>> 8 & 255, A.check = a(A.check, j, 2, 0)), O = B = 0, A.mode = 3;
              case 3:
                for (; O < 32; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                A.head && (A.head.time = B), 512 & A.flags && (j[0] = 255 & B, j[1] = B >>> 8 & 255, j[2] = B >>> 16 & 255, j[3] = B >>> 24 & 255, A.check = a(A.check, j, 4, 0)), O = B = 0, A.mode = 4;
              case 4:
                for (; O < 16; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                A.head && (A.head.xflags = 255 & B, A.head.os = B >> 8), 512 & A.flags && (j[0] = 255 & B, j[1] = B >>> 8 & 255, A.check = a(A.check, j, 2, 0)), O = B = 0, A.mode = 5;
              case 5:
                if (1024 & A.flags) {
                  for (; O < 16; ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  A.length = B, A.head && (A.head.extra_len = B), 512 & A.flags && (j[0] = 255 & B, j[1] = B >>> 8 & 255, A.check = a(A.check, j, 2, 0)), O = B = 0;
                } else
                  A.head && (A.head.extra = null);
                A.mode = 6;
              case 6:
                if (1024 & A.flags && (Y < (J = A.length) && (J = Y), J && (A.head && (v = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), r.arraySet(A.head.extra, G, z, J, v)), 512 & A.flags && (A.check = a(A.check, G, J, z)), Y -= J, z += J, A.length -= J), A.length))
                  break t;
                A.length = 0, A.mode = 7;
              case 7:
                if (2048 & A.flags) {
                  if (Y === 0)
                    break t;
                  for (J = 0; v = G[z + J++], A.head && v && A.length < 65536 && (A.head.name += String.fromCharCode(v)), v && J < Y; )
                    ;
                  if (512 & A.flags && (A.check = a(A.check, G, J, z)), Y -= J, z += J, v)
                    break t;
                } else
                  A.head && (A.head.name = null);
                A.length = 0, A.mode = 8;
              case 8:
                if (4096 & A.flags) {
                  if (Y === 0)
                    break t;
                  for (J = 0; v = G[z + J++], A.head && v && A.length < 65536 && (A.head.comment += String.fromCharCode(v)), v && J < Y; )
                    ;
                  if (512 & A.flags && (A.check = a(A.check, G, J, z)), Y -= J, z += J, v)
                    break t;
                } else
                  A.head && (A.head.comment = null);
                A.mode = 9;
              case 9:
                if (512 & A.flags) {
                  for (; O < 16; ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  if (B !== (65535 & A.check)) {
                    I.msg = "header crc mismatch", A.mode = 30;
                    break;
                  }
                  O = B = 0;
                }
                A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), I.adler = A.check = 0, A.mode = 12;
                break;
              case 10:
                for (; O < 32; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                I.adler = A.check = b(B), O = B = 0, A.mode = 11;
              case 11:
                if (A.havedict === 0)
                  return I.next_out = K, I.avail_out = ot, I.next_in = z, I.avail_in = Y, A.hold = B, A.bits = O, 2;
                I.adler = A.check = 1, A.mode = 12;
              case 12:
                if (F === 5 || F === 6)
                  break t;
              case 13:
                if (A.last) {
                  B >>>= 7 & O, O -= 7 & O, A.mode = 27;
                  break;
                }
                for (; O < 3; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                switch (A.last = 1 & B, O -= 1, 3 & (B >>>= 1)) {
                  case 0:
                    A.mode = 14;
                    break;
                  case 1:
                    if (L(A), A.mode = 20, F !== 6)
                      break;
                    B >>>= 2, O -= 2;
                    break t;
                  case 2:
                    A.mode = 17;
                    break;
                  case 3:
                    I.msg = "invalid block type", A.mode = 30;
                }
                B >>>= 2, O -= 2;
                break;
              case 14:
                for (B >>>= 7 & O, O -= 7 & O; O < 32; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                if ((65535 & B) != (B >>> 16 ^ 65535)) {
                  I.msg = "invalid stored block lengths", A.mode = 30;
                  break;
                }
                if (A.length = 65535 & B, O = B = 0, A.mode = 15, F === 6)
                  break t;
              case 15:
                A.mode = 16;
              case 16:
                if (J = A.length) {
                  if (Y < J && (J = Y), ot < J && (J = ot), J === 0)
                    break t;
                  r.arraySet(et, G, z, J, K), Y -= J, z += J, ot -= J, K += J, A.length -= J;
                  break;
                }
                A.mode = 12;
                break;
              case 17:
                for (; O < 14; ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                if (A.nlen = 257 + (31 & B), B >>>= 5, O -= 5, A.ndist = 1 + (31 & B), B >>>= 5, O -= 5, A.ncode = 4 + (15 & B), B >>>= 4, O -= 4, 286 < A.nlen || 30 < A.ndist) {
                  I.msg = "too many length or distance symbols", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 18;
              case 18:
                for (; A.have < A.ncode; ) {
                  for (; O < 3; ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  A.lens[Q[A.have++]] = 7 & B, B >>>= 3, O -= 3;
                }
                for (; A.have < 19; )
                  A.lens[Q[A.have++]] = 0;
                if (A.lencode = A.lendyn, A.lenbits = 7, U = { bits: A.lenbits }, V = c(0, A.lens, 0, 19, A.lencode, 0, A.work, U), A.lenbits = U.bits, V) {
                  I.msg = "invalid code lengths set", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 19;
              case 19:
                for (; A.have < A.nlen + A.ndist; ) {
                  for (; lt = (T = A.lencode[B & (1 << A.lenbits) - 1]) >>> 16 & 255, dt = 65535 & T, !((at = T >>> 24) <= O); ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  if (dt < 16)
                    B >>>= at, O -= at, A.lens[A.have++] = dt;
                  else {
                    if (dt === 16) {
                      for (D = at + 2; O < D; ) {
                        if (Y === 0)
                          break t;
                        Y--, B += G[z++] << O, O += 8;
                      }
                      if (B >>>= at, O -= at, A.have === 0) {
                        I.msg = "invalid bit length repeat", A.mode = 30;
                        break;
                      }
                      v = A.lens[A.have - 1], J = 3 + (3 & B), B >>>= 2, O -= 2;
                    } else if (dt === 17) {
                      for (D = at + 3; O < D; ) {
                        if (Y === 0)
                          break t;
                        Y--, B += G[z++] << O, O += 8;
                      }
                      O -= at, v = 0, J = 3 + (7 & (B >>>= at)), B >>>= 3, O -= 3;
                    } else {
                      for (D = at + 7; O < D; ) {
                        if (Y === 0)
                          break t;
                        Y--, B += G[z++] << O, O += 8;
                      }
                      O -= at, v = 0, J = 11 + (127 & (B >>>= at)), B >>>= 7, O -= 7;
                    }
                    if (A.have + J > A.nlen + A.ndist) {
                      I.msg = "invalid bit length repeat", A.mode = 30;
                      break;
                    }
                    for (; J--; )
                      A.lens[A.have++] = v;
                  }
                }
                if (A.mode === 30)
                  break;
                if (A.lens[256] === 0) {
                  I.msg = "invalid code -- missing end-of-block", A.mode = 30;
                  break;
                }
                if (A.lenbits = 9, U = { bits: A.lenbits }, V = c(d, A.lens, 0, A.nlen, A.lencode, 0, A.work, U), A.lenbits = U.bits, V) {
                  I.msg = "invalid literal/lengths set", A.mode = 30;
                  break;
                }
                if (A.distbits = 6, A.distcode = A.distdyn, U = { bits: A.distbits }, V = c(u, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, U), A.distbits = U.bits, V) {
                  I.msg = "invalid distances set", A.mode = 30;
                  break;
                }
                if (A.mode = 20, F === 6)
                  break t;
              case 20:
                A.mode = 21;
              case 21:
                if (6 <= Y && 258 <= ot) {
                  I.next_out = K, I.avail_out = ot, I.next_in = z, I.avail_in = Y, A.hold = B, A.bits = O, h(I, tt), K = I.next_out, et = I.output, ot = I.avail_out, z = I.next_in, G = I.input, Y = I.avail_in, B = A.hold, O = A.bits, A.mode === 12 && (A.back = -1);
                  break;
                }
                for (A.back = 0; lt = (T = A.lencode[B & (1 << A.lenbits) - 1]) >>> 16 & 255, dt = 65535 & T, !((at = T >>> 24) <= O); ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                if (lt && !(240 & lt)) {
                  for (ct = at, Et = lt, gt = dt; lt = (T = A.lencode[gt + ((B & (1 << ct + Et) - 1) >> ct)]) >>> 16 & 255, dt = 65535 & T, !(ct + (at = T >>> 24) <= O); ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  B >>>= ct, O -= ct, A.back += ct;
                }
                if (B >>>= at, O -= at, A.back += at, A.length = dt, lt === 0) {
                  A.mode = 26;
                  break;
                }
                if (32 & lt) {
                  A.back = -1, A.mode = 12;
                  break;
                }
                if (64 & lt) {
                  I.msg = "invalid literal/length code", A.mode = 30;
                  break;
                }
                A.extra = 15 & lt, A.mode = 22;
              case 22:
                if (A.extra) {
                  for (D = A.extra; O < D; ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  A.length += B & (1 << A.extra) - 1, B >>>= A.extra, O -= A.extra, A.back += A.extra;
                }
                A.was = A.length, A.mode = 23;
              case 23:
                for (; lt = (T = A.distcode[B & (1 << A.distbits) - 1]) >>> 16 & 255, dt = 65535 & T, !((at = T >>> 24) <= O); ) {
                  if (Y === 0)
                    break t;
                  Y--, B += G[z++] << O, O += 8;
                }
                if (!(240 & lt)) {
                  for (ct = at, Et = lt, gt = dt; lt = (T = A.distcode[gt + ((B & (1 << ct + Et) - 1) >> ct)]) >>> 16 & 255, dt = 65535 & T, !(ct + (at = T >>> 24) <= O); ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  B >>>= ct, O -= ct, A.back += ct;
                }
                if (B >>>= at, O -= at, A.back += at, 64 & lt) {
                  I.msg = "invalid distance code", A.mode = 30;
                  break;
                }
                A.offset = dt, A.extra = 15 & lt, A.mode = 24;
              case 24:
                if (A.extra) {
                  for (D = A.extra; O < D; ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  A.offset += B & (1 << A.extra) - 1, B >>>= A.extra, O -= A.extra, A.back += A.extra;
                }
                if (A.offset > A.dmax) {
                  I.msg = "invalid distance too far back", A.mode = 30;
                  break;
                }
                A.mode = 25;
              case 25:
                if (ot === 0)
                  break t;
                if (J = tt - ot, A.offset > J) {
                  if ((J = A.offset - J) > A.whave && A.sane) {
                    I.msg = "invalid distance too far back", A.mode = 30;
                    break;
                  }
                  ut = J > A.wnext ? (J -= A.wnext, A.wsize - J) : A.wnext - J, J > A.length && (J = A.length), ft = A.window;
                } else
                  ft = et, ut = K - A.offset, J = A.length;
                for (ot < J && (J = ot), ot -= J, A.length -= J; et[K++] = ft[ut++], --J; )
                  ;
                A.length === 0 && (A.mode = 21);
                break;
              case 26:
                if (ot === 0)
                  break t;
                et[K++] = A.length, ot--, A.mode = 21;
                break;
              case 27:
                if (A.wrap) {
                  for (; O < 32; ) {
                    if (Y === 0)
                      break t;
                    Y--, B |= G[z++] << O, O += 8;
                  }
                  if (tt -= ot, I.total_out += tt, A.total += tt, tt && (I.adler = A.check = A.flags ? a(A.check, et, tt, K - tt) : n(A.check, et, tt, K - tt)), tt = ot, (A.flags ? B : b(B)) !== A.check) {
                    I.msg = "incorrect data check", A.mode = 30;
                    break;
                  }
                  O = B = 0;
                }
                A.mode = 28;
              case 28:
                if (A.wrap && A.flags) {
                  for (; O < 32; ) {
                    if (Y === 0)
                      break t;
                    Y--, B += G[z++] << O, O += 8;
                  }
                  if (B !== (4294967295 & A.total)) {
                    I.msg = "incorrect length check", A.mode = 30;
                    break;
                  }
                  O = B = 0;
                }
                A.mode = 29;
              case 29:
                V = 1;
                break t;
              case 30:
                V = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return p;
            }
        return I.next_out = K, I.avail_out = ot, I.next_in = z, I.avail_in = Y, A.hold = B, A.bits = O, (A.wsize || tt !== I.avail_out && A.mode < 30 && (A.mode < 27 || F !== 4)) && H(I, I.output, I.next_out, tt - I.avail_out) ? (A.mode = 31, -4) : (q -= I.avail_in, tt -= I.avail_out, I.total_in += q, I.total_out += tt, A.total += tt, A.wrap && tt && (I.adler = A.check = A.flags ? a(A.check, et, tt, I.next_out - tt) : n(A.check, et, tt, I.next_out - tt)), I.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (q == 0 && tt === 0 || F === 4) && V === f && (V = -5), V);
      }, i.inflateEnd = function(I) {
        if (!I || !I.state)
          return p;
        var F = I.state;
        return F.window && (F.window = null), I.state = null, f;
      }, i.inflateGetHeader = function(I, F) {
        var A;
        return I && I.state && 2 & (A = I.state).wrap ? ((A.head = F).done = !1, f) : p;
      }, i.inflateSetDictionary = function(I, F) {
        var A, G = F.length;
        return I && I.state ? (A = I.state).wrap !== 0 && A.mode !== 11 ? p : A.mode === 11 && n(1, F, G, 0) !== A.check ? -3 : H(I, F, G, G) ? (A.mode = 31, -4) : (A.havedict = 1, f) : p;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, s, i) {
      var r = t("../utils/common"), n = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], h = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      s.exports = function(d, u, f, p, m, g, w, b) {
        var _, k, C, N, R, P, M, S, L, H = b.bits, I = 0, F = 0, A = 0, G = 0, et = 0, z = 0, K = 0, Y = 0, ot = 0, B = 0, O = null, q = 0, tt = new r.Buf16(16), J = new r.Buf16(16), ut = null, ft = 0;
        for (I = 0; I <= 15; I++)
          tt[I] = 0;
        for (F = 0; F < p; F++)
          tt[u[f + F]]++;
        for (et = H, G = 15; 1 <= G && tt[G] === 0; G--)
          ;
        if (G < et && (et = G), G === 0)
          return m[g++] = 20971520, m[g++] = 20971520, b.bits = 1, 0;
        for (A = 1; A < G && tt[A] === 0; A++)
          ;
        for (et < A && (et = A), I = Y = 1; I <= 15; I++)
          if (Y <<= 1, (Y -= tt[I]) < 0)
            return -1;
        if (0 < Y && (d === 0 || G !== 1))
          return -1;
        for (J[1] = 0, I = 1; I < 15; I++)
          J[I + 1] = J[I] + tt[I];
        for (F = 0; F < p; F++)
          u[f + F] !== 0 && (w[J[u[f + F]]++] = F);
        if (P = d === 0 ? (O = ut = w, 19) : d === 1 ? (O = n, q -= 257, ut = a, ft -= 257, 256) : (O = h, ut = c, -1), I = A, R = g, K = F = B = 0, C = -1, N = (ot = 1 << (z = et)) - 1, d === 1 && 852 < ot || d === 2 && 592 < ot)
          return 1;
        for (; ; ) {
          for (M = I - K, L = w[F] < P ? (S = 0, w[F]) : w[F] > P ? (S = ut[ft + w[F]], O[q + w[F]]) : (S = 96, 0), _ = 1 << I - K, A = k = 1 << z; m[R + (B >> K) + (k -= _)] = M << 24 | S << 16 | L | 0, k !== 0; )
            ;
          for (_ = 1 << I - 1; B & _; )
            _ >>= 1;
          if (_ !== 0 ? (B &= _ - 1, B += _) : B = 0, F++, --tt[I] == 0) {
            if (I === G)
              break;
            I = u[f + w[F]];
          }
          if (et < I && (B & N) !== C) {
            for (K === 0 && (K = et), R += A, Y = 1 << (z = I - K); z + K < G && !((Y -= tt[z + K]) <= 0); )
              z++, Y <<= 1;
            if (ot += 1 << z, d === 1 && 852 < ot || d === 2 && 592 < ot)
              return 1;
            m[C = B & N] = et << 24 | z << 16 | R - g | 0;
          }
        }
        return B !== 0 && (m[R + B] = I - K << 24 | 64 << 16 | 0), b.bits = et, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, s, i) {
      s.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, s, i) {
      var r = t("../utils/common"), n = 0, a = 1;
      function h(T) {
        for (var j = T.length; 0 <= --j; )
          T[j] = 0;
      }
      var c = 0, d = 29, u = 256, f = u + 1 + d, p = 30, m = 19, g = 2 * f + 1, w = 15, b = 16, _ = 7, k = 256, C = 16, N = 17, R = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], L = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], H = new Array(2 * (f + 2));
      h(H);
      var I = new Array(2 * p);
      h(I);
      var F = new Array(512);
      h(F);
      var A = new Array(256);
      h(A);
      var G = new Array(d);
      h(G);
      var et, z, K, Y = new Array(p);
      function ot(T, j, Q, Z, $) {
        this.static_tree = T, this.extra_bits = j, this.extra_base = Q, this.elems = Z, this.max_length = $, this.has_stree = T && T.length;
      }
      function B(T, j) {
        this.dyn_tree = T, this.max_code = 0, this.stat_desc = j;
      }
      function O(T) {
        return T < 256 ? F[T] : F[256 + (T >>> 7)];
      }
      function q(T, j) {
        T.pending_buf[T.pending++] = 255 & j, T.pending_buf[T.pending++] = j >>> 8 & 255;
      }
      function tt(T, j, Q) {
        T.bi_valid > b - Q ? (T.bi_buf |= j << T.bi_valid & 65535, q(T, T.bi_buf), T.bi_buf = j >> b - T.bi_valid, T.bi_valid += Q - b) : (T.bi_buf |= j << T.bi_valid & 65535, T.bi_valid += Q);
      }
      function J(T, j, Q) {
        tt(T, Q[2 * j], Q[2 * j + 1]);
      }
      function ut(T, j) {
        for (var Q = 0; Q |= 1 & T, T >>>= 1, Q <<= 1, 0 < --j; )
          ;
        return Q >>> 1;
      }
      function ft(T, j, Q) {
        var Z, $, it = new Array(w + 1), nt = 0;
        for (Z = 1; Z <= w; Z++)
          it[Z] = nt = nt + Q[Z - 1] << 1;
        for ($ = 0; $ <= j; $++) {
          var st = T[2 * $ + 1];
          st !== 0 && (T[2 * $] = ut(it[st]++, st));
        }
      }
      function at(T) {
        var j;
        for (j = 0; j < f; j++)
          T.dyn_ltree[2 * j] = 0;
        for (j = 0; j < p; j++)
          T.dyn_dtree[2 * j] = 0;
        for (j = 0; j < m; j++)
          T.bl_tree[2 * j] = 0;
        T.dyn_ltree[2 * k] = 1, T.opt_len = T.static_len = 0, T.last_lit = T.matches = 0;
      }
      function lt(T) {
        8 < T.bi_valid ? q(T, T.bi_buf) : 0 < T.bi_valid && (T.pending_buf[T.pending++] = T.bi_buf), T.bi_buf = 0, T.bi_valid = 0;
      }
      function dt(T, j, Q, Z) {
        var $ = 2 * j, it = 2 * Q;
        return T[$] < T[it] || T[$] === T[it] && Z[j] <= Z[Q];
      }
      function ct(T, j, Q) {
        for (var Z = T.heap[Q], $ = Q << 1; $ <= T.heap_len && ($ < T.heap_len && dt(j, T.heap[$ + 1], T.heap[$], T.depth) && $++, !dt(j, Z, T.heap[$], T.depth)); )
          T.heap[Q] = T.heap[$], Q = $, $ <<= 1;
        T.heap[Q] = Z;
      }
      function Et(T, j, Q) {
        var Z, $, it, nt, st = 0;
        if (T.last_lit !== 0)
          for (; Z = T.pending_buf[T.d_buf + 2 * st] << 8 | T.pending_buf[T.d_buf + 2 * st + 1], $ = T.pending_buf[T.l_buf + st], st++, Z === 0 ? J(T, $, j) : (J(T, (it = A[$]) + u + 1, j), (nt = P[it]) !== 0 && tt(T, $ -= G[it], nt), J(T, it = O(--Z), Q), (nt = M[it]) !== 0 && tt(T, Z -= Y[it], nt)), st < T.last_lit; )
            ;
        J(T, k, j);
      }
      function gt(T, j) {
        var Q, Z, $, it = j.dyn_tree, nt = j.stat_desc.static_tree, st = j.stat_desc.has_stree, ht = j.stat_desc.elems, yt = -1;
        for (T.heap_len = 0, T.heap_max = g, Q = 0; Q < ht; Q++)
          it[2 * Q] !== 0 ? (T.heap[++T.heap_len] = yt = Q, T.depth[Q] = 0) : it[2 * Q + 1] = 0;
        for (; T.heap_len < 2; )
          it[2 * ($ = T.heap[++T.heap_len] = yt < 2 ? ++yt : 0)] = 1, T.depth[$] = 0, T.opt_len--, st && (T.static_len -= nt[2 * $ + 1]);
        for (j.max_code = yt, Q = T.heap_len >> 1; 1 <= Q; Q--)
          ct(T, it, Q);
        for ($ = ht; Q = T.heap[1], T.heap[1] = T.heap[T.heap_len--], ct(T, it, 1), Z = T.heap[1], T.heap[--T.heap_max] = Q, T.heap[--T.heap_max] = Z, it[2 * $] = it[2 * Q] + it[2 * Z], T.depth[$] = (T.depth[Q] >= T.depth[Z] ? T.depth[Q] : T.depth[Z]) + 1, it[2 * Q + 1] = it[2 * Z + 1] = $, T.heap[1] = $++, ct(T, it, 1), 2 <= T.heap_len; )
          ;
        T.heap[--T.heap_max] = T.heap[1], function(bt, Xt) {
          var Ze, pe, we, Lt, br, hf, $s = Xt.dyn_tree, ug = Xt.max_code, Qy = Xt.stat_desc.static_tree, Ky = Xt.stat_desc.has_stree, Zy = Xt.stat_desc.extra_bits, fg = Xt.stat_desc.extra_base, Co = Xt.stat_desc.max_length, dc = 0;
          for (Lt = 0; Lt <= w; Lt++)
            bt.bl_count[Lt] = 0;
          for ($s[2 * bt.heap[bt.heap_max] + 1] = 0, Ze = bt.heap_max + 1; Ze < g; Ze++)
            Co < (Lt = $s[2 * $s[2 * (pe = bt.heap[Ze]) + 1] + 1] + 1) && (Lt = Co, dc++), $s[2 * pe + 1] = Lt, ug < pe || (bt.bl_count[Lt]++, br = 0, fg <= pe && (br = Zy[pe - fg]), hf = $s[2 * pe], bt.opt_len += hf * (Lt + br), Ky && (bt.static_len += hf * (Qy[2 * pe + 1] + br)));
          if (dc !== 0) {
            do {
              for (Lt = Co - 1; bt.bl_count[Lt] === 0; )
                Lt--;
              bt.bl_count[Lt]--, bt.bl_count[Lt + 1] += 2, bt.bl_count[Co]--, dc -= 2;
            } while (0 < dc);
            for (Lt = Co; Lt !== 0; Lt--)
              for (pe = bt.bl_count[Lt]; pe !== 0; )
                ug < (we = bt.heap[--Ze]) || ($s[2 * we + 1] !== Lt && (bt.opt_len += (Lt - $s[2 * we + 1]) * $s[2 * we], $s[2 * we + 1] = Lt), pe--);
          }
        }(T, j), ft(it, yt, T.bl_count);
      }
      function v(T, j, Q) {
        var Z, $, it = -1, nt = j[1], st = 0, ht = 7, yt = 4;
        for (nt === 0 && (ht = 138, yt = 3), j[2 * (Q + 1) + 1] = 65535, Z = 0; Z <= Q; Z++)
          $ = nt, nt = j[2 * (Z + 1) + 1], ++st < ht && $ === nt || (st < yt ? T.bl_tree[2 * $] += st : $ !== 0 ? ($ !== it && T.bl_tree[2 * $]++, T.bl_tree[2 * C]++) : st <= 10 ? T.bl_tree[2 * N]++ : T.bl_tree[2 * R]++, it = $, yt = (st = 0) === nt ? (ht = 138, 3) : $ === nt ? (ht = 6, 3) : (ht = 7, 4));
      }
      function V(T, j, Q) {
        var Z, $, it = -1, nt = j[1], st = 0, ht = 7, yt = 4;
        for (nt === 0 && (ht = 138, yt = 3), Z = 0; Z <= Q; Z++)
          if ($ = nt, nt = j[2 * (Z + 1) + 1], !(++st < ht && $ === nt)) {
            if (st < yt)
              for (; J(T, $, T.bl_tree), --st != 0; )
                ;
            else
              $ !== 0 ? ($ !== it && (J(T, $, T.bl_tree), st--), J(T, C, T.bl_tree), tt(T, st - 3, 2)) : st <= 10 ? (J(T, N, T.bl_tree), tt(T, st - 3, 3)) : (J(T, R, T.bl_tree), tt(T, st - 11, 7));
            it = $, yt = (st = 0) === nt ? (ht = 138, 3) : $ === nt ? (ht = 6, 3) : (ht = 7, 4);
          }
      }
      h(Y);
      var U = !1;
      function D(T, j, Q, Z) {
        tt(T, (c << 1) + (Z ? 1 : 0), 3), function($, it, nt, st) {
          lt($), st && (q($, nt), q($, ~nt)), r.arraySet($.pending_buf, $.window, it, nt, $.pending), $.pending += nt;
        }(T, j, Q, !0);
      }
      i._tr_init = function(T) {
        U || (function() {
          var j, Q, Z, $, it, nt = new Array(w + 1);
          for ($ = Z = 0; $ < d - 1; $++)
            for (G[$] = Z, j = 0; j < 1 << P[$]; j++)
              A[Z++] = $;
          for (A[Z - 1] = $, $ = it = 0; $ < 16; $++)
            for (Y[$] = it, j = 0; j < 1 << M[$]; j++)
              F[it++] = $;
          for (it >>= 7; $ < p; $++)
            for (Y[$] = it << 7, j = 0; j < 1 << M[$] - 7; j++)
              F[256 + it++] = $;
          for (Q = 0; Q <= w; Q++)
            nt[Q] = 0;
          for (j = 0; j <= 143; )
            H[2 * j + 1] = 8, j++, nt[8]++;
          for (; j <= 255; )
            H[2 * j + 1] = 9, j++, nt[9]++;
          for (; j <= 279; )
            H[2 * j + 1] = 7, j++, nt[7]++;
          for (; j <= 287; )
            H[2 * j + 1] = 8, j++, nt[8]++;
          for (ft(H, f + 1, nt), j = 0; j < p; j++)
            I[2 * j + 1] = 5, I[2 * j] = ut(j, 5);
          et = new ot(H, P, u + 1, f, w), z = new ot(I, M, 0, p, w), K = new ot(new Array(0), S, 0, m, _);
        }(), U = !0), T.l_desc = new B(T.dyn_ltree, et), T.d_desc = new B(T.dyn_dtree, z), T.bl_desc = new B(T.bl_tree, K), T.bi_buf = 0, T.bi_valid = 0, at(T);
      }, i._tr_stored_block = D, i._tr_flush_block = function(T, j, Q, Z) {
        var $, it, nt = 0;
        0 < T.level ? (T.strm.data_type === 2 && (T.strm.data_type = function(st) {
          var ht, yt = 4093624447;
          for (ht = 0; ht <= 31; ht++, yt >>>= 1)
            if (1 & yt && st.dyn_ltree[2 * ht] !== 0)
              return n;
          if (st.dyn_ltree[18] !== 0 || st.dyn_ltree[20] !== 0 || st.dyn_ltree[26] !== 0)
            return a;
          for (ht = 32; ht < u; ht++)
            if (st.dyn_ltree[2 * ht] !== 0)
              return a;
          return n;
        }(T)), gt(T, T.l_desc), gt(T, T.d_desc), nt = function(st) {
          var ht;
          for (v(st, st.dyn_ltree, st.l_desc.max_code), v(st, st.dyn_dtree, st.d_desc.max_code), gt(st, st.bl_desc), ht = m - 1; 3 <= ht && st.bl_tree[2 * L[ht] + 1] === 0; ht--)
            ;
          return st.opt_len += 3 * (ht + 1) + 5 + 5 + 4, ht;
        }(T), $ = T.opt_len + 3 + 7 >>> 3, (it = T.static_len + 3 + 7 >>> 3) <= $ && ($ = it)) : $ = it = Q + 5, Q + 4 <= $ && j !== -1 ? D(T, j, Q, Z) : T.strategy === 4 || it === $ ? (tt(T, 2 + (Z ? 1 : 0), 3), Et(T, H, I)) : (tt(T, 4 + (Z ? 1 : 0), 3), function(st, ht, yt, bt) {
          var Xt;
          for (tt(st, ht - 257, 5), tt(st, yt - 1, 5), tt(st, bt - 4, 4), Xt = 0; Xt < bt; Xt++)
            tt(st, st.bl_tree[2 * L[Xt] + 1], 3);
          V(st, st.dyn_ltree, ht - 1), V(st, st.dyn_dtree, yt - 1);
        }(T, T.l_desc.max_code + 1, T.d_desc.max_code + 1, nt + 1), Et(T, T.dyn_ltree, T.dyn_dtree)), at(T), Z && lt(T);
      }, i._tr_tally = function(T, j, Q) {
        return T.pending_buf[T.d_buf + 2 * T.last_lit] = j >>> 8 & 255, T.pending_buf[T.d_buf + 2 * T.last_lit + 1] = 255 & j, T.pending_buf[T.l_buf + T.last_lit] = 255 & Q, T.last_lit++, j === 0 ? T.dyn_ltree[2 * Q]++ : (T.matches++, j--, T.dyn_ltree[2 * (A[Q] + u + 1)]++, T.dyn_dtree[2 * O(j)]++), T.last_lit === T.lit_bufsize - 1;
      }, i._tr_align = function(T) {
        tt(T, 2, 3), J(T, k, H), function(j) {
          j.bi_valid === 16 ? (q(j, j.bi_buf), j.bi_buf = 0, j.bi_valid = 0) : 8 <= j.bi_valid && (j.pending_buf[j.pending++] = 255 & j.bi_buf, j.bi_buf >>= 8, j.bi_valid -= 8);
        }(T);
      };
    }, { "../utils/common": 41 }], 53: [function(t, s, i) {
      s.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, s, i) {
      (function(r) {
        (function(n, a) {
          if (!n.setImmediate) {
            var h, c, d, u, f = 1, p = {}, m = !1, g = n.document, w = Object.getPrototypeOf && Object.getPrototypeOf(n);
            w = w && w.setTimeout ? w : n, h = {}.toString.call(n.process) === "[object process]" ? function(C) {
              process.nextTick(function() {
                _(C);
              });
            } : function() {
              if (n.postMessage && !n.importScripts) {
                var C = !0, N = n.onmessage;
                return n.onmessage = function() {
                  C = !1;
                }, n.postMessage("", "*"), n.onmessage = N, C;
              }
            }() ? (u = "setImmediate$" + Math.random() + "$", n.addEventListener ? n.addEventListener("message", k, !1) : n.attachEvent("onmessage", k), function(C) {
              n.postMessage(u + C, "*");
            }) : n.MessageChannel ? ((d = new MessageChannel()).port1.onmessage = function(C) {
              _(C.data);
            }, function(C) {
              d.port2.postMessage(C);
            }) : g && "onreadystatechange" in g.createElement("script") ? (c = g.documentElement, function(C) {
              var N = g.createElement("script");
              N.onreadystatechange = function() {
                _(C), N.onreadystatechange = null, c.removeChild(N), N = null;
              }, c.appendChild(N);
            }) : function(C) {
              setTimeout(_, 0, C);
            }, w.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var N = new Array(arguments.length - 1), R = 0; R < N.length; R++)
                N[R] = arguments[R + 1];
              var P = { callback: C, args: N };
              return p[f] = P, h(f), f++;
            }, w.clearImmediate = b;
          }
          function b(C) {
            delete p[C];
          }
          function _(C) {
            if (m)
              setTimeout(_, 0, C);
            else {
              var N = p[C];
              if (N) {
                m = !0;
                try {
                  (function(R) {
                    var P = R.callback, M = R.args;
                    switch (M.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(M[0]);
                        break;
                      case 2:
                        P(M[0], M[1]);
                        break;
                      case 3:
                        P(M[0], M[1], M[2]);
                        break;
                      default:
                        P.apply(a, M);
                    }
                  })(N);
                } finally {
                  b(C), m = !1;
                }
              }
            }
          }
          function k(C) {
            C.source === n && typeof C.data == "string" && C.data.indexOf(u) === 0 && _(+C.data.slice(u.length));
          }
        })(typeof self > "u" ? r === void 0 ? this : r : self);
      }).call(this, typeof Lo < "u" ? Lo : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(pm);
var P0 = pm.exports;
const L0 = /* @__PURE__ */ Wp(P0);
var Qt;
(function(l) {
  l.OfficeDocument = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", l.FontTable = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable", l.Image = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", l.Numbering = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering", l.Styles = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", l.StylesWithEffects = "http://schemas.microsoft.com/office/2007/relationships/stylesWithEffects", l.Theme = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", l.Settings = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings", l.WebSettings = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings", l.Hyperlink = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", l.Footnotes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes", l.Endnotes = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes", l.Footer = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer", l.Header = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header", l.ExtendedProperties = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", l.CoreProperties = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", l.CustomProperties = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/custom-properties", l.Comments = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments", l.CommentsExtended = "http://schemas.microsoft.com/office/2011/relationships/commentsExtended", l.AltChunk = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/aFChunk";
})(Qt || (Qt = {}));
function R0(l, e) {
  return e.elements(l).map((t) => ({
    id: e.attr(t, "Id"),
    type: e.attr(t, "Type"),
    target: e.attr(t, "Target"),
    targetMode: e.attr(t, "TargetMode")
  }));
}
function O0(l) {
  return l == null ? void 0 : l.replace(/[ .]+/g, "-").replace(/[&]+/g, "and").toLowerCase();
}
function Af(l) {
  return /^[^"'].*\s.*[^"']$/.test(l) ? `'${l}'` : l;
}
function vc(l) {
  let e = l.lastIndexOf("/") + 1, t = e == 0 ? "" : l.substring(0, e), s = e == 0 ? l : l.substring(e);
  return [t, s];
}
function df(l, e) {
  try {
    const t = "http://docx/";
    return new URL(l, t + e).toString().substring(t.length);
  } catch {
    return `${e}${l}`;
  }
}
function Ii(l, e) {
  return l.reduce((t, s) => (t[e(s)] = s, t), {});
}
function F0(l) {
  return new Promise((e, t) => {
    const s = new FileReader();
    s.onloadend = () => e(s.result), s.onerror = () => t(), s.readAsDataURL(l);
  });
}
function uf(l) {
  return l && typeof l == "object" && !Array.isArray(l);
}
function j0(l) {
  return typeof l == "string" || l instanceof String;
}
function Jc(l, ...e) {
  if (!e.length)
    return l;
  const t = e.shift();
  if (uf(l) && uf(t))
    for (const s in t)
      if (uf(t[s])) {
        const i = l[s] ?? (l[s] = {});
        Jc(i, t[s]);
      } else
        l[s] = t[s];
  return Jc(l, ...e);
}
function To(l) {
  return Array.isArray(l) ? l : [l];
}
function z0(l, e, t) {
  return e > l ? e : t < l ? t : l;
}
const gm = {
  wordml: "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  drawingml: "http://schemas.openxmlformats.org/drawingml/2006/main",
  picture: "http://schemas.openxmlformats.org/drawingml/2006/picture",
  compatibility: "http://schemas.openxmlformats.org/markup-compatibility/2006",
  math: "http://schemas.openxmlformats.org/officeDocument/2006/math"
}, Kt = {
  Dxa: { mul: 0.05, unit: "pt" },
  Emu: { mul: 1 / 12700, unit: "pt" },
  FontSize: { mul: 0.5, unit: "pt" },
  Border: { mul: 0.125, unit: "pt", min: 0.25, max: 12 },
  Point: { mul: 1, unit: "pt" },
  Percent: { mul: 0.02, unit: "%" },
  LineHeight: { mul: 1 / 240, unit: "" },
  VmlEmu: { mul: 1 / 12700, unit: "" }
};
function mm(l, e = Kt.Dxa) {
  if (l == null || /.+(p[xt]|[%])$/.test(l))
    return l;
  var t = parseInt(l) * e.mul;
  return e.min && e.max && (t = z0(t, e.min, e.max)), `${t.toFixed(2)}${e.unit}`;
}
function B0(l, e = !1) {
  switch (l) {
    case "1":
      return !0;
    case "0":
      return !1;
    case "on":
      return !0;
    case "off":
      return !1;
    case "true":
      return !0;
    case "false":
      return !1;
    default:
      return e;
  }
}
function bm(l, e, t) {
  if (l.namespaceURI != gm.wordml)
    return !1;
  switch (l.localName) {
    case "color":
      e.color = t.attr(l, "val");
      break;
    case "sz":
      e.fontSize = t.lengthAttr(l, "val", Kt.FontSize);
      break;
    default:
      return !1;
  }
  return !0;
}
function U0(l, e = !1) {
  e && (l = l.replace(/<[?].*[?]>/, "")), l = W0(l);
  const t = new DOMParser().parseFromString(l, "application/xml"), s = H0(t);
  if (s)
    throw new Error(s);
  return t;
}
function H0(l) {
  var e;
  return (e = l.getElementsByTagName("parsererror")[0]) == null ? void 0 : e.textContent;
}
function W0(l) {
  return l.charCodeAt(0) === 65279 ? l.substring(1) : l;
}
function $0(l) {
  return new XMLSerializer().serializeToString(l);
}
class ym {
  elements(e, t = null) {
    const s = [];
    for (let i = 0, r = e.childNodes.length; i < r; i++) {
      let n = e.childNodes.item(i);
      n.nodeType == 1 && (t == null || n.localName == t) && s.push(n);
    }
    return s;
  }
  element(e, t) {
    for (let s = 0, i = e.childNodes.length; s < i; s++) {
      let r = e.childNodes.item(s);
      if (r.nodeType == 1 && r.localName == t)
        return r;
    }
    return null;
  }
  elementAttr(e, t, s) {
    var i = this.element(e, t);
    return i ? this.attr(i, s) : void 0;
  }
  attrs(e) {
    return Array.from(e.attributes);
  }
  attr(e, t) {
    for (let s = 0, i = e.attributes.length; s < i; s++) {
      let r = e.attributes.item(s);
      if (r.localName == t)
        return r.value;
    }
    return null;
  }
  intAttr(e, t, s = null) {
    var i = this.attr(e, t);
    return i ? parseInt(i) : s;
  }
  hexAttr(e, t, s = null) {
    var i = this.attr(e, t);
    return i ? parseInt(i, 16) : s;
  }
  floatAttr(e, t, s = null) {
    var i = this.attr(e, t);
    return i ? parseFloat(i) : s;
  }
  boolAttr(e, t, s = null) {
    return B0(this.attr(e, t), s);
  }
  lengthAttr(e, t, s = Kt.Dxa) {
    return mm(this.attr(e, t), s);
  }
}
const W = new ym();
class Ke {
  constructor(e, t) {
    this._package = e, this.path = t;
  }
  async load() {
    this.rels = await this._package.loadRelationships(this.path);
    const e = await this._package.load(this.path), t = this._package.parseXmlDocument(e);
    this._package.options.keepOrigin && (this._xmlDocument = t), this.parseXml(t.firstElementChild);
  }
  save() {
    this._package.update(this.path, $0(this._xmlDocument));
  }
  parseXml(e) {
  }
}
const G0 = {
  embedRegular: "regular",
  embedBold: "bold",
  embedItalic: "italic",
  embedBoldItalic: "boldItalic"
};
function V0(l, e) {
  return e.elements(l).map((t) => Y0(t, e));
}
function Y0(l, e) {
  let t = {
    name: e.attr(l, "name"),
    embedFontRefs: []
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "family":
        t.family = e.attr(s, "val");
        break;
      case "altName":
        t.altName = e.attr(s, "val");
        break;
      case "embedRegular":
      case "embedBold":
      case "embedItalic":
      case "embedBoldItalic":
        t.embedFontRefs.push(X0(s, e));
        break;
    }
  return t;
}
function X0(l, e) {
  return {
    id: e.attr(l, "id"),
    key: e.attr(l, "fontKey"),
    type: G0[l.localName]
  };
}
class q0 extends Ke {
  parseXml(e) {
    this.fonts = V0(e, this._package.xmlParser);
  }
}
class Gp {
  constructor(e, t) {
    this._zip = e, this.options = t, this.xmlParser = new ym();
  }
  get(e) {
    const t = Q0(e);
    return this._zip.files[t] ?? this._zip.files[t.replace(/\//g, "\\")];
  }
  update(e, t) {
    this._zip.file(e, t);
  }
  static async load(e, t) {
    const s = await L0.loadAsync(e);
    return new Gp(s, t);
  }
  save(e = "blob") {
    return this._zip.generateAsync({ type: e });
  }
  load(e, t = "string") {
    var s;
    return ((s = this.get(e)) == null ? void 0 : s.async(t)) ?? Promise.resolve(null);
  }
  async loadRelationships(e = null) {
    let t = "_rels/.rels";
    if (e != null) {
      const [i, r] = vc(e);
      t = `${i}_rels/${r}.rels`;
    }
    const s = await this.load(t);
    return s ? R0(this.parseXmlDocument(s).firstElementChild, this.xmlParser) : null;
  }
  parseXmlDocument(e) {
    return U0(e, this.options.trimXmlDeclaration);
  }
}
function Q0(l) {
  return l.startsWith("/") ? l.substr(1) : l;
}
class K0 extends Ke {
  constructor(e, t, s) {
    super(e, t), this._documentParser = s;
  }
  parseXml(e) {
    this.body = this._documentParser.parseDocumentFile(e);
  }
}
function fc(l, e) {
  return {
    type: e.attr(l, "val"),
    color: e.attr(l, "color"),
    size: e.lengthAttr(l, "sz", Kt.Border),
    offset: e.lengthAttr(l, "space", Kt.Point),
    frame: e.boolAttr(l, "frame"),
    shadow: e.boolAttr(l, "shadow")
  };
}
function Z0(l, e) {
  var t = {};
  for (let s of e.elements(l))
    switch (s.localName) {
      case "left":
        t.left = fc(s, e);
        break;
      case "top":
        t.top = fc(s, e);
        break;
      case "right":
        t.right = fc(s, e);
        break;
      case "bottom":
        t.bottom = fc(s, e);
        break;
    }
  return t;
}
var vg;
(function(l) {
  l.Continuous = "continuous", l.NextPage = "nextPage", l.NextColumn = "nextColumn", l.EvenPage = "evenPage", l.OddPage = "oddPage";
})(vg || (vg = {}));
function vm(l, e = W) {
  var t = {};
  for (let s of e.elements(l))
    switch (s.localName) {
      case "pgSz":
        t.pageSize = {
          width: e.lengthAttr(s, "w"),
          height: e.lengthAttr(s, "h"),
          orientation: e.attr(s, "orient")
        };
        break;
      case "type":
        t.type = e.attr(s, "val");
        break;
      case "pgMar":
        t.pageMargins = {
          left: e.lengthAttr(s, "left"),
          right: e.lengthAttr(s, "right"),
          top: e.lengthAttr(s, "top"),
          bottom: e.lengthAttr(s, "bottom"),
          header: e.lengthAttr(s, "header"),
          footer: e.lengthAttr(s, "footer"),
          gutter: e.lengthAttr(s, "gutter")
        };
        break;
      case "cols":
        t.columns = J0(s, e);
        break;
      case "headerReference":
        (t.headerRefs ?? (t.headerRefs = [])).push(wg(s, e));
        break;
      case "footerReference":
        (t.footerRefs ?? (t.footerRefs = [])).push(wg(s, e));
        break;
      case "titlePg":
        t.titlePage = e.boolAttr(s, "val", !0);
        break;
      case "pgBorders":
        t.pageBorders = Z0(s, e);
        break;
      case "pgNumType":
        t.pageNumber = tv(s, e);
        break;
    }
  return t;
}
function J0(l, e) {
  return {
    numberOfColumns: e.intAttr(l, "num"),
    space: e.lengthAttr(l, "space"),
    separator: e.boolAttr(l, "sep"),
    equalWidth: e.boolAttr(l, "equalWidth", !0),
    columns: e.elements(l, "col").map((t) => ({
      width: e.lengthAttr(t, "w"),
      space: e.lengthAttr(t, "space")
    }))
  };
}
function tv(l, e) {
  return {
    chapSep: e.attr(l, "chapSep"),
    chapStyle: e.attr(l, "chapStyle"),
    format: e.attr(l, "fmt"),
    start: e.intAttr(l, "start")
  };
}
function wg(l, e) {
  return {
    id: e.attr(l, "id"),
    type: e.attr(l, "type")
  };
}
function ev(l, e) {
  return {
    before: e.lengthAttr(l, "before"),
    after: e.lengthAttr(l, "after"),
    line: e.intAttr(l, "line"),
    lineRule: e.attr(l, "lineRule")
  };
}
function Vp(l, e) {
  let t = {};
  for (let s of e.elements(l))
    sv(s, t, e);
  return t;
}
function sv(l, e, t) {
  return !!bm(l, e, t);
}
function wm(l, e) {
  let t = {};
  for (let s of e.elements(l))
    Am(s, t, e);
  return t;
}
function Am(l, e, t) {
  if (l.namespaceURI != gm.wordml)
    return !1;
  if (bm(l, e, t))
    return !0;
  switch (l.localName) {
    case "tabs":
      e.tabs = iv(l, t);
      break;
    case "sectPr":
      e.sectionProps = vm(l, t);
      break;
    case "numPr":
      e.numbering = rv(l, t);
      break;
    case "spacing":
      return e.lineSpacing = ev(l, t), !1;
    case "textAlignment":
      return e.textAlignment = t.attr(l, "val"), !1;
    case "keepLines":
      e.keepLines = t.boolAttr(l, "val", !0);
      break;
    case "keepNext":
      e.keepNext = t.boolAttr(l, "val", !0);
      break;
    case "pageBreakBefore":
      e.pageBreakBefore = t.boolAttr(l, "val", !0);
      break;
    case "outlineLvl":
      e.outlineLevel = t.intAttr(l, "val");
      break;
    case "pStyle":
      e.styleName = t.attr(l, "val");
      break;
    case "rPr":
      e.runProps = Vp(l, t);
      break;
    default:
      return !1;
  }
  return !0;
}
function iv(l, e) {
  return e.elements(l, "tab").map((t) => ({
    position: e.lengthAttr(t, "pos"),
    leader: e.attr(t, "leader"),
    style: e.attr(t, "val")
  }));
}
function rv(l, e) {
  var t = {};
  for (let s of e.elements(l))
    switch (s.localName) {
      case "numId":
        t.id = e.attr(s, "val");
        break;
      case "ilvl":
        t.level = e.intAttr(s, "val");
        break;
    }
  return t;
}
function nv(l, e) {
  let t = {
    numberings: [],
    abstractNumberings: [],
    bulletPictures: []
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "num":
        t.numberings.push(av(s, e));
        break;
      case "abstractNum":
        t.abstractNumberings.push(ov(s, e));
        break;
      case "numPicBullet":
        t.bulletPictures.push(hv(s, e));
        break;
    }
  return t;
}
function av(l, e) {
  let t = {
    id: e.attr(l, "numId"),
    overrides: []
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "abstractNumId":
        t.abstractId = e.attr(s, "val");
        break;
      case "lvlOverride":
        t.overrides.push(lv(s, e));
        break;
    }
  return t;
}
function ov(l, e) {
  let t = {
    id: e.attr(l, "abstractNumId"),
    levels: []
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "name":
        t.name = e.attr(s, "val");
        break;
      case "multiLevelType":
        t.multiLevelType = e.attr(s, "val");
        break;
      case "numStyleLink":
        t.numberingStyleLink = e.attr(s, "val");
        break;
      case "styleLink":
        t.styleLink = e.attr(s, "val");
        break;
      case "lvl":
        t.levels.push(_m(s, e));
        break;
    }
  return t;
}
function _m(l, e) {
  let t = {
    level: e.intAttr(l, "ilvl")
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "start":
        t.start = e.attr(s, "val");
        break;
      case "lvlRestart":
        t.restart = e.intAttr(s, "val");
        break;
      case "numFmt":
        t.format = e.attr(s, "val");
        break;
      case "lvlText":
        t.text = e.attr(s, "val");
        break;
      case "lvlJc":
        t.justification = e.attr(s, "val");
        break;
      case "lvlPicBulletId":
        t.bulletPictureId = e.attr(s, "val");
        break;
      case "pStyle":
        t.paragraphStyle = e.attr(s, "val");
        break;
      case "pPr":
        t.paragraphProps = wm(s, e);
        break;
      case "rPr":
        t.runProps = Vp(s, e);
        break;
    }
  return t;
}
function lv(l, e) {
  let t = {
    level: e.intAttr(l, "ilvl")
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "startOverride":
        t.start = e.intAttr(s, "val");
        break;
      case "lvl":
        t.numberingLevel = _m(s, e);
        break;
    }
  return t;
}
function hv(l, e) {
  var t = e.element(l, "pict"), s = t && e.element(t, "shape"), i = s && e.element(s, "imagedata");
  return i ? {
    id: e.attr(l, "numPicBulletId"),
    referenceId: e.attr(i, "id"),
    style: e.attr(s, "style")
  } : null;
}
class cv extends Ke {
  constructor(e, t, s) {
    super(e, t), this._documentParser = s;
  }
  parseXml(e) {
    Object.assign(this, nv(e, this._package.xmlParser)), this.domNumberings = this._documentParser.parseNumberingFile(e);
  }
}
class dv extends Ke {
  constructor(e, t, s) {
    super(e, t), this._documentParser = s;
  }
  parseXml(e) {
    this.styles = this._documentParser.parseStylesFile(e);
  }
}
var X;
(function(l) {
  l.Document = "document", l.Paragraph = "paragraph", l.Run = "run", l.Break = "break", l.NoBreakHyphen = "noBreakHyphen", l.Table = "table", l.Row = "row", l.Cell = "cell", l.Hyperlink = "hyperlink", l.SmartTag = "smartTag", l.Drawing = "drawing", l.Image = "image", l.Text = "text", l.Tab = "tab", l.Symbol = "symbol", l.BookmarkStart = "bookmarkStart", l.BookmarkEnd = "bookmarkEnd", l.Footer = "footer", l.Header = "header", l.FootnoteReference = "footnoteReference", l.EndnoteReference = "endnoteReference", l.Footnote = "footnote", l.Endnote = "endnote", l.SimpleField = "simpleField", l.ComplexField = "complexField", l.Instruction = "instruction", l.VmlPicture = "vmlPicture", l.MmlMath = "mmlMath", l.MmlMathParagraph = "mmlMathParagraph", l.MmlFraction = "mmlFraction", l.MmlFunction = "mmlFunction", l.MmlFunctionName = "mmlFunctionName", l.MmlNumerator = "mmlNumerator", l.MmlDenominator = "mmlDenominator", l.MmlRadical = "mmlRadical", l.MmlBase = "mmlBase", l.MmlDegree = "mmlDegree", l.MmlSuperscript = "mmlSuperscript", l.MmlSubscript = "mmlSubscript", l.MmlPreSubSuper = "mmlPreSubSuper", l.MmlSubArgument = "mmlSubArgument", l.MmlSuperArgument = "mmlSuperArgument", l.MmlNary = "mmlNary", l.MmlDelimiter = "mmlDelimiter", l.MmlRun = "mmlRun", l.MmlEquationArray = "mmlEquationArray", l.MmlLimit = "mmlLimit", l.MmlLimitLower = "mmlLimitLower", l.MmlMatrix = "mmlMatrix", l.MmlMatrixRow = "mmlMatrixRow", l.MmlBox = "mmlBox", l.MmlBar = "mmlBar", l.MmlGroupChar = "mmlGroupChar", l.VmlElement = "vmlElement", l.Inserted = "inserted", l.Deleted = "deleted", l.DeletedText = "deletedText", l.Comment = "comment", l.CommentReference = "commentReference", l.CommentRangeStart = "commentRangeStart", l.CommentRangeEnd = "commentRangeEnd", l.AltChunk = "altChunk";
})(X || (X = {}));
class zn {
  constructor() {
    this.children = [], this.cssStyle = {};
  }
}
class uv extends zn {
  constructor() {
    super(...arguments), this.type = X.Header;
  }
}
class fv extends zn {
  constructor() {
    super(...arguments), this.type = X.Footer;
  }
}
class Em extends Ke {
  constructor(e, t, s) {
    super(e, t), this._documentParser = s;
  }
  parseXml(e) {
    this.rootElement = this.createRootElement(), this.rootElement.children = this._documentParser.parseBodyElements(e);
  }
}
class pv extends Em {
  createRootElement() {
    return new uv();
  }
}
class gv extends Em {
  createRootElement() {
    return new fv();
  }
}
function mv(l, e) {
  const t = {};
  for (let s of e.elements(l))
    switch (s.localName) {
      case "Template":
        t.template = s.textContent;
        break;
      case "Pages":
        t.pages = Io(s.textContent);
        break;
      case "Words":
        t.words = Io(s.textContent);
        break;
      case "Characters":
        t.characters = Io(s.textContent);
        break;
      case "Application":
        t.application = s.textContent;
        break;
      case "Lines":
        t.lines = Io(s.textContent);
        break;
      case "Paragraphs":
        t.paragraphs = Io(s.textContent);
        break;
      case "Company":
        t.company = s.textContent;
        break;
      case "AppVersion":
        t.appVersion = s.textContent;
        break;
    }
  return t;
}
function Io(l) {
  if (!(typeof l > "u"))
    return parseInt(l);
}
class bv extends Ke {
  parseXml(e) {
    this.props = mv(e, this._package.xmlParser);
  }
}
function yv(l, e) {
  const t = {};
  for (let s of e.elements(l))
    switch (s.localName) {
      case "title":
        t.title = s.textContent;
        break;
      case "description":
        t.description = s.textContent;
        break;
      case "subject":
        t.subject = s.textContent;
        break;
      case "creator":
        t.creator = s.textContent;
        break;
      case "keywords":
        t.keywords = s.textContent;
        break;
      case "language":
        t.language = s.textContent;
        break;
      case "lastModifiedBy":
        t.lastModifiedBy = s.textContent;
        break;
      case "revision":
        s.textContent && (t.revision = parseInt(s.textContent));
        break;
    }
  return t;
}
class vv extends Ke {
  parseXml(e) {
    this.props = yv(e, this._package.xmlParser);
  }
}
class wv {
}
function Av(l, e) {
  var t = new wv(), s = e.element(l, "themeElements");
  for (let i of e.elements(s))
    switch (i.localName) {
      case "clrScheme":
        t.colorScheme = _v(i, e);
        break;
      case "fontScheme":
        t.fontScheme = Ev(i, e);
        break;
    }
  return t;
}
function _v(l, e) {
  var t = {
    name: e.attr(l, "name"),
    colors: {}
  };
  for (let r of e.elements(l)) {
    var s = e.element(r, "srgbClr"), i = e.element(r, "sysClr");
    s ? t.colors[r.localName] = e.attr(s, "val") : i && (t.colors[r.localName] = e.attr(i, "lastClr"));
  }
  return t;
}
function Ev(l, e) {
  var t = {
    name: e.attr(l, "name")
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "majorFont":
        t.majorFont = Ag(s, e);
        break;
      case "minorFont":
        t.minorFont = Ag(s, e);
        break;
    }
  return t;
}
function Ag(l, e) {
  return {
    latinTypeface: e.elementAttr(l, "latin", "typeface"),
    eaTypeface: e.elementAttr(l, "ea", "typeface"),
    csTypeface: e.elementAttr(l, "cs", "typeface")
  };
}
class xv extends Ke {
  constructor(e, t) {
    super(e, t);
  }
  parseXml(e) {
    this.theme = Av(e, this._package.xmlParser);
  }
}
class xm {
}
class Sv extends xm {
  constructor() {
    super(...arguments), this.type = X.Footnote;
  }
}
class kv extends xm {
  constructor() {
    super(...arguments), this.type = X.Endnote;
  }
}
class Sm extends Ke {
  constructor(e, t, s) {
    super(e, t), this._documentParser = s;
  }
}
class Mv extends Sm {
  constructor(e, t, s) {
    super(e, t, s);
  }
  parseXml(e) {
    this.notes = this._documentParser.parseNotes(e, "footnote", Sv);
  }
}
class Cv extends Sm {
  constructor(e, t, s) {
    super(e, t, s);
  }
  parseXml(e) {
    this.notes = this._documentParser.parseNotes(e, "endnote", kv);
  }
}
function Tv(l, e) {
  var t = {};
  for (let s of e.elements(l))
    switch (s.localName) {
      case "defaultTabStop":
        t.defaultTabStop = e.lengthAttr(s, "val");
        break;
      case "footnotePr":
        t.footnoteProps = _g(s, e);
        break;
      case "endnotePr":
        t.endnoteProps = _g(s, e);
        break;
      case "autoHyphenation":
        t.autoHyphenation = e.boolAttr(s, "val");
        break;
    }
  return t;
}
function _g(l, e) {
  var t = {
    defaultNoteIds: []
  };
  for (let s of e.elements(l))
    switch (s.localName) {
      case "numFmt":
        t.nummeringFormat = e.attr(s, "val");
        break;
      case "footnote":
      case "endnote":
        t.defaultNoteIds.push(e.attr(s, "id"));
        break;
    }
  return t;
}
class Iv extends Ke {
  constructor(e, t) {
    super(e, t);
  }
  parseXml(e) {
    this.settings = Tv(e, this._package.xmlParser);
  }
}
function Nv(l, e) {
  return e.elements(l, "property").map((t) => {
    const s = t.firstChild;
    return {
      formatId: e.attr(t, "fmtid"),
      name: e.attr(t, "name"),
      type: s.nodeName,
      value: s.textContent
    };
  });
}
class Dv extends Ke {
  parseXml(e) {
    this.props = Nv(e, this._package.xmlParser);
  }
}
class Pv extends Ke {
  constructor(e, t, s) {
    super(e, t), this._documentParser = s;
  }
  parseXml(e) {
    this.comments = this._documentParser.parseComments(e), this.commentMap = Ii(this.comments, (t) => t.id);
  }
}
class Lv extends Ke {
  constructor(e, t) {
    super(e, t), this.comments = [];
  }
  parseXml(e) {
    const t = this._package.xmlParser;
    for (let s of t.elements(e, "commentEx"))
      this.comments.push({
        paraId: t.attr(s, "paraId"),
        paraIdParent: t.attr(s, "paraIdParent"),
        done: t.boolAttr(s, "done")
      });
    this.commentMap = Ii(this.comments, (s) => s.paraId);
  }
}
const Rv = [
  { type: Qt.OfficeDocument, target: "word/document.xml" },
  { type: Qt.ExtendedProperties, target: "docProps/app.xml" },
  { type: Qt.CoreProperties, target: "docProps/core.xml" },
  { type: Qt.CustomProperties, target: "docProps/custom.xml" }
];
class Yp {
  constructor() {
    this.parts = [], this.partsMap = {};
  }
  static async load(e, t, s) {
    var i = new Yp();
    return i._options = s, i._parser = t, i._package = await Gp.load(e, s), i.rels = await i._package.loadRelationships(), await Promise.all(Rv.map((r) => {
      const n = i.rels.find((a) => a.type === r.type) ?? r;
      return i.loadRelationshipPart(n.target, n.type);
    })), i;
  }
  save(e = "blob") {
    return this._package.save(e);
  }
  async loadRelationshipPart(e, t) {
    var i;
    if (this.partsMap[e])
      return this.partsMap[e];
    if (!this._package.get(e))
      return null;
    let s = null;
    switch (t) {
      case Qt.OfficeDocument:
        this.documentPart = s = new K0(this._package, e, this._parser);
        break;
      case Qt.FontTable:
        this.fontTablePart = s = new q0(this._package, e);
        break;
      case Qt.Numbering:
        this.numberingPart = s = new cv(this._package, e, this._parser);
        break;
      case Qt.Styles:
        this.stylesPart = s = new dv(this._package, e, this._parser);
        break;
      case Qt.Theme:
        this.themePart = s = new xv(this._package, e);
        break;
      case Qt.Footnotes:
        this.footnotesPart = s = new Mv(this._package, e, this._parser);
        break;
      case Qt.Endnotes:
        this.endnotesPart = s = new Cv(this._package, e, this._parser);
        break;
      case Qt.Footer:
        s = new gv(this._package, e, this._parser);
        break;
      case Qt.Header:
        s = new pv(this._package, e, this._parser);
        break;
      case Qt.CoreProperties:
        this.corePropsPart = s = new vv(this._package, e);
        break;
      case Qt.ExtendedProperties:
        this.extendedPropsPart = s = new bv(this._package, e);
        break;
      case Qt.CustomProperties:
        s = new Dv(this._package, e);
        break;
      case Qt.Settings:
        this.settingsPart = s = new Iv(this._package, e);
        break;
      case Qt.Comments:
        this.commentsPart = s = new Pv(this._package, e, this._parser);
        break;
      case Qt.CommentsExtended:
        this.commentsExtendedPart = s = new Lv(this._package, e);
        break;
    }
    if (s == null)
      return Promise.resolve(null);
    if (this.partsMap[e] = s, this.parts.push(s), await s.load(), ((i = s.rels) == null ? void 0 : i.length) > 0) {
      const [r] = vc(s.path);
      await Promise.all(s.rels.map((n) => this.loadRelationshipPart(df(n.target, r), n.type)));
    }
    return s;
  }
  async loadDocumentImage(e, t) {
    const s = await this.loadResource(t ?? this.documentPart, e, "blob");
    return this.blobToURL(s);
  }
  async loadNumberingImage(e) {
    const t = await this.loadResource(this.numberingPart, e, "blob");
    return this.blobToURL(t);
  }
  async loadFont(e, t) {
    const s = await this.loadResource(this.fontTablePart, e, "uint8array");
    return s && this.blobToURL(new Blob([Ov(s, t)]));
  }
  async loadAltChunk(e, t) {
    return await this.loadResource(t ?? this.documentPart, e, "string");
  }
  blobToURL(e) {
    return e ? this._options.useBase64URL ? F0(e) : URL.createObjectURL(e) : null;
  }
  findPartByRelId(e, t = null) {
    var s = (t.rels ?? this.rels).find((r) => r.id == e);
    const i = t ? vc(t.path)[0] : "";
    return s ? this.partsMap[df(s.target, i)] : null;
  }
  getPathById(e, t) {
    const s = e.rels.find((r) => r.id == t), [i] = vc(e.path);
    return s ? df(s.target, i) : null;
  }
  loadResource(e, t, s) {
    const i = this.getPathById(e, t);
    return i ? this._package.load(i, s) : Promise.resolve(null);
  }
}
function Ov(l, e) {
  const s = e.replace(/{|}|-/g, ""), i = new Array(16);
  for (let r = 0; r < 16; r++)
    i[16 - r - 1] = parseInt(s.substr(r * 2, 2), 16);
  for (let r = 0; r < 32; r++)
    l[r] = l[r] ^ i[r % 16];
  return l;
}
function Fv(l, e) {
  return {
    type: X.BookmarkStart,
    id: e.attr(l, "id"),
    name: e.attr(l, "name"),
    colFirst: e.intAttr(l, "colFirst"),
    colLast: e.intAttr(l, "colLast")
  };
}
function jv(l, e) {
  return {
    type: X.BookmarkEnd,
    id: e.attr(l, "id")
  };
}
class zv extends zn {
  constructor() {
    super(...arguments), this.type = X.VmlElement, this.attrs = {};
  }
}
function km(l, e) {
  var t = new zv();
  switch (l.localName) {
    case "rect":
      t.tagName = "rect", Object.assign(t.attrs, { width: "100%", height: "100%" });
      break;
    case "oval":
      t.tagName = "ellipse", Object.assign(t.attrs, { cx: "50%", cy: "50%", rx: "50%", ry: "50%" });
      break;
    case "line":
      t.tagName = "line";
      break;
    case "shape":
      t.tagName = "g";
      break;
    case "textbox":
      t.tagName = "foreignObject", Object.assign(t.attrs, { width: "100%", height: "100%" });
      break;
    default:
      return null;
  }
  for (const s of W.attrs(l))
    switch (s.localName) {
      case "style":
        t.cssStyleText = s.value;
        break;
      case "fillcolor":
        t.attrs.fill = s.value;
        break;
      case "from":
        const [i, r] = Eg(s.value);
        Object.assign(t.attrs, { x1: i, y1: r });
        break;
      case "to":
        const [n, a] = Eg(s.value);
        Object.assign(t.attrs, { x2: n, y2: a });
        break;
    }
  for (const s of W.elements(l))
    switch (s.localName) {
      case "stroke":
        Object.assign(t.attrs, Bv(s));
        break;
      case "fill":
        Object.assign(t.attrs, Uv());
        break;
      case "imagedata":
        t.tagName = "image", Object.assign(t.attrs, { width: "100%", height: "100%" }), t.imageHref = {
          id: W.attr(s, "id"),
          title: W.attr(s, "title")
        };
        break;
      case "txbxContent":
        t.children.push(...e.parseBodyElements(s));
        break;
      default:
        const i = km(s, e);
        i && t.children.push(i);
        break;
    }
  return t;
}
function Bv(l) {
  return {
    stroke: W.attr(l, "color"),
    "stroke-width": W.lengthAttr(l, "weight", Kt.Emu) ?? "1px"
  };
}
function Uv(l) {
  return {};
}
function Eg(l) {
  return l.split(",");
}
class Hv extends zn {
  constructor() {
    super(...arguments), this.type = X.Comment;
  }
}
class Wv extends zn {
  constructor(e) {
    super(), this.id = e, this.type = X.CommentReference;
  }
}
class $v extends zn {
  constructor(e) {
    super(), this.id = e, this.type = X.CommentRangeStart;
  }
}
class Gv extends zn {
  constructor(e) {
    super(), this.id = e, this.type = X.CommentRangeEnd;
  }
}
var wc = {
  shd: "inherit",
  color: "black",
  borderColor: "black",
  highlight: "transparent"
};
const Vv = [], xg = {
  oMath: X.MmlMath,
  oMathPara: X.MmlMathParagraph,
  f: X.MmlFraction,
  func: X.MmlFunction,
  fName: X.MmlFunctionName,
  num: X.MmlNumerator,
  den: X.MmlDenominator,
  rad: X.MmlRadical,
  deg: X.MmlDegree,
  e: X.MmlBase,
  sSup: X.MmlSuperscript,
  sSub: X.MmlSubscript,
  sPre: X.MmlPreSubSuper,
  sup: X.MmlSuperArgument,
  sub: X.MmlSubArgument,
  d: X.MmlDelimiter,
  nary: X.MmlNary,
  eqArr: X.MmlEquationArray,
  lim: X.MmlLimit,
  limLow: X.MmlLimitLower,
  m: X.MmlMatrix,
  mr: X.MmlMatrixRow,
  box: X.MmlBox,
  bar: X.MmlBar,
  groupChr: X.MmlGroupChar
};
class Yv {
  constructor(e) {
    this.options = {
      ignoreWidth: !1,
      debug: !1,
      ...e
    };
  }
  parseNotes(e, t, s) {
    var i = [];
    for (let r of W.elements(e, t)) {
      const n = new s();
      n.id = W.attr(r, "id"), n.noteType = W.attr(r, "type"), n.children = this.parseBodyElements(r), i.push(n);
    }
    return i;
  }
  parseComments(e) {
    var t = [];
    for (let s of W.elements(e, "comment")) {
      const i = new Hv();
      i.id = W.attr(s, "id"), i.author = W.attr(s, "author"), i.initials = W.attr(s, "initials"), i.date = W.attr(s, "date"), i.children = this.parseBodyElements(s), t.push(i);
    }
    return t;
  }
  parseDocumentFile(e) {
    var t = W.element(e, "body"), s = W.element(e, "background"), i = W.element(t, "sectPr");
    return {
      type: X.Document,
      children: this.parseBodyElements(t),
      props: i ? vm(i, W) : {},
      cssStyle: s ? this.parseBackground(s) : {}
    };
  }
  parseBackground(e) {
    var t = {}, s = jt.colorAttr(e, "color");
    return s && (t["background-color"] = s), t;
  }
  parseBodyElements(e) {
    var t = [];
    for (let s of W.elements(e))
      switch (s.localName) {
        case "p":
          t.push(this.parseParagraph(s));
          break;
        case "altChunk":
          t.push(this.parseAltChunk(s));
          break;
        case "tbl":
          t.push(this.parseTable(s));
          break;
        case "sdt":
          t.push(...this.parseSdt(s, (i) => this.parseBodyElements(i)));
          break;
      }
    return t;
  }
  parseStylesFile(e) {
    var t = [];
    return jt.foreach(e, (s) => {
      switch (s.localName) {
        case "style":
          t.push(this.parseStyle(s));
          break;
        case "docDefaults":
          t.push(this.parseDefaultStyles(s));
          break;
      }
    }), t;
  }
  parseDefaultStyles(e) {
    var t = {
      id: null,
      name: null,
      target: null,
      basedOn: null,
      styles: []
    };
    return jt.foreach(e, (s) => {
      switch (s.localName) {
        case "rPrDefault":
          var i = W.element(s, "rPr");
          i && t.styles.push({
            target: "span",
            values: this.parseDefaultProperties(i, {})
          });
          break;
        case "pPrDefault":
          var r = W.element(s, "pPr");
          r && t.styles.push({
            target: "p",
            values: this.parseDefaultProperties(r, {})
          });
          break;
      }
    }), t;
  }
  parseStyle(e) {
    var t = {
      id: W.attr(e, "styleId"),
      isDefault: W.boolAttr(e, "default"),
      name: null,
      target: null,
      basedOn: null,
      styles: [],
      linked: null
    };
    switch (W.attr(e, "type")) {
      case "paragraph":
        t.target = "p";
        break;
      case "table":
        t.target = "table";
        break;
      case "character":
        t.target = "span";
        break;
    }
    return jt.foreach(e, (s) => {
      switch (s.localName) {
        case "basedOn":
          t.basedOn = W.attr(s, "val");
          break;
        case "name":
          t.name = W.attr(s, "val");
          break;
        case "link":
          t.linked = W.attr(s, "val");
          break;
        case "next":
          t.next = W.attr(s, "val");
          break;
        case "aliases":
          t.aliases = W.attr(s, "val").split(",");
          break;
        case "pPr":
          t.styles.push({
            target: "p",
            values: this.parseDefaultProperties(s, {})
          }), t.paragraphProps = wm(s, W);
          break;
        case "rPr":
          t.styles.push({
            target: "span",
            values: this.parseDefaultProperties(s, {})
          }), t.runProps = Vp(s, W);
          break;
        case "tblPr":
        case "tcPr":
          t.styles.push({
            target: "td",
            values: this.parseDefaultProperties(s, {})
          });
          break;
        case "tblStylePr":
          for (let i of this.parseTableStyle(s))
            t.styles.push(i);
          break;
        case "rsid":
        case "qFormat":
        case "hidden":
        case "semiHidden":
        case "unhideWhenUsed":
        case "autoRedefine":
        case "uiPriority":
          break;
        default:
          this.options.debug && console.warn(`DOCX: Unknown style element: ${s.localName}`);
      }
    }), t;
  }
  parseTableStyle(e) {
    var t = [], s = W.attr(e, "type"), i = "", r = "";
    switch (s) {
      case "firstRow":
        r = ".first-row", i = "tr.first-row td";
        break;
      case "lastRow":
        r = ".last-row", i = "tr.last-row td";
        break;
      case "firstCol":
        r = ".first-col", i = "td.first-col";
        break;
      case "lastCol":
        r = ".last-col", i = "td.last-col";
        break;
      case "band1Vert":
        r = ":not(.no-vband)", i = "td.odd-col";
        break;
      case "band2Vert":
        r = ":not(.no-vband)", i = "td.even-col";
        break;
      case "band1Horz":
        r = ":not(.no-hband)", i = "tr.odd-row";
        break;
      case "band2Horz":
        r = ":not(.no-hband)", i = "tr.even-row";
        break;
      default:
        return [];
    }
    return jt.foreach(e, (n) => {
      switch (n.localName) {
        case "pPr":
          t.push({
            target: `${i} p`,
            mod: r,
            values: this.parseDefaultProperties(n, {})
          });
          break;
        case "rPr":
          t.push({
            target: `${i} span`,
            mod: r,
            values: this.parseDefaultProperties(n, {})
          });
          break;
        case "tblPr":
        case "tcPr":
          t.push({
            target: i,
            mod: r,
            values: this.parseDefaultProperties(n, {})
          });
          break;
      }
    }), t;
  }
  parseNumberingFile(e) {
    var t = [], s = {}, i = [];
    return jt.foreach(e, (r) => {
      switch (r.localName) {
        case "abstractNum":
          this.parseAbstractNumbering(r, i).forEach((h) => t.push(h));
          break;
        case "numPicBullet":
          i.push(this.parseNumberingPicBullet(r));
          break;
        case "num":
          var n = W.attr(r, "numId"), a = W.elementAttr(r, "abstractNumId", "val");
          s[a] = n;
          break;
      }
    }), t.forEach((r) => r.id = s[r.id]), t;
  }
  parseNumberingPicBullet(e) {
    var t = W.element(e, "pict"), s = t && W.element(t, "shape"), i = s && W.element(s, "imagedata");
    return i ? {
      id: W.intAttr(e, "numPicBulletId"),
      src: W.attr(i, "id"),
      style: W.attr(s, "style")
    } : null;
  }
  parseAbstractNumbering(e, t) {
    var s = [], i = W.attr(e, "abstractNumId");
    return jt.foreach(e, (r) => {
      switch (r.localName) {
        case "lvl":
          s.push(this.parseNumberingLevel(i, r, t));
          break;
      }
    }), s;
  }
  parseNumberingLevel(e, t, s) {
    var i = {
      id: e,
      level: W.intAttr(t, "ilvl"),
      start: 1,
      pStyleName: void 0,
      pStyle: {},
      rStyle: {},
      suff: "tab"
    };
    return jt.foreach(t, (r) => {
      switch (r.localName) {
        case "start":
          i.start = W.intAttr(r, "val");
          break;
        case "pPr":
          this.parseDefaultProperties(r, i.pStyle);
          break;
        case "rPr":
          this.parseDefaultProperties(r, i.rStyle);
          break;
        case "lvlPicBulletId":
          var n = W.intAttr(r, "val");
          i.bullet = s.find((a) => (a == null ? void 0 : a.id) == n);
          break;
        case "lvlText":
          i.levelText = W.attr(r, "val");
          break;
        case "pStyle":
          i.pStyleName = W.attr(r, "val");
          break;
        case "numFmt":
          i.format = W.attr(r, "val");
          break;
        case "suff":
          i.suff = W.attr(r, "val");
          break;
      }
    }), i;
  }
  parseSdt(e, t) {
    const s = W.element(e, "sdtContent");
    return s ? t(s) : [];
  }
  parseInserted(e, t) {
    var s;
    return {
      type: X.Inserted,
      children: ((s = t(e)) == null ? void 0 : s.children) ?? []
    };
  }
  parseDeleted(e, t) {
    var s;
    return {
      type: X.Deleted,
      children: ((s = t(e)) == null ? void 0 : s.children) ?? []
    };
  }
  parseAltChunk(e) {
    return { type: X.AltChunk, children: [], id: W.attr(e, "id") };
  }
  parseParagraph(e) {
    var t = { type: X.Paragraph, children: [] };
    for (let s of W.elements(e))
      switch (s.localName) {
        case "pPr":
          this.parseParagraphProperties(s, t);
          break;
        case "r":
          t.children.push(this.parseRun(s, t));
          break;
        case "hyperlink":
          t.children.push(this.parseHyperlink(s, t));
          break;
        case "smartTag":
          t.children.push(this.parseSmartTag(s, t));
          break;
        case "bookmarkStart":
          t.children.push(Fv(s, W));
          break;
        case "bookmarkEnd":
          t.children.push(jv(s, W));
          break;
        case "commentRangeStart":
          t.children.push(new $v(W.attr(s, "id")));
          break;
        case "commentRangeEnd":
          t.children.push(new Gv(W.attr(s, "id")));
          break;
        case "oMath":
        case "oMathPara":
          t.children.push(this.parseMathElement(s));
          break;
        case "sdt":
          t.children.push(...this.parseSdt(s, (i) => this.parseParagraph(i).children));
          break;
        case "ins":
          t.children.push(this.parseInserted(s, (i) => this.parseParagraph(i)));
          break;
        case "del":
          t.children.push(this.parseDeleted(s, (i) => this.parseParagraph(i)));
          break;
      }
    return t;
  }
  parseParagraphProperties(e, t) {
    this.parseDefaultProperties(e, t.cssStyle = {}, null, (s) => {
      if (Am(s, t, W))
        return !0;
      switch (s.localName) {
        case "pStyle":
          t.styleName = W.attr(s, "val");
          break;
        case "cnfStyle":
          t.className = Ft.classNameOfCnfStyle(s);
          break;
        case "framePr":
          this.parseFrame(s, t);
          break;
        case "rPr":
          break;
        default:
          return !1;
      }
      return !0;
    });
  }
  parseFrame(e, t) {
    var s = W.attr(e, "dropCap");
    s == "drop" && (t.cssStyle.float = "left");
  }
  parseHyperlink(e, t) {
    var s = { type: X.Hyperlink, parent: t, children: [] };
    return s.anchor = W.attr(e, "anchor"), s.id = W.attr(e, "id"), jt.foreach(e, (i) => {
      switch (i.localName) {
        case "r":
          s.children.push(this.parseRun(i, s));
          break;
      }
    }), s;
  }
  parseSmartTag(e, t) {
    var s = { type: X.SmartTag, parent: t, children: [] }, i = W.attr(e, "uri"), r = W.attr(e, "element");
    return i && (s.uri = i), r && (s.element = r), jt.foreach(e, (n) => {
      switch (n.localName) {
        case "r":
          s.children.push(this.parseRun(n, s));
          break;
      }
    }), s;
  }
  parseRun(e, t) {
    var s = { type: X.Run, parent: t, children: [] };
    return jt.foreach(e, (i) => {
      switch (i = this.checkAlternateContent(i), i.localName) {
        case "t":
          s.children.push({
            type: X.Text,
            text: i.textContent
          });
          break;
        case "delText":
          s.children.push({
            type: X.DeletedText,
            text: i.textContent
          });
          break;
        case "commentReference":
          s.children.push(new Wv(W.attr(i, "id")));
          break;
        case "fldSimple":
          s.children.push({
            type: X.SimpleField,
            instruction: W.attr(i, "instr"),
            lock: W.boolAttr(i, "lock", !1),
            dirty: W.boolAttr(i, "dirty", !1)
          });
          break;
        case "instrText":
          s.fieldRun = !0, s.children.push({
            type: X.Instruction,
            text: i.textContent
          });
          break;
        case "fldChar":
          s.fieldRun = !0, s.children.push({
            type: X.ComplexField,
            charType: W.attr(i, "fldCharType"),
            lock: W.boolAttr(i, "lock", !1),
            dirty: W.boolAttr(i, "dirty", !1)
          });
          break;
        case "noBreakHyphen":
          s.children.push({ type: X.NoBreakHyphen });
          break;
        case "br":
          s.children.push({
            type: X.Break,
            break: W.attr(i, "type") || "textWrapping"
          });
          break;
        case "lastRenderedPageBreak":
          s.children.push({
            type: X.Break,
            break: "lastRenderedPageBreak"
          });
          break;
        case "sym":
          s.children.push({
            type: X.Symbol,
            font: Af(W.attr(i, "font")),
            char: W.attr(i, "char")
          });
          break;
        case "tab":
          s.children.push({ type: X.Tab });
          break;
        case "footnoteReference":
          s.children.push({
            type: X.FootnoteReference,
            id: W.attr(i, "id")
          });
          break;
        case "endnoteReference":
          s.children.push({
            type: X.EndnoteReference,
            id: W.attr(i, "id")
          });
          break;
        case "drawing":
          let r = this.parseDrawing(i);
          r && (s.children = [r]);
          break;
        case "pict":
          s.children.push(this.parseVmlPicture(i));
          break;
        case "rPr":
          this.parseRunProperties(i, s);
          break;
      }
    }), s;
  }
  parseMathElement(e) {
    const t = `${e.localName}Pr`, s = { type: xg[e.localName], children: [] };
    for (const r of W.elements(e))
      if (xg[r.localName])
        s.children.push(this.parseMathElement(r));
      else if (r.localName == "r") {
        var i = this.parseRun(r);
        i.type = X.MmlRun, s.children.push(i);
      } else
        r.localName == t && (s.props = this.parseMathProperies(r));
    return s;
  }
  parseMathProperies(e) {
    const t = {};
    for (const s of W.elements(e))
      switch (s.localName) {
        case "chr":
          t.char = W.attr(s, "val");
          break;
        case "vertJc":
          t.verticalJustification = W.attr(s, "val");
          break;
        case "pos":
          t.position = W.attr(s, "val");
          break;
        case "degHide":
          t.hideDegree = W.boolAttr(s, "val");
          break;
        case "begChr":
          t.beginChar = W.attr(s, "val");
          break;
        case "endChr":
          t.endChar = W.attr(s, "val");
          break;
      }
    return t;
  }
  parseRunProperties(e, t) {
    this.parseDefaultProperties(e, t.cssStyle = {}, null, (s) => {
      switch (s.localName) {
        case "rStyle":
          t.styleName = W.attr(s, "val");
          break;
        case "vertAlign":
          t.verticalAlign = Ft.valueOfVertAlign(s, !0);
          break;
        default:
          return !1;
      }
      return !0;
    });
  }
  parseVmlPicture(e) {
    const t = { type: X.VmlPicture, children: [] };
    for (const s of W.elements(e)) {
      const i = km(s, this);
      i && t.children.push(i);
    }
    return t;
  }
  checkAlternateContent(e) {
    var r;
    if (e.localName != "AlternateContent")
      return e;
    var t = W.element(e, "Choice");
    if (t) {
      var s = W.attr(t, "Requires"), i = e.lookupNamespaceURI(s);
      if (Vv.includes(i))
        return t.firstElementChild;
    }
    return (r = W.element(e, "Fallback")) == null ? void 0 : r.firstElementChild;
  }
  parseDrawing(e) {
    for (var t of W.elements(e))
      switch (t.localName) {
        case "inline":
        case "anchor":
          return this.parseDrawingWrapper(t);
      }
  }
  parseDrawingWrapper(e) {
    var t = { type: X.Drawing, children: [], cssStyle: {} }, s = e.localName == "anchor";
    let i = null, r = W.boolAttr(e, "simplePos");
    W.boolAttr(e, "behindDoc");
    let n = { relative: "page", align: "left", offset: "0" }, a = { relative: "page", align: "top", offset: "0" };
    for (var h of W.elements(e))
      switch (h.localName) {
        case "simplePos":
          r && (n.offset = W.lengthAttr(h, "x", Kt.Emu), a.offset = W.lengthAttr(h, "y", Kt.Emu));
          break;
        case "extent":
          t.cssStyle.width = W.lengthAttr(h, "cx", Kt.Emu), t.cssStyle.height = W.lengthAttr(h, "cy", Kt.Emu);
          break;
        case "positionH":
        case "positionV":
          if (!r) {
            let f = h.localName == "positionH" ? n : a;
            var c = W.element(h, "align"), d = W.element(h, "posOffset");
            f.relative = W.attr(h, "relativeFrom") ?? f.relative, c && (f.align = c.textContent), d && (f.offset = jt.sizeValue(d, Kt.Emu));
          }
          break;
        case "wrapTopAndBottom":
          i = "wrapTopAndBottom";
          break;
        case "wrapNone":
          i = "wrapNone";
          break;
        case "graphic":
          var u = this.parseGraphic(h);
          u && t.children.push(u);
          break;
      }
    return i == "wrapTopAndBottom" ? (t.cssStyle.display = "block", n.align && (t.cssStyle["text-align"] = n.align, t.cssStyle.width = "100%")) : i == "wrapNone" ? (t.cssStyle.display = "block", t.cssStyle.position = "relative", t.cssStyle.width = "0px", t.cssStyle.height = "0px", n.offset && (t.cssStyle.left = n.offset), a.offset && (t.cssStyle.top = a.offset)) : s && (n.align == "left" || n.align == "right") && (t.cssStyle.float = n.align), t;
  }
  parseGraphic(e) {
    var t = W.element(e, "graphicData");
    for (let s of W.elements(t))
      switch (s.localName) {
        case "pic":
          return this.parsePicture(s);
      }
    return null;
  }
  parsePicture(e) {
    var t = { type: X.Image, src: "", cssStyle: {} }, s = W.element(e, "blipFill"), i = W.element(s, "blip");
    t.src = W.attr(i, "embed");
    var r = W.element(e, "spPr"), n = W.element(r, "xfrm");
    t.cssStyle.position = "relative";
    for (var a of W.elements(n))
      switch (a.localName) {
        case "ext":
          t.cssStyle.width = W.lengthAttr(a, "cx", Kt.Emu), t.cssStyle.height = W.lengthAttr(a, "cy", Kt.Emu);
          break;
        case "off":
          t.cssStyle.left = W.lengthAttr(a, "x", Kt.Emu), t.cssStyle.top = W.lengthAttr(a, "y", Kt.Emu);
          break;
      }
    return t;
  }
  parseTable(e) {
    var t = { type: X.Table, children: [] };
    return jt.foreach(e, (s) => {
      switch (s.localName) {
        case "tr":
          t.children.push(this.parseTableRow(s));
          break;
        case "tblGrid":
          t.columns = this.parseTableColumns(s);
          break;
        case "tblPr":
          this.parseTableProperties(s, t);
          break;
      }
    }), t;
  }
  parseTableColumns(e) {
    var t = [];
    return jt.foreach(e, (s) => {
      switch (s.localName) {
        case "gridCol":
          t.push({ width: W.lengthAttr(s, "w") });
          break;
      }
    }), t;
  }
  parseTableProperties(e, t) {
    switch (t.cssStyle = {}, t.cellStyle = {}, this.parseDefaultProperties(e, t.cssStyle, t.cellStyle, (s) => {
      switch (s.localName) {
        case "tblStyle":
          t.styleName = W.attr(s, "val");
          break;
        case "tblLook":
          t.className = Ft.classNameOftblLook(s);
          break;
        case "tblpPr":
          this.parseTablePosition(s, t);
          break;
        case "tblStyleColBandSize":
          t.colBandSize = W.intAttr(s, "val");
          break;
        case "tblStyleRowBandSize":
          t.rowBandSize = W.intAttr(s, "val");
          break;
        default:
          return !1;
      }
      return !0;
    }), t.cssStyle["text-align"]) {
      case "center":
        delete t.cssStyle["text-align"], t.cssStyle["margin-left"] = "auto", t.cssStyle["margin-right"] = "auto";
        break;
      case "right":
        delete t.cssStyle["text-align"], t.cssStyle["margin-left"] = "auto";
        break;
    }
  }
  parseTablePosition(e, t) {
    var s = W.lengthAttr(e, "topFromText"), i = W.lengthAttr(e, "bottomFromText"), r = W.lengthAttr(e, "rightFromText"), n = W.lengthAttr(e, "leftFromText");
    t.cssStyle.float = "left", t.cssStyle["margin-bottom"] = Ft.addSize(t.cssStyle["margin-bottom"], i), t.cssStyle["margin-left"] = Ft.addSize(t.cssStyle["margin-left"], n), t.cssStyle["margin-right"] = Ft.addSize(t.cssStyle["margin-right"], r), t.cssStyle["margin-top"] = Ft.addSize(t.cssStyle["margin-top"], s);
  }
  parseTableRow(e) {
    var t = { type: X.Row, children: [] };
    return jt.foreach(e, (s) => {
      switch (s.localName) {
        case "tc":
          t.children.push(this.parseTableCell(s));
          break;
        case "trPr":
          this.parseTableRowProperties(s, t);
          break;
      }
    }), t;
  }
  parseTableRowProperties(e, t) {
    t.cssStyle = this.parseDefaultProperties(e, {}, null, (s) => {
      switch (s.localName) {
        case "cnfStyle":
          t.className = Ft.classNameOfCnfStyle(s);
          break;
        case "tblHeader":
          t.isHeader = W.boolAttr(s, "val");
          break;
        default:
          return !1;
      }
      return !0;
    });
  }
  parseTableCell(e) {
    var t = { type: X.Cell, children: [] };
    return jt.foreach(e, (s) => {
      switch (s.localName) {
        case "tbl":
          t.children.push(this.parseTable(s));
          break;
        case "p":
          t.children.push(this.parseParagraph(s));
          break;
        case "tcPr":
          this.parseTableCellProperties(s, t);
          break;
      }
    }), t;
  }
  parseTableCellProperties(e, t) {
    t.cssStyle = this.parseDefaultProperties(e, {}, null, (s) => {
      switch (s.localName) {
        case "gridSpan":
          t.span = W.intAttr(s, "val", null);
          break;
        case "vMerge":
          t.verticalMerge = W.attr(s, "val") ?? "continue";
          break;
        case "cnfStyle":
          t.className = Ft.classNameOfCnfStyle(s);
          break;
        default:
          return !1;
      }
      return !0;
    }), this.parseTableCellVerticalText(e, t);
  }
  parseTableCellVerticalText(e, t) {
    const s = {
      btLr: {
        writingMode: "vertical-rl",
        transform: "rotate(180deg)"
      },
      lrTb: {
        writingMode: "vertical-lr",
        transform: "none"
      },
      tbRl: {
        writingMode: "vertical-rl",
        transform: "none"
      }
    };
    jt.foreach(e, (i) => {
      if (i.localName === "textDirection") {
        const r = W.attr(i, "val"), n = s[r] || { writingMode: "horizontal-tb" };
        t.cssStyle["writing-mode"] = n.writingMode, t.cssStyle.transform = n.transform;
      }
    });
  }
  parseDefaultProperties(e, t = null, s = null, i = null) {
    return t = t || {}, jt.foreach(e, (r) => {
      if (!(i != null && i(r)))
        switch (r.localName) {
          case "jc":
            t["text-align"] = Ft.valueOfJc(r);
            break;
          case "textAlignment":
            t["vertical-align"] = Ft.valueOfTextAlignment(r);
            break;
          case "color":
            t.color = jt.colorAttr(r, "val", null, wc.color);
            break;
          case "sz":
            t["font-size"] = t["min-height"] = W.lengthAttr(r, "val", Kt.FontSize);
            break;
          case "shd":
            t["background-color"] = jt.colorAttr(r, "fill", null, wc.shd);
            break;
          case "highlight":
            t["background-color"] = jt.colorAttr(r, "val", null, wc.highlight);
            break;
          case "vertAlign":
            break;
          case "position":
            t.verticalAlign = W.lengthAttr(r, "val", Kt.FontSize);
            break;
          case "tcW":
            if (this.options.ignoreWidth)
              break;
          case "tblW":
            t.width = Ft.valueOfSize(r, "w");
            break;
          case "trHeight":
            this.parseTrHeight(r, t);
            break;
          case "strike":
            t["text-decoration"] = W.boolAttr(r, "val", !0) ? "line-through" : "none";
            break;
          case "b":
            t["font-weight"] = W.boolAttr(r, "val", !0) ? "bold" : "normal";
            break;
          case "i":
            t["font-style"] = W.boolAttr(r, "val", !0) ? "italic" : "normal";
            break;
          case "caps":
            t["text-transform"] = W.boolAttr(r, "val", !0) ? "uppercase" : "none";
            break;
          case "smallCaps":
            t["font-variant"] = W.boolAttr(r, "val", !0) ? "small-caps" : "none";
            break;
          case "u":
            this.parseUnderline(r, t);
            break;
          case "ind":
          case "tblInd":
            this.parseIndentation(r, t);
            break;
          case "rFonts":
            this.parseFont(r, t);
            break;
          case "tblBorders":
            this.parseBorderProperties(r, s || t);
            break;
          case "tblCellSpacing":
            t["border-spacing"] = Ft.valueOfMargin(r), t["border-collapse"] = "separate";
            break;
          case "pBdr":
            this.parseBorderProperties(r, t);
            break;
          case "bdr":
            t.border = Ft.valueOfBorder(r);
            break;
          case "tcBorders":
            this.parseBorderProperties(r, t);
            break;
          case "vanish":
            W.boolAttr(r, "val", !0) && (t.display = "none");
            break;
          case "kern":
            break;
          case "noWrap":
            break;
          case "tblCellMar":
          case "tcMar":
            this.parseMarginProperties(r, s || t);
            break;
          case "tblLayout":
            t["table-layout"] = Ft.valueOfTblLayout(r);
            break;
          case "vAlign":
            t["vertical-align"] = Ft.valueOfTextAlignment(r);
            break;
          case "spacing":
            e.localName == "pPr" && this.parseSpacing(r, t);
            break;
          case "wordWrap":
            W.boolAttr(r, "val") && (t["overflow-wrap"] = "break-word");
            break;
          case "suppressAutoHyphens":
            t.hyphens = W.boolAttr(r, "val", !0) ? "none" : "auto";
            break;
          case "lang":
            t.$lang = W.attr(r, "val");
            break;
          case "bCs":
          case "iCs":
          case "szCs":
          case "tabs":
          case "outlineLvl":
          case "contextualSpacing":
          case "tblStyleColBandSize":
          case "tblStyleRowBandSize":
          case "webHidden":
          case "pageBreakBefore":
          case "suppressLineNumbers":
          case "keepLines":
          case "keepNext":
          case "widowControl":
          case "bidi":
          case "rtl":
          case "noProof":
            break;
          default:
            this.options.debug && console.warn(`DOCX: Unknown document element: ${e.localName}.${r.localName}`);
            break;
        }
    }), t;
  }
  parseUnderline(e, t) {
    var s = W.attr(e, "val");
    if (s != null) {
      switch (s) {
        case "dash":
        case "dashDotDotHeavy":
        case "dashDotHeavy":
        case "dashedHeavy":
        case "dashLong":
        case "dashLongHeavy":
        case "dotDash":
        case "dotDotDash":
          t["text-decoration"] = "underline dashed";
          break;
        case "dotted":
        case "dottedHeavy":
          t["text-decoration"] = "underline dotted";
          break;
        case "double":
          t["text-decoration"] = "underline double";
          break;
        case "single":
        case "thick":
          t["text-decoration"] = "underline";
          break;
        case "wave":
        case "wavyDouble":
        case "wavyHeavy":
          t["text-decoration"] = "underline wavy";
          break;
        case "words":
          t["text-decoration"] = "underline";
          break;
        case "none":
          t["text-decoration"] = "none";
          break;
      }
      var i = jt.colorAttr(e, "color");
      i && (t["text-decoration-color"] = i);
    }
  }
  parseFont(e, t) {
    var s = W.attr(e, "ascii"), i = Ft.themeValue(e, "asciiTheme"), r = W.attr(e, "eastAsia"), n = [s, i, r].filter((a) => a).map((a) => Af(a));
    n.length > 0 && (t["font-family"] = [...new Set(n)].join(", "));
  }
  parseIndentation(e, t) {
    var s = W.lengthAttr(e, "firstLine"), i = W.lengthAttr(e, "hanging"), r = W.lengthAttr(e, "left"), n = W.lengthAttr(e, "start"), a = W.lengthAttr(e, "right"), h = W.lengthAttr(e, "end");
    s && (t["text-indent"] = s), i && (t["text-indent"] = `-${i}`), (r || n) && (t["margin-left"] = r || n), (a || h) && (t["margin-right"] = a || h);
  }
  parseSpacing(e, t) {
    var s = W.lengthAttr(e, "before"), i = W.lengthAttr(e, "after"), r = W.intAttr(e, "line", null), n = W.attr(e, "lineRule");
    if (s && (t["margin-top"] = s), i && (t["margin-bottom"] = i), r !== null)
      switch (n) {
        case "auto":
          t["line-height"] = `${(r / 240).toFixed(2)}`;
          break;
        case "atLeast":
          t["line-height"] = `calc(100% + ${r / 20}pt)`;
          break;
        default:
          t["line-height"] = t["min-height"] = `${r / 20}pt`;
          break;
      }
  }
  parseMarginProperties(e, t) {
    jt.foreach(e, (s) => {
      switch (s.localName) {
        case "left":
          t["padding-left"] = Ft.valueOfMargin(s);
          break;
        case "right":
          t["padding-right"] = Ft.valueOfMargin(s);
          break;
        case "top":
          t["padding-top"] = Ft.valueOfMargin(s);
          break;
        case "bottom":
          t["padding-bottom"] = Ft.valueOfMargin(s);
          break;
      }
    });
  }
  parseTrHeight(e, t) {
    switch (W.attr(e, "hRule")) {
      case "exact":
        t.height = W.lengthAttr(e, "val");
        break;
      case "atLeast":
      default:
        t.height = W.lengthAttr(e, "val");
        break;
    }
  }
  parseBorderProperties(e, t) {
    jt.foreach(e, (s) => {
      switch (s.localName) {
        case "start":
        case "left":
          t["border-left"] = Ft.valueOfBorder(s);
          break;
        case "end":
        case "right":
          t["border-right"] = Ft.valueOfBorder(s);
          break;
        case "top":
          t["border-top"] = Ft.valueOfBorder(s);
          break;
        case "bottom":
          t["border-bottom"] = Ft.valueOfBorder(s);
          break;
      }
    });
  }
}
const Xv = ["black", "blue", "cyan", "darkBlue", "darkCyan", "darkGray", "darkGreen", "darkMagenta", "darkRed", "darkYellow", "green", "lightGray", "magenta", "none", "red", "white", "yellow"];
class jt {
  static foreach(e, t) {
    for (var s = 0; s < e.childNodes.length; s++) {
      let i = e.childNodes[s];
      i.nodeType == Node.ELEMENT_NODE && t(i);
    }
  }
  static colorAttr(e, t, s = null, i = "black") {
    var r = W.attr(e, t);
    if (r)
      return r == "auto" ? i : Xv.includes(r) ? r : `#${r}`;
    var n = W.attr(e, "themeColor");
    return n ? `var(--docx-${n}-color)` : s;
  }
  static sizeValue(e, t = Kt.Dxa) {
    return mm(e.textContent, t);
  }
}
class Ft {
  static themeValue(e, t) {
    var s = W.attr(e, t);
    return s ? `var(--docx-${s}-font)` : null;
  }
  static valueOfSize(e, t) {
    var s = Kt.Dxa;
    switch (W.attr(e, "type")) {
      case "dxa":
        break;
      case "pct":
        s = Kt.Percent;
        break;
      case "auto":
        return "auto";
    }
    return W.lengthAttr(e, t, s);
  }
  static valueOfMargin(e) {
    return W.lengthAttr(e, "w");
  }
  static valueOfBorder(e) {
    var t = W.attr(e, "val");
    if (t == "nil")
      return "none";
    var s = jt.colorAttr(e, "color"), i = W.lengthAttr(e, "sz", Kt.Border);
    return `${i} solid ${s == "auto" ? wc.borderColor : s}`;
  }
  static valueOfTblLayout(e) {
    var t = W.attr(e, "val");
    return t == "fixed" ? "fixed" : "auto";
  }
  static classNameOfCnfStyle(e) {
    const t = W.attr(e, "val");
    return [
      "first-row",
      "last-row",
      "first-col",
      "last-col",
      "odd-col",
      "even-col",
      "odd-row",
      "even-row",
      "ne-cell",
      "nw-cell",
      "se-cell",
      "sw-cell"
    ].filter((i, r) => t[r] == "1").join(" ");
  }
  static valueOfJc(e) {
    var t = W.attr(e, "val");
    switch (t) {
      case "start":
      case "left":
        return "left";
      case "center":
        return "center";
      case "end":
      case "right":
        return "right";
      case "both":
        return "justify";
    }
    return t;
  }
  static valueOfVertAlign(e, t = !1) {
    var s = W.attr(e, "val");
    switch (s) {
      case "subscript":
        return "sub";
      case "superscript":
        return t ? "sup" : "super";
    }
    return t ? null : s;
  }
  static valueOfTextAlignment(e) {
    var t = W.attr(e, "val");
    switch (t) {
      case "auto":
      case "baseline":
        return "baseline";
      case "top":
        return "top";
      case "center":
        return "middle";
      case "bottom":
        return "bottom";
    }
    return t;
  }
  static addSize(e, t) {
    return e == null ? t : t == null ? e : `calc(${e} + ${t})`;
  }
  static classNameOftblLook(e) {
    const t = W.hexAttr(e, "val", 0);
    let s = "";
    return (W.boolAttr(e, "firstRow") || t & 32) && (s += " first-row"), (W.boolAttr(e, "lastRow") || t & 64) && (s += " last-row"), (W.boolAttr(e, "firstColumn") || t & 128) && (s += " first-col"), (W.boolAttr(e, "lastColumn") || t & 256) && (s += " last-col"), (W.boolAttr(e, "noHBand") || t & 512) && (s += " no-hband"), (W.boolAttr(e, "noVBand") || t & 1024) && (s += " no-vband"), s.trim();
  }
}
const Sg = { pos: 0, leader: "none", style: "left" }, qv = 50;
function Qv(l = document.body) {
  const e = document.createElement("div");
  e.style.width = "100pt", l.appendChild(e);
  const t = 100 / e.offsetWidth;
  return l.removeChild(e), t;
}
function Kv(l, e, t, s = 72 / 96) {
  const i = l.closest("p"), r = l.getBoundingClientRect(), n = i.getBoundingClientRect(), a = getComputedStyle(i), h = (e == null ? void 0 : e.length) > 0 ? e.map((_) => ({
    pos: kg(_.position),
    leader: _.leader,
    style: _.style
  })).sort((_, k) => _.pos - k.pos) : [Sg], c = h[h.length - 1], d = n.width * s, u = kg(t);
  let f = c.pos + u;
  if (f < d)
    for (; f < d && h.length < qv; f += u)
      h.push({ ...Sg, pos: f });
  const p = parseFloat(a.marginLeft), m = n.left + p, g = (r.left - m) * s, w = h.find((_) => _.style != "clear" && _.pos > g);
  if (w == null)
    return;
  let b = 1;
  if (w.style == "right" || w.style == "center") {
    const _ = Array.from(i.querySelectorAll(`.${l.className}`)), k = _.indexOf(l) + 1, C = document.createRange();
    C.setStart(l, 1), k < _.length ? C.setEndBefore(_[k]) : C.setEndAfter(i);
    const N = w.style == "center" ? 0.5 : 1, R = C.getBoundingClientRect(), P = R.left + N * R.width - (n.left - p);
    b = w.pos - P * s;
  } else
    b = w.pos - g;
  switch (l.innerHTML = "&nbsp;", l.style.textDecoration = "inherit", l.style.wordSpacing = `${b.toFixed(0)}pt`, w.leader) {
    case "dot":
    case "middleDot":
      l.style.textDecoration = "underline", l.style.textDecorationStyle = "dotted";
      break;
    case "hyphen":
    case "heavy":
    case "underscore":
      l.style.textDecoration = "underline";
      break;
  }
}
function kg(l) {
  return parseFloat(l);
}
const kt = {
  svg: "http://www.w3.org/2000/svg",
  mathML: "http://www.w3.org/1998/Math/MathML"
};
class Zv {
  constructor(e) {
    this.htmlDocument = e, this.className = "docx", this.styleMap = {}, this.currentPart = null, this.tableVerticalMerges = [], this.currentVerticalMerge = null, this.tableCellPositions = [], this.currentCellPosition = null, this.footnoteMap = {}, this.endnoteMap = {}, this.currentEndnoteIds = [], this.usedHederFooterParts = [], this.currentTabs = [], this.commentMap = {}, this.tasks = [], this.postRenderTasks = [];
  }
  async render(e, t, s = null, i) {
    var n;
    this.document = e, this.options = i, this.className = i.className, this.rootSelector = i.inWrapper ? `.${this.className}-wrapper` : ":root", this.styleMap = null, this.tasks = [], this.options.renderComments && globalThis.Highlight && (this.commentHighlight = new Highlight()), s = s || t, Mg(s), Mg(t), s.appendChild(this.createComment("docxjs library predefined styles")), s.appendChild(this.renderDefaultStyle()), e.themePart && (s.appendChild(this.createComment("docxjs document theme values")), this.renderTheme(e.themePart, s)), e.stylesPart != null && (this.styleMap = this.processStyles(e.stylesPart.styles), s.appendChild(this.createComment("docxjs document styles")), s.appendChild(this.renderStyles(e.stylesPart.styles))), e.numberingPart && (this.prodessNumberings(e.numberingPart.domNumberings), s.appendChild(this.createComment("docxjs document numbering styles")), s.appendChild(this.renderNumbering(e.numberingPart.domNumberings, s))), e.footnotesPart && (this.footnoteMap = Ii(e.footnotesPart.notes, (a) => a.id)), e.endnotesPart && (this.endnoteMap = Ii(e.endnotesPart.notes, (a) => a.id)), e.settingsPart && (this.defaultTabSize = (n = e.settingsPart.settings) == null ? void 0 : n.defaultTabStop), !i.ignoreFonts && e.fontTablePart && this.renderFontTable(e.fontTablePart, s);
    var r = this.renderSections(e.documentPart.body);
    this.options.inWrapper ? t.appendChild(this.renderWrapper(r)) : ff(t, r), this.commentHighlight && i.renderComments && CSS.highlights.set(`${this.className}-comments`, this.commentHighlight), this.postRenderTasks.forEach((a) => a()), await Promise.allSettled(this.tasks), this.refreshTabStops();
  }
  renderTheme(e, t) {
    var a, h;
    const s = {}, i = (a = e.theme) == null ? void 0 : a.fontScheme;
    i && (i.majorFont && (s["--docx-majorHAnsi-font"] = i.majorFont.latinTypeface), i.minorFont && (s["--docx-minorHAnsi-font"] = i.minorFont.latinTypeface));
    const r = (h = e.theme) == null ? void 0 : h.colorScheme;
    if (r)
      for (let [c, d] of Object.entries(r.colors))
        s[`--docx-${c}-color`] = `#${d}`;
    const n = this.styleToString(`.${this.className}`, s);
    t.appendChild(this.createStyleElement(n));
  }
  renderFontTable(e, t) {
    for (let s of e.fonts)
      for (let i of s.embedFontRefs)
        this.tasks.push(this.document.loadFont(i.id, i.key).then((r) => {
          const n = {
            "font-family": Af(s.name),
            src: `url(${r})`
          };
          (i.type == "bold" || i.type == "boldItalic") && (n["font-weight"] = "bold"), (i.type == "italic" || i.type == "boldItalic") && (n["font-style"] = "italic");
          const a = this.styleToString("@font-face", n);
          t.appendChild(this.createComment(`docxjs ${s.name} font`)), t.appendChild(this.createStyleElement(a));
        }));
  }
  processStyleName(e) {
    return e ? `${this.className}_${O0(e)}` : this.className;
  }
  processStyles(e) {
    const t = Ii(e.filter((i) => i.id != null), (i) => i.id);
    for (const i of e.filter((r) => r.basedOn)) {
      var s = t[i.basedOn];
      if (s) {
        i.paragraphProps = Jc(i.paragraphProps, s.paragraphProps), i.runProps = Jc(i.runProps, s.runProps);
        for (const r of s.styles) {
          const n = i.styles.find((a) => a.target == r.target);
          n ? this.copyStyleProperties(r.values, n.values) : i.styles.push({ ...r, values: { ...r.values } });
        }
      } else
        this.options.debug && console.warn(`Can't find base style ${i.basedOn}`);
    }
    for (let i of e)
      i.cssName = this.processStyleName(i.id);
    return t;
  }
  prodessNumberings(e) {
    var t;
    for (let s of e.filter((i) => i.pStyleName)) {
      const i = this.findStyle(s.pStyleName);
      (t = i == null ? void 0 : i.paragraphProps) != null && t.numbering && (i.paragraphProps.numbering.level = s.level);
    }
  }
  processElement(e) {
    if (e.children)
      for (var t of e.children)
        t.parent = e, t.type == X.Table ? this.processTable(t) : this.processElement(t);
  }
  processTable(e) {
    for (var t of e.children)
      for (var s of t.children)
        s.cssStyle = this.copyStyleProperties(e.cellStyle, s.cssStyle, [
          "border-left",
          "border-right",
          "border-top",
          "border-bottom",
          "padding-left",
          "padding-right",
          "padding-top",
          "padding-bottom"
        ]), this.processElement(s);
  }
  copyStyleProperties(e, t, s = null) {
    if (!e)
      return t;
    t == null && (t = {}), s == null && (s = Object.getOwnPropertyNames(e));
    for (var i of s)
      e.hasOwnProperty(i) && !t.hasOwnProperty(i) && (t[i] = e[i]);
    return t;
  }
  createPageElement(e, t) {
    var s = this.createElement("section", { className: e });
    return t && (t.pageMargins && (s.style.paddingLeft = t.pageMargins.left, s.style.paddingRight = t.pageMargins.right, s.style.paddingTop = t.pageMargins.top, s.style.paddingBottom = t.pageMargins.bottom), t.pageSize && (this.options.ignoreWidth || (s.style.width = t.pageSize.width), this.options.ignoreHeight || (s.style.minHeight = t.pageSize.height))), s;
  }
  createSectionContent(e) {
    var t = this.createElement("article");
    return e.columns && e.columns.numberOfColumns && (t.style.columnCount = `${e.columns.numberOfColumns}`, t.style.columnGap = e.columns.space, e.columns.separator && (t.style.columnRule = "1px solid black")), t;
  }
  renderSections(e) {
    const t = [];
    this.processElement(e);
    const s = this.splitBySection(e.children, e.props), i = this.groupByPageBreaks(s);
    let r = null;
    for (let a = 0, h = i.length; a < h; a++) {
      this.currentFootnoteIds = [];
      let d = i[a][0].sectProps;
      const u = this.createPageElement(this.className, d);
      this.renderStyleValues(e.cssStyle, u), this.options.renderHeaders && this.renderHeaderFooter(d.headerRefs, d, t.length, r != d, u);
      for (const f of i[a]) {
        var n = this.createSectionContent(f.sectProps);
        this.renderElements(f.elements, n), u.appendChild(n), d = f.sectProps;
      }
      this.options.renderFootnotes && this.renderNotes(this.currentFootnoteIds, this.footnoteMap, u), this.options.renderEndnotes && a == h - 1 && this.renderNotes(this.currentEndnoteIds, this.endnoteMap, u), this.options.renderFooters && this.renderHeaderFooter(d.footerRefs, d, t.length, r != d, u), t.push(u), r = d;
    }
    return t;
  }
  renderHeaderFooter(e, t, s, i, r) {
    if (e) {
      var n = (t.titlePage && i ? e.find((h) => h.type == "first") : null) ?? (s % 2 == 1 ? e.find((h) => h.type == "even") : null) ?? e.find((h) => h.type == "default"), a = n && this.document.findPartByRelId(n.id, this.document.documentPart);
      if (a) {
        this.currentPart = a, this.usedHederFooterParts.includes(a.path) || (this.processElement(a.rootElement), this.usedHederFooterParts.push(a.path));
        const [h] = this.renderElements([a.rootElement], r);
        t != null && t.pageMargins && (a.rootElement.type === X.Header ? (h.style.marginTop = `calc(${t.pageMargins.header} - ${t.pageMargins.top})`, h.style.minHeight = `calc(${t.pageMargins.top} - ${t.pageMargins.header})`) : a.rootElement.type === X.Footer && (h.style.marginBottom = `calc(${t.pageMargins.footer} - ${t.pageMargins.bottom})`, h.style.minHeight = `calc(${t.pageMargins.bottom} - ${t.pageMargins.footer})`)), this.currentPart = null;
      }
    }
  }
  isPageBreakElement(e) {
    return e.type != X.Break ? !1 : e.break == "lastRenderedPageBreak" ? !this.options.ignoreLastRenderedPageBreak : e.break == "page";
  }
  isPageBreakSection(e, t) {
    var s, i, r, n, a, h;
    return !e || !t ? !1 : ((s = e.pageSize) == null ? void 0 : s.orientation) != ((i = t.pageSize) == null ? void 0 : i.orientation) || ((r = e.pageSize) == null ? void 0 : r.width) != ((n = t.pageSize) == null ? void 0 : n.width) || ((a = e.pageSize) == null ? void 0 : a.height) != ((h = t.pageSize) == null ? void 0 : h.height);
  }
  splitBySection(e, t) {
    var u;
    var s = { sectProps: null, elements: [], pageBreak: !1 }, i = [s];
    for (let f of e) {
      if (f.type == X.Paragraph) {
        const p = this.findStyle(f.styleName);
        (u = p == null ? void 0 : p.paragraphProps) != null && u.pageBreakBefore && (s.sectProps = r, s.pageBreak = !0, s = { sectProps: null, elements: [], pageBreak: !1 }, i.push(s));
      }
      if (s.elements.push(f), f.type == X.Paragraph) {
        const p = f;
        var r = p.sectionProps, n = -1, a = -1;
        if (this.options.breakPages && p.children && (n = p.children.findIndex((m) => {
          var g;
          return a = ((g = m.children) == null ? void 0 : g.findIndex(this.isPageBreakElement.bind(this))) ?? -1, a != -1;
        })), (r || n != -1) && (s.sectProps = r, s.pageBreak = n != -1, s = { sectProps: null, elements: [], pageBreak: !1 }, i.push(s)), n != -1) {
          let m = p.children[n], g = a < m.children.length - 1;
          if (n < p.children.length - 1 || g) {
            var h = f.children, c = { ...f, children: h.slice(n) };
            if (f.children = h.slice(0, n), s.elements.push(c), g) {
              let w = m.children, b = { ...m, children: w.slice(0, a) };
              f.children.push(b), m.children = w.slice(a);
            }
          }
        }
      }
    }
    let d = null;
    for (let f = i.length - 1; f >= 0; f--)
      i[f].sectProps == null ? i[f].sectProps = d ?? t : d = i[f].sectProps;
    return i;
  }
  groupByPageBreaks(e) {
    let t = [], s;
    const i = [t];
    for (let r of e)
      t.push(r), (this.options.ignoreLastRenderedPageBreak || r.pageBreak || this.isPageBreakSection(s, r.sectProps)) && i.push(t = []), s = r.sectProps;
    return i.filter((r) => r.length > 0);
  }
  renderWrapper(e) {
    return this.createElement("div", { className: `${this.className}-wrapper` }, e);
  }
  renderDefaultStyle() {
    var e = this.className, t = `
.${e}-wrapper { background: gray; padding: 30px; padding-bottom: 0px; display: flex; flex-flow: column; align-items: center; } 
.${e}-wrapper>section.${e} { background: white; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); margin-bottom: 30px; }`;
    this.options.hideWrapperOnPrint && (t = `@media not print { ${t} }`);
    var s = `${t}
.${e} { color: black; hyphens: auto; text-underline-position: from-font; }
section.${e} { box-sizing: border-box; display: flex; flex-flow: column nowrap; position: relative; overflow: hidden; }
section.${e}>article { margin-bottom: auto; z-index: 1; }
section.${e}>footer { z-index: 1; }
.${e} table { border-collapse: collapse; }
.${e} table td, .${e} table th { vertical-align: top; }
.${e} p { margin: 0pt; min-height: 1em; }
.${e} span { white-space: pre-wrap; overflow-wrap: break-word; }
.${e} a { color: inherit; text-decoration: inherit; }
.${e} svg { fill: transparent; }
`;
    return this.options.renderComments && (s += `
.${e}-comment-ref { cursor: default; }
.${e}-comment-popover { display: none; z-index: 1000; padding: 0.5rem; background: white; position: absolute; box-shadow: 0 0 0.25rem rgba(0, 0, 0, 0.25); width: 30ch; }
.${e}-comment-ref:hover~.${e}-comment-popover { display: block; }
.${e}-comment-author,.${e}-comment-date { font-size: 0.875rem; color: #888; }
`), this.createStyleElement(s);
  }
  renderNumbering(e, t) {
    var s = "", i = [];
    for (var r of e) {
      var n = `p.${this.numberingClass(r.id, r.level)}`, a = "none";
      if (r.bullet) {
        let h = `--${this.className}-${r.bullet.src}`.toLowerCase();
        s += this.styleToString(`${n}:before`, {
          content: "' '",
          display: "inline-block",
          background: `var(${h})`
        }, r.bullet.style), this.tasks.push(this.document.loadNumberingImage(r.bullet.src).then((c) => {
          var d = `${this.rootSelector} { ${h}: url(${c}) }`;
          t.appendChild(this.createStyleElement(d));
        }));
      } else if (r.levelText) {
        let h = this.numberingCounter(r.id, r.level);
        const c = h + " " + (r.start - 1);
        r.level > 0 && (s += this.styleToString(`p.${this.numberingClass(r.id, r.level - 1)}`, {
          "counter-set": c
        })), i.push(c), s += this.styleToString(`${n}:before`, {
          content: this.levelTextToContent(r.levelText, r.suff, r.id, this.numFormatToCssValue(r.format)),
          "counter-increment": h,
          ...r.rStyle
        });
      } else
        a = this.numFormatToCssValue(r.format);
      s += this.styleToString(n, {
        display: "list-item",
        "list-style-position": "inside",
        "list-style-type": a,
        ...r.pStyle
      });
    }
    return i.length > 0 && (s += this.styleToString(this.rootSelector, {
      "counter-reset": i.join(" ")
    })), this.createStyleElement(s);
  }
  renderStyles(e) {
    var t = "";
    const s = this.styleMap, i = Ii(e.filter((h) => h.isDefault), (h) => h.target);
    for (const h of e) {
      var r = h.styles;
      if (h.linked) {
        var n = h.linked && s[h.linked];
        n ? r = r.concat(n.styles) : this.options.debug && console.warn(`Can't find linked style ${h.linked}`);
      }
      for (const c of r) {
        var a = `${h.target ?? ""}.${h.cssName}`;
        h.target != c.target && (a += ` ${c.target}`), i[h.target] == h && (a = `.${this.className} ${h.target}, ` + a), t += this.styleToString(a, c.values);
      }
    }
    return this.createStyleElement(t);
  }
  renderNotes(e, t, s) {
    var i = e.map((n) => t[n]).filter((n) => n);
    if (i.length > 0) {
      var r = this.createElement("ol", null, this.renderElements(i));
      s.appendChild(r);
    }
  }
  renderElement(e) {
    switch (e.type) {
      case X.Paragraph:
        return this.renderParagraph(e);
      case X.BookmarkStart:
        return this.renderBookmarkStart(e);
      case X.BookmarkEnd:
        return null;
      case X.Run:
        return this.renderRun(e);
      case X.Table:
        return this.renderTable(e);
      case X.Row:
        return this.renderTableRow(e);
      case X.Cell:
        return this.renderTableCell(e);
      case X.Hyperlink:
        return this.renderHyperlink(e);
      case X.SmartTag:
        return this.renderSmartTag(e);
      case X.Drawing:
        return this.renderDrawing(e);
      case X.Image:
        return this.renderImage(e);
      case X.Text:
        return this.renderText(e);
      case X.Text:
        return this.renderText(e);
      case X.DeletedText:
        return this.renderDeletedText(e);
      case X.Tab:
        return this.renderTab(e);
      case X.Symbol:
        return this.renderSymbol(e);
      case X.Break:
        return this.renderBreak(e);
      case X.Footer:
        return this.renderContainer(e, "footer");
      case X.Header:
        return this.renderContainer(e, "header");
      case X.Footnote:
      case X.Endnote:
        return this.renderContainer(e, "li");
      case X.FootnoteReference:
        return this.renderFootnoteReference(e);
      case X.EndnoteReference:
        return this.renderEndnoteReference(e);
      case X.NoBreakHyphen:
        return this.createElement("wbr");
      case X.VmlPicture:
        return this.renderVmlPicture(e);
      case X.VmlElement:
        return this.renderVmlElement(e);
      case X.MmlMath:
        return this.renderContainerNS(e, kt.mathML, "math", { xmlns: kt.mathML });
      case X.MmlMathParagraph:
        return this.renderContainer(e, "span");
      case X.MmlFraction:
        return this.renderContainerNS(e, kt.mathML, "mfrac");
      case X.MmlBase:
        return this.renderContainerNS(e, kt.mathML, e.parent.type == X.MmlMatrixRow ? "mtd" : "mrow");
      case X.MmlNumerator:
      case X.MmlDenominator:
      case X.MmlFunction:
      case X.MmlLimit:
      case X.MmlBox:
        return this.renderContainerNS(e, kt.mathML, "mrow");
      case X.MmlGroupChar:
        return this.renderMmlGroupChar(e);
      case X.MmlLimitLower:
        return this.renderContainerNS(e, kt.mathML, "munder");
      case X.MmlMatrix:
        return this.renderContainerNS(e, kt.mathML, "mtable");
      case X.MmlMatrixRow:
        return this.renderContainerNS(e, kt.mathML, "mtr");
      case X.MmlRadical:
        return this.renderMmlRadical(e);
      case X.MmlSuperscript:
        return this.renderContainerNS(e, kt.mathML, "msup");
      case X.MmlSubscript:
        return this.renderContainerNS(e, kt.mathML, "msub");
      case X.MmlDegree:
      case X.MmlSuperArgument:
      case X.MmlSubArgument:
        return this.renderContainerNS(e, kt.mathML, "mn");
      case X.MmlFunctionName:
        return this.renderContainerNS(e, kt.mathML, "ms");
      case X.MmlDelimiter:
        return this.renderMmlDelimiter(e);
      case X.MmlRun:
        return this.renderMmlRun(e);
      case X.MmlNary:
        return this.renderMmlNary(e);
      case X.MmlPreSubSuper:
        return this.renderMmlPreSubSuper(e);
      case X.MmlBar:
        return this.renderMmlBar(e);
      case X.MmlEquationArray:
        return this.renderMllList(e);
      case X.Inserted:
        return this.renderInserted(e);
      case X.Deleted:
        return this.renderDeleted(e);
      case X.CommentRangeStart:
        return this.renderCommentRangeStart(e);
      case X.CommentRangeEnd:
        return this.renderCommentRangeEnd(e);
      case X.CommentReference:
        return this.renderCommentReference(e);
      case X.AltChunk:
        return this.renderAltChunk(e);
    }
    return null;
  }
  renderElements(e, t) {
    if (e == null)
      return null;
    var s = e.flatMap((i) => this.renderElement(i)).filter((i) => i != null);
    return t && ff(t, s), s;
  }
  renderContainer(e, t, s) {
    return this.createElement(t, s, this.renderElements(e.children));
  }
  renderContainerNS(e, t, s, i) {
    return this.createElementNS(t, s, i, this.renderElements(e.children));
  }
  renderParagraph(e) {
    var r, n;
    var t = this.renderContainer(e, "p");
    const s = this.findStyle(e.styleName);
    e.tabs ?? (e.tabs = (r = s == null ? void 0 : s.paragraphProps) == null ? void 0 : r.tabs), this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), this.renderCommonProperties(t.style, e);
    const i = e.numbering ?? ((n = s == null ? void 0 : s.paragraphProps) == null ? void 0 : n.numbering);
    return i && t.classList.add(this.numberingClass(i.id, i.level)), t;
  }
  renderRunProperties(e, t) {
    this.renderCommonProperties(e, t);
  }
  renderCommonProperties(e, t) {
    t != null && (t.color && (e.color = t.color), t.fontSize && (e["font-size"] = t.fontSize));
  }
  renderHyperlink(e) {
    var t = this.renderContainer(e, "a");
    this.renderStyleValues(e.cssStyle, t);
    let s = "";
    if (e.id) {
      const i = this.document.documentPart.rels.find((r) => r.id == e.id && r.targetMode === "External");
      s = (i == null ? void 0 : i.target) ?? s;
    }
    return e.anchor && (s += `#${e.anchor}`), t.href = s, t;
  }
  renderSmartTag(e) {
    return this.renderContainer(e, "span");
  }
  renderCommentRangeStart(e) {
    var i;
    if (!this.options.renderComments)
      return null;
    const t = new Range();
    (i = this.commentHighlight) == null || i.add(t);
    const s = this.htmlDocument.createComment(`start of comment #${e.id}`);
    return this.later(() => t.setStart(s, 0)), this.commentMap[e.id] = t, s;
  }
  renderCommentRangeEnd(e) {
    if (!this.options.renderComments)
      return null;
    const t = this.commentMap[e.id], s = this.htmlDocument.createComment(`end of comment #${e.id}`);
    return this.later(() => t == null ? void 0 : t.setEnd(s, 0)), s;
  }
  renderCommentReference(e) {
    var n;
    if (!this.options.renderComments)
      return null;
    var t = (n = this.document.commentsPart) == null ? void 0 : n.commentMap[e.id];
    if (!t)
      return null;
    const s = new DocumentFragment(), i = this.createElement("span", { className: `${this.className}-comment-ref` }, [""]), r = this.createElement("div", { className: `${this.className}-comment-popover` });
    return this.renderCommentContent(t, r), s.appendChild(this.htmlDocument.createComment(`comment #${t.id} by ${t.author} on ${t.date}`)), s.appendChild(i), s.appendChild(r), s;
  }
  renderAltChunk(e) {
    if (!this.options.renderAltChunks)
      return null;
    var t = this.createElement("iframe");
    return this.tasks.push(this.document.loadAltChunk(e.id, this.currentPart).then((s) => {
      t.srcdoc = s;
    })), t;
  }
  renderCommentContent(e, t) {
    t.appendChild(this.createElement("div", { className: `${this.className}-comment-author` }, [e.author])), t.appendChild(this.createElement("div", { className: `${this.className}-comment-date` }, [new Date(e.date).toLocaleString()])), this.renderElements(e.children, t);
  }
  renderDrawing(e) {
    var t = this.renderContainer(e, "div");
    return t.style.display = "inline-block", t.style.position = "relative", t.style.textIndent = "0px", this.renderStyleValues(e.cssStyle, t), t;
  }
  renderImage(e) {
    let t = this.createElement("img");
    return this.renderStyleValues(e.cssStyle, t), this.document && this.tasks.push(this.document.loadDocumentImage(e.src, this.currentPart).then((s) => {
      t.src = s;
    })), t;
  }
  renderText(e) {
    return this.htmlDocument.createTextNode(e.text);
  }
  renderDeletedText(e) {
    return this.options.renderEndnotes ? this.htmlDocument.createTextNode(e.text) : null;
  }
  renderBreak(e) {
    return e.break == "textWrapping" ? this.createElement("br") : null;
  }
  renderInserted(e) {
    return this.options.renderChanges ? this.renderContainer(e, "ins") : this.renderElements(e.children);
  }
  renderDeleted(e) {
    return this.options.renderChanges ? this.renderContainer(e, "del") : null;
  }
  renderSymbol(e) {
    var t = this.createElement("span");
    return t.style.fontFamily = e.font, t.innerHTML = `&#x${e.char};`, t;
  }
  renderFootnoteReference(e) {
    var t = this.createElement("sup");
    return this.currentFootnoteIds.push(e.id), t.textContent = `${this.currentFootnoteIds.length}`, t;
  }
  renderEndnoteReference(e) {
    var t = this.createElement("sup");
    return this.currentEndnoteIds.push(e.id), t.textContent = `${this.currentEndnoteIds.length}`, t;
  }
  renderTab(e) {
    var i;
    var t = this.createElement("span");
    if (t.innerHTML = "&emsp;", this.options.experimental) {
      t.className = this.tabStopClass();
      var s = (i = Jv(e, X.Paragraph)) == null ? void 0 : i.tabs;
      this.currentTabs.push({ stops: s, span: t });
    }
    return t;
  }
  renderBookmarkStart(e) {
    return this.createElement("span", { id: e.name });
  }
  renderRun(e) {
    if (e.fieldRun)
      return null;
    const t = this.createElement("span");
    if (e.id && (t.id = e.id), this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), e.verticalAlign) {
      const s = this.createElement(e.verticalAlign);
      this.renderElements(e.children, s), t.appendChild(s);
    } else
      this.renderElements(e.children, t);
    return t;
  }
  renderTable(e) {
    let t = this.createElement("table");
    return this.tableCellPositions.push(this.currentCellPosition), this.tableVerticalMerges.push(this.currentVerticalMerge), this.currentVerticalMerge = {}, this.currentCellPosition = { col: 0, row: 0 }, e.columns && t.appendChild(this.renderTableColumns(e.columns)), this.renderClass(e, t), this.renderElements(e.children, t), this.renderStyleValues(e.cssStyle, t), this.currentVerticalMerge = this.tableVerticalMerges.pop(), this.currentCellPosition = this.tableCellPositions.pop(), t;
  }
  renderTableColumns(e) {
    let t = this.createElement("colgroup");
    for (let s of e) {
      let i = this.createElement("col");
      s.width && (i.style.width = s.width), t.appendChild(i);
    }
    return t;
  }
  renderTableRow(e) {
    let t = this.renderContainer(e, "tr");
    return this.currentCellPosition.col = 0, this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), this.currentCellPosition.row++, t;
  }
  renderTableCell(e) {
    let t = this.renderContainer(e, "td");
    const s = this.currentCellPosition.col;
    return e.verticalMerge ? e.verticalMerge == "restart" ? (this.currentVerticalMerge[s] = t, t.rowSpan = 1) : this.currentVerticalMerge[s] && (this.currentVerticalMerge[s].rowSpan += 1, t.style.display = "none") : this.currentVerticalMerge[s] = null, this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), e.span && (t.colSpan = e.span), this.currentCellPosition.col += t.colSpan, t;
  }
  renderVmlPicture(e) {
    return this.renderContainer(e, "div");
  }
  renderVmlElement(e) {
    var i, r;
    var t = this.createSvgElement("svg");
    t.setAttribute("style", e.cssStyleText);
    const s = this.renderVmlChildElement(e);
    return (i = e.imageHref) != null && i.id && this.tasks.push((r = this.document) == null ? void 0 : r.loadDocumentImage(e.imageHref.id, this.currentPart).then((n) => s.setAttribute("href", n))), t.appendChild(s), requestAnimationFrame(() => {
      const n = t.firstElementChild.getBBox();
      t.setAttribute("width", `${Math.ceil(n.x + n.width)}`), t.setAttribute("height", `${Math.ceil(n.y + n.height)}`);
    }), t;
  }
  renderVmlChildElement(e) {
    const t = this.createSvgElement(e.tagName);
    Object.entries(e.attrs).forEach(([s, i]) => t.setAttribute(s, i));
    for (let s of e.children)
      s.type == X.VmlElement ? t.appendChild(this.renderVmlChildElement(s)) : t.appendChild(...To(this.renderElement(s)));
    return t;
  }
  renderMmlRadical(e) {
    var i;
    const t = e.children.find((r) => r.type == X.MmlBase);
    if ((i = e.props) != null && i.hideDegree)
      return this.createElementNS(kt.mathML, "msqrt", null, this.renderElements([t]));
    const s = e.children.find((r) => r.type == X.MmlDegree);
    return this.createElementNS(kt.mathML, "mroot", null, this.renderElements([t, s]));
  }
  renderMmlDelimiter(e) {
    const t = [];
    return t.push(this.createElementNS(kt.mathML, "mo", null, [e.props.beginChar ?? "("])), t.push(...this.renderElements(e.children)), t.push(this.createElementNS(kt.mathML, "mo", null, [e.props.endChar ?? ")"])), this.createElementNS(kt.mathML, "mrow", null, t);
  }
  renderMmlNary(e) {
    var c;
    const t = [], s = Ii(e.children, (d) => d.type), i = s[X.MmlSuperArgument], r = s[X.MmlSubArgument], n = i ? this.createElementNS(kt.mathML, "mo", null, To(this.renderElement(i))) : null, a = r ? this.createElementNS(kt.mathML, "mo", null, To(this.renderElement(r))) : null, h = this.createElementNS(kt.mathML, "mo", null, [((c = e.props) == null ? void 0 : c.char) ?? ""]);
    return n || a ? t.push(this.createElementNS(kt.mathML, "munderover", null, [h, a, n])) : n ? t.push(this.createElementNS(kt.mathML, "mover", null, [h, n])) : a ? t.push(this.createElementNS(kt.mathML, "munder", null, [h, a])) : t.push(h), t.push(...this.renderElements(s[X.MmlBase].children)), this.createElementNS(kt.mathML, "mrow", null, t);
  }
  renderMmlPreSubSuper(e) {
    const t = [], s = Ii(e.children, (c) => c.type), i = s[X.MmlSuperArgument], r = s[X.MmlSubArgument], n = i ? this.createElementNS(kt.mathML, "mo", null, To(this.renderElement(i))) : null, a = r ? this.createElementNS(kt.mathML, "mo", null, To(this.renderElement(r))) : null, h = this.createElementNS(kt.mathML, "mo", null);
    return t.push(this.createElementNS(kt.mathML, "msubsup", null, [h, a, n])), t.push(...this.renderElements(s[X.MmlBase].children)), this.createElementNS(kt.mathML, "mrow", null, t);
  }
  renderMmlGroupChar(e) {
    const t = e.props.verticalJustification === "bot" ? "mover" : "munder", s = this.renderContainerNS(e, kt.mathML, t);
    return e.props.char && s.appendChild(this.createElementNS(kt.mathML, "mo", null, [e.props.char])), s;
  }
  renderMmlBar(e) {
    const t = this.renderContainerNS(e, kt.mathML, "mrow");
    switch (e.props.position) {
      case "top":
        t.style.textDecoration = "overline";
        break;
      case "bottom":
        t.style.textDecoration = "underline";
        break;
    }
    return t;
  }
  renderMmlRun(e) {
    const t = this.createElementNS(kt.mathML, "ms", null, this.renderElements(e.children));
    return this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t), t;
  }
  renderMllList(e) {
    const t = this.createElementNS(kt.mathML, "mtable");
    this.renderClass(e, t), this.renderStyleValues(e.cssStyle, t);
    for (let s of this.renderElements(e.children))
      t.appendChild(this.createElementNS(kt.mathML, "mtr", null, [
        this.createElementNS(kt.mathML, "mtd", null, [s])
      ]));
    return t;
  }
  renderStyleValues(e, t) {
    for (let s in e)
      s.startsWith("$") ? t.setAttribute(s.slice(1), e[s]) : t.style[s] = e[s];
  }
  renderClass(e, t) {
    e.className && (t.className = e.className), e.styleName && t.classList.add(this.processStyleName(e.styleName));
  }
  findStyle(e) {
    var t;
    return e && ((t = this.styleMap) == null ? void 0 : t[e]);
  }
  numberingClass(e, t) {
    return `${this.className}-num-${e}-${t}`;
  }
  tabStopClass() {
    return `${this.className}-tab-stop`;
  }
  styleToString(e, t, s = null) {
    let i = `${e} {\r
`;
    for (const r in t)
      r.startsWith("$") || (i += `  ${r}: ${t[r]};\r
`);
    return s && (i += s), i + `}\r
`;
  }
  numberingCounter(e, t) {
    return `${this.className}-num-${e}-${t}`;
  }
  levelTextToContent(e, t, s, i) {
    const r = {
      tab: "\\9",
      space: "\\a0"
    };
    var n = e.replace(/%\d*/g, (a) => {
      let h = parseInt(a.substring(1), 10) - 1;
      return `"counter(${this.numberingCounter(s, h)}, ${i})"`;
    });
    return `"${n}${r[t] ?? ""}"`;
  }
  numFormatToCssValue(e) {
    var t = {
      none: "none",
      bullet: "disc",
      decimal: "decimal",
      lowerLetter: "lower-alpha",
      upperLetter: "upper-alpha",
      lowerRoman: "lower-roman",
      upperRoman: "upper-roman",
      decimalZero: "decimal-leading-zero",
      aiueo: "katakana",
      aiueoFullWidth: "katakana",
      chineseCounting: "simp-chinese-informal",
      chineseCountingThousand: "simp-chinese-informal",
      chineseLegalSimplified: "simp-chinese-formal",
      chosung: "hangul-consonant",
      ideographDigital: "cjk-ideographic",
      ideographTraditional: "cjk-heavenly-stem",
      ideographLegalTraditional: "trad-chinese-formal",
      ideographZodiac: "cjk-earthly-branch",
      iroha: "katakana-iroha",
      irohaFullWidth: "katakana-iroha",
      japaneseCounting: "japanese-informal",
      japaneseDigitalTenThousand: "cjk-decimal",
      japaneseLegal: "japanese-formal",
      thaiNumbers: "thai",
      koreanCounting: "korean-hangul-formal",
      koreanDigital: "korean-hangul-formal",
      koreanDigital2: "korean-hanja-informal",
      hebrew1: "hebrew",
      hebrew2: "hebrew",
      hindiNumbers: "devanagari",
      ganada: "hangul",
      taiwaneseCounting: "cjk-ideographic",
      taiwaneseCountingThousand: "cjk-ideographic",
      taiwaneseDigital: "cjk-decimal"
    };
    return t[e] ?? e;
  }
  refreshTabStops() {
    this.options.experimental && setTimeout(() => {
      const e = Qv();
      for (let t of this.currentTabs)
        Kv(t.span, t.stops, this.defaultTabSize, e);
    }, 500);
  }
  createElementNS(e, t, s, i) {
    var r = e ? this.htmlDocument.createElementNS(e, t) : this.htmlDocument.createElement(t);
    return Object.assign(r, s), i && ff(r, i), r;
  }
  createElement(e, t, s) {
    return this.createElementNS(void 0, e, t, s);
  }
  createSvgElement(e, t, s) {
    return this.createElementNS(kt.svg, e, t, s);
  }
  createStyleElement(e) {
    return this.createElement("style", { innerHTML: e });
  }
  createComment(e) {
    return this.htmlDocument.createComment(e);
  }
  later(e) {
    this.postRenderTasks.push(e);
  }
}
function Mg(l) {
  l.innerHTML = "";
}
function ff(l, e) {
  e.forEach((t) => l.appendChild(j0(t) ? document.createTextNode(t) : t));
}
function Jv(l, e) {
  for (var t = l.parent; t != null && t.type != e; )
    t = t.parent;
  return t;
}
const Mm = {
  ignoreHeight: !1,
  ignoreWidth: !1,
  ignoreFonts: !1,
  breakPages: !0,
  debug: !1,
  experimental: !1,
  className: "docx",
  inWrapper: !0,
  hideWrapperOnPrint: !1,
  trimXmlDeclaration: !0,
  ignoreLastRenderedPageBreak: !0,
  renderHeaders: !0,
  renderFooters: !0,
  renderFootnotes: !0,
  renderEndnotes: !0,
  useBase64URL: !1,
  renderChanges: !1,
  renderComments: !1,
  renderAltChunks: !0
};
function tw(l, e) {
  const t = { ...Mm, ...e };
  return Yp.load(l, new Yv(t), t);
}
async function ew(l, e, t, s) {
  const i = { ...Mm, ...s };
  return await new Zv(window.document).render(l, e, t, i);
}
async function sw(l, e, t, s) {
  const i = await tw(l, s);
  return await ew(i, e, t, s), i;
}
const iw = ({ blob: l, rotate: e }) => {
  const t = _s(null), [s, i] = Mi(!1);
  return Pt(() => {
    t.current && sw(l, t.current, void 0, {
      inWrapper: !1
    }).then(() => {
      i(!0);
    }).catch((r) => {
      console.error("Failed to render DOCX file:", r);
    });
  }, [l]), /* @__PURE__ */ rt.jsx(fm, { children: /* @__PURE__ */ rt.jsx(
    C0,
    {
      loaded: s,
      ref: t,
      style: { transform: `rotate(${e}deg)` }
    }
  ) });
};
var Ko = {};
Ko.d = (l, e) => {
  for (var t in e)
    Ko.o(e, t) && !Ko.o(l, t) && Object.defineProperty(l, t, { enumerable: !0, get: e[t] });
};
Ko.o = (l, e) => Object.prototype.hasOwnProperty.call(l, e);
var At = globalThis.pdfjsLib = {};
Ko.d(At, {
  AbortException: () => (
    /* reexport */
    Un
  ),
  AnnotationEditorLayer: () => (
    /* reexport */
    Pp
  ),
  AnnotationEditorParamsType: () => (
    /* reexport */
    wt
  ),
  AnnotationEditorType: () => (
    /* reexport */
    _t
  ),
  AnnotationEditorUIManager: () => (
    /* reexport */
    On
  ),
  AnnotationLayer: () => (
    /* reexport */
    e_
  ),
  AnnotationMode: () => (
    /* reexport */
    Ni
  ),
  ColorPicker: () => (
    /* reexport */
    id
  ),
  DOMSVGFactory: () => (
    /* reexport */
    ng
  ),
  DrawLayer: () => (
    /* reexport */
    Fp
  ),
  FeatureTest: () => (
    /* reexport */
    Pe
  ),
  GlobalWorkerOptions: () => (
    /* reexport */
    xi
  ),
  ImageKind: () => (
    /* reexport */
    Ac
  ),
  InvalidPDFException: () => (
    /* reexport */
    Tm
  ),
  MissingPDFException: () => (
    /* reexport */
    Bn
  ),
  OPS: () => (
    /* reexport */
    ls
  ),
  OutputScale: () => (
    /* reexport */
    kf
  ),
  PDFDataRangeTransport: () => (
    /* reexport */
    Sb
  ),
  PDFDateString: () => (
    /* reexport */
    Zp
  ),
  PDFWorker: () => (
    /* reexport */
    Jn
  ),
  PasswordResponses: () => (
    /* reexport */
    ow
  ),
  PermissionFlag: () => (
    /* reexport */
    aw
  ),
  PixelsPerInch: () => (
    /* reexport */
    pr
  ),
  RenderingCancelledException: () => (
    /* reexport */
    Qp
  ),
  TextLayer: () => (
    /* reexport */
    tp
  ),
  UnexpectedResponseException: () => (
    /* reexport */
    tf
  ),
  Util: () => (
    /* reexport */
    pt
  ),
  VerbosityLevel: () => (
    /* reexport */
    Ku
  ),
  XfaLayer: () => (
    /* reexport */
    Mb
  ),
  build: () => (
    /* reexport */
    RA
  ),
  createValidAbsoluteUrl: () => (
    /* reexport */
    dw
  ),
  fetchData: () => (
    /* reexport */
    sf
  ),
  getDocument: () => (
    /* reexport */
    kA
  ),
  getFilenameFromUrl: () => (
    /* reexport */
    ww
  ),
  getPdfFilenameFromUrl: () => (
    /* reexport */
    Aw
  ),
  getXfaPageViewport: () => (
    /* reexport */
    _w
  ),
  isDataScheme: () => (
    /* reexport */
    rf
  ),
  isPdfFile: () => (
    /* reexport */
    Kp
  ),
  noContextMenu: () => (
    /* reexport */
    as
  ),
  normalizeUnicode: () => (
    /* reexport */
    bw
  ),
  setLayerDimensions: () => (
    /* reexport */
    Rn
  ),
  shadow: () => (
    /* reexport */
    Mt
  ),
  version: () => (
    /* reexport */
    LA
  )
});
const Ce = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"), Cm = [1, 0, 0, 1, 0, 0], _f = [1e-3, 0, 0, 1e-3, 0, 0], rw = 1e7, pf = 1.35, Qe = {
  ANY: 1,
  DISPLAY: 2,
  PRINT: 4,
  SAVE: 8,
  ANNOTATIONS_FORMS: 16,
  ANNOTATIONS_STORAGE: 32,
  ANNOTATIONS_DISABLE: 64,
  IS_EDITING: 128,
  OPLIST: 256
}, Ni = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
}, nw = "pdfjs_internal_editor_", _t = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  HIGHLIGHT: 9,
  STAMP: 13,
  INK: 15
}, wt = {
  RESIZE: 1,
  CREATE: 2,
  FREETEXT_SIZE: 11,
  FREETEXT_COLOR: 12,
  FREETEXT_OPACITY: 13,
  INK_COLOR: 21,
  INK_THICKNESS: 22,
  INK_OPACITY: 23,
  HIGHLIGHT_COLOR: 31,
  HIGHLIGHT_DEFAULT_COLOR: 32,
  HIGHLIGHT_THICKNESS: 33,
  HIGHLIGHT_FREE: 34,
  HIGHLIGHT_SHOW_ALL: 35
}, aw = {
  PRINT: 4,
  MODIFY_CONTENTS: 8,
  COPY: 16,
  MODIFY_ANNOTATIONS: 32,
  FILL_INTERACTIVE_FORMS: 256,
  COPY_FOR_ACCESSIBILITY: 512,
  ASSEMBLE: 1024,
  PRINT_HIGH_QUALITY: 2048
}, Ae = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
}, Ac = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
}, se = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
}, No = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
}, Ku = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
}, ls = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91,
  setStrokeTransparent: 92,
  setFillTransparent: 93
}, ow = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
let Zu = Ku.WARNINGS;
function lw(l) {
  Number.isInteger(l) && (Zu = l);
}
function hw() {
  return Zu;
}
function Ju(l) {
  Zu >= Ku.INFOS && console.log(`Info: ${l}`);
}
function xt(l) {
  Zu >= Ku.WARNINGS && console.log(`Warning: ${l}`);
}
function Bt(l) {
  throw new Error(l);
}
function ae(l, e) {
  l || Bt(e);
}
function cw(l) {
  switch (l == null ? void 0 : l.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return !0;
    default:
      return !1;
  }
}
function dw(l, e = null, t = null) {
  if (!l)
    return null;
  try {
    if (t && typeof l == "string") {
      if (t.addDefaultProtocol && l.startsWith("www.")) {
        const i = l.match(/\./g);
        (i == null ? void 0 : i.length) >= 2 && (l = `http://${l}`);
      }
      if (t.tryConvertEncoding)
        try {
          l = mw(l);
        } catch {
        }
    }
    const s = e ? new URL(l, e) : new URL(l);
    if (cw(s))
      return s;
  } catch {
  }
  return null;
}
function Mt(l, e, t, s = !1) {
  return Object.defineProperty(l, e, {
    value: t,
    enumerable: !s,
    configurable: !0,
    writable: !1
  }), t;
}
const mr = function() {
  function e(t, s) {
    this.message = t, this.name = s;
  }
  return e.prototype = new Error(), e.constructor = e, e;
}();
class Ef extends mr {
  constructor(e, t) {
    super(e, "PasswordException"), this.code = t;
  }
}
class xf extends mr {
  constructor(e, t) {
    super(e, "UnknownErrorException"), this.details = t;
  }
}
class Tm extends mr {
  constructor(e) {
    super(e, "InvalidPDFException");
  }
}
class Bn extends mr {
  constructor(e) {
    super(e, "MissingPDFException");
  }
}
class tf extends mr {
  constructor(e, t) {
    super(e, "UnexpectedResponseException"), this.status = t;
  }
}
class uw extends mr {
  constructor(e) {
    super(e, "FormatError");
  }
}
class Un extends mr {
  constructor(e) {
    super(e, "AbortException");
  }
}
function Im(l) {
  (typeof l != "object" || (l == null ? void 0 : l.length) === void 0) && Bt("Invalid argument for bytesToString");
  const e = l.length, t = 8192;
  if (e < t)
    return String.fromCharCode.apply(null, l);
  const s = [];
  for (let i = 0; i < e; i += t) {
    const r = Math.min(i + t, e), n = l.subarray(i, r);
    s.push(String.fromCharCode.apply(null, n));
  }
  return s.join("");
}
function ef(l) {
  typeof l != "string" && Bt("Invalid argument for stringToBytes");
  const e = l.length, t = new Uint8Array(e);
  for (let s = 0; s < e; ++s)
    t[s] = l.charCodeAt(s) & 255;
  return t;
}
function fw(l) {
  return String.fromCharCode(l >> 24 & 255, l >> 16 & 255, l >> 8 & 255, l & 255);
}
function Xp(l) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const [t, s] of l)
    e[t] = s;
  return e;
}
function pw() {
  const l = new Uint8Array(4);
  return l[0] = 1, new Uint32Array(l.buffer, 0, 1)[0] === 1;
}
function gw() {
  try {
    return new Function(""), !0;
  } catch {
    return !1;
  }
}
class Pe {
  static get isLittleEndian() {
    return Mt(this, "isLittleEndian", pw());
  }
  static get isEvalSupported() {
    return Mt(this, "isEvalSupported", gw());
  }
  static get isOffscreenCanvasSupported() {
    return Mt(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
  }
  static get platform() {
    return typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.platform) == "string" ? Mt(this, "platform", {
      isMac: navigator.platform.includes("Mac"),
      isWindows: navigator.platform.includes("Win"),
      isFirefox: typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && navigator.userAgent.includes("Firefox")
    }) : Mt(this, "platform", {
      isMac: !1,
      isWindows: !1,
      isFirefox: !1
    });
  }
  static get isCSSRoundSupported() {
    var e, t;
    return Mt(this, "isCSSRoundSupported", (t = (e = globalThis.CSS) == null ? void 0 : e.supports) == null ? void 0 : t.call(e, "width: round(1.5px, 1px)"));
  }
}
const gf = Array.from(Array(256).keys(), (l) => l.toString(16).padStart(2, "0"));
var sa, _c, el, Sf;
class pt {
  static makeHexColor(e, t, s) {
    return `#${gf[e]}${gf[t]}${gf[s]}`;
  }
  static scaleMinMax(e, t) {
    let s;
    e[0] ? (e[0] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[0], t[2] *= e[0], e[3] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[3], t[3] *= e[3]) : (s = t[0], t[0] = t[1], t[1] = s, s = t[2], t[2] = t[3], t[3] = s, e[1] < 0 && (s = t[1], t[1] = t[3], t[3] = s), t[1] *= e[1], t[3] *= e[1], e[2] < 0 && (s = t[0], t[0] = t[2], t[2] = s), t[0] *= e[2], t[2] *= e[2]), t[0] += e[4], t[1] += e[5], t[2] += e[4], t[3] += e[5];
  }
  static transform(e, t) {
    return [e[0] * t[0] + e[2] * t[1], e[1] * t[0] + e[3] * t[1], e[0] * t[2] + e[2] * t[3], e[1] * t[2] + e[3] * t[3], e[0] * t[4] + e[2] * t[5] + e[4], e[1] * t[4] + e[3] * t[5] + e[5]];
  }
  static applyTransform(e, t) {
    const s = e[0] * t[0] + e[1] * t[2] + t[4], i = e[0] * t[1] + e[1] * t[3] + t[5];
    return [s, i];
  }
  static applyInverseTransform(e, t) {
    const s = t[0] * t[3] - t[1] * t[2], i = (e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / s, r = (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / s;
    return [i, r];
  }
  static getAxialAlignedBoundingBox(e, t) {
    const s = this.applyTransform(e, t), i = this.applyTransform(e.slice(2, 4), t), r = this.applyTransform([e[0], e[3]], t), n = this.applyTransform([e[2], e[1]], t);
    return [Math.min(s[0], i[0], r[0], n[0]), Math.min(s[1], i[1], r[1], n[1]), Math.max(s[0], i[0], r[0], n[0]), Math.max(s[1], i[1], r[1], n[1])];
  }
  static inverseTransform(e) {
    const t = e[0] * e[3] - e[1] * e[2];
    return [e[3] / t, -e[1] / t, -e[2] / t, e[0] / t, (e[2] * e[5] - e[4] * e[3]) / t, (e[4] * e[1] - e[5] * e[0]) / t];
  }
  static singularValueDecompose2dScale(e) {
    const t = [e[0], e[2], e[1], e[3]], s = e[0] * t[0] + e[1] * t[2], i = e[0] * t[1] + e[1] * t[3], r = e[2] * t[0] + e[3] * t[2], n = e[2] * t[1] + e[3] * t[3], a = (s + n) / 2, h = Math.sqrt((s + n) ** 2 - 4 * (s * n - r * i)) / 2, c = a + h || 1, d = a - h || 1;
    return [Math.sqrt(c), Math.sqrt(d)];
  }
  static normalizeRect(e) {
    const t = e.slice(0);
    return e[0] > e[2] && (t[0] = e[2], t[2] = e[0]), e[1] > e[3] && (t[1] = e[3], t[3] = e[1]), t;
  }
  static intersect(e, t) {
    const s = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2])), i = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2]));
    if (s > i)
      return null;
    const r = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3])), n = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3]));
    return r > n ? null : [s, r, i, n];
  }
  static bezierBoundingBox(e, t, s, i, r, n, a, h, c) {
    return c ? (c[0] = Math.min(c[0], e, a), c[1] = Math.min(c[1], t, h), c[2] = Math.max(c[2], e, a), c[3] = Math.max(c[3], t, h)) : c = [Math.min(e, a), Math.min(t, h), Math.max(e, a), Math.max(t, h)], x(this, el, Sf).call(this, e, s, r, a, t, i, n, h, 3 * (-e + 3 * (s - r) + a), 6 * (e - 2 * s + r), 3 * (s - e), c), x(this, el, Sf).call(this, e, s, r, a, t, i, n, h, 3 * (-t + 3 * (i - n) + h), 6 * (t - 2 * i + n), 3 * (i - t), c), c;
  }
}
sa = new WeakSet(), _c = function(e, t, s, i, r, n, a, h, c, d) {
  if (c <= 0 || c >= 1)
    return;
  const u = 1 - c, f = c * c, p = f * c, m = u * (u * (u * e + 3 * c * t) + 3 * f * s) + p * i, g = u * (u * (u * r + 3 * c * n) + 3 * f * a) + p * h;
  d[0] = Math.min(d[0], m), d[1] = Math.min(d[1], g), d[2] = Math.max(d[2], m), d[3] = Math.max(d[3], g);
}, el = new WeakSet(), Sf = function(e, t, s, i, r, n, a, h, c, d, u, f) {
  if (Math.abs(c) < 1e-12) {
    Math.abs(d) >= 1e-12 && x(this, sa, _c).call(this, e, t, s, i, r, n, a, h, -u / d, f);
    return;
  }
  const p = d ** 2 - 4 * u * c;
  if (p < 0)
    return;
  const m = Math.sqrt(p), g = 2 * c;
  x(this, sa, _c).call(this, e, t, s, i, r, n, a, h, (-d + m) / g, f), x(this, sa, _c).call(this, e, t, s, i, r, n, a, h, (-d - m) / g, f);
}, y(pt, sa), y(pt, el);
function mw(l) {
  return decodeURIComponent(escape(l));
}
let mf = null, Cg = null;
function bw(l) {
  return mf || (mf = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, Cg = /* @__PURE__ */ new Map([["", "t"]])), l.replaceAll(mf, (e, t, s) => t ? t.normalize("NFKC") : Cg.get(s));
}
function yw() {
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
    return crypto.randomUUID();
  const l = new Uint8Array(32);
  if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
    crypto.getRandomValues(l);
  else
    for (let e = 0; e < 32; e++)
      l[e] = Math.floor(Math.random() * 255);
  return Im(l);
}
const qp = "pdfjs_internal_id_", Gs = {
  BEZIER_CURVE_TO: 0,
  MOVE_TO: 1,
  LINE_TO: 2,
  QUADRATIC_CURVE_TO: 3,
  RESTORE: 4,
  SAVE: 5,
  SCALE: 6,
  TRANSFORM: 7,
  TRANSLATE: 8
};
function vw(l) {
  return Uint8Array.prototype.toBase64 ? l.toBase64() : btoa(Im(l));
}
const Ys = "http://www.w3.org/2000/svg", Er = class Er {
};
vt(Er, "CSS", 96), vt(Er, "PDF", 72), vt(Er, "PDF_TO_CSS_UNITS", Er.CSS / Er.PDF);
let pr = Er;
async function sf(l, e = "text") {
  if (Ro(l, document.baseURI)) {
    const t = await fetch(l);
    if (!t.ok)
      throw new Error(t.statusText);
    switch (e) {
      case "arraybuffer":
        return t.arrayBuffer();
      case "blob":
        return t.blob();
      case "json":
        return t.json();
    }
    return t.text();
  }
  return new Promise((t, s) => {
    const i = new XMLHttpRequest();
    i.open("GET", l, !0), i.responseType = e, i.onreadystatechange = () => {
      if (i.readyState === XMLHttpRequest.DONE) {
        if (i.status === 200 || i.status === 0) {
          switch (e) {
            case "arraybuffer":
            case "blob":
            case "json":
              t(i.response);
              return;
          }
          t(i.responseText);
          return;
        }
        s(new Error(i.statusText));
      }
    }, i.send(null);
  });
}
class oc {
  constructor({
    viewBox: e,
    scale: t,
    rotation: s,
    offsetX: i = 0,
    offsetY: r = 0,
    dontFlip: n = !1
  }) {
    this.viewBox = e, this.scale = t, this.rotation = s, this.offsetX = i, this.offsetY = r;
    const a = (e[2] + e[0]) / 2, h = (e[3] + e[1]) / 2;
    let c, d, u, f;
    switch (s %= 360, s < 0 && (s += 360), s) {
      case 180:
        c = -1, d = 0, u = 0, f = 1;
        break;
      case 90:
        c = 0, d = 1, u = 1, f = 0;
        break;
      case 270:
        c = 0, d = -1, u = -1, f = 0;
        break;
      case 0:
        c = 1, d = 0, u = 0, f = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    n && (u = -u, f = -f);
    let p, m, g, w;
    c === 0 ? (p = Math.abs(h - e[1]) * t + i, m = Math.abs(a - e[0]) * t + r, g = (e[3] - e[1]) * t, w = (e[2] - e[0]) * t) : (p = Math.abs(a - e[0]) * t + i, m = Math.abs(h - e[1]) * t + r, g = (e[2] - e[0]) * t, w = (e[3] - e[1]) * t), this.transform = [c * t, d * t, u * t, f * t, p - c * t * a - u * t * h, m - d * t * a - f * t * h], this.width = g, this.height = w;
  }
  get rawDims() {
    const {
      viewBox: e
    } = this;
    return Mt(this, "rawDims", {
      pageWidth: e[2] - e[0],
      pageHeight: e[3] - e[1],
      pageX: e[0],
      pageY: e[1]
    });
  }
  clone({
    scale: e = this.scale,
    rotation: t = this.rotation,
    offsetX: s = this.offsetX,
    offsetY: i = this.offsetY,
    dontFlip: r = !1
  } = {}) {
    return new oc({
      viewBox: this.viewBox.slice(),
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: r
    });
  }
  convertToViewportPoint(e, t) {
    return pt.applyTransform([e, t], this.transform);
  }
  convertToViewportRectangle(e) {
    const t = pt.applyTransform([e[0], e[1]], this.transform), s = pt.applyTransform([e[2], e[3]], this.transform);
    return [t[0], t[1], s[0], s[1]];
  }
  convertToPdfPoint(e, t) {
    return pt.applyInverseTransform([e, t], this.transform);
  }
}
class Qp extends mr {
  constructor(e, t = 0) {
    super(e, "RenderingCancelledException"), this.extraDelay = t;
  }
}
function rf(l) {
  const e = l.length;
  let t = 0;
  for (; t < e && l[t].trim() === ""; )
    t++;
  return l.substring(t, t + 5).toLowerCase() === "data:";
}
function Kp(l) {
  return typeof l == "string" && /\.pdf$/i.test(l);
}
function ww(l) {
  return [l] = l.split(/[#?]/, 1), l.substring(l.lastIndexOf("/") + 1);
}
function Aw(l, e = "document.pdf") {
  if (typeof l != "string")
    return e;
  if (rf(l))
    return xt('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), e;
  const t = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, s = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, i = t.exec(l);
  let r = s.exec(i[1]) || s.exec(i[2]) || s.exec(i[3]);
  if (r && (r = r[0], r.includes("%")))
    try {
      r = s.exec(decodeURIComponent(r))[0];
    } catch {
    }
  return r || e;
}
class Tg {
  constructor() {
    vt(this, "started", /* @__PURE__ */ Object.create(null));
    vt(this, "times", []);
  }
  time(e) {
    e in this.started && xt(`Timer is already running for ${e}`), this.started[e] = Date.now();
  }
  timeEnd(e) {
    e in this.started || xt(`Timer has not been started for ${e}`), this.times.push({
      name: e,
      start: this.started[e],
      end: Date.now()
    }), delete this.started[e];
  }
  toString() {
    const e = [];
    let t = 0;
    for (const {
      name: s
    } of this.times)
      t = Math.max(s.length, t);
    for (const {
      name: s,
      start: i,
      end: r
    } of this.times)
      e.push(`${s.padEnd(t)} ${r - i}ms
`);
    return e.join("");
  }
}
function Ro(l, e) {
  try {
    const {
      protocol: t
    } = e ? new URL(l, e) : new URL(l);
    return t === "http:" || t === "https:";
  } catch {
    return !1;
  }
}
function as(l) {
  l.preventDefault();
}
function Ig(l) {
  console.log("Deprecated API usage: " + l);
}
var sl;
class Zp {
  static toDateObject(e) {
    if (!e || typeof e != "string")
      return null;
    o(this, sl) || E(this, sl, new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
    const t = o(this, sl).exec(e);
    if (!t)
      return null;
    const s = parseInt(t[1], 10);
    let i = parseInt(t[2], 10);
    i = i >= 1 && i <= 12 ? i - 1 : 0;
    let r = parseInt(t[3], 10);
    r = r >= 1 && r <= 31 ? r : 1;
    let n = parseInt(t[4], 10);
    n = n >= 0 && n <= 23 ? n : 0;
    let a = parseInt(t[5], 10);
    a = a >= 0 && a <= 59 ? a : 0;
    let h = parseInt(t[6], 10);
    h = h >= 0 && h <= 59 ? h : 0;
    const c = t[7] || "Z";
    let d = parseInt(t[8], 10);
    d = d >= 0 && d <= 23 ? d : 0;
    let u = parseInt(t[9], 10) || 0;
    return u = u >= 0 && u <= 59 ? u : 0, c === "-" ? (n += d, a += u) : c === "+" && (n -= d, a -= u), new Date(Date.UTC(s, i, r, n, a, h));
  }
}
sl = new WeakMap(), y(Zp, sl, void 0);
function _w(l, {
  scale: e = 1,
  rotation: t = 0
}) {
  const {
    width: s,
    height: i
  } = l.attributes.style, r = [0, 0, parseInt(s), parseInt(i)];
  return new oc({
    viewBox: r,
    scale: e,
    rotation: t
  });
}
function Jp(l) {
  if (l.startsWith("#")) {
    const e = parseInt(l.slice(1), 16);
    return [(e & 16711680) >> 16, (e & 65280) >> 8, e & 255];
  }
  return l.startsWith("rgb(") ? l.slice(4, -1).split(",").map((e) => parseInt(e)) : l.startsWith("rgba(") ? l.slice(5, -1).split(",").map((e) => parseInt(e)).slice(0, 3) : (xt(`Not a valid color format: "${l}"`), [0, 0, 0]);
}
function Ew(l) {
  const e = document.createElement("span");
  e.style.visibility = "hidden", document.body.append(e);
  for (const t of l.keys()) {
    e.style.color = t;
    const s = window.getComputedStyle(e).color;
    l.set(t, Jp(s));
  }
  e.remove();
}
function Gt(l) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: r,
    f: n
  } = l.getTransform();
  return [e, t, s, i, r, n];
}
function Vs(l) {
  const {
    a: e,
    b: t,
    c: s,
    d: i,
    e: r,
    f: n
  } = l.getTransform().invertSelf();
  return [e, t, s, i, r, n];
}
function Rn(l, e, t = !1, s = !0) {
  if (e instanceof oc) {
    const {
      pageWidth: i,
      pageHeight: r
    } = e.rawDims, {
      style: n
    } = l, a = Pe.isCSSRoundSupported, h = `var(--scale-factor) * ${i}px`, c = `var(--scale-factor) * ${r}px`, d = a ? `round(down, ${h}, var(--scale-round-x, 1px))` : `calc(${h})`, u = a ? `round(down, ${c}, var(--scale-round-y, 1px))` : `calc(${c})`;
    !t || e.rotation % 180 === 0 ? (n.width = d, n.height = u) : (n.width = u, n.height = d);
  }
  s && l.setAttribute("data-main-rotation", e.rotation);
}
class kf {
  constructor() {
    const e = window.devicePixelRatio || 1;
    this.sx = e, this.sy = e;
  }
  get scaled() {
    return this.sx !== 1 || this.sy !== 1;
  }
  get symmetric() {
    return this.sx === this.sy;
  }
}
var Di, Sr, hs, kr, il, rl, nd, Nm, ad, Dm, od, Pm, ia, Ec, ld, Lm, nl, Cf;
const Xs = class Xs {
  constructor(e) {
    y(this, ad);
    y(this, od);
    y(this, ia);
    y(this, ld);
    y(this, nl);
    y(this, Di, null);
    y(this, Sr, null);
    y(this, hs, void 0);
    y(this, kr, null);
    y(this, il, null);
    E(this, hs, e), o(Xs, rl) || E(Xs, rl, Object.freeze({
      freetext: "pdfjs-editor-remove-freetext-button",
      highlight: "pdfjs-editor-remove-highlight-button",
      ink: "pdfjs-editor-remove-ink-button",
      stamp: "pdfjs-editor-remove-stamp-button"
    }));
  }
  render() {
    const e = E(this, Di, document.createElement("div"));
    e.classList.add("editToolbar", "hidden"), e.setAttribute("role", "toolbar");
    const t = o(this, hs)._uiManager._signal;
    e.addEventListener("contextmenu", as, {
      signal: t
    }), e.addEventListener("pointerdown", x(Xs, nd, Nm), {
      signal: t
    });
    const s = E(this, kr, document.createElement("div"));
    s.className = "buttons", e.append(s);
    const i = o(this, hs).toolbarPosition;
    if (i) {
      const {
        style: r
      } = e, n = o(this, hs)._uiManager.direction === "ltr" ? 1 - i[0] : i[0];
      r.insetInlineEnd = `${100 * n}%`, r.top = `calc(${100 * i[1]}% + var(--editor-toolbar-vert-offset))`;
    }
    return x(this, ld, Lm).call(this), e;
  }
  get div() {
    return o(this, Di);
  }
  hide() {
    var e;
    o(this, Di).classList.add("hidden"), (e = o(this, Sr)) == null || e.hideDropdown();
  }
  show() {
    var e;
    o(this, Di).classList.remove("hidden"), (e = o(this, il)) == null || e.shown();
  }
  async addAltText(e) {
    const t = await e.render();
    x(this, ia, Ec).call(this, t), o(this, kr).prepend(t, o(this, nl, Cf)), E(this, il, e);
  }
  addColorPicker(e) {
    E(this, Sr, e);
    const t = e.renderButton();
    x(this, ia, Ec).call(this, t), o(this, kr).prepend(t, o(this, nl, Cf));
  }
  remove() {
    var e;
    o(this, Di).remove(), (e = o(this, Sr)) == null || e.destroy(), E(this, Sr, null);
  }
};
Di = new WeakMap(), Sr = new WeakMap(), hs = new WeakMap(), kr = new WeakMap(), il = new WeakMap(), rl = new WeakMap(), nd = new WeakSet(), Nm = function(e) {
  e.stopPropagation();
}, ad = new WeakSet(), Dm = function(e) {
  o(this, hs)._focusEventsAllowed = !1, e.preventDefault(), e.stopPropagation();
}, od = new WeakSet(), Pm = function(e) {
  o(this, hs)._focusEventsAllowed = !0, e.preventDefault(), e.stopPropagation();
}, ia = new WeakSet(), Ec = function(e) {
  const t = o(this, hs)._uiManager._signal;
  e.addEventListener("focusin", x(this, ad, Dm).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("focusout", x(this, od, Pm).bind(this), {
    capture: !0,
    signal: t
  }), e.addEventListener("contextmenu", as, {
    signal: t
  });
}, ld = new WeakSet(), Lm = function() {
  const {
    editorType: e,
    _uiManager: t
  } = o(this, hs), s = document.createElement("button");
  s.className = "delete", s.tabIndex = 0, s.setAttribute("data-l10n-id", o(Xs, rl)[e]), x(this, ia, Ec).call(this, s), s.addEventListener("click", (i) => {
    t.delete();
  }, {
    signal: t._signal
  }), o(this, kr).append(s);
}, nl = new WeakSet(), Cf = function() {
  const e = document.createElement("div");
  return e.className = "divider", e;
}, y(Xs, nd), y(Xs, rl, null);
let Mf = Xs;
var al, Mr, Cr, hd, Rm, cd, Om, dd, Fm;
class xw {
  constructor(e) {
    y(this, hd);
    y(this, cd);
    y(this, dd);
    y(this, al, null);
    y(this, Mr, null);
    y(this, Cr, void 0);
    E(this, Cr, e);
  }
  show(e, t, s) {
    const [i, r] = x(this, cd, Om).call(this, t, s), {
      style: n
    } = o(this, Mr) || E(this, Mr, x(this, hd, Rm).call(this));
    e.append(o(this, Mr)), n.insetInlineEnd = `${100 * i}%`, n.top = `calc(${100 * r}% + var(--editor-toolbar-vert-offset))`;
  }
  hide() {
    o(this, Mr).remove();
  }
}
al = new WeakMap(), Mr = new WeakMap(), Cr = new WeakMap(), hd = new WeakSet(), Rm = function() {
  const e = E(this, Mr, document.createElement("div"));
  e.className = "editToolbar", e.setAttribute("role", "toolbar"), e.addEventListener("contextmenu", as, {
    signal: o(this, Cr)._signal
  });
  const t = E(this, al, document.createElement("div"));
  return t.className = "buttons", e.append(t), x(this, dd, Fm).call(this), e;
}, cd = new WeakSet(), Om = function(e, t) {
  let s = 0, i = 0;
  for (const r of e) {
    const n = r.y + r.height;
    if (n < s)
      continue;
    const a = r.x + (t ? r.width : 0);
    if (n > s) {
      i = a, s = n;
      continue;
    }
    t ? a > i && (i = a) : a < i && (i = a);
  }
  return [t ? 1 - i : i, s];
}, dd = new WeakSet(), Fm = function() {
  const e = document.createElement("button");
  e.className = "highlightButton", e.tabIndex = 0, e.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button1");
  const t = document.createElement("span");
  e.append(t), t.className = "visuallyHidden", t.setAttribute("data-l10n-id", "pdfjs-highlight-floating-button-label");
  const s = o(this, Cr)._signal;
  e.addEventListener("contextmenu", as, {
    signal: s
  }), e.addEventListener("click", () => {
    o(this, Cr).highlightSelection("floating_button");
  }, {
    signal: s
  }), o(this, al).append(e);
};
function td(l, e, t) {
  for (const s of t)
    e.addEventListener(s, l[s].bind(l));
}
function Sw(l) {
  return Math.round(Math.min(255, Math.max(1, 255 * l))).toString(16).padStart(2, "0");
}
var ud;
class kw {
  constructor() {
    y(this, ud, 0);
  }
  get id() {
    return `${nw}${Te(this, ud)._++}`;
  }
}
ud = new WeakMap();
var ra, ol, Ee, na, xc;
const hg = class hg {
  constructor() {
    y(this, na);
    y(this, ra, yw());
    y(this, ol, 0);
    y(this, Ee, null);
  }
  static get _isSVGFittingCanvas() {
    const e = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', s = new OffscreenCanvas(1, 3).getContext("2d", {
      willReadFrequently: !0
    }), i = new Image();
    i.src = e;
    const r = i.decode().then(() => (s.drawImage(i, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(s.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
    return Mt(this, "_isSVGFittingCanvas", r);
  }
  async getFromFile(e) {
    const {
      lastModified: t,
      name: s,
      size: i,
      type: r
    } = e;
    return x(this, na, xc).call(this, `${t}_${s}_${i}_${r}`, e);
  }
  async getFromUrl(e) {
    return x(this, na, xc).call(this, e, e);
  }
  async getFromBlob(e, t) {
    const s = await t;
    return x(this, na, xc).call(this, e, s);
  }
  async getFromId(e) {
    o(this, Ee) || E(this, Ee, /* @__PURE__ */ new Map());
    const t = o(this, Ee).get(e);
    if (!t)
      return null;
    if (t.bitmap)
      return t.refCounter += 1, t;
    if (t.file)
      return this.getFromFile(t.file);
    if (t.blobPromise) {
      const {
        blobPromise: s
      } = t;
      return delete t.blobPromise, this.getFromBlob(t.id, s);
    }
    return this.getFromUrl(t.url);
  }
  getFromCanvas(e, t) {
    o(this, Ee) || E(this, Ee, /* @__PURE__ */ new Map());
    let s = o(this, Ee).get(e);
    if (s != null && s.bitmap)
      return s.refCounter += 1, s;
    const i = new OffscreenCanvas(t.width, t.height);
    return i.getContext("2d").drawImage(t, 0, 0), s = {
      bitmap: i.transferToImageBitmap(),
      id: `image_${o(this, ra)}_${Te(this, ol)._++}`,
      refCounter: 1,
      isSvg: !1
    }, o(this, Ee).set(e, s), o(this, Ee).set(s.id, s), s;
  }
  getSvgUrl(e) {
    const t = o(this, Ee).get(e);
    return t != null && t.isSvg ? t.svgUrl : null;
  }
  deleteId(e) {
    var i;
    o(this, Ee) || E(this, Ee, /* @__PURE__ */ new Map());
    const t = o(this, Ee).get(e);
    if (!t || (t.refCounter -= 1, t.refCounter !== 0))
      return;
    const {
      bitmap: s
    } = t;
    if (!t.url && !t.file) {
      const r = new OffscreenCanvas(s.width, s.height);
      r.getContext("bitmaprenderer").transferFromImageBitmap(s), t.blobPromise = r.convertToBlob();
    }
    (i = s.close) == null || i.call(s), t.bitmap = null;
  }
  isValidId(e) {
    return e.startsWith(`image_${o(this, ra)}_`);
  }
};
ra = new WeakMap(), ol = new WeakMap(), Ee = new WeakMap(), na = new WeakSet(), xc = async function(e, t) {
  o(this, Ee) || E(this, Ee, /* @__PURE__ */ new Map());
  let s = o(this, Ee).get(e);
  if (s === null)
    return null;
  if (s != null && s.bitmap)
    return s.refCounter += 1, s;
  try {
    s || (s = {
      bitmap: null,
      id: `image_${o(this, ra)}_${Te(this, ol)._++}`,
      refCounter: 0,
      isSvg: !1
    });
    let i;
    if (typeof t == "string" ? (s.url = t, i = await sf(t, "blob")) : t instanceof File ? i = s.file = t : t instanceof Blob && (i = t), i.type === "image/svg+xml") {
      const r = hg._isSVGFittingCanvas, n = new FileReader(), a = new Image(), h = new Promise((c, d) => {
        a.onload = () => {
          s.bitmap = a, s.isSvg = !0, c();
        }, n.onload = async () => {
          const u = s.svgUrl = n.result;
          a.src = await r ? `${u}#svgView(preserveAspectRatio(none))` : u;
        }, a.onerror = n.onerror = d;
      });
      n.readAsDataURL(i), await h;
    } else
      s.bitmap = await createImageBitmap(i);
    s.refCounter = 1;
  } catch (i) {
    console.error(i), s = null;
  }
  return o(this, Ee).set(e, s), s && o(this, Ee).set(s.id, s), s;
};
let Tf = hg;
var le, Pi, ll, he;
class Mw {
  constructor(e = 128) {
    y(this, le, []);
    y(this, Pi, !1);
    y(this, ll, void 0);
    y(this, he, -1);
    E(this, ll, e);
  }
  add({
    cmd: e,
    undo: t,
    post: s,
    mustExec: i,
    type: r = NaN,
    overwriteIfSameType: n = !1,
    keepUndo: a = !1
  }) {
    if (i && e(), o(this, Pi))
      return;
    const h = {
      cmd: e,
      undo: t,
      post: s,
      type: r
    };
    if (o(this, he) === -1) {
      o(this, le).length > 0 && (o(this, le).length = 0), E(this, he, 0), o(this, le).push(h);
      return;
    }
    if (n && o(this, le)[o(this, he)].type === r) {
      a && (h.undo = o(this, le)[o(this, he)].undo), o(this, le)[o(this, he)] = h;
      return;
    }
    const c = o(this, he) + 1;
    c === o(this, ll) ? o(this, le).splice(0, 1) : (E(this, he, c), c < o(this, le).length && o(this, le).splice(c)), o(this, le).push(h);
  }
  undo() {
    if (o(this, he) === -1)
      return;
    E(this, Pi, !0);
    const {
      undo: e,
      post: t
    } = o(this, le)[o(this, he)];
    e(), t == null || t(), E(this, Pi, !1), E(this, he, o(this, he) - 1);
  }
  redo() {
    if (o(this, he) < o(this, le).length - 1) {
      E(this, he, o(this, he) + 1), E(this, Pi, !0);
      const {
        cmd: e,
        post: t
      } = o(this, le)[o(this, he)];
      e(), t == null || t(), E(this, Pi, !1);
    }
  }
  hasSomethingToUndo() {
    return o(this, he) !== -1;
  }
  hasSomethingToRedo() {
    return o(this, he) < o(this, le).length - 1;
  }
  destroy() {
    E(this, le, null);
  }
}
le = new WeakMap(), Pi = new WeakMap(), ll = new WeakMap(), he = new WeakMap();
var fd, jm;
class lc {
  constructor(e) {
    y(this, fd);
    this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
    const {
      isMac: t
    } = Pe.platform;
    for (const [s, i, r = {}] of e)
      for (const n of s) {
        const a = n.startsWith("mac+");
        t && a ? (this.callbacks.set(n.slice(4), {
          callback: i,
          options: r
        }), this.allKeys.add(n.split("+").at(-1))) : !t && !a && (this.callbacks.set(n, {
          callback: i,
          options: r
        }), this.allKeys.add(n.split("+").at(-1)));
      }
  }
  exec(e, t) {
    if (!this.allKeys.has(t.key))
      return;
    const s = this.callbacks.get(x(this, fd, jm).call(this, t));
    if (!s)
      return;
    const {
      callback: i,
      options: {
        bubbles: r = !1,
        args: n = [],
        checker: a = null
      }
    } = s;
    a && !a(e, t) || (i.bind(e, ...n, t)(), r || (t.stopPropagation(), t.preventDefault()));
  }
}
fd = new WeakSet(), jm = function(e) {
  e.altKey && this.buffer.push("alt"), e.ctrlKey && this.buffer.push("ctrl"), e.metaKey && this.buffer.push("meta"), e.shiftKey && this.buffer.push("shift"), this.buffer.push(e.key);
  const t = this.buffer.join("+");
  return this.buffer.length = 0, t;
};
const pd = class pd {
  get _colors() {
    const e = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
    return Ew(e), Mt(this, "_colors", e);
  }
  convert(e) {
    const t = Jp(e);
    if (!window.matchMedia("(forced-colors: active)").matches)
      return t;
    for (const [s, i] of this._colors)
      if (i.every((r, n) => r === t[n]))
        return pd._colorsMapping.get(s);
    return t;
  }
  getHexCode(e) {
    const t = this._colors.get(e);
    return t ? pt.makeHexColor(...t) : e;
  }
};
vt(pd, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
let If = pd;
var aa, He, ie, me, oa, Qs, la, cs, Li, ha, Tr, xs, ds, Ir, hl, cl, ca, dl, Ss, Ri, da, Oi, ks, gd, Fi, ul, ji, Nr, fl, pl, ce, It, Ks, Dr, gl, ml, zi, Ms, Zs, bl, ts, ua, Sc, yl, Nf, md, zm, bd, Bm, fa, kc, yd, Um, vd, Hm, wd, Wm, vl, Df, Ad, $m, wl, Pf, Al, Lf, _d, Gm, be, Ie, Cs, Ci, Ed, Vm, xd, Ym, _l, Rf, Sd, Xm, Pr, Oo, El, Of;
const Kn = class Kn {
  constructor(e, t, s, i, r, n, a, h, c, d, u) {
    y(this, ua);
    y(this, yl);
    y(this, md);
    y(this, bd);
    y(this, fa);
    y(this, yd);
    y(this, vd);
    y(this, wd);
    y(this, vl);
    y(this, Ad);
    y(this, wl);
    y(this, Al);
    y(this, _d);
    y(this, be);
    y(this, Cs);
    y(this, Ed);
    y(this, xd);
    y(this, _l);
    y(this, Sd);
    y(this, Pr);
    y(this, El);
    y(this, aa, new AbortController());
    y(this, He, null);
    y(this, ie, /* @__PURE__ */ new Map());
    y(this, me, /* @__PURE__ */ new Map());
    y(this, oa, null);
    y(this, Qs, null);
    y(this, la, null);
    y(this, cs, new Mw());
    y(this, Li, null);
    y(this, ha, 0);
    y(this, Tr, /* @__PURE__ */ new Set());
    y(this, xs, null);
    y(this, ds, null);
    y(this, Ir, /* @__PURE__ */ new Set());
    y(this, hl, !1);
    y(this, cl, !1);
    y(this, ca, !1);
    y(this, dl, null);
    y(this, Ss, null);
    y(this, Ri, null);
    y(this, da, null);
    y(this, Oi, !1);
    y(this, ks, null);
    y(this, gd, new kw());
    y(this, Fi, !1);
    y(this, ul, !1);
    y(this, ji, null);
    y(this, Nr, null);
    y(this, fl, null);
    y(this, pl, null);
    y(this, ce, _t.NONE);
    y(this, It, /* @__PURE__ */ new Set());
    y(this, Ks, null);
    y(this, Dr, null);
    y(this, gl, null);
    y(this, ml, {
      isEditing: !1,
      isEmpty: !0,
      hasSomethingToUndo: !1,
      hasSomethingToRedo: !1,
      hasSelectedEditor: !1,
      hasSelectedText: !1
    });
    y(this, zi, [0, 0]);
    y(this, Ms, null);
    y(this, Zs, null);
    y(this, bl, null);
    y(this, ts, null);
    const f = this._signal = o(this, aa).signal;
    E(this, Zs, e), E(this, bl, t), E(this, oa, s), this._eventBus = i, i._on("editingaction", this.onEditingAction.bind(this), {
      signal: f
    }), i._on("pagechanging", this.onPageChanging.bind(this), {
      signal: f
    }), i._on("scalechanging", this.onScaleChanging.bind(this), {
      signal: f
    }), i._on("rotationchanging", this.onRotationChanging.bind(this), {
      signal: f
    }), i._on("setpreference", this.onSetPreference.bind(this), {
      signal: f
    }), i._on("switchannotationeditorparams", (p) => this.updateParams(p.type, p.value), {
      signal: f
    }), x(this, yd, Um).call(this), x(this, _d, Gm).call(this), x(this, vl, Df).call(this), E(this, Qs, r.annotationStorage), E(this, dl, r.filterFactory), E(this, Dr, n), E(this, da, a || null), E(this, hl, h), E(this, cl, c), E(this, ca, d), E(this, pl, u || null), this.viewParameters = {
      realScale: pr.PDF_TO_CSS_UNITS,
      rotation: 0
    }, this.isShiftKeyDown = !1;
  }
  static get _keyboardManager() {
    const e = Kn.prototype, t = (n) => o(n, Zs).contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && n.hasSomethingToControl(), s = (n, {
      target: a
    }) => {
      if (a instanceof HTMLInputElement) {
        const {
          type: h
        } = a;
        return h !== "text" && h !== "number";
      }
      return !0;
    }, i = this.TRANSLATE_SMALL, r = this.TRANSLATE_BIG;
    return Mt(this, "_keyboardManager", new lc([[["ctrl+a", "mac+meta+a"], e.selectAll, {
      checker: s
    }], [["ctrl+z", "mac+meta+z"], e.undo, {
      checker: s
    }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], e.redo, {
      checker: s
    }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], e.delete, {
      checker: s
    }], [["Enter", "mac+Enter"], e.addNewEditorFromKeyboard, {
      checker: (n, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && o(n, Zs).contains(a) && !n.isEnterHandled
    }], [[" ", "mac+ "], e.addNewEditorFromKeyboard, {
      checker: (n, {
        target: a
      }) => !(a instanceof HTMLButtonElement) && o(n, Zs).contains(document.activeElement)
    }], [["Escape", "mac+Escape"], e.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], e.translateSelectedEditors, {
      args: [-i, 0],
      checker: t
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e.translateSelectedEditors, {
      args: [-r, 0],
      checker: t
    }], [["ArrowRight", "mac+ArrowRight"], e.translateSelectedEditors, {
      args: [i, 0],
      checker: t
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e.translateSelectedEditors, {
      args: [r, 0],
      checker: t
    }], [["ArrowUp", "mac+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -i],
      checker: t
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e.translateSelectedEditors, {
      args: [0, -r],
      checker: t
    }], [["ArrowDown", "mac+ArrowDown"], e.translateSelectedEditors, {
      args: [0, i],
      checker: t
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e.translateSelectedEditors, {
      args: [0, r],
      checker: t
    }]]));
  }
  destroy() {
    var e, t, s, i;
    (e = o(this, ts)) == null || e.resolve(), E(this, ts, null), (t = o(this, aa)) == null || t.abort(), E(this, aa, null), this._signal = null;
    for (const r of o(this, me).values())
      r.destroy();
    o(this, me).clear(), o(this, ie).clear(), o(this, Ir).clear(), E(this, He, null), o(this, It).clear(), o(this, cs).destroy(), (s = o(this, oa)) == null || s.destroy(), (i = o(this, ks)) == null || i.hide(), E(this, ks, null), o(this, Ss) && (clearTimeout(o(this, Ss)), E(this, Ss, null)), o(this, Ms) && (clearTimeout(o(this, Ms)), E(this, Ms, null));
  }
  combinedSignal(e) {
    return AbortSignal.any([this._signal, e.signal]);
  }
  get mlManager() {
    return o(this, pl);
  }
  get useNewAltTextFlow() {
    return o(this, cl);
  }
  get useNewAltTextWhenAddingImage() {
    return o(this, ca);
  }
  get hcmFilter() {
    return Mt(this, "hcmFilter", o(this, Dr) ? o(this, dl).addHCMFilter(o(this, Dr).foreground, o(this, Dr).background) : "none");
  }
  get direction() {
    return Mt(this, "direction", getComputedStyle(o(this, Zs)).direction);
  }
  get highlightColors() {
    return Mt(this, "highlightColors", o(this, da) ? new Map(o(this, da).split(",").map((e) => e.split("=").map((t) => t.trim()))) : null);
  }
  get highlightColorNames() {
    return Mt(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
  }
  setMainHighlightColorPicker(e) {
    E(this, fl, e);
  }
  editAltText(e, t = !1) {
    var s;
    (s = o(this, oa)) == null || s.editAltText(this, e, t);
  }
  switchToMode(e, t) {
    this._eventBus.on("annotationeditormodechanged", t, {
      once: !0,
      signal: this._signal
    }), this._eventBus.dispatch("showannotationeditorui", {
      source: this,
      mode: e
    });
  }
  setPreference(e, t) {
    this._eventBus.dispatch("setpreference", {
      source: this,
      name: e,
      value: t
    });
  }
  onSetPreference({
    name: e,
    value: t
  }) {
    switch (e) {
      case "enableNewAltTextWhenAddingImage":
        E(this, ca, t);
        break;
    }
  }
  onPageChanging({
    pageNumber: e
  }) {
    E(this, ha, e - 1);
  }
  focusMainContainer() {
    o(this, Zs).focus();
  }
  findParent(e, t) {
    for (const s of o(this, me).values()) {
      const {
        x: i,
        y: r,
        width: n,
        height: a
      } = s.div.getBoundingClientRect();
      if (e >= i && e <= i + n && t >= r && t <= r + a)
        return s;
    }
    return null;
  }
  disableUserSelect(e = !1) {
    o(this, bl).classList.toggle("noUserSelect", e);
  }
  addShouldRescale(e) {
    o(this, Ir).add(e);
  }
  removeShouldRescale(e) {
    o(this, Ir).delete(e);
  }
  onScaleChanging({
    scale: e
  }) {
    this.commitOrRemove(), this.viewParameters.realScale = e * pr.PDF_TO_CSS_UNITS;
    for (const t of o(this, Ir))
      t.onScaleChanging();
  }
  onRotationChanging({
    pagesRotation: e
  }) {
    this.commitOrRemove(), this.viewParameters.rotation = e;
  }
  highlightSelection(e = "") {
    const t = document.getSelection();
    if (!t || t.isCollapsed)
      return;
    const {
      anchorNode: s,
      anchorOffset: i,
      focusNode: r,
      focusOffset: n
    } = t, a = t.toString(), c = x(this, ua, Sc).call(this, t).closest(".textLayer"), d = this.getSelectionBoxes(c);
    if (!d)
      return;
    t.empty();
    const u = x(this, yl, Nf).call(this, c), f = o(this, ce) === _t.NONE, p = () => {
      u == null || u.createAndAddNewEditor({
        x: 0,
        y: 0
      }, !1, {
        methodOfCreation: e,
        boxes: d,
        anchorNode: s,
        anchorOffset: i,
        focusNode: r,
        focusOffset: n,
        text: a
      }), f && this.showAllEditors("highlight", !0, !0);
    };
    if (f) {
      this.switchToMode(_t.HIGHLIGHT, p);
      return;
    }
    p();
  }
  addToAnnotationStorage(e) {
    !e.isEmpty() && o(this, Qs) && !o(this, Qs).has(e.id) && o(this, Qs).setValue(e.id, e);
  }
  blur() {
    if (this.isShiftKeyDown = !1, o(this, Oi) && (E(this, Oi, !1), x(this, fa, kc).call(this, "main_toolbar")), !this.hasSelection)
      return;
    const {
      activeElement: e
    } = document;
    for (const t of o(this, It))
      if (t.div.contains(e)) {
        E(this, Nr, [t, e]), t._focusEventsAllowed = !1;
        break;
      }
  }
  focus() {
    if (!o(this, Nr))
      return;
    const [e, t] = o(this, Nr);
    E(this, Nr, null), t.addEventListener("focusin", () => {
      e._focusEventsAllowed = !0;
    }, {
      once: !0,
      signal: this._signal
    }), t.focus();
  }
  addEditListeners() {
    x(this, vl, Df).call(this), x(this, wl, Pf).call(this);
  }
  removeEditListeners() {
    x(this, Ad, $m).call(this), x(this, Al, Lf).call(this);
  }
  dragOver(e) {
    for (const {
      type: t
    } of e.dataTransfer.items)
      for (const s of o(this, ds))
        if (s.isHandlingMimeForPasting(t)) {
          e.dataTransfer.dropEffect = "copy", e.preventDefault();
          return;
        }
  }
  drop(e) {
    for (const t of e.dataTransfer.items)
      for (const s of o(this, ds))
        if (s.isHandlingMimeForPasting(t.type)) {
          s.paste(t, this.currentLayer), e.preventDefault();
          return;
        }
  }
  copy(e) {
    var s;
    if (e.preventDefault(), (s = o(this, He)) == null || s.commitOrRemove(), !this.hasSelection)
      return;
    const t = [];
    for (const i of o(this, It)) {
      const r = i.serialize(!0);
      r && t.push(r);
    }
    t.length !== 0 && e.clipboardData.setData("application/pdfjs", JSON.stringify(t));
  }
  cut(e) {
    this.copy(e), this.delete();
  }
  async paste(e) {
    e.preventDefault();
    const {
      clipboardData: t
    } = e;
    for (const r of t.items)
      for (const n of o(this, ds))
        if (n.isHandlingMimeForPasting(r.type)) {
          n.paste(r, this.currentLayer);
          return;
        }
    let s = t.getData("application/pdfjs");
    if (!s)
      return;
    try {
      s = JSON.parse(s);
    } catch (r) {
      xt(`paste: "${r.message}".`);
      return;
    }
    if (!Array.isArray(s))
      return;
    this.unselectAll();
    const i = this.currentLayer;
    try {
      const r = [];
      for (const h of s) {
        const c = await i.deserialize(h);
        if (!c)
          return;
        r.push(c);
      }
      const n = () => {
        for (const h of r)
          x(this, _l, Rf).call(this, h);
        x(this, El, Of).call(this, r);
      }, a = () => {
        for (const h of r)
          h.remove();
      };
      this.addCommands({
        cmd: n,
        undo: a,
        mustExec: !0
      });
    } catch (r) {
      xt(`paste: "${r.message}".`);
    }
  }
  keydown(e) {
    !this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !0), o(this, ce) !== _t.NONE && !this.isEditorHandlingKeyboard && Kn._keyboardManager.exec(this, e);
  }
  keyup(e) {
    this.isShiftKeyDown && e.key === "Shift" && (this.isShiftKeyDown = !1, o(this, Oi) && (E(this, Oi, !1), x(this, fa, kc).call(this, "main_toolbar")));
  }
  onEditingAction({
    name: e
  }) {
    switch (e) {
      case "undo":
      case "redo":
      case "delete":
      case "selectAll":
        this[e]();
        break;
      case "highlightSelection":
        this.highlightSelection("context_menu");
        break;
    }
  }
  setEditingState(e) {
    e ? (x(this, vd, Hm).call(this), x(this, wl, Pf).call(this), x(this, be, Ie).call(this, {
      isEditing: o(this, ce) !== _t.NONE,
      isEmpty: x(this, Pr, Oo).call(this),
      hasSomethingToUndo: o(this, cs).hasSomethingToUndo(),
      hasSomethingToRedo: o(this, cs).hasSomethingToRedo(),
      hasSelectedEditor: !1
    })) : (x(this, wd, Wm).call(this), x(this, Al, Lf).call(this), x(this, be, Ie).call(this, {
      isEditing: !1
    }), this.disableUserSelect(!1));
  }
  registerEditorTypes(e) {
    if (!o(this, ds)) {
      E(this, ds, e);
      for (const t of o(this, ds))
        x(this, Cs, Ci).call(this, t.defaultPropertiesToUpdate);
    }
  }
  getId() {
    return o(this, gd).id;
  }
  get currentLayer() {
    return o(this, me).get(o(this, ha));
  }
  getLayer(e) {
    return o(this, me).get(e);
  }
  get currentPageIndex() {
    return o(this, ha);
  }
  addLayer(e) {
    o(this, me).set(e.pageIndex, e), o(this, Fi) ? e.enable() : e.disable();
  }
  removeLayer(e) {
    o(this, me).delete(e.pageIndex);
  }
  async updateMode(e, t = null, s = !1) {
    if (o(this, ce) !== e && !(o(this, ts) && (await o(this, ts).promise, !o(this, ts)))) {
      if (E(this, ts, Promise.withResolvers()), E(this, ce, e), e === _t.NONE) {
        this.setEditingState(!1), x(this, xd, Ym).call(this), o(this, ts).resolve();
        return;
      }
      this.setEditingState(!0), await x(this, Ed, Vm).call(this), this.unselectAll();
      for (const i of o(this, me).values())
        i.updateMode(e);
      if (!t) {
        s && this.addNewEditorFromKeyboard(), o(this, ts).resolve();
        return;
      }
      for (const i of o(this, ie).values())
        i.annotationElementId === t ? (this.setSelected(i), i.enterInEditMode()) : i.unselect();
      o(this, ts).resolve();
    }
  }
  addNewEditorFromKeyboard() {
    this.currentLayer.canCreateNewEmptyEditor() && this.currentLayer.addNewEditor();
  }
  updateToolbar(e) {
    e !== o(this, ce) && this._eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode: e
    });
  }
  updateParams(e, t) {
    var s;
    if (o(this, ds)) {
      switch (e) {
        case wt.CREATE:
          this.currentLayer.addNewEditor();
          return;
        case wt.HIGHLIGHT_DEFAULT_COLOR:
          (s = o(this, fl)) == null || s.updateColor(t);
          break;
        case wt.HIGHLIGHT_SHOW_ALL:
          this._eventBus.dispatch("reporttelemetry", {
            source: this,
            details: {
              type: "editing",
              data: {
                type: "highlight",
                action: "toggle_visibility"
              }
            }
          }), (o(this, gl) || E(this, gl, /* @__PURE__ */ new Map())).set(e, t), this.showAllEditors("highlight", t);
          break;
      }
      for (const i of o(this, It))
        i.updateParams(e, t);
      for (const i of o(this, ds))
        i.updateDefaultParams(e, t);
    }
  }
  showAllEditors(e, t, s = !1) {
    var r;
    for (const n of o(this, ie).values())
      n.editorType === e && n.show(t);
    (((r = o(this, gl)) == null ? void 0 : r.get(wt.HIGHLIGHT_SHOW_ALL)) ?? !0) !== t && x(this, Cs, Ci).call(this, [[wt.HIGHLIGHT_SHOW_ALL, t]]);
  }
  enableWaiting(e = !1) {
    if (o(this, ul) !== e) {
      E(this, ul, e);
      for (const t of o(this, me).values())
        e ? t.disableClick() : t.enableClick(), t.div.classList.toggle("waiting", e);
    }
  }
  getEditors(e) {
    const t = [];
    for (const s of o(this, ie).values())
      s.pageIndex === e && t.push(s);
    return t;
  }
  getEditor(e) {
    return o(this, ie).get(e);
  }
  addEditor(e) {
    o(this, ie).set(e.id, e);
  }
  removeEditor(e) {
    var t;
    e.div.contains(document.activeElement) && (o(this, Ss) && clearTimeout(o(this, Ss)), E(this, Ss, setTimeout(() => {
      this.focusMainContainer(), E(this, Ss, null);
    }, 0))), o(this, ie).delete(e.id), this.unselect(e), (!e.annotationElementId || !o(this, Tr).has(e.annotationElementId)) && ((t = o(this, Qs)) == null || t.remove(e.id));
  }
  addDeletedAnnotationElement(e) {
    o(this, Tr).add(e.annotationElementId), this.addChangedExistingAnnotation(e), e.deleted = !0;
  }
  isDeletedAnnotationElement(e) {
    return o(this, Tr).has(e);
  }
  removeDeletedAnnotationElement(e) {
    o(this, Tr).delete(e.annotationElementId), this.removeChangedExistingAnnotation(e), e.deleted = !1;
  }
  setActiveEditor(e) {
    o(this, He) !== e && (E(this, He, e), e && x(this, Cs, Ci).call(this, e.propertiesToUpdate));
  }
  updateUI(e) {
    o(this, Sd, Xm) === e && x(this, Cs, Ci).call(this, e.propertiesToUpdate);
  }
  toggleSelected(e) {
    if (o(this, It).has(e)) {
      o(this, It).delete(e), e.unselect(), x(this, be, Ie).call(this, {
        hasSelectedEditor: this.hasSelection
      });
      return;
    }
    o(this, It).add(e), e.select(), x(this, Cs, Ci).call(this, e.propertiesToUpdate), x(this, be, Ie).call(this, {
      hasSelectedEditor: !0
    });
  }
  setSelected(e) {
    for (const t of o(this, It))
      t !== e && t.unselect();
    o(this, It).clear(), o(this, It).add(e), e.select(), x(this, Cs, Ci).call(this, e.propertiesToUpdate), x(this, be, Ie).call(this, {
      hasSelectedEditor: !0
    });
  }
  isSelected(e) {
    return o(this, It).has(e);
  }
  get firstSelectedEditor() {
    return o(this, It).values().next().value;
  }
  unselect(e) {
    e.unselect(), o(this, It).delete(e), x(this, be, Ie).call(this, {
      hasSelectedEditor: this.hasSelection
    });
  }
  get hasSelection() {
    return o(this, It).size !== 0;
  }
  get isEnterHandled() {
    return o(this, It).size === 1 && this.firstSelectedEditor.isEnterHandled;
  }
  undo() {
    o(this, cs).undo(), x(this, be, Ie).call(this, {
      hasSomethingToUndo: o(this, cs).hasSomethingToUndo(),
      hasSomethingToRedo: !0,
      isEmpty: x(this, Pr, Oo).call(this)
    });
  }
  redo() {
    o(this, cs).redo(), x(this, be, Ie).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: o(this, cs).hasSomethingToRedo(),
      isEmpty: x(this, Pr, Oo).call(this)
    });
  }
  addCommands(e) {
    o(this, cs).add(e), x(this, be, Ie).call(this, {
      hasSomethingToUndo: !0,
      hasSomethingToRedo: !1,
      isEmpty: x(this, Pr, Oo).call(this)
    });
  }
  delete() {
    if (this.commitOrRemove(), !this.hasSelection)
      return;
    const e = [...o(this, It)], t = () => {
      for (const i of e)
        i.remove();
    }, s = () => {
      for (const i of e)
        x(this, _l, Rf).call(this, i);
    };
    this.addCommands({
      cmd: t,
      undo: s,
      mustExec: !0
    });
  }
  commitOrRemove() {
    var e;
    (e = o(this, He)) == null || e.commitOrRemove();
  }
  hasSomethingToControl() {
    return o(this, He) || this.hasSelection;
  }
  selectAll() {
    for (const e of o(this, It))
      e.commit();
    x(this, El, Of).call(this, o(this, ie).values());
  }
  unselectAll() {
    if (!(o(this, He) && (o(this, He).commitOrRemove(), o(this, ce) !== _t.NONE)) && this.hasSelection) {
      for (const e of o(this, It))
        e.unselect();
      o(this, It).clear(), x(this, be, Ie).call(this, {
        hasSelectedEditor: !1
      });
    }
  }
  translateSelectedEditors(e, t, s = !1) {
    if (s || this.commitOrRemove(), !this.hasSelection)
      return;
    o(this, zi)[0] += e, o(this, zi)[1] += t;
    const [i, r] = o(this, zi), n = [...o(this, It)], a = 1e3;
    o(this, Ms) && clearTimeout(o(this, Ms)), E(this, Ms, setTimeout(() => {
      E(this, Ms, null), o(this, zi)[0] = o(this, zi)[1] = 0, this.addCommands({
        cmd: () => {
          for (const h of n)
            o(this, ie).has(h.id) && h.translateInPage(i, r);
        },
        undo: () => {
          for (const h of n)
            o(this, ie).has(h.id) && h.translateInPage(-i, -r);
        },
        mustExec: !1
      });
    }, a));
    for (const h of n)
      h.translateInPage(e, t);
  }
  setUpDragSession() {
    if (this.hasSelection) {
      this.disableUserSelect(!0), E(this, xs, /* @__PURE__ */ new Map());
      for (const e of o(this, It))
        o(this, xs).set(e, {
          savedX: e.x,
          savedY: e.y,
          savedPageIndex: e.pageIndex,
          newX: 0,
          newY: 0,
          newPageIndex: -1
        });
    }
  }
  endDragSession() {
    if (!o(this, xs))
      return !1;
    this.disableUserSelect(!1);
    const e = o(this, xs);
    E(this, xs, null);
    let t = !1;
    for (const [{
      x: i,
      y: r,
      pageIndex: n
    }, a] of e)
      a.newX = i, a.newY = r, a.newPageIndex = n, t || (t = i !== a.savedX || r !== a.savedY || n !== a.savedPageIndex);
    if (!t)
      return !1;
    const s = (i, r, n, a) => {
      if (o(this, ie).has(i.id)) {
        const h = o(this, me).get(a);
        h ? i._setParentAndPosition(h, r, n) : (i.pageIndex = a, i.x = r, i.y = n);
      }
    };
    return this.addCommands({
      cmd: () => {
        for (const [i, {
          newX: r,
          newY: n,
          newPageIndex: a
        }] of e)
          s(i, r, n, a);
      },
      undo: () => {
        for (const [i, {
          savedX: r,
          savedY: n,
          savedPageIndex: a
        }] of e)
          s(i, r, n, a);
      },
      mustExec: !0
    }), !0;
  }
  dragSelectedEditors(e, t) {
    if (o(this, xs))
      for (const s of o(this, xs).keys())
        s.drag(e, t);
  }
  rebuild(e) {
    if (e.parent === null) {
      const t = this.getLayer(e.pageIndex);
      t ? (t.changeParent(e), t.addOrRebuild(e)) : (this.addEditor(e), this.addToAnnotationStorage(e), e.rebuild());
    } else
      e.parent.addOrRebuild(e);
  }
  get isEditorHandlingKeyboard() {
    var e;
    return ((e = this.getActive()) == null ? void 0 : e.shouldGetKeyboardEvents()) || o(this, It).size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
  }
  isActive(e) {
    return o(this, He) === e;
  }
  getActive() {
    return o(this, He);
  }
  getMode() {
    return o(this, ce);
  }
  get imageManager() {
    return Mt(this, "imageManager", new Tf());
  }
  getSelectionBoxes(e) {
    if (!e)
      return null;
    const t = document.getSelection();
    for (let c = 0, d = t.rangeCount; c < d; c++)
      if (!e.contains(t.getRangeAt(c).commonAncestorContainer))
        return null;
    const {
      x: s,
      y: i,
      width: r,
      height: n
    } = e.getBoundingClientRect();
    let a;
    switch (e.getAttribute("data-main-rotation")) {
      case "90":
        a = (c, d, u, f) => ({
          x: (d - i) / n,
          y: 1 - (c + u - s) / r,
          width: f / n,
          height: u / r
        });
        break;
      case "180":
        a = (c, d, u, f) => ({
          x: 1 - (c + u - s) / r,
          y: 1 - (d + f - i) / n,
          width: u / r,
          height: f / n
        });
        break;
      case "270":
        a = (c, d, u, f) => ({
          x: 1 - (d + f - i) / n,
          y: (c - s) / r,
          width: f / n,
          height: u / r
        });
        break;
      default:
        a = (c, d, u, f) => ({
          x: (c - s) / r,
          y: (d - i) / n,
          width: u / r,
          height: f / n
        });
        break;
    }
    const h = [];
    for (let c = 0, d = t.rangeCount; c < d; c++) {
      const u = t.getRangeAt(c);
      if (!u.collapsed)
        for (const {
          x: f,
          y: p,
          width: m,
          height: g
        } of u.getClientRects())
          m === 0 || g === 0 || h.push(a(f, p, m, g));
    }
    return h.length === 0 ? null : h;
  }
  addChangedExistingAnnotation({
    annotationElementId: e,
    id: t
  }) {
    (o(this, la) || E(this, la, /* @__PURE__ */ new Map())).set(e, t);
  }
  removeChangedExistingAnnotation({
    annotationElementId: e
  }) {
    var t;
    (t = o(this, la)) == null || t.delete(e);
  }
  renderAnnotationElement(e) {
    var i;
    const t = (i = o(this, la)) == null ? void 0 : i.get(e.data.id);
    if (!t)
      return;
    const s = o(this, Qs).getRawValue(t);
    s && (o(this, ce) === _t.NONE && !s.hasBeenModified || s.renderAnnotationElement(e));
  }
};
aa = new WeakMap(), He = new WeakMap(), ie = new WeakMap(), me = new WeakMap(), oa = new WeakMap(), Qs = new WeakMap(), la = new WeakMap(), cs = new WeakMap(), Li = new WeakMap(), ha = new WeakMap(), Tr = new WeakMap(), xs = new WeakMap(), ds = new WeakMap(), Ir = new WeakMap(), hl = new WeakMap(), cl = new WeakMap(), ca = new WeakMap(), dl = new WeakMap(), Ss = new WeakMap(), Ri = new WeakMap(), da = new WeakMap(), Oi = new WeakMap(), ks = new WeakMap(), gd = new WeakMap(), Fi = new WeakMap(), ul = new WeakMap(), ji = new WeakMap(), Nr = new WeakMap(), fl = new WeakMap(), pl = new WeakMap(), ce = new WeakMap(), It = new WeakMap(), Ks = new WeakMap(), Dr = new WeakMap(), gl = new WeakMap(), ml = new WeakMap(), zi = new WeakMap(), Ms = new WeakMap(), Zs = new WeakMap(), bl = new WeakMap(), ts = new WeakMap(), ua = new WeakSet(), Sc = function({
  anchorNode: e
}) {
  return e.nodeType === Node.TEXT_NODE ? e.parentElement : e;
}, yl = new WeakSet(), Nf = function(e) {
  const {
    currentLayer: t
  } = this;
  if (t.hasTextLayer(e))
    return t;
  for (const s of o(this, me).values())
    if (s.hasTextLayer(e))
      return s;
  return null;
}, md = new WeakSet(), zm = function() {
  const e = document.getSelection();
  if (!e || e.isCollapsed)
    return;
  const s = x(this, ua, Sc).call(this, e).closest(".textLayer"), i = this.getSelectionBoxes(s);
  i && (o(this, ks) || E(this, ks, new xw(this)), o(this, ks).show(s, i, this.direction === "ltr"));
}, bd = new WeakSet(), Bm = function() {
  var r, n, a;
  const e = document.getSelection();
  if (!e || e.isCollapsed) {
    o(this, Ks) && ((r = o(this, ks)) == null || r.hide(), E(this, Ks, null), x(this, be, Ie).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  const {
    anchorNode: t
  } = e;
  if (t === o(this, Ks))
    return;
  const i = x(this, ua, Sc).call(this, e).closest(".textLayer");
  if (!i) {
    o(this, Ks) && ((n = o(this, ks)) == null || n.hide(), E(this, Ks, null), x(this, be, Ie).call(this, {
      hasSelectedText: !1
    }));
    return;
  }
  if ((a = o(this, ks)) == null || a.hide(), E(this, Ks, t), x(this, be, Ie).call(this, {
    hasSelectedText: !0
  }), !(o(this, ce) !== _t.HIGHLIGHT && o(this, ce) !== _t.NONE) && (o(this, ce) === _t.HIGHLIGHT && this.showAllEditors("highlight", !0, !0), E(this, Oi, this.isShiftKeyDown), !this.isShiftKeyDown)) {
    const h = o(this, ce) === _t.HIGHLIGHT ? x(this, yl, Nf).call(this, i) : null;
    h == null || h.toggleDrawing();
    const c = new AbortController(), d = this.combinedSignal(c), u = (f) => {
      f.type === "pointerup" && f.button !== 0 || (c.abort(), h == null || h.toggleDrawing(!0), f.type === "pointerup" && x(this, fa, kc).call(this, "main_toolbar"));
    };
    window.addEventListener("pointerup", u, {
      signal: d
    }), window.addEventListener("blur", u, {
      signal: d
    });
  }
}, fa = new WeakSet(), kc = function(e = "") {
  o(this, ce) === _t.HIGHLIGHT ? this.highlightSelection(e) : o(this, hl) && x(this, md, zm).call(this);
}, yd = new WeakSet(), Um = function() {
  document.addEventListener("selectionchange", x(this, bd, Bm).bind(this), {
    signal: this._signal
  });
}, vd = new WeakSet(), Hm = function() {
  if (o(this, Ri))
    return;
  E(this, Ri, new AbortController());
  const e = this.combinedSignal(o(this, Ri));
  window.addEventListener("focus", this.focus.bind(this), {
    signal: e
  }), window.addEventListener("blur", this.blur.bind(this), {
    signal: e
  });
}, wd = new WeakSet(), Wm = function() {
  var e;
  (e = o(this, Ri)) == null || e.abort(), E(this, Ri, null);
}, vl = new WeakSet(), Df = function() {
  if (o(this, ji))
    return;
  E(this, ji, new AbortController());
  const e = this.combinedSignal(o(this, ji));
  window.addEventListener("keydown", this.keydown.bind(this), {
    signal: e
  }), window.addEventListener("keyup", this.keyup.bind(this), {
    signal: e
  });
}, Ad = new WeakSet(), $m = function() {
  var e;
  (e = o(this, ji)) == null || e.abort(), E(this, ji, null);
}, wl = new WeakSet(), Pf = function() {
  if (o(this, Li))
    return;
  E(this, Li, new AbortController());
  const e = this.combinedSignal(o(this, Li));
  document.addEventListener("copy", this.copy.bind(this), {
    signal: e
  }), document.addEventListener("cut", this.cut.bind(this), {
    signal: e
  }), document.addEventListener("paste", this.paste.bind(this), {
    signal: e
  });
}, Al = new WeakSet(), Lf = function() {
  var e;
  (e = o(this, Li)) == null || e.abort(), E(this, Li, null);
}, _d = new WeakSet(), Gm = function() {
  const e = this._signal;
  document.addEventListener("dragover", this.dragOver.bind(this), {
    signal: e
  }), document.addEventListener("drop", this.drop.bind(this), {
    signal: e
  });
}, be = new WeakSet(), Ie = function(e) {
  Object.entries(e).some(([s, i]) => o(this, ml)[s] !== i) && (this._eventBus.dispatch("annotationeditorstateschanged", {
    source: this,
    details: Object.assign(o(this, ml), e)
  }), o(this, ce) === _t.HIGHLIGHT && e.hasSelectedEditor === !1 && x(this, Cs, Ci).call(this, [[wt.HIGHLIGHT_FREE, !0]]));
}, Cs = new WeakSet(), Ci = function(e) {
  this._eventBus.dispatch("annotationeditorparamschanged", {
    source: this,
    details: e
  });
}, Ed = new WeakSet(), Vm = async function() {
  if (!o(this, Fi)) {
    E(this, Fi, !0);
    const e = [];
    for (const t of o(this, me).values())
      e.push(t.enable());
    await Promise.all(e);
    for (const t of o(this, ie).values())
      t.enable();
  }
}, xd = new WeakSet(), Ym = function() {
  if (this.unselectAll(), o(this, Fi)) {
    E(this, Fi, !1);
    for (const e of o(this, me).values())
      e.disable();
    for (const e of o(this, ie).values())
      e.disable();
  }
}, _l = new WeakSet(), Rf = function(e) {
  const t = o(this, me).get(e.pageIndex);
  t ? t.addOrRebuild(e) : (this.addEditor(e), this.addToAnnotationStorage(e));
}, Sd = new WeakSet(), Xm = function() {
  let e = null;
  for (e of o(this, It))
    ;
  return e;
}, Pr = new WeakSet(), Oo = function() {
  if (o(this, ie).size === 0)
    return !0;
  if (o(this, ie).size === 1)
    for (const e of o(this, ie).values())
      return e.isEmpty();
  return !1;
}, El = new WeakSet(), Of = function(e) {
  for (const t of o(this, It))
    t.unselect();
  o(this, It).clear();
  for (const t of e)
    t.isEmpty() || (o(this, It).add(t), t.select());
  x(this, be, Ie).call(this, {
    hasSelectedEditor: this.hasSelection
  });
}, vt(Kn, "TRANSLATE_SMALL", 1), vt(Kn, "TRANSLATE_BIG", 10);
let On = Kn;
var de, Ts, us, pa, Is, We, ga, Ns, Oe, Js, Lr, Ds, Bi, Rr, Fo, ma, Mc;
const Ne = class Ne {
  constructor(e) {
    y(this, Rr);
    y(this, ma);
    y(this, de, null);
    y(this, Ts, !1);
    y(this, us, null);
    y(this, pa, null);
    y(this, Is, null);
    y(this, We, null);
    y(this, ga, !1);
    y(this, Ns, null);
    y(this, Oe, null);
    y(this, Js, null);
    y(this, Lr, null);
    y(this, Ds, !1);
    E(this, Oe, e), E(this, Ds, e._uiManager.useNewAltTextFlow), o(Ne, Bi) || E(Ne, Bi, Object.freeze({
      added: "pdfjs-editor-new-alt-text-added-button",
      "added-label": "pdfjs-editor-new-alt-text-added-button-label",
      missing: "pdfjs-editor-new-alt-text-missing-button",
      "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
      review: "pdfjs-editor-new-alt-text-to-review-button",
      "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
    }));
  }
  static initialize(e) {
    Ne._l10n ?? (Ne._l10n = e);
  }
  async render() {
    const e = E(this, us, document.createElement("button"));
    e.className = "altText", e.tabIndex = "0";
    const t = E(this, pa, document.createElement("span"));
    e.append(t), o(this, Ds) ? (e.classList.add("new"), e.setAttribute("data-l10n-id", o(Ne, Bi).missing), t.setAttribute("data-l10n-id", o(Ne, Bi)["missing-label"])) : (e.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button"), t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label"));
    const s = o(this, Oe)._uiManager._signal;
    e.addEventListener("contextmenu", as, {
      signal: s
    }), e.addEventListener("pointerdown", (r) => r.stopPropagation(), {
      signal: s
    });
    const i = (r) => {
      r.preventDefault(), o(this, Oe)._uiManager.editAltText(o(this, Oe)), o(this, Ds) && o(this, Oe)._reportTelemetry({
        action: "pdfjs.image.alt_text.image_status_label_clicked",
        data: {
          label: o(this, Rr, Fo)
        }
      });
    };
    return e.addEventListener("click", i, {
      capture: !0,
      signal: s
    }), e.addEventListener("keydown", (r) => {
      r.target === e && r.key === "Enter" && (E(this, ga, !0), i(r));
    }, {
      signal: s
    }), await x(this, ma, Mc).call(this), e;
  }
  finish() {
    o(this, us) && (o(this, us).focus({
      focusVisible: o(this, ga)
    }), E(this, ga, !1));
  }
  isEmpty() {
    return o(this, Ds) ? o(this, de) === null : !o(this, de) && !o(this, Ts);
  }
  hasData() {
    return o(this, Ds) ? o(this, de) !== null || !!o(this, Js) : this.isEmpty();
  }
  get guessedText() {
    return o(this, Js);
  }
  async setGuessedText(e) {
    o(this, de) === null && (E(this, Js, e), E(this, Lr, await Ne._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
      generatedAltText: e
    })), x(this, ma, Mc).call(this));
  }
  toggleAltTextBadge(e = !1) {
    var t;
    if (!o(this, Ds) || o(this, de)) {
      (t = o(this, Ns)) == null || t.remove(), E(this, Ns, null);
      return;
    }
    if (!o(this, Ns)) {
      const s = E(this, Ns, document.createElement("div"));
      s.className = "noAltTextBadge", o(this, Oe).div.append(s);
    }
    o(this, Ns).classList.toggle("hidden", !e);
  }
  serialize(e) {
    let t = o(this, de);
    return !e && o(this, Js) === t && (t = o(this, Lr)), {
      altText: t,
      decorative: o(this, Ts),
      guessedText: o(this, Js),
      textWithDisclaimer: o(this, Lr)
    };
  }
  get data() {
    return {
      altText: o(this, de),
      decorative: o(this, Ts)
    };
  }
  set data({
    altText: e,
    decorative: t,
    guessedText: s,
    textWithDisclaimer: i,
    cancel: r = !1
  }) {
    s && (E(this, Js, s), E(this, Lr, i)), !(o(this, de) === e && o(this, Ts) === t) && (r || (E(this, de, e), E(this, Ts, t)), x(this, ma, Mc).call(this));
  }
  toggle(e = !1) {
    o(this, us) && (!e && o(this, We) && (clearTimeout(o(this, We)), E(this, We, null)), o(this, us).disabled = !e);
  }
  shown() {
    o(this, Oe)._reportTelemetry({
      action: "pdfjs.image.alt_text.image_status_label_displayed",
      data: {
        label: o(this, Rr, Fo)
      }
    });
  }
  destroy() {
    var e, t;
    (e = o(this, us)) == null || e.remove(), E(this, us, null), E(this, pa, null), E(this, Is, null), (t = o(this, Ns)) == null || t.remove(), E(this, Ns, null);
  }
};
de = new WeakMap(), Ts = new WeakMap(), us = new WeakMap(), pa = new WeakMap(), Is = new WeakMap(), We = new WeakMap(), ga = new WeakMap(), Ns = new WeakMap(), Oe = new WeakMap(), Js = new WeakMap(), Lr = new WeakMap(), Ds = new WeakMap(), Bi = new WeakMap(), Rr = new WeakSet(), Fo = function() {
  return o(this, de) && "added" || o(this, de) === null && this.guessedText && "review" || "missing";
}, ma = new WeakSet(), Mc = async function() {
  var i, r, n;
  const e = o(this, us);
  if (!e)
    return;
  if (o(this, Ds)) {
    if (e.classList.toggle("done", !!o(this, de)), e.setAttribute("data-l10n-id", o(Ne, Bi)[o(this, Rr, Fo)]), (i = o(this, pa)) == null || i.setAttribute("data-l10n-id", o(Ne, Bi)[`${o(this, Rr, Fo)}-label`]), !o(this, de)) {
      (r = o(this, Is)) == null || r.remove();
      return;
    }
  } else {
    if (!o(this, de) && !o(this, Ts)) {
      e.classList.remove("done"), (n = o(this, Is)) == null || n.remove();
      return;
    }
    e.classList.add("done"), e.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
  }
  let t = o(this, Is);
  if (!t) {
    E(this, Is, t = document.createElement("span")), t.className = "tooltip", t.setAttribute("role", "tooltip"), t.id = `alt-text-tooltip-${o(this, Oe).id}`;
    const a = 100, h = o(this, Oe)._uiManager._signal;
    h.addEventListener("abort", () => {
      clearTimeout(o(this, We)), E(this, We, null);
    }, {
      once: !0
    }), e.addEventListener("mouseenter", () => {
      E(this, We, setTimeout(() => {
        E(this, We, null), o(this, Is).classList.add("show"), o(this, Oe)._reportTelemetry({
          action: "alt_text_tooltip"
        });
      }, a));
    }, {
      signal: h
    }), e.addEventListener("mouseleave", () => {
      var c;
      o(this, We) && (clearTimeout(o(this, We)), E(this, We, null)), (c = o(this, Is)) == null || c.classList.remove("show");
    }, {
      signal: h
    });
  }
  o(this, Ts) ? t.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip") : (t.removeAttribute("data-l10n-id"), t.textContent = o(this, de)), t.parentNode || e.append(t);
  const s = o(this, Oe).getImageForAltText();
  s == null || s.setAttribute("aria-describedby", t.id);
}, y(Ne, Bi, null), vt(Ne, "_l10n", null);
let ed = Ne;
var Or, fs, Wt, ba, Fr, ye, jr, Ui, xl, zr, Hi, Sl, Br, ti, Ps, ya, va, es, kl, kd, Ml, Ff, Cl, jf, Tl, zf, Md, qm, Cd, Qm, Il, Bf, Nl, Uf, Dl, Hf, Td, Km, Pl, Wf, Id, Zm, Nd, Jm, Dd, tb, Ll, $f, Ur, jo;
const Tt = class Tt {
  constructor(e) {
    y(this, Ml);
    y(this, Tl);
    y(this, Md);
    y(this, Cd);
    y(this, Il);
    y(this, Nl);
    y(this, Dl);
    y(this, Td);
    y(this, Pl);
    y(this, Id);
    y(this, Nd);
    y(this, Dd);
    y(this, Ll);
    y(this, Ur);
    y(this, Or, null);
    y(this, fs, null);
    y(this, Wt, null);
    y(this, ba, !1);
    y(this, Fr, !1);
    y(this, ye, null);
    y(this, jr, null);
    y(this, Ui, null);
    y(this, xl, "");
    y(this, zr, !1);
    y(this, Hi, null);
    y(this, Sl, !1);
    y(this, Br, !1);
    y(this, ti, !1);
    y(this, Ps, null);
    y(this, ya, 0);
    y(this, va, 0);
    y(this, es, null);
    vt(this, "_editToolbar", null);
    vt(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
    vt(this, "_initialData", null);
    vt(this, "_isVisible", !0);
    vt(this, "_uiManager", null);
    vt(this, "_focusEventsAllowed", !0);
    y(this, kl, !1);
    y(this, kd, Tt._zIndex++);
    this.parent = e.parent, this.id = e.id, this.width = this.height = null, this.pageIndex = e.parent.pageIndex, this.name = e.name, this.div = null, this._uiManager = e.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = e.isCentered, this._structTreeParentId = null;
    const {
      rotation: t,
      rawDims: {
        pageWidth: s,
        pageHeight: i,
        pageX: r,
        pageY: n
      }
    } = this.parent.viewport;
    this.rotation = t, this.pageRotation = (360 + t - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [s, i], this.pageTranslation = [r, n];
    const [a, h] = this.parentDimensions;
    this.x = e.x / a, this.y = e.y / h, this.isAttachedToDOM = !1, this.deleted = !1;
  }
  static get _resizerKeyboardManager() {
    const e = Tt.prototype._resizeWithKeyboard, t = On.TRANSLATE_SMALL, s = On.TRANSLATE_BIG;
    return Mt(this, "_resizerKeyboardManager", new lc([[["ArrowLeft", "mac+ArrowLeft"], e, {
      args: [-t, 0]
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], e, {
      args: [-s, 0]
    }], [["ArrowRight", "mac+ArrowRight"], e, {
      args: [t, 0]
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], e, {
      args: [s, 0]
    }], [["ArrowUp", "mac+ArrowUp"], e, {
      args: [0, -t]
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], e, {
      args: [0, -s]
    }], [["ArrowDown", "mac+ArrowDown"], e, {
      args: [0, t]
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], e, {
      args: [0, s]
    }], [["Escape", "mac+Escape"], Tt.prototype._stopResizingWithKeyboard]]));
  }
  get editorType() {
    return Object.getPrototypeOf(this).constructor._type;
  }
  static get _defaultLineColor() {
    return Mt(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }
  static deleteAnnotationElement(e) {
    const t = new Cw({
      id: e.parent.getNextId(),
      parent: e.parent,
      uiManager: e._uiManager
    });
    t.annotationElementId = e.annotationElementId, t.deleted = !0, t._uiManager.addToAnnotationStorage(t);
  }
  static initialize(e, t) {
    if (Tt._l10n ?? (Tt._l10n = e), Tt._l10nResizer || (Tt._l10nResizer = Object.freeze({
      topLeft: "pdfjs-editor-resizer-top-left",
      topMiddle: "pdfjs-editor-resizer-top-middle",
      topRight: "pdfjs-editor-resizer-top-right",
      middleRight: "pdfjs-editor-resizer-middle-right",
      bottomRight: "pdfjs-editor-resizer-bottom-right",
      bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
      bottomLeft: "pdfjs-editor-resizer-bottom-left",
      middleLeft: "pdfjs-editor-resizer-middle-left"
    })), Tt._borderLineWidth !== -1)
      return;
    const s = getComputedStyle(document.documentElement);
    Tt._borderLineWidth = parseFloat(s.getPropertyValue("--outline-width")) || 0;
  }
  static updateDefaultParams(e, t) {
  }
  static get defaultPropertiesToUpdate() {
    return [];
  }
  static isHandlingMimeForPasting(e) {
    return !1;
  }
  static paste(e, t) {
    Bt("Not implemented");
  }
  get propertiesToUpdate() {
    return [];
  }
  get _isDraggable() {
    return o(this, kl);
  }
  set _isDraggable(e) {
    var t;
    E(this, kl, e), (t = this.div) == null || t.classList.toggle("draggable", e);
  }
  get isEnterHandled() {
    return !0;
  }
  center() {
    const [e, t] = this.pageDimensions;
    switch (this.parentRotation) {
      case 90:
        this.x -= this.height * t / (e * 2), this.y += this.width * e / (t * 2);
        break;
      case 180:
        this.x += this.width / 2, this.y += this.height / 2;
        break;
      case 270:
        this.x += this.height * t / (e * 2), this.y -= this.width * e / (t * 2);
        break;
      default:
        this.x -= this.width / 2, this.y -= this.height / 2;
        break;
    }
    this.fixAndSetPosition();
  }
  addCommands(e) {
    this._uiManager.addCommands(e);
  }
  get currentLayer() {
    return this._uiManager.currentLayer;
  }
  setInBackground() {
    this.div.style.zIndex = 0;
  }
  setInForeground() {
    this.div.style.zIndex = o(this, kd);
  }
  setParent(e) {
    e !== null ? (this.pageIndex = e.pageIndex, this.pageDimensions = e.pageDimensions) : x(this, Ur, jo).call(this), this.parent = e;
  }
  focusin(e) {
    this._focusEventsAllowed && (o(this, zr) ? E(this, zr, !1) : this.parent.setSelected(this));
  }
  focusout(e) {
    var s;
    if (!this._focusEventsAllowed || !this.isAttachedToDOM)
      return;
    const t = e.relatedTarget;
    t != null && t.closest(`#${this.id}`) || (e.preventDefault(), (s = this.parent) != null && s.isMultipleSelection || this.commitOrRemove());
  }
  commitOrRemove() {
    this.isEmpty() ? this.remove() : this.commit();
  }
  commit() {
    this.addToAnnotationStorage();
  }
  addToAnnotationStorage() {
    this._uiManager.addToAnnotationStorage(this);
  }
  setAt(e, t, s, i) {
    const [r, n] = this.parentDimensions;
    [s, i] = this.screenToPageTranslation(s, i), this.x = (e + s) / r, this.y = (t + i) / n, this.fixAndSetPosition();
  }
  translate(e, t) {
    x(this, Ml, Ff).call(this, this.parentDimensions, e, t);
  }
  translateInPage(e, t) {
    o(this, Hi) || E(this, Hi, [this.x, this.y]), x(this, Ml, Ff).call(this, this.pageDimensions, e, t), this.div.scrollIntoView({
      block: "nearest"
    });
  }
  drag(e, t) {
    o(this, Hi) || E(this, Hi, [this.x, this.y]);
    const [s, i] = this.parentDimensions;
    if (this.x += e / s, this.y += t / i, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
      const {
        x: c,
        y: d
      } = this.div.getBoundingClientRect();
      this.parent.findNewParent(this, c, d) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
    }
    let {
      x: r,
      y: n
    } = this;
    const [a, h] = this.getBaseTranslation();
    r += a, n += h, this.div.style.left = `${(100 * r).toFixed(2)}%`, this.div.style.top = `${(100 * n).toFixed(2)}%`, this.div.scrollIntoView({
      block: "nearest"
    });
  }
  get _hasBeenMoved() {
    return !!o(this, Hi) && (o(this, Hi)[0] !== this.x || o(this, Hi)[1] !== this.y);
  }
  getBaseTranslation() {
    const [e, t] = this.parentDimensions, {
      _borderLineWidth: s
    } = Tt, i = s / e, r = s / t;
    switch (this.rotation) {
      case 90:
        return [-i, r];
      case 180:
        return [i, r];
      case 270:
        return [i, -r];
      default:
        return [-i, -r];
    }
  }
  get _mustFixPosition() {
    return !0;
  }
  fixAndSetPosition(e = this.rotation) {
    const [t, s] = this.pageDimensions;
    let {
      x: i,
      y: r,
      width: n,
      height: a
    } = this;
    if (n *= t, a *= s, i *= t, r *= s, this._mustFixPosition)
      switch (e) {
        case 0:
          i = Math.max(0, Math.min(t - n, i)), r = Math.max(0, Math.min(s - a, r));
          break;
        case 90:
          i = Math.max(0, Math.min(t - a, i)), r = Math.min(s, Math.max(n, r));
          break;
        case 180:
          i = Math.min(t, Math.max(n, i)), r = Math.min(s, Math.max(a, r));
          break;
        case 270:
          i = Math.min(t, Math.max(a, i)), r = Math.max(0, Math.min(s - n, r));
          break;
      }
    this.x = i /= t, this.y = r /= s;
    const [h, c] = this.getBaseTranslation();
    i += h, r += c;
    const {
      style: d
    } = this.div;
    d.left = `${(100 * i).toFixed(2)}%`, d.top = `${(100 * r).toFixed(2)}%`, this.moveInDOM();
  }
  screenToPageTranslation(e, t) {
    var s;
    return x(s = Tt, Cl, jf).call(s, e, t, this.parentRotation);
  }
  pageTranslationToScreen(e, t) {
    var s;
    return x(s = Tt, Cl, jf).call(s, e, t, 360 - this.parentRotation);
  }
  get parentScale() {
    return this._uiManager.viewParameters.realScale;
  }
  get parentRotation() {
    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
  }
  get parentDimensions() {
    const {
      parentScale: e,
      pageDimensions: [t, s]
    } = this;
    return [t * e, s * e];
  }
  setDims(e, t) {
    const [s, i] = this.parentDimensions;
    this.div.style.width = `${(100 * e / s).toFixed(2)}%`, o(this, Fr) || (this.div.style.height = `${(100 * t / i).toFixed(2)}%`);
  }
  fixDims() {
    const {
      style: e
    } = this.div, {
      height: t,
      width: s
    } = e, i = s.endsWith("%"), r = !o(this, Fr) && t.endsWith("%");
    if (i && r)
      return;
    const [n, a] = this.parentDimensions;
    i || (e.width = `${(100 * parseFloat(s) / n).toFixed(2)}%`), !o(this, Fr) && !r && (e.height = `${(100 * parseFloat(t) / a).toFixed(2)}%`);
  }
  getInitialTranslation() {
    return [0, 0];
  }
  altTextFinish() {
    var e;
    (e = o(this, Wt)) == null || e.finish();
  }
  async addEditToolbar() {
    return this._editToolbar || o(this, Br) ? this._editToolbar : (this._editToolbar = new Mf(this), this.div.append(this._editToolbar.render()), o(this, Wt) && await this._editToolbar.addAltText(o(this, Wt)), this._editToolbar);
  }
  removeEditToolbar() {
    var e;
    this._editToolbar && (this._editToolbar.remove(), this._editToolbar = null, (e = o(this, Wt)) == null || e.destroy());
  }
  addContainer(e) {
    var s;
    const t = (s = this._editToolbar) == null ? void 0 : s.div;
    t ? t.before(e) : this.div.append(e);
  }
  getClientDimensions() {
    return this.div.getBoundingClientRect();
  }
  async addAltTextButton() {
    o(this, Wt) || (ed.initialize(Tt._l10n), E(this, Wt, new ed(this)), o(this, Or) && (o(this, Wt).data = o(this, Or), E(this, Or, null)), await this.addEditToolbar());
  }
  get altTextData() {
    var e;
    return (e = o(this, Wt)) == null ? void 0 : e.data;
  }
  set altTextData(e) {
    o(this, Wt) && (o(this, Wt).data = e);
  }
  get guessedAltText() {
    var e;
    return (e = o(this, Wt)) == null ? void 0 : e.guessedText;
  }
  async setGuessedAltText(e) {
    var t;
    await ((t = o(this, Wt)) == null ? void 0 : t.setGuessedText(e));
  }
  serializeAltText(e) {
    var t;
    return (t = o(this, Wt)) == null ? void 0 : t.serialize(e);
  }
  hasAltText() {
    return !!o(this, Wt) && !o(this, Wt).isEmpty();
  }
  hasAltTextData() {
    var e;
    return ((e = o(this, Wt)) == null ? void 0 : e.hasData()) ?? !1;
  }
  render() {
    this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.tabIndex = o(this, ba) ? -1 : 0, this._isVisible || this.div.classList.add("hidden"), this.setInForeground(), x(this, Pl, Wf).call(this);
    const [e, t] = this.parentDimensions;
    this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * t / e).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * e / t).toFixed(2)}%`);
    const [s, i] = this.getInitialTranslation();
    return this.translate(s, i), td(this, this.div, ["pointerdown"]), this.div;
  }
  pointerdown(e) {
    const {
      isMac: t
    } = Pe.platform;
    if (e.button !== 0 || e.ctrlKey && t) {
      e.preventDefault();
      return;
    }
    if (E(this, zr, !0), this._isDraggable) {
      x(this, Td, Km).call(this, e);
      return;
    }
    x(this, Dl, Hf).call(this, e);
  }
  get isSelected() {
    return this._uiManager.isSelected(this);
  }
  moveInDOM() {
    o(this, Ps) && clearTimeout(o(this, Ps)), E(this, Ps, setTimeout(() => {
      var e;
      E(this, Ps, null), (e = this.parent) == null || e.moveEditorInDOM(this);
    }, 0));
  }
  _setParentAndPosition(e, t, s) {
    e.changeParent(this), this.x = t, this.y = s, this.fixAndSetPosition();
  }
  getRect(e, t, s = this.rotation) {
    const i = this.parentScale, [r, n] = this.pageDimensions, [a, h] = this.pageTranslation, c = e / i, d = t / i, u = this.x * r, f = this.y * n, p = this.width * r, m = this.height * n;
    switch (s) {
      case 0:
        return [u + c + a, n - f - d - m + h, u + c + p + a, n - f - d + h];
      case 90:
        return [u + d + a, n - f + c + h, u + d + m + a, n - f + c + p + h];
      case 180:
        return [u - c - p + a, n - f + d + h, u - c + a, n - f + d + m + h];
      case 270:
        return [u - d - m + a, n - f - c - p + h, u - d + a, n - f - c + h];
      default:
        throw new Error("Invalid rotation");
    }
  }
  getRectInCurrentCoords(e, t) {
    const [s, i, r, n] = e, a = r - s, h = n - i;
    switch (this.rotation) {
      case 0:
        return [s, t - n, a, h];
      case 90:
        return [s, t - i, h, a];
      case 180:
        return [r, t - i, a, h];
      case 270:
        return [r, t - n, h, a];
      default:
        throw new Error("Invalid rotation");
    }
  }
  onceAdded() {
  }
  isEmpty() {
    return !1;
  }
  enableEditMode() {
    E(this, Br, !0);
  }
  disableEditMode() {
    E(this, Br, !1);
  }
  isInEditMode() {
    return o(this, Br);
  }
  shouldGetKeyboardEvents() {
    return o(this, ti);
  }
  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }
  rebuild() {
    x(this, Pl, Wf).call(this);
  }
  rotate(e) {
  }
  serializeDeleted() {
    var e;
    return {
      id: this.annotationElementId,
      deleted: !0,
      pageIndex: this.pageIndex,
      popupRef: ((e = this._initialData) == null ? void 0 : e.popupRef) || ""
    };
  }
  serialize(e = !1, t = null) {
    Bt("An editor must be serializable");
  }
  static async deserialize(e, t, s) {
    const i = new this.prototype.constructor({
      parent: t,
      id: t.getNextId(),
      uiManager: s
    });
    i.rotation = e.rotation, E(i, Or, e.accessibilityData);
    const [r, n] = i.pageDimensions, [a, h, c, d] = i.getRectInCurrentCoords(e.rect, n);
    return i.x = a / r, i.y = h / n, i.width = c / r, i.height = d / n, i;
  }
  get hasBeenModified() {
    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
  }
  remove() {
    var e;
    if ((e = o(this, Ui)) == null || e.abort(), E(this, Ui, null), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), o(this, Ps) && (clearTimeout(o(this, Ps)), E(this, Ps, null)), x(this, Ur, jo).call(this), this.removeEditToolbar(), o(this, es)) {
      for (const t of o(this, es).values())
        clearTimeout(t);
      E(this, es, null);
    }
    this.parent = null;
  }
  get isResizable() {
    return !1;
  }
  makeResizable() {
    this.isResizable && (x(this, Md, qm).call(this), o(this, ye).classList.remove("hidden"), td(this, this.div, ["keydown"]));
  }
  get toolbarPosition() {
    return null;
  }
  keydown(e) {
    if (!this.isResizable || e.target !== this.div || e.key !== "Enter")
      return;
    this._uiManager.setSelected(this), E(this, jr, {
      savedX: this.x,
      savedY: this.y,
      savedWidth: this.width,
      savedHeight: this.height
    });
    const t = o(this, ye).children;
    if (!o(this, fs)) {
      E(this, fs, Array.from(t));
      const n = x(this, Id, Zm).bind(this), a = x(this, Nd, Jm).bind(this), h = this._uiManager._signal;
      for (const c of o(this, fs)) {
        const d = c.getAttribute("data-resizer-name");
        c.setAttribute("role", "spinbutton"), c.addEventListener("keydown", n, {
          signal: h
        }), c.addEventListener("blur", a, {
          signal: h
        }), c.addEventListener("focus", x(this, Dd, tb).bind(this, d), {
          signal: h
        }), c.setAttribute("data-l10n-id", Tt._l10nResizer[d]);
      }
    }
    const s = o(this, fs)[0];
    let i = 0;
    for (const n of t) {
      if (n === s)
        break;
      i++;
    }
    const r = (360 - this.rotation + this.parentRotation) % 360 / 90 * (o(this, fs).length / 4);
    if (r !== i) {
      if (r < i)
        for (let a = 0; a < i - r; a++)
          o(this, ye).append(o(this, ye).firstChild);
      else if (r > i)
        for (let a = 0; a < r - i; a++)
          o(this, ye).firstChild.before(o(this, ye).lastChild);
      let n = 0;
      for (const a of t) {
        const c = o(this, fs)[n++].getAttribute("data-resizer-name");
        a.setAttribute("data-l10n-id", Tt._l10nResizer[c]);
      }
    }
    x(this, Ll, $f).call(this, 0), E(this, ti, !0), o(this, ye).firstChild.focus({
      focusVisible: !0
    }), e.preventDefault(), e.stopImmediatePropagation();
  }
  _resizeWithKeyboard(e, t) {
    o(this, ti) && x(this, Nl, Uf).call(this, o(this, xl), {
      movementX: e,
      movementY: t
    });
  }
  _stopResizingWithKeyboard() {
    x(this, Ur, jo).call(this), this.div.focus();
  }
  select() {
    var e, t, s;
    if (this.makeResizable(), (e = this.div) == null || e.classList.add("selectedEditor"), !this._editToolbar) {
      this.addEditToolbar().then(() => {
        var i, r;
        (i = this.div) != null && i.classList.contains("selectedEditor") && ((r = this._editToolbar) == null || r.show());
      });
      return;
    }
    (t = this._editToolbar) == null || t.show(), (s = o(this, Wt)) == null || s.toggleAltTextBadge(!1);
  }
  unselect() {
    var e, t, s, i, r;
    (e = o(this, ye)) == null || e.classList.add("hidden"), (t = this.div) == null || t.classList.remove("selectedEditor"), (s = this.div) != null && s.contains(document.activeElement) && this._uiManager.currentLayer.div.focus({
      preventScroll: !0
    }), (i = this._editToolbar) == null || i.hide(), (r = o(this, Wt)) == null || r.toggleAltTextBadge(!0);
  }
  updateParams(e, t) {
  }
  disableEditing() {
  }
  enableEditing() {
  }
  enterInEditMode() {
  }
  getImageForAltText() {
    return null;
  }
  get contentDiv() {
    return this.div;
  }
  get isEditing() {
    return o(this, Sl);
  }
  set isEditing(e) {
    E(this, Sl, e), this.parent && (e ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
  }
  setAspectRatio(e, t) {
    E(this, Fr, !0);
    const s = e / t, {
      style: i
    } = this.div;
    i.aspectRatio = s, i.height = "auto";
  }
  static get MIN_SIZE() {
    return 16;
  }
  static canCreateNewEmptyEditor() {
    return !0;
  }
  get telemetryInitialData() {
    return {
      action: "added"
    };
  }
  get telemetryFinalData() {
    return null;
  }
  _reportTelemetry(e, t = !1) {
    if (t) {
      o(this, es) || E(this, es, /* @__PURE__ */ new Map());
      const {
        action: s
      } = e;
      let i = o(this, es).get(s);
      i && clearTimeout(i), i = setTimeout(() => {
        this._reportTelemetry(e), o(this, es).delete(s), o(this, es).size === 0 && E(this, es, null);
      }, Tt._telemetryTimeout), o(this, es).set(s, i);
      return;
    }
    e.type || (e.type = this.editorType), this._uiManager._eventBus.dispatch("reporttelemetry", {
      source: this,
      details: {
        type: "editing",
        data: e
      }
    });
  }
  show(e = this._isVisible) {
    this.div.classList.toggle("hidden", !e), this._isVisible = e;
  }
  enable() {
    this.div && (this.div.tabIndex = 0), E(this, ba, !1);
  }
  disable() {
    this.div && (this.div.tabIndex = -1), E(this, ba, !0);
  }
  renderAnnotationElement(e) {
    let t = e.container.querySelector(".annotationContent");
    if (!t)
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), e.container.prepend(t);
    else if (t.nodeName === "CANVAS") {
      const s = t;
      t = document.createElement("div"), t.classList.add("annotationContent", this.editorType), s.before(t);
    }
    return t;
  }
  resetAnnotationElement(e) {
    const {
      firstChild: t
    } = e.container;
    (t == null ? void 0 : t.nodeName) === "DIV" && t.classList.contains("annotationContent") && t.remove();
  }
};
Or = new WeakMap(), fs = new WeakMap(), Wt = new WeakMap(), ba = new WeakMap(), Fr = new WeakMap(), ye = new WeakMap(), jr = new WeakMap(), Ui = new WeakMap(), xl = new WeakMap(), zr = new WeakMap(), Hi = new WeakMap(), Sl = new WeakMap(), Br = new WeakMap(), ti = new WeakMap(), Ps = new WeakMap(), ya = new WeakMap(), va = new WeakMap(), es = new WeakMap(), kl = new WeakMap(), kd = new WeakMap(), Ml = new WeakSet(), Ff = function([e, t], s, i) {
  [s, i] = this.screenToPageTranslation(s, i), this.x += s / e, this.y += i / t, this.fixAndSetPosition();
}, Cl = new WeakSet(), jf = function(e, t, s) {
  switch (s) {
    case 90:
      return [t, -e];
    case 180:
      return [-e, -t];
    case 270:
      return [-t, e];
    default:
      return [e, t];
  }
}, Tl = new WeakSet(), zf = function(e) {
  switch (e) {
    case 90: {
      const [t, s] = this.pageDimensions;
      return [0, -t / s, s / t, 0];
    }
    case 180:
      return [-1, 0, 0, -1];
    case 270: {
      const [t, s] = this.pageDimensions;
      return [0, t / s, -s / t, 0];
    }
    default:
      return [1, 0, 0, 1];
  }
}, Md = new WeakSet(), qm = function() {
  if (o(this, ye))
    return;
  E(this, ye, document.createElement("div")), o(this, ye).classList.add("resizers");
  const e = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"], t = this._uiManager._signal;
  for (const s of e) {
    const i = document.createElement("div");
    o(this, ye).append(i), i.classList.add("resizer", s), i.setAttribute("data-resizer-name", s), i.addEventListener("pointerdown", x(this, Cd, Qm).bind(this, s), {
      signal: t
    }), i.addEventListener("contextmenu", as, {
      signal: t
    }), i.tabIndex = -1;
  }
  this.div.prepend(o(this, ye));
}, Cd = new WeakSet(), Qm = function(e, t) {
  var m;
  t.preventDefault();
  const {
    isMac: s
  } = Pe.platform;
  if (t.button !== 0 || t.ctrlKey && s)
    return;
  (m = o(this, Wt)) == null || m.toggle(!1);
  const i = this._isDraggable;
  this._isDraggable = !1;
  const r = new AbortController(), n = this._uiManager.combinedSignal(r);
  this.parent.togglePointerEvents(!1), window.addEventListener("pointermove", x(this, Nl, Uf).bind(this, e), {
    passive: !0,
    capture: !0,
    signal: n
  }), window.addEventListener("contextmenu", as, {
    signal: n
  });
  const a = this.x, h = this.y, c = this.width, d = this.height, u = this.parent.div.style.cursor, f = this.div.style.cursor;
  this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(t.target).cursor;
  const p = () => {
    var g;
    r.abort(), this.parent.togglePointerEvents(!0), (g = o(this, Wt)) == null || g.toggle(!0), this._isDraggable = i, this.parent.div.style.cursor = u, this.div.style.cursor = f, x(this, Il, Bf).call(this, a, h, c, d);
  };
  window.addEventListener("pointerup", p, {
    signal: n
  }), window.addEventListener("blur", p, {
    signal: n
  });
}, Il = new WeakSet(), Bf = function(e, t, s, i) {
  const r = this.x, n = this.y, a = this.width, h = this.height;
  r === e && n === t && a === s && h === i || this.addCommands({
    cmd: () => {
      this.width = a, this.height = h, this.x = r, this.y = n;
      const [c, d] = this.parentDimensions;
      this.setDims(c * a, d * h), this.fixAndSetPosition();
    },
    undo: () => {
      this.width = s, this.height = i, this.x = e, this.y = t;
      const [c, d] = this.parentDimensions;
      this.setDims(c * s, d * i), this.fixAndSetPosition();
    },
    mustExec: !0
  });
}, Nl = new WeakSet(), Uf = function(e, t) {
  const [s, i] = this.parentDimensions, r = this.x, n = this.y, a = this.width, h = this.height, c = Tt.MIN_SIZE / s, d = Tt.MIN_SIZE / i, u = (z) => Math.round(z * 1e4) / 1e4, f = x(this, Tl, zf).call(this, this.rotation), p = (z, K) => [f[0] * z + f[2] * K, f[1] * z + f[3] * K], m = x(this, Tl, zf).call(this, 360 - this.rotation), g = (z, K) => [m[0] * z + m[2] * K, m[1] * z + m[3] * K];
  let w, b, _ = !1, k = !1;
  switch (e) {
    case "topLeft":
      _ = !0, w = (z, K) => [0, 0], b = (z, K) => [z, K];
      break;
    case "topMiddle":
      w = (z, K) => [z / 2, 0], b = (z, K) => [z / 2, K];
      break;
    case "topRight":
      _ = !0, w = (z, K) => [z, 0], b = (z, K) => [0, K];
      break;
    case "middleRight":
      k = !0, w = (z, K) => [z, K / 2], b = (z, K) => [0, K / 2];
      break;
    case "bottomRight":
      _ = !0, w = (z, K) => [z, K], b = (z, K) => [0, 0];
      break;
    case "bottomMiddle":
      w = (z, K) => [z / 2, K], b = (z, K) => [z / 2, 0];
      break;
    case "bottomLeft":
      _ = !0, w = (z, K) => [0, K], b = (z, K) => [z, 0];
      break;
    case "middleLeft":
      k = !0, w = (z, K) => [0, K / 2], b = (z, K) => [z, K / 2];
      break;
  }
  const C = w(a, h), N = b(a, h);
  let R = p(...N);
  const P = u(r + R[0]), M = u(n + R[1]);
  let S = 1, L = 1, [H, I] = this.screenToPageTranslation(t.movementX, t.movementY);
  if ([H, I] = g(H / s, I / i), _) {
    const z = Math.hypot(a, h);
    S = L = Math.max(Math.min(Math.hypot(N[0] - C[0] - H, N[1] - C[1] - I) / z, 1 / a, 1 / h), c / a, d / h);
  } else
    k ? S = Math.max(c, Math.min(1, Math.abs(N[0] - C[0] - H))) / a : L = Math.max(d, Math.min(1, Math.abs(N[1] - C[1] - I))) / h;
  const F = u(a * S), A = u(h * L);
  R = p(...b(F, A));
  const G = P - R[0], et = M - R[1];
  this.width = F, this.height = A, this.x = G, this.y = et, this.setDims(s * F, i * A), this.fixAndSetPosition();
}, Dl = new WeakSet(), Hf = function(e) {
  const {
    isMac: t
  } = Pe.platform;
  e.ctrlKey && !t || e.shiftKey || e.metaKey && t ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
}, Td = new WeakSet(), Km = function(e) {
  const {
    isSelected: t
  } = this;
  this._uiManager.setUpDragSession();
  const s = new AbortController(), i = this._uiManager.combinedSignal(s);
  if (t) {
    this.div.classList.add("moving"), E(this, ya, e.clientX), E(this, va, e.clientY);
    const n = (a) => {
      const {
        clientX: h,
        clientY: c
      } = a, [d, u] = this.screenToPageTranslation(h - o(this, ya), c - o(this, va));
      E(this, ya, h), E(this, va, c), this._uiManager.dragSelectedEditors(d, u);
    };
    window.addEventListener("pointermove", n, {
      passive: !0,
      capture: !0,
      signal: i
    });
  }
  const r = () => {
    s.abort(), t && this.div.classList.remove("moving"), E(this, zr, !1), this._uiManager.endDragSession() || x(this, Dl, Hf).call(this, e);
  };
  window.addEventListener("pointerup", r, {
    signal: i
  }), window.addEventListener("blur", r, {
    signal: i
  });
}, Pl = new WeakSet(), Wf = function() {
  if (o(this, Ui) || !this.div)
    return;
  E(this, Ui, new AbortController());
  const e = this._uiManager.combinedSignal(o(this, Ui));
  this.div.addEventListener("focusin", this.focusin.bind(this), {
    signal: e
  }), this.div.addEventListener("focusout", this.focusout.bind(this), {
    signal: e
  });
}, Id = new WeakSet(), Zm = function(e) {
  Tt._resizerKeyboardManager.exec(this, e);
}, Nd = new WeakSet(), Jm = function(e) {
  var t;
  o(this, ti) && ((t = e.relatedTarget) == null ? void 0 : t.parentNode) !== o(this, ye) && x(this, Ur, jo).call(this);
}, Dd = new WeakSet(), tb = function(e) {
  E(this, xl, o(this, ti) ? e : "");
}, Ll = new WeakSet(), $f = function(e) {
  if (o(this, fs))
    for (const t of o(this, fs))
      t.tabIndex = e;
}, Ur = new WeakSet(), jo = function() {
  if (E(this, ti, !1), x(this, Ll, $f).call(this, -1), o(this, jr)) {
    const {
      savedX: e,
      savedY: t,
      savedWidth: s,
      savedHeight: i
    } = o(this, jr);
    x(this, Il, Bf).call(this, e, t, s, i), E(this, jr, null);
  }
}, y(Tt, Cl), vt(Tt, "_l10n", null), vt(Tt, "_l10nResizer", null), vt(Tt, "_borderLineWidth", -1), vt(Tt, "_colorManager", new If()), vt(Tt, "_zIndex", 1), vt(Tt, "_telemetryTimeout", 1e3);
let Dt = Tt;
class Cw extends Dt {
  constructor(e) {
    super(e), this.annotationElementId = e.annotationElementId, this.deleted = !0;
  }
  serialize() {
    return this.serializeDeleted();
  }
}
const Ng = 3285377520, Je = 4294901760, Es = 65535;
class eb {
  constructor(e) {
    this.h1 = e ? e & 4294967295 : Ng, this.h2 = e ? e & 4294967295 : Ng;
  }
  update(e) {
    let t, s;
    if (typeof e == "string") {
      t = new Uint8Array(e.length * 2), s = 0;
      for (let g = 0, w = e.length; g < w; g++) {
        const b = e.charCodeAt(g);
        b <= 255 ? t[s++] = b : (t[s++] = b >>> 8, t[s++] = b & 255);
      }
    } else if (ArrayBuffer.isView(e))
      t = e.slice(), s = t.byteLength;
    else
      throw new Error("Invalid data format, must be a string or TypedArray.");
    const i = s >> 2, r = s - i * 4, n = new Uint32Array(t.buffer, 0, i);
    let a = 0, h = 0, c = this.h1, d = this.h2;
    const u = 3432918353, f = 461845907, p = u & Es, m = f & Es;
    for (let g = 0; g < i; g++)
      g & 1 ? (a = n[g], a = a * u & Je | a * p & Es, a = a << 15 | a >>> 17, a = a * f & Je | a * m & Es, c ^= a, c = c << 13 | c >>> 19, c = c * 5 + 3864292196) : (h = n[g], h = h * u & Je | h * p & Es, h = h << 15 | h >>> 17, h = h * f & Je | h * m & Es, d ^= h, d = d << 13 | d >>> 19, d = d * 5 + 3864292196);
    switch (a = 0, r) {
      case 3:
        a ^= t[i * 4 + 2] << 16;
      case 2:
        a ^= t[i * 4 + 1] << 8;
      case 1:
        a ^= t[i * 4], a = a * u & Je | a * p & Es, a = a << 15 | a >>> 17, a = a * f & Je | a * m & Es, i & 1 ? c ^= a : d ^= a;
    }
    this.h1 = c, this.h2 = d;
  }
  hexdigest() {
    let e = this.h1, t = this.h2;
    return e ^= t >>> 1, e = e * 3981806797 & Je | e * 36045 & Es, t = t * 4283543511 & Je | ((t << 16 | e >>> 16) * 2950163797 & Je) >>> 16, e ^= t >>> 1, e = e * 444984403 & Je | e * 60499 & Es, t = t * 3301882366 & Je | ((t << 16 | e >>> 16) * 3120437893 & Je) >>> 16, e ^= t >>> 1, (e >>> 0).toString(16).padStart(8, "0") + (t >>> 0).toString(16).padStart(8, "0");
  }
}
const Gf = Object.freeze({
  map: null,
  hash: "",
  transfer: void 0
});
var Hr, Wr, ue, Pd, sb;
class tg {
  constructor() {
    y(this, Pd);
    y(this, Hr, !1);
    y(this, Wr, null);
    y(this, ue, /* @__PURE__ */ new Map());
    this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
  }
  getValue(e, t) {
    const s = o(this, ue).get(e);
    return s === void 0 ? t : Object.assign(t, s);
  }
  getRawValue(e) {
    return o(this, ue).get(e);
  }
  remove(e) {
    if (o(this, ue).delete(e), o(this, ue).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
      for (const t of o(this, ue).values())
        if (t instanceof Dt)
          return;
      this.onAnnotationEditor(null);
    }
  }
  setValue(e, t) {
    const s = o(this, ue).get(e);
    let i = !1;
    if (s !== void 0)
      for (const [r, n] of Object.entries(t))
        s[r] !== n && (i = !0, s[r] = n);
    else
      i = !0, o(this, ue).set(e, t);
    i && x(this, Pd, sb).call(this), t instanceof Dt && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(t.constructor._type);
  }
  has(e) {
    return o(this, ue).has(e);
  }
  getAll() {
    return o(this, ue).size > 0 ? Xp(o(this, ue)) : null;
  }
  setAll(e) {
    for (const [t, s] of Object.entries(e))
      this.setValue(t, s);
  }
  get size() {
    return o(this, ue).size;
  }
  resetModified() {
    o(this, Hr) && (E(this, Hr, !1), typeof this.onResetModified == "function" && this.onResetModified());
  }
  get print() {
    return new ib(this);
  }
  get serializable() {
    if (o(this, ue).size === 0)
      return Gf;
    const e = /* @__PURE__ */ new Map(), t = new eb(), s = [], i = /* @__PURE__ */ Object.create(null);
    let r = !1;
    for (const [n, a] of o(this, ue)) {
      const h = a instanceof Dt ? a.serialize(!1, i) : a;
      h && (e.set(n, h), t.update(`${n}:${JSON.stringify(h)}`), r || (r = !!h.bitmap));
    }
    if (r)
      for (const n of e.values())
        n.bitmap && s.push(n.bitmap);
    return e.size > 0 ? {
      map: e,
      hash: t.hexdigest(),
      transfer: s
    } : Gf;
  }
  get editorStats() {
    let e = null;
    const t = /* @__PURE__ */ new Map();
    for (const s of o(this, ue).values()) {
      if (!(s instanceof Dt))
        continue;
      const i = s.telemetryFinalData;
      if (!i)
        continue;
      const {
        type: r
      } = i;
      t.has(r) || t.set(r, Object.getPrototypeOf(s).constructor), e || (e = /* @__PURE__ */ Object.create(null));
      const n = e[r] || (e[r] = /* @__PURE__ */ new Map());
      for (const [a, h] of Object.entries(i)) {
        if (a === "type")
          continue;
        let c = n.get(a);
        c || (c = /* @__PURE__ */ new Map(), n.set(a, c));
        const d = c.get(h) ?? 0;
        c.set(h, d + 1);
      }
    }
    for (const [s, i] of t)
      e[s] = i.computeTelemetryFinalData(e[s]);
    return e;
  }
  resetModifiedIds() {
    E(this, Wr, null);
  }
  get modifiedIds() {
    if (o(this, Wr))
      return o(this, Wr);
    const e = [];
    for (const t of o(this, ue).values())
      !(t instanceof Dt) || !t.annotationElementId || !t.serialize() || e.push(t.annotationElementId);
    return E(this, Wr, {
      ids: new Set(e),
      hash: e.join(",")
    });
  }
}
Hr = new WeakMap(), Wr = new WeakMap(), ue = new WeakMap(), Pd = new WeakSet(), sb = function() {
  o(this, Hr) || (E(this, Hr, !0), typeof this.onSetModified == "function" && this.onSetModified());
};
var Rl;
class ib extends tg {
  constructor(t) {
    super();
    y(this, Rl, void 0);
    const {
      map: s,
      hash: i,
      transfer: r
    } = t.serializable, n = structuredClone(s, r ? {
      transfer: r
    } : null);
    E(this, Rl, {
      map: n,
      hash: i,
      transfer: r
    });
  }
  get print() {
    Bt("Should not call PrintAnnotationStorage.print");
  }
  get serializable() {
    return o(this, Rl);
  }
  get modifiedIds() {
    return Mt(this, "modifiedIds", {
      ids: /* @__PURE__ */ new Set(),
      hash: ""
    });
  }
}
Rl = new WeakMap();
var wa;
class Tw {
  constructor({
    ownerDocument: e = globalThis.document,
    styleElement: t = null
  }) {
    y(this, wa, /* @__PURE__ */ new Set());
    this._document = e, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
  }
  addNativeFontFace(e) {
    this.nativeFontFaces.add(e), this._document.fonts.add(e);
  }
  removeNativeFontFace(e) {
    this.nativeFontFaces.delete(e), this._document.fonts.delete(e);
  }
  insertRule(e) {
    this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
    const t = this.styleElement.sheet;
    t.insertRule(e, t.cssRules.length);
  }
  clear() {
    for (const e of this.nativeFontFaces)
      this._document.fonts.delete(e);
    this.nativeFontFaces.clear(), o(this, wa).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
  }
  async loadSystemFont({
    systemFontInfo: e,
    _inspectFont: t
  }) {
    if (!(!e || o(this, wa).has(e.loadedName))) {
      if (ae(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
        const {
          loadedName: s,
          src: i,
          style: r
        } = e, n = new FontFace(s, i, r);
        this.addNativeFontFace(n);
        try {
          await n.load(), o(this, wa).add(s), t == null || t(e);
        } catch {
          xt(`Cannot load system font: ${e.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(n);
        }
        return;
      }
      Bt("Not implemented: loadSystemFont without the Font Loading API.");
    }
  }
  async bind(e) {
    if (e.attached || e.missingFile && !e.systemFontInfo)
      return;
    if (e.attached = !0, e.systemFontInfo) {
      await this.loadSystemFont(e);
      return;
    }
    if (this.isFontLoadingAPISupported) {
      const s = e.createNativeFontFace();
      if (s) {
        this.addNativeFontFace(s);
        try {
          await s.loaded;
        } catch (i) {
          throw xt(`Failed to load font '${s.family}': '${i}'.`), e.disableFontFace = !0, i;
        }
      }
      return;
    }
    const t = e.createFontFaceRule();
    if (t) {
      if (this.insertRule(t), this.isSyncFontLoadingSupported)
        return;
      await new Promise((s) => {
        const i = this._queueLoadingCallback(s);
        this._prepareFontLoadEvent(e, i);
      });
    }
  }
  get isFontLoadingAPISupported() {
    var t;
    const e = !!((t = this._document) != null && t.fonts);
    return Mt(this, "isFontLoadingAPISupported", e);
  }
  get isSyncFontLoadingSupported() {
    let e = !1;
    return (Ce || typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (e = !0), Mt(this, "isSyncFontLoadingSupported", e);
  }
  _queueLoadingCallback(e) {
    function t() {
      for (ae(!i.done, "completeRequest() cannot be called twice."), i.done = !0; s.length > 0 && s[0].done; ) {
        const r = s.shift();
        setTimeout(r.callback, 0);
      }
    }
    const {
      loadingRequests: s
    } = this, i = {
      done: !1,
      complete: t,
      callback: e
    };
    return s.push(i), i;
  }
  get _loadTestFont() {
    const e = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
    return Mt(this, "_loadTestFont", e);
  }
  _prepareFontLoadEvent(e, t) {
    function s(C, N) {
      return C.charCodeAt(N) << 24 | C.charCodeAt(N + 1) << 16 | C.charCodeAt(N + 2) << 8 | C.charCodeAt(N + 3) & 255;
    }
    function i(C, N, R, P) {
      const M = C.substring(0, N), S = C.substring(N + R);
      return M + P + S;
    }
    let r, n;
    const a = this._document.createElement("canvas");
    a.width = 1, a.height = 1;
    const h = a.getContext("2d");
    let c = 0;
    function d(C, N) {
      if (++c > 30) {
        xt("Load test font never loaded."), N();
        return;
      }
      if (h.font = "30px " + C, h.fillText(".", 0, 20), h.getImageData(0, 0, 1, 1).data[3] > 0) {
        N();
        return;
      }
      setTimeout(d.bind(null, C, N));
    }
    const u = `lt${Date.now()}${this.loadTestFontId++}`;
    let f = this._loadTestFont;
    f = i(f, 976, u.length, u);
    const m = 16, g = 1482184792;
    let w = s(f, m);
    for (r = 0, n = u.length - 3; r < n; r += 4)
      w = w - g + s(u, r) | 0;
    r < u.length && (w = w - g + s(u + "XXX", r) | 0), f = i(f, m, 4, fw(w));
    const b = `url(data:font/opentype;base64,${btoa(f)});`, _ = `@font-face {font-family:"${u}";src:${b}}`;
    this.insertRule(_);
    const k = this._document.createElement("div");
    k.style.visibility = "hidden", k.style.width = k.style.height = "10px", k.style.position = "absolute", k.style.top = k.style.left = "0px";
    for (const C of [e.loadedName, u]) {
      const N = this._document.createElement("span");
      N.textContent = "Hi", N.style.fontFamily = C, k.append(N);
    }
    this._document.body.append(k), d(u, () => {
      k.remove(), t.complete();
    });
  }
}
wa = new WeakMap();
class Iw {
  constructor(e, {
    disableFontFace: t = !1,
    inspectFont: s = null
  }) {
    this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
    for (const i in e)
      this[i] = e[i];
    this.disableFontFace = t === !0, this._inspectFont = s;
  }
  createNativeFontFace() {
    var t;
    if (!this.data || this.disableFontFace)
      return null;
    let e;
    if (!this.cssFontInfo)
      e = new FontFace(this.loadedName, this.data, {});
    else {
      const s = {
        weight: this.cssFontInfo.fontWeight
      };
      this.cssFontInfo.italicAngle && (s.style = `oblique ${this.cssFontInfo.italicAngle}deg`), e = new FontFace(this.cssFontInfo.fontFamily, this.data, s);
    }
    return (t = this._inspectFont) == null || t.call(this, this), e;
  }
  createFontFaceRule() {
    var s;
    if (!this.data || this.disableFontFace)
      return null;
    const e = `url(data:${this.mimetype};base64,${vw(this.data)});`;
    let t;
    if (!this.cssFontInfo)
      t = `@font-face {font-family:"${this.loadedName}";src:${e}}`;
    else {
      let i = `font-weight: ${this.cssFontInfo.fontWeight};`;
      this.cssFontInfo.italicAngle && (i += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), t = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${i}src:${e}}`;
    }
    return (s = this._inspectFont) == null || s.call(this, this, e), t;
  }
  getPathGenerator(e, t) {
    if (this.compiledGlyphs[t] !== void 0)
      return this.compiledGlyphs[t];
    let s;
    try {
      s = e.get(this.loadedName + "_path_" + t);
    } catch (r) {
      xt(`getPathGenerator - ignoring character: "${r}".`);
    }
    if (!Array.isArray(s) || s.length === 0)
      return this.compiledGlyphs[t] = function(r, n) {
      };
    const i = [];
    for (let r = 0, n = s.length; r < n; )
      switch (s[r++]) {
        case Gs.BEZIER_CURVE_TO:
          {
            const [a, h, c, d, u, f] = s.slice(r, r + 6);
            i.push((p) => p.bezierCurveTo(a, h, c, d, u, f)), r += 6;
          }
          break;
        case Gs.MOVE_TO:
          {
            const [a, h] = s.slice(r, r + 2);
            i.push((c) => c.moveTo(a, h)), r += 2;
          }
          break;
        case Gs.LINE_TO:
          {
            const [a, h] = s.slice(r, r + 2);
            i.push((c) => c.lineTo(a, h)), r += 2;
          }
          break;
        case Gs.QUADRATIC_CURVE_TO:
          {
            const [a, h, c, d] = s.slice(r, r + 4);
            i.push((u) => u.quadraticCurveTo(a, h, c, d)), r += 4;
          }
          break;
        case Gs.RESTORE:
          i.push((a) => a.restore());
          break;
        case Gs.SAVE:
          i.push((a) => a.save());
          break;
        case Gs.SCALE:
          ae(i.length === 2, "Scale command is only valid at the third position.");
          break;
        case Gs.TRANSFORM:
          {
            const [a, h, c, d, u, f] = s.slice(r, r + 6);
            i.push((p) => p.transform(a, h, c, d, u, f)), r += 6;
          }
          break;
        case Gs.TRANSLATE:
          {
            const [a, h] = s.slice(r, r + 2);
            i.push((c) => c.translate(a, h)), r += 2;
          }
          break;
      }
    return this.compiledGlyphs[t] = function(n, a) {
      i[0](n), i[1](n), n.scale(a, -a);
      for (let h = 2, c = i.length; h < c; h++)
        i[h](n);
    };
  }
}
var Ol;
class rb {
  constructor({
    enableHWA: e = !1
  }) {
    y(this, Ol, !1);
    E(this, Ol, e);
  }
  create(e, t) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid canvas size");
    const s = this._createCanvas(e, t);
    return {
      canvas: s,
      context: s.getContext("2d", {
        willReadFrequently: !o(this, Ol)
      })
    };
  }
  reset(e, t, s) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    if (t <= 0 || s <= 0)
      throw new Error("Invalid canvas size");
    e.canvas.width = t, e.canvas.height = s;
  }
  destroy(e) {
    if (!e.canvas)
      throw new Error("Canvas is not specified");
    e.canvas.width = 0, e.canvas.height = 0, e.canvas = null, e.context = null;
  }
  _createCanvas(e, t) {
    Bt("Abstract method `_createCanvas` called.");
  }
}
Ol = new WeakMap();
class Nw extends rb {
  constructor({
    ownerDocument: e = globalThis.document,
    enableHWA: t = !1
  }) {
    super({
      enableHWA: t
    }), this._document = e;
  }
  _createCanvas(e, t) {
    const s = this._document.createElement("canvas");
    return s.width = e, s.height = t, s;
  }
}
class nb {
  constructor({
    baseUrl: e = null,
    isCompressed: t = !0
  }) {
    this.baseUrl = e, this.isCompressed = t;
  }
  async fetch({
    name: e
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
    if (!e)
      throw new Error("CMap name must be specified.");
    const t = this.baseUrl + e + (this.isCompressed ? ".bcmap" : "");
    return this._fetch(t).then((s) => ({
      cMapData: s,
      isCompressed: this.isCompressed
    })).catch((s) => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${t}`);
    });
  }
  async _fetch(e) {
    Bt("Abstract method `_fetch` called.");
  }
}
class ab extends nb {
  async _fetch(e) {
    const t = await sf(e, this.isCompressed ? "arraybuffer" : "text");
    return t instanceof ArrayBuffer ? new Uint8Array(t) : ef(t);
  }
}
class ob {
  addFilter(e) {
    return "none";
  }
  addHCMFilter(e, t) {
    return "none";
  }
  addAlphaFilter(e) {
    return "none";
  }
  addLuminosityFilter(e) {
    return "none";
  }
  addHighlightHCMFilter(e, t, s, i, r) {
    return "none";
  }
  destroy(e = !1) {
  }
}
var $r, Gr, Ls, ei, xe, Ld, Vr, fe, _e, Wi, Wn, $i, $n, Aa, Cc, Gi, Gn, Rd, lb, Fl, Vf, Vi, Vn, Yr, zo, Xr, Bo, jl, Yf, qr, Uo;
class Dw extends ob {
  constructor({
    docId: t,
    ownerDocument: s = globalThis.document
  }) {
    super();
    y(this, fe);
    y(this, Wi);
    y(this, $i);
    y(this, Aa);
    y(this, Gi);
    y(this, Rd);
    y(this, Fl);
    y(this, Vi);
    y(this, Yr);
    y(this, Xr);
    y(this, jl);
    y(this, qr);
    y(this, $r, void 0);
    y(this, Gr, void 0);
    y(this, Ls, void 0);
    y(this, ei, void 0);
    y(this, xe, void 0);
    y(this, Ld, void 0);
    y(this, Vr, 0);
    E(this, ei, t), E(this, xe, s);
  }
  addFilter(t) {
    if (!t)
      return "none";
    let s = o(this, fe, _e).get(t);
    if (s)
      return s;
    const [i, r, n] = x(this, Aa, Cc).call(this, t), a = t.length === 1 ? i : `${i}${r}${n}`;
    if (s = o(this, fe, _e).get(a), s)
      return o(this, fe, _e).set(t, s), s;
    const h = `g_${o(this, ei)}_transfer_map_${Te(this, Vr)._++}`, c = x(this, Gi, Gn).call(this, h);
    o(this, fe, _e).set(t, c), o(this, fe, _e).set(a, c);
    const d = x(this, Vi, Vn).call(this, h);
    return x(this, Xr, Bo).call(this, i, r, n, d), c;
  }
  addHCMFilter(t, s) {
    var m;
    const i = `${t}-${s}`, r = "base";
    let n = o(this, Wi, Wn).get(r);
    if ((n == null ? void 0 : n.key) === i || (n ? ((m = n.filter) == null || m.remove(), n.key = i, n.url = "none", n.filter = null) : (n = {
      key: i,
      url: "none",
      filter: null
    }, o(this, Wi, Wn).set(r, n)), !t || !s))
      return n.url;
    const a = x(this, qr, Uo).call(this, t);
    t = pt.makeHexColor(...a);
    const h = x(this, qr, Uo).call(this, s);
    if (s = pt.makeHexColor(...h), o(this, $i, $n).style.color = "", t === "#000000" && s === "#ffffff" || t === s)
      return n.url;
    const c = new Array(256);
    for (let g = 0; g <= 255; g++) {
      const w = g / 255;
      c[g] = w <= 0.03928 ? w / 12.92 : ((w + 0.055) / 1.055) ** 2.4;
    }
    const d = c.join(","), u = `g_${o(this, ei)}_hcm_filter`, f = n.filter = x(this, Vi, Vn).call(this, u);
    x(this, Xr, Bo).call(this, d, d, d, f), x(this, Fl, Vf).call(this, f);
    const p = (g, w) => {
      const b = a[g] / 255, _ = h[g] / 255, k = new Array(w + 1);
      for (let C = 0; C <= w; C++)
        k[C] = b + C / w * (_ - b);
      return k.join(",");
    };
    return x(this, Xr, Bo).call(this, p(0, 5), p(1, 5), p(2, 5), f), n.url = x(this, Gi, Gn).call(this, u), n.url;
  }
  addAlphaFilter(t) {
    let s = o(this, fe, _e).get(t);
    if (s)
      return s;
    const [i] = x(this, Aa, Cc).call(this, [t]), r = `alpha_${i}`;
    if (s = o(this, fe, _e).get(r), s)
      return o(this, fe, _e).set(t, s), s;
    const n = `g_${o(this, ei)}_alpha_map_${Te(this, Vr)._++}`, a = x(this, Gi, Gn).call(this, n);
    o(this, fe, _e).set(t, a), o(this, fe, _e).set(r, a);
    const h = x(this, Vi, Vn).call(this, n);
    return x(this, jl, Yf).call(this, i, h), a;
  }
  addLuminosityFilter(t) {
    let s = o(this, fe, _e).get(t || "luminosity");
    if (s)
      return s;
    let i, r;
    if (t ? ([i] = x(this, Aa, Cc).call(this, [t]), r = `luminosity_${i}`) : r = "luminosity", s = o(this, fe, _e).get(r), s)
      return o(this, fe, _e).set(t, s), s;
    const n = `g_${o(this, ei)}_luminosity_map_${Te(this, Vr)._++}`, a = x(this, Gi, Gn).call(this, n);
    o(this, fe, _e).set(t, a), o(this, fe, _e).set(r, a);
    const h = x(this, Vi, Vn).call(this, n);
    return x(this, Rd, lb).call(this, h), t && x(this, jl, Yf).call(this, i, h), a;
  }
  addHighlightHCMFilter(t, s, i, r, n) {
    var _;
    const a = `${s}-${i}-${r}-${n}`;
    let h = o(this, Wi, Wn).get(t);
    if ((h == null ? void 0 : h.key) === a || (h ? ((_ = h.filter) == null || _.remove(), h.key = a, h.url = "none", h.filter = null) : (h = {
      key: a,
      url: "none",
      filter: null
    }, o(this, Wi, Wn).set(t, h)), !s || !i))
      return h.url;
    const [c, d] = [s, i].map(x(this, qr, Uo).bind(this));
    let u = Math.round(0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2]), f = Math.round(0.2126 * d[0] + 0.7152 * d[1] + 0.0722 * d[2]), [p, m] = [r, n].map(x(this, qr, Uo).bind(this));
    f < u && ([u, f, p, m] = [f, u, m, p]), o(this, $i, $n).style.color = "";
    const g = (k, C, N) => {
      const R = new Array(256), P = (f - u) / N, M = k / 255, S = (C - k) / (255 * N);
      let L = 0;
      for (let H = 0; H <= N; H++) {
        const I = Math.round(u + H * P), F = M + H * S;
        for (let A = L; A <= I; A++)
          R[A] = F;
        L = I + 1;
      }
      for (let H = L; H < 256; H++)
        R[H] = R[L - 1];
      return R.join(",");
    }, w = `g_${o(this, ei)}_hcm_${t}_filter`, b = h.filter = x(this, Vi, Vn).call(this, w);
    return x(this, Fl, Vf).call(this, b), x(this, Xr, Bo).call(this, g(p[0], m[0], 5), g(p[1], m[1], 5), g(p[2], m[2], 5), b), h.url = x(this, Gi, Gn).call(this, w), h.url;
  }
  destroy(t = !1) {
    t && o(this, Wi, Wn).size !== 0 || (o(this, Ls) && (o(this, Ls).parentNode.parentNode.remove(), E(this, Ls, null)), o(this, Gr) && (o(this, Gr).clear(), E(this, Gr, null)), E(this, Vr, 0));
  }
}
$r = new WeakMap(), Gr = new WeakMap(), Ls = new WeakMap(), ei = new WeakMap(), xe = new WeakMap(), Ld = new WeakMap(), Vr = new WeakMap(), fe = new WeakSet(), _e = function() {
  return o(this, Gr) || E(this, Gr, /* @__PURE__ */ new Map());
}, Wi = new WeakSet(), Wn = function() {
  return o(this, Ld) || E(this, Ld, /* @__PURE__ */ new Map());
}, $i = new WeakSet(), $n = function() {
  if (!o(this, Ls)) {
    const t = o(this, xe).createElement("div"), {
      style: s
    } = t;
    s.visibility = "hidden", s.contain = "strict", s.width = s.height = 0, s.position = "absolute", s.top = s.left = 0, s.zIndex = -1;
    const i = o(this, xe).createElementNS(Ys, "svg");
    i.setAttribute("width", 0), i.setAttribute("height", 0), E(this, Ls, o(this, xe).createElementNS(Ys, "defs")), t.append(i), i.append(o(this, Ls)), o(this, xe).body.append(t);
  }
  return o(this, Ls);
}, Aa = new WeakSet(), Cc = function(t) {
  if (t.length === 1) {
    const c = t[0], d = new Array(256);
    for (let f = 0; f < 256; f++)
      d[f] = c[f] / 255;
    const u = d.join(",");
    return [u, u, u];
  }
  const [s, i, r] = t, n = new Array(256), a = new Array(256), h = new Array(256);
  for (let c = 0; c < 256; c++)
    n[c] = s[c] / 255, a[c] = i[c] / 255, h[c] = r[c] / 255;
  return [n.join(","), a.join(","), h.join(",")];
}, Gi = new WeakSet(), Gn = function(t) {
  if (o(this, $r) === void 0) {
    E(this, $r, "");
    const s = o(this, xe).URL;
    s !== o(this, xe).baseURI && (rf(s) ? xt('#createUrl: ignore "data:"-URL for performance reasons.') : E(this, $r, s.split("#", 1)[0]));
  }
  return `url(${o(this, $r)}#${t})`;
}, Rd = new WeakSet(), lb = function(t) {
  const s = o(this, xe).createElementNS(Ys, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0"), t.append(s);
}, Fl = new WeakSet(), Vf = function(t) {
  const s = o(this, xe).createElementNS(Ys, "feColorMatrix");
  s.setAttribute("type", "matrix"), s.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), t.append(s);
}, Vi = new WeakSet(), Vn = function(t) {
  const s = o(this, xe).createElementNS(Ys, "filter");
  return s.setAttribute("color-interpolation-filters", "sRGB"), s.setAttribute("id", t), o(this, $i, $n).append(s), s;
}, Yr = new WeakSet(), zo = function(t, s, i) {
  const r = o(this, xe).createElementNS(Ys, s);
  r.setAttribute("type", "discrete"), r.setAttribute("tableValues", i), t.append(r);
}, Xr = new WeakSet(), Bo = function(t, s, i, r) {
  const n = o(this, xe).createElementNS(Ys, "feComponentTransfer");
  r.append(n), x(this, Yr, zo).call(this, n, "feFuncR", t), x(this, Yr, zo).call(this, n, "feFuncG", s), x(this, Yr, zo).call(this, n, "feFuncB", i);
}, jl = new WeakSet(), Yf = function(t, s) {
  const i = o(this, xe).createElementNS(Ys, "feComponentTransfer");
  s.append(i), x(this, Yr, zo).call(this, i, "feFuncA", t);
}, qr = new WeakSet(), Uo = function(t) {
  return o(this, $i, $n).style.color = t, Jp(getComputedStyle(o(this, $i, $n)).getPropertyValue("color"));
};
class hb {
  constructor({
    baseUrl: e = null
  }) {
    this.baseUrl = e;
  }
  async fetch({
    filename: e
  }) {
    if (!this.baseUrl)
      throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
    if (!e)
      throw new Error("Font filename must be specified.");
    const t = `${this.baseUrl}${e}`;
    return this._fetch(t).catch((s) => {
      throw new Error(`Unable to load font data at: ${t}`);
    });
  }
  async _fetch(e) {
    Bt("Abstract method `_fetch` called.");
  }
}
class cb extends hb {
  async _fetch(e) {
    const t = await sf(e, "arraybuffer");
    return new Uint8Array(t);
  }
}
if (Ce) {
  var Xf = Promise.withResolvers(), Zo = null;
  (async () => {
    const e = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2447137e.js"
    ), t = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2447137e.js"
    ), s = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2447137e.js"
    ), i = await import(
      /*webpackIgnore: true*/
      "./__vite-browser-external-2447137e.js"
    );
    let r, n;
    return new Map(Object.entries({
      fs: e,
      http: t,
      https: s,
      url: i,
      canvas: r,
      path2d: n
    }));
  })().then((e) => {
    Zo = e, Xf.resolve();
  }, (e) => {
    xt(`loadPackages: ${e}`), Zo = /* @__PURE__ */ new Map(), Xf.resolve();
  });
}
class gr {
  static get promise() {
    return Xf.promise;
  }
  static get(e) {
    return Zo == null ? void 0 : Zo.get(e);
  }
}
async function db(l) {
  const t = await gr.get("fs").promises.readFile(l);
  return new Uint8Array(t);
}
class Pw extends ob {
}
class Lw extends rb {
  _createCanvas(e, t) {
    return gr.get("canvas").createCanvas(e, t);
  }
}
class Rw extends nb {
  async _fetch(e) {
    return db(e);
  }
}
class Ow extends hb {
  async _fetch(e) {
    return db(e);
  }
}
const De = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
function qf(l, e) {
  if (!e)
    return;
  const t = e[2] - e[0], s = e[3] - e[1], i = new Path2D();
  i.rect(e[0], e[1], t, s), l.clip(i);
}
class eg {
  getPattern() {
    Bt("Abstract method `getPattern` called.");
  }
}
class Fw extends eg {
  constructor(e) {
    super(), this._type = e[1], this._bbox = e[2], this._colorStops = e[3], this._p0 = e[4], this._p1 = e[5], this._r0 = e[6], this._r1 = e[7], this.matrix = null;
  }
  _createGradient(e) {
    let t;
    this._type === "axial" ? t = e.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (t = e.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
    for (const s of this._colorStops)
      t.addColorStop(s[0], s[1]);
    return t;
  }
  getPattern(e, t, s, i) {
    let r;
    if (i === De.STROKE || i === De.FILL) {
      const n = t.current.getClippedPathBoundingBox(i, Gt(e)) || [0, 0, 0, 0], a = Math.ceil(n[2] - n[0]) || 1, h = Math.ceil(n[3] - n[1]) || 1, c = t.cachedCanvases.getCanvas("pattern", a, h), d = c.context;
      d.clearRect(0, 0, d.canvas.width, d.canvas.height), d.beginPath(), d.rect(0, 0, d.canvas.width, d.canvas.height), d.translate(-n[0], -n[1]), s = pt.transform(s, [1, 0, 0, 1, n[0], n[1]]), d.transform(...t.baseTransform), this.matrix && d.transform(...this.matrix), qf(d, this._bbox), d.fillStyle = this._createGradient(d), d.fill(), r = e.createPattern(c.canvas, "no-repeat");
      const u = new DOMMatrix(s);
      r.setTransform(u);
    } else
      qf(e, this._bbox), r = this._createGradient(e);
    return r;
  }
}
function bf(l, e, t, s, i, r, n, a) {
  const h = e.coords, c = e.colors, d = l.data, u = l.width * 4;
  let f;
  h[t + 1] > h[s + 1] && (f = t, t = s, s = f, f = r, r = n, n = f), h[s + 1] > h[i + 1] && (f = s, s = i, i = f, f = n, n = a, a = f), h[t + 1] > h[s + 1] && (f = t, t = s, s = f, f = r, r = n, n = f);
  const p = (h[t] + e.offsetX) * e.scaleX, m = (h[t + 1] + e.offsetY) * e.scaleY, g = (h[s] + e.offsetX) * e.scaleX, w = (h[s + 1] + e.offsetY) * e.scaleY, b = (h[i] + e.offsetX) * e.scaleX, _ = (h[i + 1] + e.offsetY) * e.scaleY;
  if (m >= _)
    return;
  const k = c[r], C = c[r + 1], N = c[r + 2], R = c[n], P = c[n + 1], M = c[n + 2], S = c[a], L = c[a + 1], H = c[a + 2], I = Math.round(m), F = Math.round(_);
  let A, G, et, z, K, Y, ot, B;
  for (let O = I; O <= F; O++) {
    if (O < w) {
      const ft = O < m ? 0 : (m - O) / (m - w);
      A = p - (p - g) * ft, G = k - (k - R) * ft, et = C - (C - P) * ft, z = N - (N - M) * ft;
    } else {
      let ft;
      O > _ ? ft = 1 : w === _ ? ft = 0 : ft = (w - O) / (w - _), A = g - (g - b) * ft, G = R - (R - S) * ft, et = P - (P - L) * ft, z = M - (M - H) * ft;
    }
    let q;
    O < m ? q = 0 : O > _ ? q = 1 : q = (m - O) / (m - _), K = p - (p - b) * q, Y = k - (k - S) * q, ot = C - (C - L) * q, B = N - (N - H) * q;
    const tt = Math.round(Math.min(A, K)), J = Math.round(Math.max(A, K));
    let ut = u * O + tt * 4;
    for (let ft = tt; ft <= J; ft++)
      q = (A - ft) / (A - K), q < 0 ? q = 0 : q > 1 && (q = 1), d[ut++] = G - (G - Y) * q | 0, d[ut++] = et - (et - ot) * q | 0, d[ut++] = z - (z - B) * q | 0, d[ut++] = 255;
  }
}
function jw(l, e, t) {
  const s = e.coords, i = e.colors;
  let r, n;
  switch (e.type) {
    case "lattice":
      const a = e.verticesPerRow, h = Math.floor(s.length / a) - 1, c = a - 1;
      for (r = 0; r < h; r++) {
        let d = r * a;
        for (let u = 0; u < c; u++, d++)
          bf(l, t, s[d], s[d + 1], s[d + a], i[d], i[d + 1], i[d + a]), bf(l, t, s[d + a + 1], s[d + 1], s[d + a], i[d + a + 1], i[d + 1], i[d + a]);
      }
      break;
    case "triangles":
      for (r = 0, n = s.length; r < n; r += 3)
        bf(l, t, s[r], s[r + 1], s[r + 2], i[r], i[r + 1], i[r + 2]);
      break;
    default:
      throw new Error("illegal figure");
  }
}
class zw extends eg {
  constructor(e) {
    super(), this._coords = e[2], this._colors = e[3], this._figures = e[4], this._bounds = e[5], this._bbox = e[7], this._background = e[8], this.matrix = null;
  }
  _createMeshCanvas(e, t, s) {
    const a = Math.floor(this._bounds[0]), h = Math.floor(this._bounds[1]), c = Math.ceil(this._bounds[2]) - a, d = Math.ceil(this._bounds[3]) - h, u = Math.min(Math.ceil(Math.abs(c * e[0] * 1.1)), 3e3), f = Math.min(Math.ceil(Math.abs(d * e[1] * 1.1)), 3e3), p = c / u, m = d / f, g = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -a,
      offsetY: -h,
      scaleX: 1 / p,
      scaleY: 1 / m
    }, w = u + 2 * 2, b = f + 2 * 2, _ = s.getCanvas("mesh", w, b), k = _.context, C = k.createImageData(u, f);
    if (t) {
      const R = C.data;
      for (let P = 0, M = R.length; P < M; P += 4)
        R[P] = t[0], R[P + 1] = t[1], R[P + 2] = t[2], R[P + 3] = 255;
    }
    for (const R of this._figures)
      jw(C, R, g);
    return k.putImageData(C, 2, 2), {
      canvas: _.canvas,
      offsetX: a - 2 * p,
      offsetY: h - 2 * m,
      scaleX: p,
      scaleY: m
    };
  }
  getPattern(e, t, s, i) {
    qf(e, this._bbox);
    let r;
    if (i === De.SHADING)
      r = pt.singularValueDecompose2dScale(Gt(e));
    else if (r = pt.singularValueDecompose2dScale(t.baseTransform), this.matrix) {
      const a = pt.singularValueDecompose2dScale(this.matrix);
      r = [r[0] * a[0], r[1] * a[1]];
    }
    const n = this._createMeshCanvas(r, i === De.SHADING ? null : this._background, t.cachedCanvases);
    return i !== De.SHADING && (e.setTransform(...t.baseTransform), this.matrix && e.transform(...this.matrix)), e.translate(n.offsetX, n.offsetY), e.scale(n.scaleX, n.scaleY), e.createPattern(n.canvas, "no-repeat");
  }
}
class Bw extends eg {
  getPattern() {
    return "hotpink";
  }
}
function Uw(l) {
  switch (l[0]) {
    case "RadialAxial":
      return new Fw(l);
    case "Mesh":
      return new zw(l);
    case "Dummy":
      return new Bw();
  }
  throw new Error(`Unknown IR type: ${l[0]}`);
}
const Dg = {
  COLORED: 1,
  UNCOLORED: 2
}, Od = class Od {
  constructor(e, t, s, i, r) {
    this.operatorList = e[2], this.matrix = e[3], this.bbox = e[4], this.xstep = e[5], this.ystep = e[6], this.paintType = e[7], this.tilingType = e[8], this.color = t, this.ctx = s, this.canvasGraphicsFactory = i, this.baseTransform = r;
  }
  createPatternCanvas(e) {
    const {
      bbox: t,
      operatorList: s,
      paintType: i,
      tilingType: r,
      color: n,
      canvasGraphicsFactory: a
    } = this;
    let {
      xstep: h,
      ystep: c
    } = this;
    h = Math.abs(h), c = Math.abs(c), Ju("TilingType: " + r);
    const d = t[0], u = t[1], f = t[2], p = t[3], m = f - d, g = p - u, w = pt.singularValueDecompose2dScale(this.matrix), b = pt.singularValueDecompose2dScale(this.baseTransform), _ = w[0] * b[0], k = w[1] * b[1];
    let C = m, N = g, R = !1, P = !1;
    const M = Math.ceil(h * _), S = Math.ceil(c * k), L = Math.ceil(m * _), H = Math.ceil(g * k);
    M >= L ? C = h : R = !0, S >= H ? N = c : P = !0;
    const I = this.getSizeAndScale(C, this.ctx.canvas.width, _), F = this.getSizeAndScale(N, this.ctx.canvas.height, k), A = e.cachedCanvases.getCanvas("pattern", I.size, F.size), G = A.context, et = a.createCanvasGraphics(G);
    if (et.groupLevel = e.groupLevel, this.setFillAndStrokeStyleToContext(et, i, n), G.translate(-I.scale * d, -F.scale * u), et.transform(I.scale, 0, 0, F.scale, 0, 0), G.save(), this.clipBbox(et, d, u, f, p), et.baseTransform = Gt(et.ctx), et.executeOperatorList(s), et.endDrawing(), G.restore(), R || P) {
      const z = A.canvas;
      R && (C = h), P && (N = c);
      const K = this.getSizeAndScale(C, this.ctx.canvas.width, _), Y = this.getSizeAndScale(N, this.ctx.canvas.height, k), ot = K.size, B = Y.size, O = e.cachedCanvases.getCanvas("pattern-workaround", ot, B), q = O.context, tt = R ? Math.floor(m / h) : 0, J = P ? Math.floor(g / c) : 0;
      for (let ut = 0; ut <= tt; ut++)
        for (let ft = 0; ft <= J; ft++)
          q.drawImage(z, ot * ut, B * ft, ot, B, 0, 0, ot, B);
      return {
        canvas: O.canvas,
        scaleX: K.scale,
        scaleY: Y.scale,
        offsetX: d,
        offsetY: u
      };
    }
    return {
      canvas: A.canvas,
      scaleX: I.scale,
      scaleY: F.scale,
      offsetX: d,
      offsetY: u
    };
  }
  getSizeAndScale(e, t, s) {
    const i = Math.max(Od.MAX_PATTERN_SIZE, t);
    let r = Math.ceil(e * s);
    return r >= i ? r = i : s = r / e, {
      scale: s,
      size: r
    };
  }
  clipBbox(e, t, s, i, r) {
    const n = i - t, a = r - s;
    e.ctx.rect(t, s, n, a), e.current.updateRectMinMax(Gt(e.ctx), [t, s, i, r]), e.clip(), e.endPath();
  }
  setFillAndStrokeStyleToContext(e, t, s) {
    const i = e.ctx, r = e.current;
    switch (t) {
      case Dg.COLORED:
        const n = this.ctx;
        i.fillStyle = n.fillStyle, i.strokeStyle = n.strokeStyle, r.fillColor = n.fillStyle, r.strokeColor = n.strokeStyle;
        break;
      case Dg.UNCOLORED:
        const a = pt.makeHexColor(s[0], s[1], s[2]);
        i.fillStyle = a, i.strokeStyle = a, r.fillColor = a, r.strokeColor = a;
        break;
      default:
        throw new uw(`Unsupported paint type: ${t}`);
    }
  }
  getPattern(e, t, s, i) {
    let r = s;
    i !== De.SHADING && (r = pt.transform(r, t.baseTransform), this.matrix && (r = pt.transform(r, this.matrix)));
    const n = this.createPatternCanvas(t);
    let a = new DOMMatrix(r);
    a = a.translate(n.offsetX, n.offsetY), a = a.scale(1 / n.scaleX, 1 / n.scaleY);
    const h = e.createPattern(n.canvas, "repeat");
    return h.setTransform(a), h;
  }
};
vt(Od, "MAX_PATTERN_SIZE", 3e3);
let Qf = Od;
function Hw({
  src: l,
  srcPos: e = 0,
  dest: t,
  width: s,
  height: i,
  nonBlackColor: r = 4294967295,
  inverseDecode: n = !1
}) {
  const a = Pe.isLittleEndian ? 4278190080 : 255, [h, c] = n ? [r, a] : [a, r], d = s >> 3, u = s & 7, f = l.length;
  t = new Uint32Array(t.buffer);
  let p = 0;
  for (let m = 0; m < i; m++) {
    for (const w = e + d; e < w; e++) {
      const b = e < f ? l[e] : 255;
      t[p++] = b & 128 ? c : h, t[p++] = b & 64 ? c : h, t[p++] = b & 32 ? c : h, t[p++] = b & 16 ? c : h, t[p++] = b & 8 ? c : h, t[p++] = b & 4 ? c : h, t[p++] = b & 2 ? c : h, t[p++] = b & 1 ? c : h;
    }
    if (u === 0)
      continue;
    const g = e < f ? l[e++] : 255;
    for (let w = 0; w < u; w++)
      t[p++] = g & 1 << 7 - w ? c : h;
  }
  return {
    srcPos: e,
    destPos: p
  };
}
const Pg = 16, Lg = 100, Ww = 15, Rg = 10, Og = 1e3, ze = 16;
function $w(l, e) {
  if (l._removeMirroring)
    throw new Error("Context is already forwarding operations.");
  l.__originalSave = l.save, l.__originalRestore = l.restore, l.__originalRotate = l.rotate, l.__originalScale = l.scale, l.__originalTranslate = l.translate, l.__originalTransform = l.transform, l.__originalSetTransform = l.setTransform, l.__originalResetTransform = l.resetTransform, l.__originalClip = l.clip, l.__originalMoveTo = l.moveTo, l.__originalLineTo = l.lineTo, l.__originalBezierCurveTo = l.bezierCurveTo, l.__originalRect = l.rect, l.__originalClosePath = l.closePath, l.__originalBeginPath = l.beginPath, l._removeMirroring = () => {
    l.save = l.__originalSave, l.restore = l.__originalRestore, l.rotate = l.__originalRotate, l.scale = l.__originalScale, l.translate = l.__originalTranslate, l.transform = l.__originalTransform, l.setTransform = l.__originalSetTransform, l.resetTransform = l.__originalResetTransform, l.clip = l.__originalClip, l.moveTo = l.__originalMoveTo, l.lineTo = l.__originalLineTo, l.bezierCurveTo = l.__originalBezierCurveTo, l.rect = l.__originalRect, l.closePath = l.__originalClosePath, l.beginPath = l.__originalBeginPath, delete l._removeMirroring;
  }, l.save = function() {
    e.save(), this.__originalSave();
  }, l.restore = function() {
    e.restore(), this.__originalRestore();
  }, l.translate = function(s, i) {
    e.translate(s, i), this.__originalTranslate(s, i);
  }, l.scale = function(s, i) {
    e.scale(s, i), this.__originalScale(s, i);
  }, l.transform = function(s, i, r, n, a, h) {
    e.transform(s, i, r, n, a, h), this.__originalTransform(s, i, r, n, a, h);
  }, l.setTransform = function(s, i, r, n, a, h) {
    e.setTransform(s, i, r, n, a, h), this.__originalSetTransform(s, i, r, n, a, h);
  }, l.resetTransform = function() {
    e.resetTransform(), this.__originalResetTransform();
  }, l.rotate = function(s) {
    e.rotate(s), this.__originalRotate(s);
  }, l.clip = function(s) {
    e.clip(s), this.__originalClip(s);
  }, l.moveTo = function(t, s) {
    e.moveTo(t, s), this.__originalMoveTo(t, s);
  }, l.lineTo = function(t, s) {
    e.lineTo(t, s), this.__originalLineTo(t, s);
  }, l.bezierCurveTo = function(t, s, i, r, n, a) {
    e.bezierCurveTo(t, s, i, r, n, a), this.__originalBezierCurveTo(t, s, i, r, n, a);
  }, l.rect = function(t, s, i, r) {
    e.rect(t, s, i, r), this.__originalRect(t, s, i, r);
  }, l.closePath = function() {
    e.closePath(), this.__originalClosePath();
  }, l.beginPath = function() {
    e.beginPath(), this.__originalBeginPath();
  };
}
class Gw {
  constructor(e) {
    this.canvasFactory = e, this.cache = /* @__PURE__ */ Object.create(null);
  }
  getCanvas(e, t, s) {
    let i;
    return this.cache[e] !== void 0 ? (i = this.cache[e], this.canvasFactory.reset(i, t, s)) : (i = this.canvasFactory.create(t, s), this.cache[e] = i), i;
  }
  delete(e) {
    delete this.cache[e];
  }
  clear() {
    for (const e in this.cache) {
      const t = this.cache[e];
      this.canvasFactory.destroy(t), delete this.cache[e];
    }
  }
}
function pc(l, e, t, s, i, r, n, a, h, c) {
  const [d, u, f, p, m, g] = Gt(l);
  if (u === 0 && f === 0) {
    const _ = n * d + m, k = Math.round(_), C = a * p + g, N = Math.round(C), R = (n + h) * d + m, P = Math.abs(Math.round(R) - k) || 1, M = (a + c) * p + g, S = Math.abs(Math.round(M) - N) || 1;
    return l.setTransform(Math.sign(d), 0, 0, Math.sign(p), k, N), l.drawImage(e, t, s, i, r, 0, 0, P, S), l.setTransform(d, u, f, p, m, g), [P, S];
  }
  if (d === 0 && p === 0) {
    const _ = a * f + m, k = Math.round(_), C = n * u + g, N = Math.round(C), R = (a + c) * f + m, P = Math.abs(Math.round(R) - k) || 1, M = (n + h) * u + g, S = Math.abs(Math.round(M) - N) || 1;
    return l.setTransform(0, Math.sign(u), Math.sign(f), 0, k, N), l.drawImage(e, t, s, i, r, 0, 0, S, P), l.setTransform(d, u, f, p, m, g), [S, P];
  }
  l.drawImage(e, t, s, i, r, n, a, h, c);
  const w = Math.hypot(d, u), b = Math.hypot(f, p);
  return [w * h, b * c];
}
function Vw(l) {
  const {
    width: e,
    height: t
  } = l;
  if (e > Og || t > Og)
    return null;
  const s = 1e3, i = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), r = e + 1;
  let n = new Uint8Array(r * (t + 1)), a, h, c;
  const d = e + 7 & -8;
  let u = new Uint8Array(d * t), f = 0;
  for (const b of l.data) {
    let _ = 128;
    for (; _ > 0; )
      u[f++] = b & _ ? 0 : 255, _ >>= 1;
  }
  let p = 0;
  for (f = 0, u[f] !== 0 && (n[0] = 1, ++p), h = 1; h < e; h++)
    u[f] !== u[f + 1] && (n[h] = u[f] ? 2 : 1, ++p), f++;
  for (u[f] !== 0 && (n[h] = 2, ++p), a = 1; a < t; a++) {
    f = a * d, c = a * r, u[f - d] !== u[f] && (n[c] = u[f] ? 1 : 8, ++p);
    let b = (u[f] ? 4 : 0) + (u[f - d] ? 8 : 0);
    for (h = 1; h < e; h++)
      b = (b >> 2) + (u[f + 1] ? 4 : 0) + (u[f - d + 1] ? 8 : 0), i[b] && (n[c + h] = i[b], ++p), f++;
    if (u[f - d] !== u[f] && (n[c + h] = u[f] ? 2 : 4, ++p), p > s)
      return null;
  }
  for (f = d * (t - 1), c = a * r, u[f] !== 0 && (n[c] = 8, ++p), h = 1; h < e; h++)
    u[f] !== u[f + 1] && (n[c + h] = u[f] ? 4 : 8, ++p), f++;
  if (u[f] !== 0 && (n[c + h] = 4, ++p), p > s)
    return null;
  const m = new Int32Array([0, r, -1, 0, -r, 0, 0, 0, 1]), g = new Path2D();
  for (a = 0; p && a <= t; a++) {
    let b = a * r;
    const _ = b + e;
    for (; b < _ && !n[b]; )
      b++;
    if (b === _)
      continue;
    g.moveTo(b % r, a);
    const k = b;
    let C = n[b];
    do {
      const N = m[C];
      do
        b += N;
      while (!n[b]);
      const R = n[b];
      R !== 5 && R !== 10 ? (C = R, n[b] = 0) : (C = R & 51 * C >> 4, n[b] &= C >> 2 | C << 2), g.lineTo(b % r, b / r | 0), n[b] || --p;
    } while (k !== b);
    --a;
  }
  return u = null, n = null, function(b) {
    b.save(), b.scale(1 / e, -1 / t), b.translate(0, -t), b.fill(g), b.beginPath(), b.restore();
  };
}
class Fg {
  constructor(e, t) {
    this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = Cm, this.textMatrixScale = 1, this.fontMatrix = _f, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = Ae.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, e, t]);
  }
  clone() {
    const e = Object.create(this);
    return e.clipBox = this.clipBox.slice(), e;
  }
  setCurrentPoint(e, t) {
    this.x = e, this.y = t;
  }
  updatePathMinMax(e, t, s) {
    [t, s] = pt.applyTransform([t, s], e), this.minX = Math.min(this.minX, t), this.minY = Math.min(this.minY, s), this.maxX = Math.max(this.maxX, t), this.maxY = Math.max(this.maxY, s);
  }
  updateRectMinMax(e, t) {
    const s = pt.applyTransform(t, e), i = pt.applyTransform(t.slice(2), e), r = pt.applyTransform([t[0], t[3]], e), n = pt.applyTransform([t[2], t[1]], e);
    this.minX = Math.min(this.minX, s[0], i[0], r[0], n[0]), this.minY = Math.min(this.minY, s[1], i[1], r[1], n[1]), this.maxX = Math.max(this.maxX, s[0], i[0], r[0], n[0]), this.maxY = Math.max(this.maxY, s[1], i[1], r[1], n[1]);
  }
  updateScalingPathMinMax(e, t) {
    pt.scaleMinMax(e, t), this.minX = Math.min(this.minX, t[0]), this.minY = Math.min(this.minY, t[1]), this.maxX = Math.max(this.maxX, t[2]), this.maxY = Math.max(this.maxY, t[3]);
  }
  updateCurvePathMinMax(e, t, s, i, r, n, a, h, c, d) {
    const u = pt.bezierBoundingBox(t, s, i, r, n, a, h, c, d);
    d || this.updateRectMinMax(e, u);
  }
  getPathBoundingBox(e = De.FILL, t = null) {
    const s = [this.minX, this.minY, this.maxX, this.maxY];
    if (e === De.STROKE) {
      t || Bt("Stroke bounding box must include transform.");
      const i = pt.singularValueDecompose2dScale(t), r = i[0] * this.lineWidth / 2, n = i[1] * this.lineWidth / 2;
      s[0] -= r, s[1] -= n, s[2] += r, s[3] += n;
    }
    return s;
  }
  updateClipFromPath() {
    const e = pt.intersect(this.clipBox, this.getPathBoundingBox());
    this.startNewPathAndClipBox(e || [0, 0, 0, 0]);
  }
  isEmptyClip() {
    return this.minX === 1 / 0;
  }
  startNewPathAndClipBox(e) {
    this.clipBox = e, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
  }
  getClippedPathBoundingBox(e = De.FILL, t = null) {
    return pt.intersect(this.clipBox, this.getPathBoundingBox(e, t));
  }
}
function jg(l, e) {
  if (typeof ImageData < "u" && e instanceof ImageData) {
    l.putImageData(e, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % ze, r = (t - i) / ze, n = i === 0 ? r : r + 1, a = l.createImageData(s, ze);
  let h = 0, c;
  const d = e.data, u = a.data;
  let f, p, m, g;
  if (e.kind === Ac.GRAYSCALE_1BPP) {
    const w = d.byteLength, b = new Uint32Array(u.buffer, 0, u.byteLength >> 2), _ = b.length, k = s + 7 >> 3, C = 4294967295, N = Pe.isLittleEndian ? 4278190080 : 255;
    for (f = 0; f < n; f++) {
      for (m = f < r ? ze : i, c = 0, p = 0; p < m; p++) {
        const R = w - h;
        let P = 0;
        const M = R > k ? s : R * 8 - 7, S = M & -8;
        let L = 0, H = 0;
        for (; P < S; P += 8)
          H = d[h++], b[c++] = H & 128 ? C : N, b[c++] = H & 64 ? C : N, b[c++] = H & 32 ? C : N, b[c++] = H & 16 ? C : N, b[c++] = H & 8 ? C : N, b[c++] = H & 4 ? C : N, b[c++] = H & 2 ? C : N, b[c++] = H & 1 ? C : N;
        for (; P < M; P++)
          L === 0 && (H = d[h++], L = 128), b[c++] = H & L ? C : N, L >>= 1;
      }
      for (; c < _; )
        b[c++] = 0;
      l.putImageData(a, 0, f * ze);
    }
  } else if (e.kind === Ac.RGBA_32BPP) {
    for (p = 0, g = s * ze * 4, f = 0; f < r; f++)
      u.set(d.subarray(h, h + g)), h += g, l.putImageData(a, 0, p), p += ze;
    f < n && (g = s * i * 4, u.set(d.subarray(h, h + g)), l.putImageData(a, 0, p));
  } else if (e.kind === Ac.RGB_24BPP)
    for (m = ze, g = s * m, f = 0; f < n; f++) {
      for (f >= r && (m = i, g = s * m), c = 0, p = g; p--; )
        u[c++] = d[h++], u[c++] = d[h++], u[c++] = d[h++], u[c++] = 255;
      l.putImageData(a, 0, f * ze);
    }
  else
    throw new Error(`bad image kind: ${e.kind}`);
}
function zg(l, e) {
  if (e.bitmap) {
    l.drawImage(e.bitmap, 0, 0);
    return;
  }
  const t = e.height, s = e.width, i = t % ze, r = (t - i) / ze, n = i === 0 ? r : r + 1, a = l.createImageData(s, ze);
  let h = 0;
  const c = e.data, d = a.data;
  for (let u = 0; u < n; u++) {
    const f = u < r ? ze : i;
    ({
      srcPos: h
    } = Hw({
      src: c,
      srcPos: h,
      dest: d,
      width: s,
      height: f,
      nonBlackColor: 0
    })), l.putImageData(a, 0, u * ze);
  }
}
function Do(l, e) {
  const t = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const s of t)
    l[s] !== void 0 && (e[s] = l[s]);
  l.setLineDash !== void 0 && (e.setLineDash(l.getLineDash()), e.lineDashOffset = l.lineDashOffset);
}
function gc(l) {
  if (l.strokeStyle = l.fillStyle = "#000000", l.fillRule = "nonzero", l.globalAlpha = 1, l.lineWidth = 1, l.lineCap = "butt", l.lineJoin = "miter", l.miterLimit = 10, l.globalCompositeOperation = "source-over", l.font = "10px sans-serif", l.setLineDash !== void 0 && (l.setLineDash([]), l.lineDashOffset = 0), !Ce) {
    const {
      filter: e
    } = l;
    e !== "none" && e !== "" && (l.filter = "none");
  }
}
function Bg(l, e) {
  if (e)
    return !0;
  const t = pt.singularValueDecompose2dScale(l);
  t[0] = Math.fround(t[0]), t[1] = Math.fround(t[1]);
  const s = Math.fround((globalThis.devicePixelRatio || 1) * pr.PDF_TO_CSS_UNITS);
  return t[0] <= s && t[1] <= s;
}
const Yw = ["butt", "round", "square"], Xw = ["miter", "round", "bevel"], qw = {}, Ug = {};
var zl, Kf, Bl, Zf;
const cg = class cg {
  constructor(e, t, s, i, r, {
    optionalContentConfig: n,
    markedContentStack: a = null
  }, h, c) {
    y(this, zl);
    y(this, Bl);
    this.ctx = e, this.current = new Fg(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = t, this.objs = s, this.canvasFactory = i, this.filterFactory = r, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = a || [], this.optionalContentConfig = n, this.cachedCanvases = new Gw(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = h, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = c, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
  }
  getObject(e, t = null) {
    return typeof e == "string" ? e.startsWith("g_") ? this.commonObjs.get(e) : this.objs.get(e) : t;
  }
  beginDrawing({
    transform: e,
    viewport: t,
    transparency: s = !1,
    background: i = null
  }) {
    const r = this.ctx.canvas.width, n = this.ctx.canvas.height, a = this.ctx.fillStyle;
    if (this.ctx.fillStyle = i || "#ffffff", this.ctx.fillRect(0, 0, r, n), this.ctx.fillStyle = a, s) {
      const h = this.cachedCanvases.getCanvas("transparent", r, n);
      this.compositeCtx = this.ctx, this.transparentCanvas = h.canvas, this.ctx = h.context, this.ctx.save(), this.ctx.transform(...Gt(this.compositeCtx));
    }
    this.ctx.save(), gc(this.ctx), e && (this.ctx.transform(...e), this.outputScaleX = e[0], this.outputScaleY = e[0]), this.ctx.transform(...t.transform), this.viewportScale = t.scale, this.baseTransform = Gt(this.ctx);
  }
  executeOperatorList(e, t, s, i) {
    const r = e.argsArray, n = e.fnArray;
    let a = t || 0;
    const h = r.length;
    if (h === a)
      return a;
    const c = h - a > Rg && typeof s == "function", d = c ? Date.now() + Ww : 0;
    let u = 0;
    const f = this.commonObjs, p = this.objs;
    let m;
    for (; ; ) {
      if (i !== void 0 && a === i.nextBreakPoint)
        return i.breakIt(a, s), a;
      if (m = n[a], m !== ls.dependency)
        this[m].apply(this, r[a]);
      else
        for (const g of r[a]) {
          const w = g.startsWith("g_") ? f : p;
          if (!w.has(g))
            return w.get(g, s), a;
        }
      if (a++, a === h)
        return a;
      if (c && ++u > Rg) {
        if (Date.now() > d)
          return s(), a;
        u = 0;
      }
    }
  }
  endDrawing() {
    x(this, zl, Kf).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
    for (const e of this._cachedBitmapsMap.values()) {
      for (const t of e.values())
        typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement && (t.width = t.height = 0);
      e.clear();
    }
    this._cachedBitmapsMap.clear(), x(this, Bl, Zf).call(this);
  }
  _scaleImage(e, t) {
    const s = e.width ?? e.displayWidth, i = e.height ?? e.displayHeight;
    let r = Math.max(Math.hypot(t[0], t[1]), 1), n = Math.max(Math.hypot(t[2], t[3]), 1), a = s, h = i, c = "prescale1", d, u;
    for (; r > 2 && a > 1 || n > 2 && h > 1; ) {
      let f = a, p = h;
      r > 2 && a > 1 && (f = a >= 16384 ? Math.floor(a / 2) - 1 || 1 : Math.ceil(a / 2), r /= a / f), n > 2 && h > 1 && (p = h >= 16384 ? Math.floor(h / 2) - 1 || 1 : Math.ceil(h) / 2, n /= h / p), d = this.cachedCanvases.getCanvas(c, f, p), u = d.context, u.clearRect(0, 0, f, p), u.drawImage(e, 0, 0, a, h, 0, 0, f, p), e = d.canvas, a = f, h = p, c = c === "prescale1" ? "prescale2" : "prescale1";
    }
    return {
      img: e,
      paintWidth: a,
      paintHeight: h
    };
  }
  _createMaskCanvas(e) {
    const t = this.ctx, {
      width: s,
      height: i
    } = e, r = this.current.fillColor, n = this.current.patternFill, a = Gt(t);
    let h, c, d, u;
    if ((e.bitmap || e.data) && e.count > 1) {
      const M = e.bitmap || e.data.buffer;
      c = JSON.stringify(n ? a : [a.slice(0, 4), r]), h = this._cachedBitmapsMap.get(M), h || (h = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(M, h));
      const S = h.get(c);
      if (S && !n) {
        const L = Math.round(Math.min(a[0], a[2]) + a[4]), H = Math.round(Math.min(a[1], a[3]) + a[5]);
        return {
          canvas: S,
          offsetX: L,
          offsetY: H
        };
      }
      d = S;
    }
    d || (u = this.cachedCanvases.getCanvas("maskCanvas", s, i), zg(u.context, e));
    let f = pt.transform(a, [1 / s, 0, 0, -1 / i, 0, 0]);
    f = pt.transform(f, [1, 0, 0, 1, 0, -i]);
    const [p, m, g, w] = pt.getAxialAlignedBoundingBox([0, 0, s, i], f), b = Math.round(g - p) || 1, _ = Math.round(w - m) || 1, k = this.cachedCanvases.getCanvas("fillCanvas", b, _), C = k.context, N = p, R = m;
    C.translate(-N, -R), C.transform(...f), d || (d = this._scaleImage(u.canvas, Vs(C)), d = d.img, h && n && h.set(c, d)), C.imageSmoothingEnabled = Bg(Gt(C), e.interpolate), pc(C, d, 0, 0, d.width, d.height, 0, 0, s, i), C.globalCompositeOperation = "source-in";
    const P = pt.transform(Vs(C), [1, 0, 0, 1, -N, -R]);
    return C.fillStyle = n ? r.getPattern(t, this, P, De.FILL) : r, C.fillRect(0, 0, s, i), h && !n && (this.cachedCanvases.delete("fillCanvas"), h.set(c, k.canvas)), {
      canvas: k.canvas,
      offsetX: Math.round(N),
      offsetY: Math.round(R)
    };
  }
  setLineWidth(e) {
    e !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = e, this.ctx.lineWidth = e;
  }
  setLineCap(e) {
    this.ctx.lineCap = Yw[e];
  }
  setLineJoin(e) {
    this.ctx.lineJoin = Xw[e];
  }
  setMiterLimit(e) {
    this.ctx.miterLimit = e;
  }
  setDash(e, t) {
    const s = this.ctx;
    s.setLineDash !== void 0 && (s.setLineDash(e), s.lineDashOffset = t);
  }
  setRenderingIntent(e) {
  }
  setFlatness(e) {
  }
  setGState(e) {
    for (const [t, s] of e)
      switch (t) {
        case "LW":
          this.setLineWidth(s);
          break;
        case "LC":
          this.setLineCap(s);
          break;
        case "LJ":
          this.setLineJoin(s);
          break;
        case "ML":
          this.setMiterLimit(s);
          break;
        case "D":
          this.setDash(s[0], s[1]);
          break;
        case "RI":
          this.setRenderingIntent(s);
          break;
        case "FL":
          this.setFlatness(s);
          break;
        case "Font":
          this.setFont(s[0], s[1]);
          break;
        case "CA":
          this.current.strokeAlpha = s;
          break;
        case "ca":
          this.current.fillAlpha = s, this.ctx.globalAlpha = s;
          break;
        case "BM":
          this.ctx.globalCompositeOperation = s;
          break;
        case "SMask":
          this.current.activeSMask = s ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
          break;
        case "TR":
          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(s);
          break;
      }
  }
  get inSMaskMode() {
    return !!this.suspendedCtx;
  }
  checkSMaskState() {
    const e = this.inSMaskMode;
    this.current.activeSMask && !e ? this.beginSMaskMode() : !this.current.activeSMask && e && this.endSMaskMode();
  }
  beginSMaskMode() {
    if (this.inSMaskMode)
      throw new Error("beginSMaskMode called while already in smask mode");
    const e = this.ctx.canvas.width, t = this.ctx.canvas.height, s = "smaskGroupAt" + this.groupLevel, i = this.cachedCanvases.getCanvas(s, e, t);
    this.suspendedCtx = this.ctx, this.ctx = i.context;
    const r = this.ctx;
    r.setTransform(...Gt(this.suspendedCtx)), Do(this.suspendedCtx, r), $w(r, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }
  endSMaskMode() {
    if (!this.inSMaskMode)
      throw new Error("endSMaskMode called while not in smask mode");
    this.ctx._removeMirroring(), Do(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
  }
  compose(e) {
    if (!this.current.activeSMask)
      return;
    e ? (e[0] = Math.floor(e[0]), e[1] = Math.floor(e[1]), e[2] = Math.ceil(e[2]), e[3] = Math.ceil(e[3])) : e = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    const t = this.current.activeSMask, s = this.suspendedCtx;
    this.composeSMask(s, t, this.ctx, e), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
  }
  composeSMask(e, t, s, i) {
    const r = i[0], n = i[1], a = i[2] - r, h = i[3] - n;
    a === 0 || h === 0 || (this.genericComposeSMask(t.context, s, a, h, t.subtype, t.backdrop, t.transferMap, r, n, t.offsetX, t.offsetY), e.save(), e.globalAlpha = 1, e.globalCompositeOperation = "source-over", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(s.canvas, 0, 0), e.restore());
  }
  genericComposeSMask(e, t, s, i, r, n, a, h, c, d, u) {
    let f = e.canvas, p = h - d, m = c - u;
    if (n) {
      const w = pt.makeHexColor(...n);
      if (p < 0 || m < 0 || p + s > f.width || m + i > f.height) {
        const b = this.cachedCanvases.getCanvas("maskExtension", s, i), _ = b.context;
        _.drawImage(f, -p, -m), _.globalCompositeOperation = "destination-atop", _.fillStyle = w, _.fillRect(0, 0, s, i), _.globalCompositeOperation = "source-over", f = b.canvas, p = m = 0;
      } else {
        e.save(), e.globalAlpha = 1, e.setTransform(1, 0, 0, 1, 0, 0);
        const b = new Path2D();
        b.rect(p, m, s, i), e.clip(b), e.globalCompositeOperation = "destination-atop", e.fillStyle = w, e.fillRect(p, m, s, i), e.restore();
      }
    }
    t.save(), t.globalAlpha = 1, t.setTransform(1, 0, 0, 1, 0, 0), r === "Alpha" && a ? t.filter = this.filterFactory.addAlphaFilter(a) : r === "Luminosity" && (t.filter = this.filterFactory.addLuminosityFilter(a));
    const g = new Path2D();
    g.rect(h, c, s, i), t.clip(g), t.globalCompositeOperation = "destination-in", t.drawImage(f, p, m, s, i, h, c, s, i), t.restore();
  }
  save() {
    this.inSMaskMode ? (Do(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
    const e = this.current;
    this.stateStack.push(e), this.current = e.clone();
  }
  restore() {
    this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), Do(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
  }
  transform(e, t, s, i, r, n) {
    this.ctx.transform(e, t, s, i, r, n), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
  }
  constructPath(e, t, s) {
    const i = this.ctx, r = this.current;
    let n = r.x, a = r.y, h, c;
    const d = Gt(i), u = d[0] === 0 && d[3] === 0 || d[1] === 0 && d[2] === 0, f = u ? s.slice(0) : null;
    for (let p = 0, m = 0, g = e.length; p < g; p++)
      switch (e[p] | 0) {
        case ls.rectangle:
          n = t[m++], a = t[m++];
          const w = t[m++], b = t[m++], _ = n + w, k = a + b;
          i.moveTo(n, a), w === 0 || b === 0 ? i.lineTo(_, k) : (i.lineTo(_, a), i.lineTo(_, k), i.lineTo(n, k)), u || r.updateRectMinMax(d, [n, a, _, k]), i.closePath();
          break;
        case ls.moveTo:
          n = t[m++], a = t[m++], i.moveTo(n, a), u || r.updatePathMinMax(d, n, a);
          break;
        case ls.lineTo:
          n = t[m++], a = t[m++], i.lineTo(n, a), u || r.updatePathMinMax(d, n, a);
          break;
        case ls.curveTo:
          h = n, c = a, n = t[m + 4], a = t[m + 5], i.bezierCurveTo(t[m], t[m + 1], t[m + 2], t[m + 3], n, a), r.updateCurvePathMinMax(d, h, c, t[m], t[m + 1], t[m + 2], t[m + 3], n, a, f), m += 6;
          break;
        case ls.curveTo2:
          h = n, c = a, i.bezierCurveTo(n, a, t[m], t[m + 1], t[m + 2], t[m + 3]), r.updateCurvePathMinMax(d, h, c, n, a, t[m], t[m + 1], t[m + 2], t[m + 3], f), n = t[m + 2], a = t[m + 3], m += 4;
          break;
        case ls.curveTo3:
          h = n, c = a, n = t[m + 2], a = t[m + 3], i.bezierCurveTo(t[m], t[m + 1], n, a, n, a), r.updateCurvePathMinMax(d, h, c, t[m], t[m + 1], n, a, n, a, f), m += 4;
          break;
        case ls.closePath:
          i.closePath();
          break;
      }
    u && r.updateScalingPathMinMax(d, f), r.setCurrentPoint(n, a);
  }
  closePath() {
    this.ctx.closePath();
  }
  stroke(e = !0) {
    const t = this.ctx, s = this.current.strokeColor;
    t.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof s == "object" && (s != null && s.getPattern) ? (t.save(), t.strokeStyle = s.getPattern(t, this, Vs(t), De.STROKE), this.rescaleAndStroke(!1), t.restore()) : this.rescaleAndStroke(!0)), e && this.consumePath(this.current.getClippedPathBoundingBox()), t.globalAlpha = this.current.fillAlpha;
  }
  closeStroke() {
    this.closePath(), this.stroke();
  }
  fill(e = !0) {
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    let r = !1;
    i && (t.save(), t.fillStyle = s.getPattern(t, this, Vs(t), De.FILL), r = !0);
    const n = this.current.getClippedPathBoundingBox();
    this.contentVisible && n !== null && (this.pendingEOFill ? (t.fill("evenodd"), this.pendingEOFill = !1) : t.fill()), r && t.restore(), e && this.consumePath(n);
  }
  eoFill() {
    this.pendingEOFill = !0, this.fill();
  }
  fillStroke() {
    this.fill(!1), this.stroke(!1), this.consumePath();
  }
  eoFillStroke() {
    this.pendingEOFill = !0, this.fillStroke();
  }
  closeFillStroke() {
    this.closePath(), this.fillStroke();
  }
  closeEOFillStroke() {
    this.pendingEOFill = !0, this.closePath(), this.fillStroke();
  }
  endPath() {
    this.consumePath();
  }
  clip() {
    this.pendingClip = qw;
  }
  eoClip() {
    this.pendingClip = Ug;
  }
  beginText() {
    this.current.textMatrix = Cm, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  endText() {
    const e = this.pendingTextPaths, t = this.ctx;
    if (e === void 0) {
      t.beginPath();
      return;
    }
    t.save(), t.beginPath();
    for (const s of e)
      t.setTransform(...s.transform), t.translate(s.x, s.y), s.addToPath(t, s.fontSize);
    t.restore(), t.clip(), t.beginPath(), delete this.pendingTextPaths;
  }
  setCharSpacing(e) {
    this.current.charSpacing = e;
  }
  setWordSpacing(e) {
    this.current.wordSpacing = e;
  }
  setHScale(e) {
    this.current.textHScale = e / 100;
  }
  setLeading(e) {
    this.current.leading = -e;
  }
  setFont(e, t) {
    var d;
    const s = this.commonObjs.get(e), i = this.current;
    if (!s)
      throw new Error(`Can't find font for ${e}`);
    if (i.fontMatrix = s.fontMatrix || _f, (i.fontMatrix[0] === 0 || i.fontMatrix[3] === 0) && xt("Invalid font matrix for font " + e), t < 0 ? (t = -t, i.fontDirection = -1) : i.fontDirection = 1, this.current.font = s, this.current.fontSize = t, s.isType3Font)
      return;
    const r = s.loadedName || "sans-serif", n = ((d = s.systemFontInfo) == null ? void 0 : d.css) || `"${r}", ${s.fallbackName}`;
    let a = "normal";
    s.black ? a = "900" : s.bold && (a = "bold");
    const h = s.italic ? "italic" : "normal";
    let c = t;
    t < Pg ? c = Pg : t > Lg && (c = Lg), this.current.fontSizeScale = t / c, this.ctx.font = `${h} ${a} ${c}px ${n}`;
  }
  setTextRenderingMode(e) {
    this.current.textRenderingMode = e;
  }
  setTextRise(e) {
    this.current.textRise = e;
  }
  moveText(e, t) {
    this.current.x = this.current.lineX += e, this.current.y = this.current.lineY += t;
  }
  setLeadingMoveText(e, t) {
    this.setLeading(-t), this.moveText(e, t);
  }
  setTextMatrix(e, t, s, i, r, n) {
    this.current.textMatrix = [e, t, s, i, r, n], this.current.textMatrixScale = Math.hypot(e, t), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
  }
  nextLine() {
    this.moveText(0, this.current.leading);
  }
  paintChar(e, t, s, i) {
    const r = this.ctx, n = this.current, a = n.font, h = n.textRenderingMode, c = n.fontSize / n.fontSizeScale, d = h & Ae.FILL_STROKE_MASK, u = !!(h & Ae.ADD_TO_PATH_FLAG), f = n.patternFill && !a.missingFile;
    let p;
    (a.disableFontFace || u || f) && (p = a.getPathGenerator(this.commonObjs, e)), a.disableFontFace || f ? (r.save(), r.translate(t, s), r.beginPath(), p(r, c), i && r.setTransform(...i), (d === Ae.FILL || d === Ae.FILL_STROKE) && r.fill(), (d === Ae.STROKE || d === Ae.FILL_STROKE) && r.stroke(), r.restore()) : ((d === Ae.FILL || d === Ae.FILL_STROKE) && r.fillText(e, t, s), (d === Ae.STROKE || d === Ae.FILL_STROKE) && r.strokeText(e, t, s)), u && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
      transform: Gt(r),
      x: t,
      y: s,
      fontSize: c,
      addToPath: p
    });
  }
  get isFontSubpixelAAEnabled() {
    const {
      context: e
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    e.scale(1.5, 1), e.fillText("I", 0, 10);
    const t = e.getImageData(0, 0, 10, 10).data;
    let s = !1;
    for (let i = 3; i < t.length; i += 4)
      if (t[i] > 0 && t[i] < 255) {
        s = !0;
        break;
      }
    return Mt(this, "isFontSubpixelAAEnabled", s);
  }
  showText(e) {
    const t = this.current, s = t.font;
    if (s.isType3Font)
      return this.showType3Text(e);
    const i = t.fontSize;
    if (i === 0)
      return;
    const r = this.ctx, n = t.fontSizeScale, a = t.charSpacing, h = t.wordSpacing, c = t.fontDirection, d = t.textHScale * c, u = e.length, f = s.vertical, p = f ? 1 : -1, m = s.defaultVMetrics, g = i * t.fontMatrix[0], w = t.textRenderingMode === Ae.FILL && !s.disableFontFace && !t.patternFill;
    r.save(), r.transform(...t.textMatrix), r.translate(t.x, t.y + t.textRise), c > 0 ? r.scale(d, -1) : r.scale(d, 1);
    let b;
    if (t.patternFill) {
      r.save();
      const R = t.fillColor.getPattern(r, this, Vs(r), De.FILL);
      b = Gt(r), r.restore(), r.fillStyle = R;
    }
    let _ = t.lineWidth;
    const k = t.textMatrixScale;
    if (k === 0 || _ === 0) {
      const R = t.textRenderingMode & Ae.FILL_STROKE_MASK;
      (R === Ae.STROKE || R === Ae.FILL_STROKE) && (_ = this.getSinglePixelWidth());
    } else
      _ /= k;
    if (n !== 1 && (r.scale(n, n), _ /= n), r.lineWidth = _, s.isInvalidPDFjsFont) {
      const R = [];
      let P = 0;
      for (const M of e)
        R.push(M.unicode), P += M.width;
      r.fillText(R.join(""), 0, 0), t.x += P * g * d, r.restore(), this.compose();
      return;
    }
    let C = 0, N;
    for (N = 0; N < u; ++N) {
      const R = e[N];
      if (typeof R == "number") {
        C += p * R * i / 1e3;
        continue;
      }
      let P = !1;
      const M = (R.isSpace ? h : 0) + a, S = R.fontChar, L = R.accent;
      let H, I, F = R.width;
      if (f) {
        const G = R.vmetric || m, et = -(R.vmetric ? G[1] : F * 0.5) * g, z = G[2] * g;
        F = G ? -G[0] : F, H = et / n, I = (C + z) / n;
      } else
        H = C / n, I = 0;
      if (s.remeasure && F > 0) {
        const G = r.measureText(S).width * 1e3 / i * n;
        if (F < G && this.isFontSubpixelAAEnabled) {
          const et = F / G;
          P = !0, r.save(), r.scale(et, 1), H /= et;
        } else
          F !== G && (H += (F - G) / 2e3 * i / n);
      }
      if (this.contentVisible && (R.isInFont || s.missingFile)) {
        if (w && !L)
          r.fillText(S, H, I);
        else if (this.paintChar(S, H, I, b), L) {
          const G = H + i * L.offset.x / n, et = I - i * L.offset.y / n;
          this.paintChar(L.fontChar, G, et, b);
        }
      }
      const A = f ? F * g - M * c : F * g + M * c;
      C += A, P && r.restore();
    }
    f ? t.y -= C : t.x += C * d, r.restore(), this.compose();
  }
  showType3Text(e) {
    const t = this.ctx, s = this.current, i = s.font, r = s.fontSize, n = s.fontDirection, a = i.vertical ? 1 : -1, h = s.charSpacing, c = s.wordSpacing, d = s.textHScale * n, u = s.fontMatrix || _f, f = e.length, p = s.textRenderingMode === Ae.INVISIBLE;
    let m, g, w, b;
    if (!(p || r === 0)) {
      for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, t.save(), t.transform(...s.textMatrix), t.translate(s.x, s.y), t.scale(d, n), m = 0; m < f; ++m) {
        if (g = e[m], typeof g == "number") {
          b = a * g * r / 1e3, this.ctx.translate(b, 0), s.x += b * d;
          continue;
        }
        const _ = (g.isSpace ? c : 0) + h, k = i.charProcOperatorList[g.operatorListId];
        if (!k) {
          xt(`Type3 character "${g.operatorListId}" is not available.`);
          continue;
        }
        this.contentVisible && (this.processingType3 = g, this.save(), t.scale(r, r), t.transform(...u), this.executeOperatorList(k), this.restore()), w = pt.applyTransform([g.width, 0], u)[0] * r + _, t.translate(w, 0), s.x += w * d;
      }
      t.restore(), this.processingType3 = null;
    }
  }
  setCharWidth(e, t) {
  }
  setCharWidthAndBounds(e, t, s, i, r, n) {
    this.ctx.rect(s, i, r - s, n - i), this.ctx.clip(), this.endPath();
  }
  getColorN_Pattern(e) {
    let t;
    if (e[0] === "TilingPattern") {
      const s = e[1], i = this.baseTransform || Gt(this.ctx), r = {
        createCanvasGraphics: (n) => new cg(n, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig: this.optionalContentConfig,
          markedContentStack: this.markedContentStack
        })
      };
      t = new Qf(e, s, this.ctx, r, i);
    } else
      t = this._getPattern(e[1], e[2]);
    return t;
  }
  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }
  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
  }
  setStrokeRGBColor(e, t, s) {
    this.ctx.strokeStyle = this.current.strokeColor = pt.makeHexColor(e, t, s);
  }
  setStrokeTransparent() {
    this.ctx.strokeStyle = this.current.strokeColor = "transparent";
  }
  setFillRGBColor(e, t, s) {
    this.ctx.fillStyle = this.current.fillColor = pt.makeHexColor(e, t, s), this.current.patternFill = !1;
  }
  setFillTransparent() {
    this.ctx.fillStyle = this.current.fillColor = "transparent", this.current.patternFill = !1;
  }
  _getPattern(e, t = null) {
    let s;
    return this.cachedPatterns.has(e) ? s = this.cachedPatterns.get(e) : (s = Uw(this.getObject(e)), this.cachedPatterns.set(e, s)), t && (s.matrix = t), s;
  }
  shadingFill(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx;
    this.save();
    const s = this._getPattern(e);
    t.fillStyle = s.getPattern(t, this, Vs(t), De.SHADING);
    const i = Vs(t);
    if (i) {
      const {
        width: r,
        height: n
      } = t.canvas, [a, h, c, d] = pt.getAxialAlignedBoundingBox([0, 0, r, n], i);
      this.ctx.fillRect(a, h, c - a, d - h);
    } else
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    this.compose(this.current.getClippedPathBoundingBox()), this.restore();
  }
  beginInlineImage() {
    Bt("Should not call beginInlineImage");
  }
  beginImageData() {
    Bt("Should not call beginImageData");
  }
  paintFormXObjectBegin(e, t) {
    if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), e && this.transform(...e), this.baseTransform = Gt(this.ctx), t)) {
      const s = t[2] - t[0], i = t[3] - t[1];
      this.ctx.rect(t[0], t[1], s, i), this.current.updateRectMinMax(Gt(this.ctx), t), this.clip(), this.endPath();
    }
  }
  paintFormXObjectEnd() {
    this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
  }
  beginGroup(e) {
    if (!this.contentVisible)
      return;
    this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
    const t = this.ctx;
    e.isolated || Ju("TODO: Support non-isolated groups."), e.knockout && xt("Knockout groups not supported.");
    const s = Gt(t);
    if (e.matrix && t.transform(...e.matrix), !e.bbox)
      throw new Error("Bounding box is required.");
    let i = pt.getAxialAlignedBoundingBox(e.bbox, Gt(t));
    const r = [0, 0, t.canvas.width, t.canvas.height];
    i = pt.intersect(i, r) || [0, 0, 0, 0];
    const n = Math.floor(i[0]), a = Math.floor(i[1]), h = Math.max(Math.ceil(i[2]) - n, 1), c = Math.max(Math.ceil(i[3]) - a, 1);
    this.current.startNewPathAndClipBox([0, 0, h, c]);
    let d = "groupAt" + this.groupLevel;
    e.smask && (d += "_smask_" + this.smaskCounter++ % 2);
    const u = this.cachedCanvases.getCanvas(d, h, c), f = u.context;
    f.translate(-n, -a), f.transform(...s), e.smask ? this.smaskStack.push({
      canvas: u.canvas,
      context: f,
      offsetX: n,
      offsetY: a,
      subtype: e.smask.subtype,
      backdrop: e.smask.backdrop,
      transferMap: e.smask.transferMap || null,
      startTransformInverse: null
    }) : (t.setTransform(1, 0, 0, 1, 0, 0), t.translate(n, a), t.save()), Do(t, f), this.ctx = f, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(t), this.groupLevel++;
  }
  endGroup(e) {
    if (!this.contentVisible)
      return;
    this.groupLevel--;
    const t = this.ctx, s = this.groupStack.pop();
    if (this.ctx = s, this.ctx.imageSmoothingEnabled = !1, e.smask)
      this.tempSMask = this.smaskStack.pop(), this.restore();
    else {
      this.ctx.restore();
      const i = Gt(this.ctx);
      this.restore(), this.ctx.save(), this.ctx.setTransform(...i);
      const r = pt.getAxialAlignedBoundingBox([0, 0, t.canvas.width, t.canvas.height], i);
      this.ctx.drawImage(t.canvas, 0, 0), this.ctx.restore(), this.compose(r);
    }
  }
  beginAnnotation(e, t, s, i, r) {
    if (x(this, zl, Kf).call(this), gc(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), t) {
      const n = t[2] - t[0], a = t[3] - t[1];
      if (r && this.annotationCanvasMap) {
        s = s.slice(), s[4] -= t[0], s[5] -= t[1], t = t.slice(), t[0] = t[1] = 0, t[2] = n, t[3] = a;
        const [h, c] = pt.singularValueDecompose2dScale(Gt(this.ctx)), {
          viewportScale: d
        } = this, u = Math.ceil(n * this.outputScaleX * d), f = Math.ceil(a * this.outputScaleY * d);
        this.annotationCanvas = this.canvasFactory.create(u, f);
        const {
          canvas: p,
          context: m
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(e, p), this.annotationCanvas.savedCtx = this.ctx, this.ctx = m, this.ctx.save(), this.ctx.setTransform(h, 0, 0, -c, 0, a * c), gc(this.ctx);
      } else
        gc(this.ctx), this.endPath(), this.ctx.rect(t[0], t[1], n, a), this.ctx.clip(), this.ctx.beginPath();
    }
    this.current = new Fg(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...s), this.transform(...i);
  }
  endAnnotation() {
    this.annotationCanvas && (this.ctx.restore(), x(this, Bl, Zf).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
  }
  paintImageMaskXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.count;
    e = this.getObject(e.data, e), e.count = t;
    const s = this.ctx, i = this.processingType3;
    if (i && (i.compiled === void 0 && (i.compiled = Vw(e)), i.compiled)) {
      i.compiled(s);
      return;
    }
    const r = this._createMaskCanvas(e), n = r.canvas;
    s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.drawImage(n, r.offsetX, r.offsetY), s.restore(), this.compose();
  }
  paintImageMaskXObjectRepeat(e, t, s = 0, i = 0, r, n) {
    if (!this.contentVisible)
      return;
    e = this.getObject(e.data, e);
    const a = this.ctx;
    a.save();
    const h = Gt(a);
    a.transform(t, s, i, r, 0, 0);
    const c = this._createMaskCanvas(e);
    a.setTransform(1, 0, 0, 1, c.offsetX - h[4], c.offsetY - h[5]);
    for (let d = 0, u = n.length; d < u; d += 2) {
      const f = pt.transform(h, [t, s, i, r, n[d], n[d + 1]]), [p, m] = pt.applyTransform([0, 0], f);
      a.drawImage(c.canvas, p, m);
    }
    a.restore(), this.compose();
  }
  paintImageMaskXObjectGroup(e) {
    if (!this.contentVisible)
      return;
    const t = this.ctx, s = this.current.fillColor, i = this.current.patternFill;
    for (const r of e) {
      const {
        data: n,
        width: a,
        height: h,
        transform: c
      } = r, d = this.cachedCanvases.getCanvas("maskCanvas", a, h), u = d.context;
      u.save();
      const f = this.getObject(n, r);
      zg(u, f), u.globalCompositeOperation = "source-in", u.fillStyle = i ? s.getPattern(u, this, Vs(t), De.FILL) : s, u.fillRect(0, 0, a, h), u.restore(), t.save(), t.transform(...c), t.scale(1, -1), pc(t, d.canvas, 0, 0, a, h, 0, -1, 1, 1), t.restore();
    }
    this.compose();
  }
  paintImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = this.getObject(e);
    if (!t) {
      xt("Dependent image isn't ready yet");
      return;
    }
    this.paintInlineImageXObject(t);
  }
  paintImageXObjectRepeat(e, t, s, i) {
    if (!this.contentVisible)
      return;
    const r = this.getObject(e);
    if (!r) {
      xt("Dependent image isn't ready yet");
      return;
    }
    const n = r.width, a = r.height, h = [];
    for (let c = 0, d = i.length; c < d; c += 2)
      h.push({
        transform: [t, 0, 0, s, i[c], i[c + 1]],
        x: 0,
        y: 0,
        w: n,
        h: a
      });
    this.paintInlineImageXObjectGroup(r, h);
  }
  applyTransferMapsToCanvas(e) {
    return this.current.transferMaps !== "none" && (e.filter = this.current.transferMaps, e.drawImage(e.canvas, 0, 0), e.filter = "none"), e.canvas;
  }
  applyTransferMapsToBitmap(e) {
    if (this.current.transferMaps === "none")
      return e.bitmap;
    const {
      bitmap: t,
      width: s,
      height: i
    } = e, r = this.cachedCanvases.getCanvas("inlineImage", s, i), n = r.context;
    return n.filter = this.current.transferMaps, n.drawImage(t, 0, 0), n.filter = "none", r.canvas;
  }
  paintInlineImageXObject(e) {
    if (!this.contentVisible)
      return;
    const t = e.width, s = e.height, i = this.ctx;
    if (this.save(), !Ce) {
      const {
        filter: a
      } = i;
      a !== "none" && a !== "" && (i.filter = "none");
    }
    i.scale(1 / t, -1 / s);
    let r;
    if (e.bitmap)
      r = this.applyTransferMapsToBitmap(e);
    else if (typeof HTMLElement == "function" && e instanceof HTMLElement || !e.data)
      r = e;
    else {
      const h = this.cachedCanvases.getCanvas("inlineImage", t, s).context;
      jg(h, e), r = this.applyTransferMapsToCanvas(h);
    }
    const n = this._scaleImage(r, Vs(i));
    i.imageSmoothingEnabled = Bg(Gt(i), e.interpolate), pc(i, n.img, 0, 0, n.paintWidth, n.paintHeight, 0, -s, t, s), this.compose(), this.restore();
  }
  paintInlineImageXObjectGroup(e, t) {
    if (!this.contentVisible)
      return;
    const s = this.ctx;
    let i;
    if (e.bitmap)
      i = e.bitmap;
    else {
      const r = e.width, n = e.height, h = this.cachedCanvases.getCanvas("inlineImage", r, n).context;
      jg(h, e), i = this.applyTransferMapsToCanvas(h);
    }
    for (const r of t)
      s.save(), s.transform(...r.transform), s.scale(1, -1), pc(s, i, r.x, r.y, r.w, r.h, 0, -1, 1, 1), s.restore();
    this.compose();
  }
  paintSolidColorImageMask() {
    this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
  }
  markPoint(e) {
  }
  markPointProps(e, t) {
  }
  beginMarkedContent(e) {
    this.markedContentStack.push({
      visible: !0
    });
  }
  beginMarkedContentProps(e, t) {
    e === "OC" ? this.markedContentStack.push({
      visible: this.optionalContentConfig.isVisible(t)
    }) : this.markedContentStack.push({
      visible: !0
    }), this.contentVisible = this.isContentVisible();
  }
  endMarkedContent() {
    this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
  }
  beginCompat() {
  }
  endCompat() {
  }
  consumePath(e) {
    const t = this.current.isEmptyClip();
    this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(e);
    const s = this.ctx;
    this.pendingClip && (t || (this.pendingClip === Ug ? s.clip("evenodd") : s.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), s.beginPath();
  }
  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const e = Gt(this.ctx);
      if (e[1] === 0 && e[2] === 0)
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e[0]), Math.abs(e[3]));
      else {
        const t = Math.abs(e[0] * e[3] - e[2] * e[1]), s = Math.hypot(e[0], e[2]), i = Math.hypot(e[1], e[3]);
        this._cachedGetSinglePixelWidth = Math.max(s, i) / t;
      }
    }
    return this._cachedGetSinglePixelWidth;
  }
  getScaleForStroking() {
    if (this._cachedScaleForStroking[0] === -1) {
      const {
        lineWidth: e
      } = this.current, {
        a: t,
        b: s,
        c: i,
        d: r
      } = this.ctx.getTransform();
      let n, a;
      if (s === 0 && i === 0) {
        const h = Math.abs(t), c = Math.abs(r);
        if (h === c)
          if (e === 0)
            n = a = 1 / h;
          else {
            const d = h * e;
            n = a = d < 1 ? 1 / d : 1;
          }
        else if (e === 0)
          n = 1 / h, a = 1 / c;
        else {
          const d = h * e, u = c * e;
          n = d < 1 ? 1 / d : 1, a = u < 1 ? 1 / u : 1;
        }
      } else {
        const h = Math.abs(t * r - s * i), c = Math.hypot(t, s), d = Math.hypot(i, r);
        if (e === 0)
          n = d / h, a = c / h;
        else {
          const u = e * h;
          n = d > u ? d / u : 1, a = c > u ? c / u : 1;
        }
      }
      this._cachedScaleForStroking[0] = n, this._cachedScaleForStroking[1] = a;
    }
    return this._cachedScaleForStroking;
  }
  rescaleAndStroke(e) {
    const {
      ctx: t
    } = this, {
      lineWidth: s
    } = this.current, [i, r] = this.getScaleForStroking();
    if (t.lineWidth = s || 1, i === 1 && r === 1) {
      t.stroke();
      return;
    }
    const n = t.getLineDash();
    if (e && t.save(), t.scale(i, r), n.length > 0) {
      const a = Math.max(i, r);
      t.setLineDash(n.map((h) => h / a)), t.lineDashOffset /= a;
    }
    t.stroke(), e && t.restore();
  }
  isContentVisible() {
    for (let e = this.markedContentStack.length - 1; e >= 0; e--)
      if (!this.markedContentStack[e].visible)
        return !1;
    return !0;
  }
};
zl = new WeakSet(), Kf = function() {
  for (; this.stateStack.length || this.inSMaskMode; )
    this.restore();
  this.current.activeSMask = null, this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
}, Bl = new WeakSet(), Zf = function() {
  if (this.pageColors) {
    const e = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
    if (e !== "none") {
      const t = this.ctx.filter;
      this.ctx.filter = e, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = t;
    }
  }
};
let Zn = cg;
for (const l in ls)
  Zn.prototype[l] !== void 0 && (Zn.prototype[ls[l]] = Zn.prototype[l]);
var Ul, Hl;
class xi {
  static get workerPort() {
    return o(this, Ul);
  }
  static set workerPort(e) {
    if (!(typeof Worker < "u" && e instanceof Worker) && e !== null)
      throw new Error("Invalid `workerPort` type.");
    E(this, Ul, e);
  }
  static get workerSrc() {
    return o(this, Hl);
  }
  static set workerSrc(e) {
    if (typeof e != "string")
      throw new Error("Invalid `workerSrc` type.");
    E(this, Hl, e);
  }
}
Ul = new WeakMap(), Hl = new WeakMap(), y(xi, Ul, null), y(xi, Hl, "");
const mc = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
}, te = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};
function Ue(l) {
  switch (l instanceof Error || typeof l == "object" && l !== null || Bt('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), l.name) {
    case "AbortException":
      return new Un(l.message);
    case "MissingPDFException":
      return new Bn(l.message);
    case "PasswordException":
      return new Ef(l.message, l.code);
    case "UnexpectedResponseException":
      return new tf(l.message, l.status);
    case "UnknownErrorException":
      return new xf(l.message, l.details);
    default:
      return new xf(l.message, l.toString());
  }
}
var _a, Fd, ub, jd, fb, zd, pb, Ea, Tc;
class Ho {
  constructor(e, t, s) {
    y(this, Fd);
    y(this, jd);
    y(this, zd);
    y(this, Ea);
    y(this, _a, new AbortController());
    this.sourceName = e, this.targetName = t, this.comObj = s, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), s.addEventListener("message", x(this, Fd, ub).bind(this), {
      signal: o(this, _a).signal
    });
  }
  on(e, t) {
    const s = this.actionHandler;
    if (s[e])
      throw new Error(`There is already an actionName called "${e}"`);
    s[e] = t;
  }
  send(e, t, s) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: e,
      data: t
    }, s);
  }
  sendWithPromise(e, t, s) {
    const i = this.callbackId++, r = Promise.withResolvers();
    this.callbackCapabilities[i] = r;
    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: e,
        callbackId: i,
        data: t
      }, s);
    } catch (n) {
      r.reject(n);
    }
    return r.promise;
  }
  sendWithStream(e, t, s, i) {
    const r = this.streamId++, n = this.sourceName, a = this.targetName, h = this.comObj;
    return new ReadableStream({
      start: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[r] = {
          controller: c,
          startCall: d,
          pullCall: null,
          cancelCall: null,
          isClosed: !1
        }, h.postMessage({
          sourceName: n,
          targetName: a,
          action: e,
          streamId: r,
          data: t,
          desiredSize: c.desiredSize
        }, i), d.promise;
      },
      pull: (c) => {
        const d = Promise.withResolvers();
        return this.streamControllers[r].pullCall = d, h.postMessage({
          sourceName: n,
          targetName: a,
          stream: te.PULL,
          streamId: r,
          desiredSize: c.desiredSize
        }), d.promise;
      },
      cancel: (c) => {
        ae(c instanceof Error, "cancel must have a valid reason");
        const d = Promise.withResolvers();
        return this.streamControllers[r].cancelCall = d, this.streamControllers[r].isClosed = !0, h.postMessage({
          sourceName: n,
          targetName: a,
          stream: te.CANCEL,
          streamId: r,
          reason: Ue(c)
        }), d.promise;
      }
    }, s);
  }
  destroy() {
    var e;
    (e = o(this, _a)) == null || e.abort(), E(this, _a, null);
  }
}
_a = new WeakMap(), Fd = new WeakSet(), ub = function({
  data: e
}) {
  if (e.targetName !== this.sourceName)
    return;
  if (e.stream) {
    x(this, zd, pb).call(this, e);
    return;
  }
  if (e.callback) {
    const s = e.callbackId, i = this.callbackCapabilities[s];
    if (!i)
      throw new Error(`Cannot resolve callback ${s}`);
    if (delete this.callbackCapabilities[s], e.callback === mc.DATA)
      i.resolve(e.data);
    else if (e.callback === mc.ERROR)
      i.reject(Ue(e.reason));
    else
      throw new Error("Unexpected callback case");
    return;
  }
  const t = this.actionHandler[e.action];
  if (!t)
    throw new Error(`Unknown action from worker: ${e.action}`);
  if (e.callbackId) {
    const s = this.sourceName, i = e.sourceName, r = this.comObj;
    new Promise(function(n) {
      n(t(e.data));
    }).then(function(n) {
      r.postMessage({
        sourceName: s,
        targetName: i,
        callback: mc.DATA,
        callbackId: e.callbackId,
        data: n
      });
    }, function(n) {
      r.postMessage({
        sourceName: s,
        targetName: i,
        callback: mc.ERROR,
        callbackId: e.callbackId,
        reason: Ue(n)
      });
    });
    return;
  }
  if (e.streamId) {
    x(this, jd, fb).call(this, e);
    return;
  }
  t(e.data);
}, jd = new WeakSet(), fb = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, r = this.comObj, n = this, a = this.actionHandler[e.action], h = {
    enqueue(c, d = 1, u) {
      if (this.isCancelled)
        return;
      const f = this.desiredSize;
      this.desiredSize -= d, f > 0 && this.desiredSize <= 0 && (this.sinkCapability = Promise.withResolvers(), this.ready = this.sinkCapability.promise), r.postMessage({
        sourceName: s,
        targetName: i,
        stream: te.ENQUEUE,
        streamId: t,
        chunk: c
      }, u);
    },
    close() {
      this.isCancelled || (this.isCancelled = !0, r.postMessage({
        sourceName: s,
        targetName: i,
        stream: te.CLOSE,
        streamId: t
      }), delete n.streamSinks[t]);
    },
    error(c) {
      ae(c instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, r.postMessage({
        sourceName: s,
        targetName: i,
        stream: te.ERROR,
        streamId: t,
        reason: Ue(c)
      }));
    },
    sinkCapability: Promise.withResolvers(),
    onPull: null,
    onCancel: null,
    isCancelled: !1,
    desiredSize: e.desiredSize,
    ready: null
  };
  h.sinkCapability.resolve(), h.ready = h.sinkCapability.promise, this.streamSinks[t] = h, new Promise(function(c) {
    c(a(e.data, h));
  }).then(function() {
    r.postMessage({
      sourceName: s,
      targetName: i,
      stream: te.START_COMPLETE,
      streamId: t,
      success: !0
    });
  }, function(c) {
    r.postMessage({
      sourceName: s,
      targetName: i,
      stream: te.START_COMPLETE,
      streamId: t,
      reason: Ue(c)
    });
  });
}, zd = new WeakSet(), pb = function(e) {
  const t = e.streamId, s = this.sourceName, i = e.sourceName, r = this.comObj, n = this.streamControllers[t], a = this.streamSinks[t];
  switch (e.stream) {
    case te.START_COMPLETE:
      e.success ? n.startCall.resolve() : n.startCall.reject(Ue(e.reason));
      break;
    case te.PULL_COMPLETE:
      e.success ? n.pullCall.resolve() : n.pullCall.reject(Ue(e.reason));
      break;
    case te.PULL:
      if (!a) {
        r.postMessage({
          sourceName: s,
          targetName: i,
          stream: te.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
        break;
      }
      a.desiredSize <= 0 && e.desiredSize > 0 && a.sinkCapability.resolve(), a.desiredSize = e.desiredSize, new Promise(function(h) {
        var c;
        h((c = a.onPull) == null ? void 0 : c.call(a));
      }).then(function() {
        r.postMessage({
          sourceName: s,
          targetName: i,
          stream: te.PULL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(h) {
        r.postMessage({
          sourceName: s,
          targetName: i,
          stream: te.PULL_COMPLETE,
          streamId: t,
          reason: Ue(h)
        });
      });
      break;
    case te.ENQUEUE:
      if (ae(n, "enqueue should have stream controller"), n.isClosed)
        break;
      n.controller.enqueue(e.chunk);
      break;
    case te.CLOSE:
      if (ae(n, "close should have stream controller"), n.isClosed)
        break;
      n.isClosed = !0, n.controller.close(), x(this, Ea, Tc).call(this, n, t);
      break;
    case te.ERROR:
      ae(n, "error should have stream controller"), n.controller.error(Ue(e.reason)), x(this, Ea, Tc).call(this, n, t);
      break;
    case te.CANCEL_COMPLETE:
      e.success ? n.cancelCall.resolve() : n.cancelCall.reject(Ue(e.reason)), x(this, Ea, Tc).call(this, n, t);
      break;
    case te.CANCEL:
      if (!a)
        break;
      new Promise(function(h) {
        var c;
        h((c = a.onCancel) == null ? void 0 : c.call(a, Ue(e.reason)));
      }).then(function() {
        r.postMessage({
          sourceName: s,
          targetName: i,
          stream: te.CANCEL_COMPLETE,
          streamId: t,
          success: !0
        });
      }, function(h) {
        r.postMessage({
          sourceName: s,
          targetName: i,
          stream: te.CANCEL_COMPLETE,
          streamId: t,
          reason: Ue(h)
        });
      }), a.sinkCapability.reject(Ue(e.reason)), a.isCancelled = !0, delete this.streamSinks[t];
      break;
    default:
      throw new Error("Unexpected stream case");
  }
}, Ea = new WeakSet(), Tc = async function(e, t) {
  var s, i, r;
  await Promise.allSettled([(s = e.startCall) == null ? void 0 : s.promise, (i = e.pullCall) == null ? void 0 : i.promise, (r = e.cancelCall) == null ? void 0 : r.promise]), delete this.streamControllers[t];
};
var Qr, Wl;
class Qw {
  constructor({
    parsedData: e,
    rawData: t
  }) {
    y(this, Qr, void 0);
    y(this, Wl, void 0);
    E(this, Qr, e), E(this, Wl, t);
  }
  getRaw() {
    return o(this, Wl);
  }
  get(e) {
    return o(this, Qr).get(e) ?? null;
  }
  getAll() {
    return Xp(o(this, Qr));
  }
  has(e) {
    return o(this, Qr).has(e);
  }
}
Qr = new WeakMap(), Wl = new WeakMap();
const Yn = Symbol("INTERNAL");
var $l, Gl, Vl, xa;
class Kw {
  constructor(e, {
    name: t,
    intent: s,
    usage: i,
    rbGroups: r
  }) {
    y(this, $l, !1);
    y(this, Gl, !1);
    y(this, Vl, !1);
    y(this, xa, !0);
    E(this, $l, !!(e & Qe.DISPLAY)), E(this, Gl, !!(e & Qe.PRINT)), this.name = t, this.intent = s, this.usage = i, this.rbGroups = r;
  }
  get visible() {
    if (o(this, Vl))
      return o(this, xa);
    if (!o(this, xa))
      return !1;
    const {
      print: e,
      view: t
    } = this.usage;
    return o(this, $l) ? (t == null ? void 0 : t.viewState) !== "OFF" : o(this, Gl) ? (e == null ? void 0 : e.printState) !== "OFF" : !0;
  }
  _setVisible(e, t, s = !1) {
    e !== Yn && Bt("Internal method `_setVisible` called."), E(this, Vl, s), E(this, xa, t);
  }
}
$l = new WeakMap(), Gl = new WeakMap(), Vl = new WeakMap(), xa = new WeakMap();
var Yi, Nt, Sa, ka, Yl, Jf;
class Zw {
  constructor(e, t = Qe.DISPLAY) {
    y(this, Yl);
    y(this, Yi, null);
    y(this, Nt, /* @__PURE__ */ new Map());
    y(this, Sa, null);
    y(this, ka, null);
    if (this.renderingIntent = t, this.name = null, this.creator = null, e !== null) {
      this.name = e.name, this.creator = e.creator, E(this, ka, e.order);
      for (const s of e.groups)
        o(this, Nt).set(s.id, new Kw(t, s));
      if (e.baseState === "OFF")
        for (const s of o(this, Nt).values())
          s._setVisible(Yn, !1);
      for (const s of e.on)
        o(this, Nt).get(s)._setVisible(Yn, !0);
      for (const s of e.off)
        o(this, Nt).get(s)._setVisible(Yn, !1);
      E(this, Sa, this.getHash());
    }
  }
  isVisible(e) {
    if (o(this, Nt).size === 0)
      return !0;
    if (!e)
      return Ju("Optional content group not defined."), !0;
    if (e.type === "OCG")
      return o(this, Nt).has(e.id) ? o(this, Nt).get(e.id).visible : (xt(`Optional content group not found: ${e.id}`), !0);
    if (e.type === "OCMD") {
      if (e.expression)
        return x(this, Yl, Jf).call(this, e.expression);
      if (!e.policy || e.policy === "AnyOn") {
        for (const t of e.ids) {
          if (!o(this, Nt).has(t))
            return xt(`Optional content group not found: ${t}`), !0;
          if (o(this, Nt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOn") {
        for (const t of e.ids) {
          if (!o(this, Nt).has(t))
            return xt(`Optional content group not found: ${t}`), !0;
          if (!o(this, Nt).get(t).visible)
            return !1;
        }
        return !0;
      } else if (e.policy === "AnyOff") {
        for (const t of e.ids) {
          if (!o(this, Nt).has(t))
            return xt(`Optional content group not found: ${t}`), !0;
          if (!o(this, Nt).get(t).visible)
            return !0;
        }
        return !1;
      } else if (e.policy === "AllOff") {
        for (const t of e.ids) {
          if (!o(this, Nt).has(t))
            return xt(`Optional content group not found: ${t}`), !0;
          if (o(this, Nt).get(t).visible)
            return !1;
        }
        return !0;
      }
      return xt(`Unknown optional content policy ${e.policy}.`), !0;
    }
    return xt(`Unknown group type ${e.type}.`), !0;
  }
  setVisibility(e, t = !0, s = !0) {
    var r;
    const i = o(this, Nt).get(e);
    if (!i) {
      xt(`Optional content group not found: ${e}`);
      return;
    }
    if (s && t && i.rbGroups.length)
      for (const n of i.rbGroups)
        for (const a of n)
          a !== e && ((r = o(this, Nt).get(a)) == null || r._setVisible(Yn, !1, !0));
    i._setVisible(Yn, !!t, !0), E(this, Yi, null);
  }
  setOCGState({
    state: e,
    preserveRB: t
  }) {
    let s;
    for (const i of e) {
      switch (i) {
        case "ON":
        case "OFF":
        case "Toggle":
          s = i;
          continue;
      }
      const r = o(this, Nt).get(i);
      if (r)
        switch (s) {
          case "ON":
            this.setVisibility(i, !0, t);
            break;
          case "OFF":
            this.setVisibility(i, !1, t);
            break;
          case "Toggle":
            this.setVisibility(i, !r.visible, t);
            break;
        }
    }
    E(this, Yi, null);
  }
  get hasInitialVisibility() {
    return o(this, Sa) === null || this.getHash() === o(this, Sa);
  }
  getOrder() {
    return o(this, Nt).size ? o(this, ka) ? o(this, ka).slice() : [...o(this, Nt).keys()] : null;
  }
  getGroups() {
    return o(this, Nt).size > 0 ? Xp(o(this, Nt)) : null;
  }
  getGroup(e) {
    return o(this, Nt).get(e) || null;
  }
  getHash() {
    if (o(this, Yi) !== null)
      return o(this, Yi);
    const e = new eb();
    for (const [t, s] of o(this, Nt))
      e.update(`${t}:${s.visible}`);
    return E(this, Yi, e.hexdigest());
  }
}
Yi = new WeakMap(), Nt = new WeakMap(), Sa = new WeakMap(), ka = new WeakMap(), Yl = new WeakSet(), Jf = function(e) {
  const t = e.length;
  if (t < 2)
    return !0;
  const s = e[0];
  for (let i = 1; i < t; i++) {
    const r = e[i];
    let n;
    if (Array.isArray(r))
      n = x(this, Yl, Jf).call(this, r);
    else if (o(this, Nt).has(r))
      n = o(this, Nt).get(r).visible;
    else
      return xt(`Optional content group not found: ${r}`), !0;
    switch (s) {
      case "And":
        if (!n)
          return !1;
        break;
      case "Or":
        if (n)
          return !0;
        break;
      case "Not":
        return !n;
      default:
        return !0;
    }
  }
  return s === "And";
};
class Jw {
  constructor(e, {
    disableRange: t = !1,
    disableStream: s = !1
  }) {
    ae(e, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    const {
      length: i,
      initialData: r,
      progressiveDone: n,
      contentDispositionFilename: a
    } = e;
    if (this._queuedChunks = [], this._progressiveDone = n, this._contentDispositionFilename = a, (r == null ? void 0 : r.length) > 0) {
      const h = r instanceof Uint8Array && r.byteLength === r.buffer.byteLength ? r.buffer : new Uint8Array(r).buffer;
      this._queuedChunks.push(h);
    }
    this._pdfDataRangeTransport = e, this._isStreamingSupported = !s, this._isRangeSupported = !t, this._contentLength = i, this._fullRequestReader = null, this._rangeReaders = [], e.addRangeListener((h, c) => {
      this._onReceiveData({
        begin: h,
        chunk: c
      });
    }), e.addProgressListener((h, c) => {
      this._onProgress({
        loaded: h,
        total: c
      });
    }), e.addProgressiveReadListener((h) => {
      this._onReceiveData({
        chunk: h
      });
    }), e.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    }), e.transportReady();
  }
  _onReceiveData({
    begin: e,
    chunk: t
  }) {
    const s = t instanceof Uint8Array && t.byteLength === t.buffer.byteLength ? t.buffer : new Uint8Array(t).buffer;
    if (e === void 0)
      this._fullRequestReader ? this._fullRequestReader._enqueue(s) : this._queuedChunks.push(s);
    else {
      const i = this._rangeReaders.some(function(r) {
        return r._begin !== e ? !1 : (r._enqueue(s), !0);
      });
      ae(i, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  _onProgress(e) {
    var t, s, i, r;
    e.total === void 0 ? (s = (t = this._rangeReaders[0]) == null ? void 0 : t.onProgress) == null || s.call(t, {
      loaded: e.loaded
    }) : (r = (i = this._fullRequestReader) == null ? void 0 : i.onProgress) == null || r.call(i, {
      loaded: e.loaded,
      total: e.total
    });
  }
  _onProgressiveDone() {
    var e;
    (e = this._fullRequestReader) == null || e.progressiveDone(), this._progressiveDone = !0;
  }
  _removeRangeReader(e) {
    const t = this._rangeReaders.indexOf(e);
    t >= 0 && this._rangeReaders.splice(t, 1);
  }
  getFullReader() {
    ae(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const e = this._queuedChunks;
    return this._queuedChunks = null, new tA(this, e, this._progressiveDone, this._contentDispositionFilename);
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new eA(this, e, t);
    return this._pdfDataRangeTransport.requestDataRange(e, t), this._rangeReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeReaders.slice(0))
      s.cancel(e);
    this._pdfDataRangeTransport.abort();
  }
}
class tA {
  constructor(e, t, s = !1, i = null) {
    this._stream = e, this._done = s || !1, this._filename = Kp(i) ? i : null, this._queuedChunks = t || [], this._loaded = 0;
    for (const r of this._queuedChunks)
      this._loaded += r.byteLength;
    this._requests = [], this._headersReady = Promise.resolve(), e._fullRequestReader = this, this.onProgress = null;
  }
  _enqueue(e) {
    this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e,
      done: !1
    }) : this._queuedChunks.push(e), this._loaded += e.byteLength);
  }
  get headersReady() {
    return this._headersReady;
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }
  get contentLength() {
    return this._stream._contentLength;
  }
  async read() {
    if (this._queuedChunks.length > 0)
      return {
        value: this._queuedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0;
  }
  progressiveDone() {
    this._done || (this._done = !0);
  }
}
class eA {
  constructor(e, t, s) {
    this._stream = e, this._begin = t, this._end = s, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
  }
  _enqueue(e) {
    if (!this._done) {
      if (this._requests.length === 0)
        this._queuedChunk = e;
      else {
        this._requests.shift().resolve({
          value: e,
          done: !1
        });
        for (const s of this._requests)
          s.resolve({
            value: void 0,
            done: !0
          });
        this._requests.length = 0;
      }
      this._done = !0, this._stream._removeRangeReader(this);
    }
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._queuedChunk) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._stream._removeRangeReader(this);
  }
}
function sA(l) {
  let e = !0, t = s("filename\\*", "i").exec(l);
  if (t) {
    t = t[1];
    let d = a(t);
    return d = unescape(d), d = h(d), d = c(d), r(d);
  }
  if (t = n(l), t) {
    const d = c(t);
    return r(d);
  }
  if (t = s("filename", "i").exec(l), t) {
    t = t[1];
    let d = a(t);
    return d = c(d), r(d);
  }
  function s(d, u) {
    return new RegExp("(?:^|;)\\s*" + d + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', u);
  }
  function i(d, u) {
    if (d) {
      if (!/^[\x00-\xFF]+$/.test(u))
        return u;
      try {
        const f = new TextDecoder(d, {
          fatal: !0
        }), p = ef(u);
        u = f.decode(p), e = !1;
      } catch {
      }
    }
    return u;
  }
  function r(d) {
    return e && /[\x80-\xff]/.test(d) && (d = i("utf-8", d), e && (d = i("iso-8859-1", d))), d;
  }
  function n(d) {
    const u = [];
    let f;
    const p = s("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    for (; (f = p.exec(d)) !== null; ) {
      let [, g, w, b] = f;
      if (g = parseInt(g, 10), g in u) {
        if (g === 0)
          break;
        continue;
      }
      u[g] = [w, b];
    }
    const m = [];
    for (let g = 0; g < u.length && g in u; ++g) {
      let [w, b] = u[g];
      b = a(b), w && (b = unescape(b), g === 0 && (b = h(b))), m.push(b);
    }
    return m.join("");
  }
  function a(d) {
    if (d.startsWith('"')) {
      const u = d.slice(1).split('\\"');
      for (let f = 0; f < u.length; ++f) {
        const p = u[f].indexOf('"');
        p !== -1 && (u[f] = u[f].slice(0, p), u.length = f + 1), u[f] = u[f].replaceAll(/\\(.)/g, "$1");
      }
      d = u.join('"');
    }
    return d;
  }
  function h(d) {
    const u = d.indexOf("'");
    if (u === -1)
      return d;
    const f = d.slice(0, u), m = d.slice(u + 1).replace(/^[^']*'/, "");
    return i(f, m);
  }
  function c(d) {
    return !d.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(d) ? d : d.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, f, p, m) {
      if (p === "q" || p === "Q")
        return m = m.replaceAll("_", " "), m = m.replaceAll(/=([0-9a-fA-F]{2})/g, function(g, w) {
          return String.fromCharCode(parseInt(w, 16));
        }), i(f, m);
      try {
        m = atob(m);
      } catch {
      }
      return i(f, m);
    });
  }
  return "";
}
function sg(l, e) {
  const t = new Headers();
  if (!l || !e || typeof e != "object")
    return t;
  for (const s in e) {
    const i = e[s];
    i !== void 0 && t.append(s, i);
  }
  return t;
}
function ig({
  responseHeaders: l,
  isHttp: e,
  rangeChunkSize: t,
  disableRange: s
}) {
  const i = {
    allowRangeRequests: !1,
    suggestedLength: void 0
  }, r = parseInt(l.get("Content-Length"), 10);
  return !Number.isInteger(r) || (i.suggestedLength = r, r <= 2 * t) || s || !e || l.get("Accept-Ranges") !== "bytes" || (l.get("Content-Encoding") || "identity") !== "identity" || (i.allowRangeRequests = !0), i;
}
function rg(l) {
  const e = l.get("Content-Disposition");
  if (e) {
    let t = sA(e);
    if (t.includes("%"))
      try {
        t = decodeURIComponent(t);
      } catch {
      }
    if (Kp(t))
      return t;
  }
  return null;
}
function nf(l, e) {
  return l === 404 || l === 0 && e.startsWith("file:") ? new Bn('Missing PDF "' + e + '".') : new tf(`Unexpected server response (${l}) while retrieving PDF "${e}".`, l);
}
function gb(l) {
  return l === 200 || l === 206;
}
function mb(l, e, t) {
  return {
    method: "GET",
    headers: l,
    signal: t.signal,
    mode: "cors",
    credentials: e ? "include" : "same-origin",
    redirect: "follow"
  };
}
function bb(l) {
  return l instanceof Uint8Array ? l.buffer : l instanceof ArrayBuffer ? l : (xt(`getArrayBuffer - unexpected data format: ${l}`), new Uint8Array(l).buffer);
}
class Hg {
  constructor(e) {
    this.source = e, this.isHttp = /^https?:/i.test(e.url), this.headers = sg(this.isHttp, e.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return ae(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new iA(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = new rA(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class iA {
  constructor(e) {
    this._stream = e, this._reader = null, this._loaded = 0, this._filename = null;
    const t = e.source;
    this._withCredentials = t.withCredentials || !1, this._contentLength = t.length, this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange;
    const s = new Headers(e.headers), i = t.url;
    fetch(i, mb(s, this._withCredentials, this._abortController)).then((r) => {
      if (!gb(r.status))
        throw nf(r.status, i);
      this._reader = r.body.getReader(), this._headersCapability.resolve();
      const n = r.headers, {
        allowRangeRequests: a,
        suggestedLength: h
      } = ig({
        responseHeaders: n,
        isHttp: e.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = a, this._contentLength = h || this._contentLength, this._filename = rg(n), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new Un("Streaming is disabled."));
    }).catch(this._headersCapability.reject), this.onProgress = null;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._headersCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: bb(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
class rA {
  constructor(e, t, s) {
    this._stream = e, this._reader = null, this._loaded = 0;
    const i = e.source;
    this._withCredentials = i.withCredentials || !1, this._readCapability = Promise.withResolvers(), this._isStreamingSupported = !i.disableStream, this._abortController = new AbortController();
    const r = new Headers(e.headers);
    r.append("Range", `bytes=${t}-${s - 1}`);
    const n = i.url;
    fetch(n, mb(r, this._withCredentials, this._abortController)).then((a) => {
      if (!gb(a.status))
        throw nf(a.status, n);
      this._readCapability.resolve(), this._reader = a.body.getReader();
    }).catch(this._readCapability.reject), this.onProgress = null;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    await this._readCapability.promise;
    const {
      value: e,
      done: t
    } = await this._reader.read();
    return t ? {
      value: e,
      done: t
    } : (this._loaded += e.byteLength, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: bb(e),
      done: !1
    });
  }
  cancel(e) {
    var t;
    (t = this._reader) == null || t.cancel(e), this._abortController.abort();
  }
}
const yf = 200, vf = 206;
function nA(l) {
  const e = l.response;
  return typeof e != "string" ? e : ef(e).buffer;
}
class aA {
  constructor({
    url: e,
    httpHeaders: t,
    withCredentials: s
  }) {
    this.url = e, this.isHttp = /^https?:/i.test(e), this.headers = sg(this.isHttp, t), this.withCredentials = s || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
  }
  requestRange(e, t, s) {
    const i = {
      begin: e,
      end: t
    };
    for (const r in s)
      i[r] = s[r];
    return this.request(i);
  }
  requestFull(e) {
    return this.request(e);
  }
  request(e) {
    const t = new XMLHttpRequest(), s = this.currXhrId++, i = this.pendingRequests[s] = {
      xhr: t
    };
    t.open("GET", this.url), t.withCredentials = this.withCredentials;
    for (const [r, n] of this.headers)
      t.setRequestHeader(r, n);
    return this.isHttp && "begin" in e && "end" in e ? (t.setRequestHeader("Range", `bytes=${e.begin}-${e.end - 1}`), i.expectedStatus = vf) : i.expectedStatus = yf, t.responseType = "arraybuffer", e.onError && (t.onerror = function(r) {
      e.onError(t.status);
    }), t.onreadystatechange = this.onStateChange.bind(this, s), t.onprogress = this.onProgress.bind(this, s), i.onHeadersReceived = e.onHeadersReceived, i.onDone = e.onDone, i.onError = e.onError, i.onProgress = e.onProgress, t.send(null), s;
  }
  onProgress(e, t) {
    var i;
    const s = this.pendingRequests[e];
    s && ((i = s.onProgress) == null || i.call(s, t));
  }
  onStateChange(e, t) {
    var h, c, d;
    const s = this.pendingRequests[e];
    if (!s)
      return;
    const i = s.xhr;
    if (i.readyState >= 2 && s.onHeadersReceived && (s.onHeadersReceived(), delete s.onHeadersReceived), i.readyState !== 4 || !(e in this.pendingRequests))
      return;
    if (delete this.pendingRequests[e], i.status === 0 && this.isHttp) {
      (h = s.onError) == null || h.call(s, i.status);
      return;
    }
    const r = i.status || yf;
    if (!(r === yf && s.expectedStatus === vf) && r !== s.expectedStatus) {
      (c = s.onError) == null || c.call(s, i.status);
      return;
    }
    const a = nA(i);
    if (r === vf) {
      const u = i.getResponseHeader("Content-Range"), f = /bytes (\d+)-(\d+)\/(\d+)/.exec(u);
      s.onDone({
        begin: parseInt(f[1], 10),
        chunk: a
      });
    } else
      a ? s.onDone({
        begin: 0,
        chunk: a
      }) : (d = s.onError) == null || d.call(s, i.status);
  }
  getRequestXhr(e) {
    return this.pendingRequests[e].xhr;
  }
  isPendingRequest(e) {
    return e in this.pendingRequests;
  }
  abortRequest(e) {
    const t = this.pendingRequests[e].xhr;
    delete this.pendingRequests[e], t.abort();
  }
}
class oA {
  constructor(e) {
    this._source = e, this._manager = new aA(e), this._rangeChunkSize = e.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  _onRangeRequestReaderClosed(e) {
    const t = this._rangeRequestReaders.indexOf(e);
    t >= 0 && this._rangeRequestReaders.splice(t, 1);
  }
  getFullReader() {
    return ae(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new lA(this._manager, this._source), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    const s = new hA(this._manager, e, t);
    return s.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class lA {
  constructor(e, t) {
    this._manager = e;
    const s = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = t.url, this._fullRequestId = e.requestFull(s), this._headersCapability = Promise.withResolvers(), this._disableRange = t.disableRange || !1, this._contentLength = t.length, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
  }
  _onHeadersReceived() {
    const e = this._fullRequestId, t = this._manager.getRequestXhr(e), s = new Headers(t.getAllResponseHeaders().trim().split(/[\r\n]+/).map((n) => {
      const [a, ...h] = n.split(": ");
      return [a, h.join(": ")];
    })), {
      allowRangeRequests: i,
      suggestedLength: r
    } = ig({
      responseHeaders: s,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });
    i && (this._isRangeSupported = !0), this._contentLength = r || this._contentLength, this._filename = rg(s), this._isRangeSupported && this._manager.abortRequest(e), this._headersCapability.resolve();
  }
  _onDone(e) {
    if (e && (this._requests.length > 0 ? this._requests.shift().resolve({
      value: e.chunk,
      done: !1
    }) : this._cachedChunks.push(e.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
      for (const t of this._requests)
        t.resolve({
          value: void 0,
          done: !0
        });
      this._requests.length = 0;
    }
  }
  _onError(e) {
    this._storedError = nf(e, this._url), this._headersCapability.reject(this._storedError);
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._cachedChunks.length = 0;
  }
  _onProgress(e) {
    var t;
    (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded,
      total: e.lengthComputable ? e.total : this._contentLength
    });
  }
  get filename() {
    return this._filename;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  get contentLength() {
    return this._contentLength;
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._cachedChunks.length > 0)
      return {
        value: this._cachedChunks.shift(),
        done: !1
      };
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0, this._headersCapability.reject(e);
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
  }
}
class hA {
  constructor(e, t, s) {
    this._manager = e;
    const i = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = e.url, this._requestId = e.requestRange(t, s, i), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
  }
  _close() {
    var e;
    (e = this.onClosed) == null || e.call(this, this);
  }
  _onDone(e) {
    const t = e.chunk;
    this._requests.length > 0 ? this._requests.shift().resolve({
      value: t,
      done: !1
    }) : this._queuedChunk = t, this._done = !0;
    for (const s of this._requests)
      s.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._close();
  }
  _onError(e) {
    this._storedError = nf(e, this._url);
    for (const t of this._requests)
      t.reject(this._storedError);
    this._requests.length = 0, this._queuedChunk = null;
  }
  _onProgress(e) {
    var t;
    this.isStreamingSupported || (t = this.onProgress) == null || t.call(this, {
      loaded: e.loaded
    });
  }
  get isStreamingSupported() {
    return !1;
  }
  async read() {
    if (this._storedError)
      throw this._storedError;
    if (this._queuedChunk !== null) {
      const t = this._queuedChunk;
      return this._queuedChunk = null, {
        value: t,
        done: !1
      };
    }
    if (this._done)
      return {
        value: void 0,
        done: !0
      };
    const e = Promise.withResolvers();
    return this._requests.push(e), e.promise;
  }
  cancel(e) {
    this._done = !0;
    for (const t of this._requests)
      t.resolve({
        value: void 0,
        done: !0
      });
    this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
  }
}
const cA = /^[a-z][a-z0-9\-+.]+:/i;
function dA(l) {
  if (cA.test(l))
    return new URL(l);
  const e = gr.get("url");
  return new URL(e.pathToFileURL(l));
}
function yb(l, e, t) {
  return l.protocol === "http:" ? gr.get("http").request(l, {
    headers: e
  }, t) : gr.get("https").request(l, {
    headers: e
  }, t);
}
class uA {
  constructor(e) {
    this.source = e, this.url = dA(e.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.headers = sg(this.isHttp, e.httpHeaders), this._fullRequestReader = null, this._rangeRequestReaders = [];
  }
  get _progressiveDataLength() {
    var e;
    return ((e = this._fullRequestReader) == null ? void 0 : e._loaded) ?? 0;
  }
  getFullReader() {
    return ae(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new gA(this) : new fA(this), this._fullRequestReader;
  }
  getRangeReader(e, t) {
    if (t <= this._progressiveDataLength)
      return null;
    const s = this.isFsUrl ? new mA(this, e, t) : new pA(this, e, t);
    return this._rangeRequestReaders.push(s), s;
  }
  cancelAllRequests(e) {
    var t;
    (t = this._fullRequestReader) == null || t.cancel(e);
    for (const s of this._rangeRequestReaders.slice(0))
      s.cancel(e);
  }
}
class vb {
  constructor(e) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null;
    const t = e.source;
    this._contentLength = t.length, this._loaded = 0, this._filename = null, this._disableRange = t.disableRange || !1, this._rangeChunkSize = t.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !t.disableStream, this._isRangeSupported = !t.disableRange, this._readableStream = null, this._readCapability = Promise.withResolvers(), this._headersCapability = Promise.withResolvers();
  }
  get headersReady() {
    return this._headersCapability.promise;
  }
  get filename() {
    return this._filename;
  }
  get contentLength() {
    return this._contentLength;
  }
  get isRangeSupported() {
    return this._isRangeSupported;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded,
      total: this._contentLength
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), !this._isStreamingSupported && this._isRangeSupported && this._error(new Un("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class wb {
  constructor(e) {
    this._url = e.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = Promise.withResolvers();
    const t = e.source;
    this._isStreamingSupported = !t.disableStream;
  }
  get isStreamingSupported() {
    return this._isStreamingSupported;
  }
  async read() {
    var s;
    if (await this._readCapability.promise, this._done)
      return {
        value: void 0,
        done: !0
      };
    if (this._storedError)
      throw this._storedError;
    const e = this._readableStream.read();
    return e === null ? (this._readCapability = Promise.withResolvers(), this.read()) : (this._loaded += e.length, (s = this.onProgress) == null || s.call(this, {
      loaded: this._loaded
    }), {
      value: new Uint8Array(e).buffer,
      done: !1
    });
  }
  cancel(e) {
    if (!this._readableStream) {
      this._error(e);
      return;
    }
    this._readableStream.destroy(e);
  }
  _error(e) {
    this._storedError = e, this._readCapability.resolve();
  }
  _setReadableStream(e) {
    this._readableStream = e, e.on("readable", () => {
      this._readCapability.resolve();
    }), e.on("end", () => {
      e.destroy(), this._done = !0, this._readCapability.resolve();
    }), e.on("error", (t) => {
      this._error(t);
    }), this._storedError && this._readableStream.destroy(this._storedError);
  }
}
class fA extends vb {
  constructor(e) {
    super(e);
    const t = Object.fromEntries(e.headers), s = (i) => {
      if (i.statusCode === 404) {
        const h = new Bn(`Missing PDF "${this._url}".`);
        this._storedError = h, this._headersCapability.reject(h);
        return;
      }
      this._headersCapability.resolve(), this._setReadableStream(i);
      const r = new Headers(this._readableStream.headers), {
        allowRangeRequests: n,
        suggestedLength: a
      } = ig({
        responseHeaders: r,
        isHttp: e.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = n, this._contentLength = a || this._contentLength, this._filename = rg(r);
    };
    this._request = yb(this._url, t, s), this._request.on("error", (i) => {
      this._storedError = i, this._headersCapability.reject(i);
    }), this._request.end();
  }
}
class pA extends wb {
  constructor(e, t, s) {
    super(e);
    const i = Object.fromEntries(e.headers);
    i.Range = `bytes=${t}-${s - 1}`;
    const r = (n) => {
      if (n.statusCode === 404) {
        const a = new Bn(`Missing PDF "${this._url}".`);
        this._storedError = a;
        return;
      }
      this._setReadableStream(n);
    };
    this._request = yb(this._url, i, r), this._request.on("error", (n) => {
      this._storedError = n;
    }), this._request.end();
  }
}
class gA extends vb {
  constructor(e) {
    super(e);
    const t = gr.get("fs");
    t.promises.lstat(this._url).then((s) => {
      this._contentLength = s.size, this._setReadableStream(t.createReadStream(this._url)), this._headersCapability.resolve();
    }, (s) => {
      s.code === "ENOENT" && (s = new Bn(`Missing PDF "${this._url}".`)), this._storedError = s, this._headersCapability.reject(s);
    });
  }
}
class mA extends wb {
  constructor(e, t, s) {
    super(e);
    const i = gr.get("fs");
    this._setReadableStream(i.createReadStream(this._url, {
      start: t,
      end: s - 1
    }));
  }
}
const bA = 1e5, Le = 30, yA = 0.8;
var am, Xi, Fe, Xl, ql, Kr, si, Ql, Kl, Zr, Ma, Ca, qi, Ta, Zl, Ia, Jr, Jl, th, Ht, tn, en, eh, Qi, Na, Bd, Ab, Ud, _b, sh, ep, Da, Ic, ih, sp, Hd, Eb, Wd, xb;
let tp = (Ht = class {
  constructor({
    textContentSource: e,
    container: t,
    viewport: s
  }) {
    y(this, Bd);
    y(this, Ud);
    y(this, sh);
    y(this, Xi, Promise.withResolvers());
    y(this, Fe, null);
    y(this, Xl, !1);
    y(this, ql, !!((am = globalThis.FontInspector) != null && am.enabled));
    y(this, Kr, null);
    y(this, si, null);
    y(this, Ql, 0);
    y(this, Kl, 0);
    y(this, Zr, null);
    y(this, Ma, null);
    y(this, Ca, 0);
    y(this, qi, 0);
    y(this, Ta, /* @__PURE__ */ Object.create(null));
    y(this, Zl, []);
    y(this, Ia, null);
    y(this, Jr, []);
    y(this, Jl, /* @__PURE__ */ new WeakMap());
    y(this, th, null);
    var h;
    if (e instanceof ReadableStream)
      E(this, Ia, e);
    else if (typeof e == "object")
      E(this, Ia, new ReadableStream({
        start(c) {
          c.enqueue(e), c.close();
        }
      }));
    else
      throw new Error('No "textContentSource" parameter specified.');
    E(this, Fe, E(this, Ma, t)), E(this, qi, s.scale * (globalThis.devicePixelRatio || 1)), E(this, Ca, s.rotation), E(this, si, {
      div: null,
      properties: null,
      ctx: null
    });
    const {
      pageWidth: i,
      pageHeight: r,
      pageX: n,
      pageY: a
    } = s.rawDims;
    E(this, th, [1, 0, 0, -1, -n, a + r]), E(this, Kl, i), E(this, Ql, r), x(h = Ht, Hd, Eb).call(h), Rn(t, s), o(this, Xi).promise.finally(() => {
      o(Ht, Na).delete(this), E(this, si, null), E(this, Ta, null);
    }).catch(() => {
    });
  }
  static get fontFamilyMap() {
    const {
      isWindows: e,
      isFirefox: t
    } = Pe.platform;
    return Mt(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${e && t ? "Calibri, " : ""}sans-serif`], ["monospace", `${e && t ? "Lucida Console, " : ""}monospace`]]));
  }
  render() {
    const e = () => {
      o(this, Zr).read().then(({
        value: t,
        done: s
      }) => {
        if (s) {
          o(this, Xi).resolve();
          return;
        }
        o(this, Kr) ?? E(this, Kr, t.lang), Object.assign(o(this, Ta), t.styles), x(this, Bd, Ab).call(this, t.items), e();
      }, o(this, Xi).reject);
    };
    return E(this, Zr, o(this, Ia).getReader()), o(Ht, Na).add(this), e(), o(this, Xi).promise;
  }
  update({
    viewport: e,
    onBefore: t = null
  }) {
    var r;
    const s = e.scale * (globalThis.devicePixelRatio || 1), i = e.rotation;
    if (i !== o(this, Ca) && (t == null || t(), E(this, Ca, i), Rn(o(this, Ma), {
      rotation: i
    })), s !== o(this, qi)) {
      t == null || t(), E(this, qi, s);
      const n = {
        div: null,
        properties: null,
        ctx: x(r = Ht, Da, Ic).call(r, o(this, Kr))
      };
      for (const a of o(this, Jr))
        n.properties = o(this, Jl).get(a), n.div = a, x(this, sh, ep).call(this, n);
    }
  }
  cancel() {
    var t;
    const e = new Un("TextLayer task cancelled.");
    (t = o(this, Zr)) == null || t.cancel(e).catch(() => {
    }), E(this, Zr, null), o(this, Xi).reject(e);
  }
  get textDivs() {
    return o(this, Jr);
  }
  get textContentItemsStr() {
    return o(this, Zl);
  }
  static cleanup() {
    if (!(o(this, Na).size > 0)) {
      o(this, tn).clear();
      for (const {
        canvas: e
      } of o(this, en).values())
        e.remove();
      o(this, en).clear();
    }
  }
}, Xi = new WeakMap(), Fe = new WeakMap(), Xl = new WeakMap(), ql = new WeakMap(), Kr = new WeakMap(), si = new WeakMap(), Ql = new WeakMap(), Kl = new WeakMap(), Zr = new WeakMap(), Ma = new WeakMap(), Ca = new WeakMap(), qi = new WeakMap(), Ta = new WeakMap(), Zl = new WeakMap(), Ia = new WeakMap(), Jr = new WeakMap(), Jl = new WeakMap(), th = new WeakMap(), tn = new WeakMap(), en = new WeakMap(), eh = new WeakMap(), Qi = new WeakMap(), Na = new WeakMap(), Bd = new WeakSet(), Ab = function(e) {
  var i, r;
  if (o(this, Xl))
    return;
  (r = o(this, si)).ctx ?? (r.ctx = x(i = Ht, Da, Ic).call(i, o(this, Kr)));
  const t = o(this, Jr), s = o(this, Zl);
  for (const n of e) {
    if (t.length > bA) {
      xt("Ignoring additional textDivs for performance reasons."), E(this, Xl, !0);
      return;
    }
    if (n.str === void 0) {
      if (n.type === "beginMarkedContentProps" || n.type === "beginMarkedContent") {
        const a = o(this, Fe);
        E(this, Fe, document.createElement("span")), o(this, Fe).classList.add("markedContent"), n.id !== null && o(this, Fe).setAttribute("id", `${n.id}`), a.append(o(this, Fe));
      } else
        n.type === "endMarkedContent" && E(this, Fe, o(this, Fe).parentNode);
      continue;
    }
    s.push(n.str), x(this, Ud, _b).call(this, n);
  }
}, Ud = new WeakSet(), _b = function(e) {
  var g;
  const t = document.createElement("span"), s = {
    angle: 0,
    canvasWidth: 0,
    hasText: e.str !== "",
    hasEOL: e.hasEOL,
    fontSize: 0
  };
  o(this, Jr).push(t);
  const i = pt.transform(o(this, th), e.transform);
  let r = Math.atan2(i[1], i[0]);
  const n = o(this, Ta)[e.fontName];
  n.vertical && (r += Math.PI / 2);
  let a = o(this, ql) && n.fontSubstitution || n.fontFamily;
  a = Ht.fontFamilyMap.get(a) || a;
  const h = Math.hypot(i[2], i[3]), c = h * x(g = Ht, Wd, xb).call(g, a, o(this, Kr));
  let d, u;
  r === 0 ? (d = i[4], u = i[5] - c) : (d = i[4] + c * Math.sin(r), u = i[5] - c * Math.cos(r));
  const f = "calc(var(--scale-factor)*", p = t.style;
  o(this, Fe) === o(this, Ma) ? (p.left = `${(100 * d / o(this, Kl)).toFixed(2)}%`, p.top = `${(100 * u / o(this, Ql)).toFixed(2)}%`) : (p.left = `${f}${d.toFixed(2)}px)`, p.top = `${f}${u.toFixed(2)}px)`), p.fontSize = `${f}${(o(Ht, Qi) * h).toFixed(2)}px)`, p.fontFamily = a, s.fontSize = h, t.setAttribute("role", "presentation"), t.textContent = e.str, t.dir = e.dir, o(this, ql) && (t.dataset.fontName = n.fontSubstitutionLoadedName || e.fontName), r !== 0 && (s.angle = r * (180 / Math.PI));
  let m = !1;
  if (e.str.length > 1)
    m = !0;
  else if (e.str !== " " && e.transform[0] !== e.transform[3]) {
    const w = Math.abs(e.transform[0]), b = Math.abs(e.transform[3]);
    w !== b && Math.max(w, b) / Math.min(w, b) > 1.5 && (m = !0);
  }
  if (m && (s.canvasWidth = n.vertical ? e.height : e.width), o(this, Jl).set(t, s), o(this, si).div = t, o(this, si).properties = s, x(this, sh, ep).call(this, o(this, si)), s.hasText && o(this, Fe).append(t), s.hasEOL) {
    const w = document.createElement("br");
    w.setAttribute("role", "presentation"), o(this, Fe).append(w);
  }
}, sh = new WeakSet(), ep = function(e) {
  var a;
  const {
    div: t,
    properties: s,
    ctx: i
  } = e, {
    style: r
  } = t;
  let n = "";
  if (o(Ht, Qi) > 1 && (n = `scale(${1 / o(Ht, Qi)})`), s.canvasWidth !== 0 && s.hasText) {
    const {
      fontFamily: h
    } = r, {
      canvasWidth: c,
      fontSize: d
    } = s;
    x(a = Ht, ih, sp).call(a, i, d * o(this, qi), h);
    const {
      width: u
    } = i.measureText(t.textContent);
    u > 0 && (n = `scaleX(${c * o(this, qi) / u}) ${n}`);
  }
  s.angle !== 0 && (n = `rotate(${s.angle}deg) ${n}`), n.length > 0 && (r.transform = n);
}, Da = new WeakSet(), Ic = function(e = null) {
  let t = o(this, en).get(e || (e = ""));
  if (!t) {
    const s = document.createElement("canvas");
    s.className = "hiddenCanvasElement", s.lang = e, document.body.append(s), t = s.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    }), o(this, en).set(e, t), o(this, eh).set(t, {
      size: 0,
      family: ""
    });
  }
  return t;
}, ih = new WeakSet(), sp = function(e, t, s) {
  const i = o(this, eh).get(e);
  t === i.size && s === i.family || (e.font = `${t}px ${s}`, i.size = t, i.family = s);
}, Hd = new WeakSet(), Eb = function() {
  if (o(this, Qi) !== null)
    return;
  const e = document.createElement("div");
  e.style.opacity = 0, e.style.lineHeight = 1, e.style.fontSize = "1px", e.style.position = "absolute", e.textContent = "X", document.body.append(e), E(this, Qi, e.getBoundingClientRect().height), e.remove();
}, Wd = new WeakSet(), xb = function(e, t) {
  const s = o(this, tn).get(e);
  if (s)
    return s;
  const i = x(this, Da, Ic).call(this, t);
  i.canvas.width = i.canvas.height = Le, x(this, ih, sp).call(this, i, Le, e);
  const r = i.measureText("");
  let n = r.fontBoundingBoxAscent, a = Math.abs(r.fontBoundingBoxDescent);
  if (n) {
    const d = n / (n + a);
    return o(this, tn).set(e, d), i.canvas.width = i.canvas.height = 0, d;
  }
  i.strokeStyle = "red", i.clearRect(0, 0, Le, Le), i.strokeText("g", 0, 0);
  let h = i.getImageData(0, 0, Le, Le).data;
  a = 0;
  for (let d = h.length - 1 - 3; d >= 0; d -= 4)
    if (h[d] > 0) {
      a = Math.ceil(d / 4 / Le);
      break;
    }
  i.clearRect(0, 0, Le, Le), i.strokeText("A", 0, Le), h = i.getImageData(0, 0, Le, Le).data, n = 0;
  for (let d = 0, u = h.length; d < u; d += 4)
    if (h[d] > 0) {
      n = Le - Math.floor(d / 4 / Le);
      break;
    }
  i.canvas.width = i.canvas.height = 0;
  const c = n ? n / (n + a) : yA;
  return o(this, tn).set(e, c), c;
}, y(Ht, Da), y(Ht, ih), y(Ht, Hd), y(Ht, Wd), y(Ht, tn, /* @__PURE__ */ new Map()), y(Ht, en, /* @__PURE__ */ new Map()), y(Ht, eh, /* @__PURE__ */ new WeakMap()), y(Ht, Qi, null), y(Ht, Na, /* @__PURE__ */ new Set()), Ht);
class tl {
  static textContent(e) {
    const t = [], s = {
      items: t,
      styles: /* @__PURE__ */ Object.create(null)
    };
    function i(r) {
      var h;
      if (!r)
        return;
      let n = null;
      const a = r.name;
      if (a === "#text")
        n = r.value;
      else if (tl.shouldBuildText(a))
        (h = r == null ? void 0 : r.attributes) != null && h.textContent ? n = r.attributes.textContent : r.value && (n = r.value);
      else
        return;
      if (n !== null && t.push({
        str: n
      }), !!r.children)
        for (const c of r.children)
          i(c);
    }
    return i(e), s;
  }
  static shouldBuildText(e) {
    return !(e === "textarea" || e === "input" || e === "option" || e === "select");
  }
}
const vA = 65536, wA = 100, AA = 5e3, _A = Ce ? Lw : Nw, EA = Ce ? Rw : ab, xA = Ce ? Pw : Dw, SA = Ce ? Ow : cb;
function kA(l = {}) {
  typeof l == "string" || l instanceof URL ? l = {
    url: l
  } : (l instanceof ArrayBuffer || ArrayBuffer.isView(l)) && (l = {
    data: l
  });
  const e = new ip(), {
    docId: t
  } = e, s = l.url ? MA(l.url) : null, i = l.data ? CA(l.data) : null, r = l.httpHeaders || null, n = l.withCredentials === !0, a = l.password ?? null, h = l.range instanceof Sb ? l.range : null, c = Number.isInteger(l.rangeChunkSize) && l.rangeChunkSize > 0 ? l.rangeChunkSize : vA;
  let d = l.worker instanceof Jn ? l.worker : null;
  const u = l.verbosity, f = typeof l.docBaseUrl == "string" && !rf(l.docBaseUrl) ? l.docBaseUrl : null, p = typeof l.cMapUrl == "string" ? l.cMapUrl : null, m = l.cMapPacked !== !1, g = l.CMapReaderFactory || EA, w = typeof l.standardFontDataUrl == "string" ? l.standardFontDataUrl : null, b = l.StandardFontDataFactory || SA, _ = l.stopAtErrors !== !0, k = Number.isInteger(l.maxImageSize) && l.maxImageSize > -1 ? l.maxImageSize : -1, C = l.isEvalSupported !== !1, N = typeof l.isOffscreenCanvasSupported == "boolean" ? l.isOffscreenCanvasSupported : !Ce, R = typeof l.isChrome == "boolean" ? l.isChrome : !Pe.platform.isFirefox && typeof window < "u" && !!(window != null && window.chrome), P = Number.isInteger(l.canvasMaxAreaInBytes) ? l.canvasMaxAreaInBytes : -1, M = typeof l.disableFontFace == "boolean" ? l.disableFontFace : Ce, S = l.fontExtraProperties === !0, L = l.enableXfa === !0, H = l.ownerDocument || globalThis.document, I = l.disableRange === !0, F = l.disableStream === !0, A = l.disableAutoFetch === !0, G = l.pdfBug === !0, et = l.CanvasFactory || _A, z = l.FilterFactory || xA, K = l.enableHWA === !0, Y = h ? h.length : l.length ?? NaN, ot = typeof l.useSystemFonts == "boolean" ? l.useSystemFonts : !Ce && !M, B = typeof l.useWorkerFetch == "boolean" ? l.useWorkerFetch : g === ab && b === cb && p && w && Ro(p, document.baseURI) && Ro(w, document.baseURI);
  l.canvasFactory && Ig("`canvasFactory`-instance option, please use `CanvasFactory` instead."), l.filterFactory && Ig("`filterFactory`-instance option, please use `FilterFactory` instead.");
  const O = null;
  lw(u);
  const q = {
    canvasFactory: new et({
      ownerDocument: H,
      enableHWA: K
    }),
    filterFactory: new z({
      docId: t,
      ownerDocument: H
    }),
    cMapReaderFactory: B ? null : new g({
      baseUrl: p,
      isCompressed: m
    }),
    standardFontDataFactory: B ? null : new b({
      baseUrl: w
    })
  };
  if (!d) {
    const ut = {
      verbosity: u,
      port: xi.workerPort
    };
    d = ut.port ? Jn.fromPort(ut) : new Jn(ut), e._worker = d;
  }
  const tt = {
    docId: t,
    apiVersion: "4.8.69",
    data: i,
    password: a,
    disableAutoFetch: A,
    rangeChunkSize: c,
    length: Y,
    docBaseUrl: f,
    enableXfa: L,
    evaluatorOptions: {
      maxImageSize: k,
      disableFontFace: M,
      ignoreErrors: _,
      isEvalSupported: C,
      isOffscreenCanvasSupported: N,
      isChrome: R,
      canvasMaxAreaInBytes: P,
      fontExtraProperties: S,
      useSystemFonts: ot,
      cMapUrl: B ? p : null,
      standardFontDataUrl: B ? w : null
    }
  }, J = {
    disableFontFace: M,
    fontExtraProperties: S,
    ownerDocument: H,
    pdfBug: G,
    styleElement: O,
    loadingParams: {
      disableAutoFetch: A,
      enableXfa: L
    }
  };
  return d.promise.then(function() {
    if (e.destroyed)
      throw new Error("Loading aborted");
    if (d.destroyed)
      throw new Error("Worker was destroyed");
    const ut = d.messageHandler.sendWithPromise("GetDocRequest", tt, i ? [i.buffer] : null);
    let ft;
    if (h)
      ft = new Jw(h, {
        disableRange: I,
        disableStream: F
      });
    else if (!i) {
      if (!s)
        throw new Error("getDocument - no `url` parameter provided.");
      let at;
      Ce ? at = typeof fetch < "u" && typeof Response < "u" && "body" in Response.prototype && Ro(s) ? Hg : uA : at = Ro(s) ? Hg : oA, ft = new at({
        url: s,
        length: Y,
        httpHeaders: r,
        withCredentials: n,
        rangeChunkSize: c,
        disableRange: I,
        disableStream: F
      });
    }
    return ut.then((at) => {
      if (e.destroyed)
        throw new Error("Loading aborted");
      if (d.destroyed)
        throw new Error("Worker was destroyed");
      const lt = new Ho(t, at, d.port), dt = new DA(lt, e, ft, J, q);
      e._transport = dt, lt.send("Ready", null);
    });
  }).catch(e._capability.reject), e;
}
function MA(l) {
  if (l instanceof URL)
    return l.href;
  try {
    return new URL(l, window.location).href;
  } catch {
    if (Ce && typeof l == "string")
      return l;
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function CA(l) {
  if (Ce && typeof Buffer < "u" && l instanceof Buffer)
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  if (l instanceof Uint8Array && l.byteLength === l.buffer.byteLength)
    return l;
  if (typeof l == "string")
    return ef(l);
  if (l instanceof ArrayBuffer || ArrayBuffer.isView(l) || typeof l == "object" && !isNaN(l == null ? void 0 : l.length))
    return new Uint8Array(l);
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function Wg(l) {
  return typeof l == "object" && Number.isInteger(l == null ? void 0 : l.num) && l.num >= 0 && Number.isInteger(l == null ? void 0 : l.gen) && l.gen >= 0;
}
var $d;
const Gd = class Gd {
  constructor() {
    this._capability = Promise.withResolvers(), this._transport = null, this._worker = null, this.docId = `d${Te(Gd, $d)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
  }
  get promise() {
    return this._capability.promise;
  }
  async destroy() {
    var e, t, s;
    this.destroyed = !0;
    try {
      (e = this._worker) != null && e.port && (this._worker._pendingDestroy = !0), await ((t = this._transport) == null ? void 0 : t.destroy());
    } catch (i) {
      throw (s = this._worker) != null && s.port && delete this._worker._pendingDestroy, i;
    }
    this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
  }
};
$d = new WeakMap(), y(Gd, $d, 0);
let ip = Gd, Sb = class {
  constructor(e, t, s = !1, i = null) {
    this.length = e, this.initialData = t, this.progressiveDone = s, this.contentDispositionFilename = i, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = Promise.withResolvers();
  }
  addRangeListener(e) {
    this._rangeListeners.push(e);
  }
  addProgressListener(e) {
    this._progressListeners.push(e);
  }
  addProgressiveReadListener(e) {
    this._progressiveReadListeners.push(e);
  }
  addProgressiveDoneListener(e) {
    this._progressiveDoneListeners.push(e);
  }
  onDataRange(e, t) {
    for (const s of this._rangeListeners)
      s(e, t);
  }
  onDataProgress(e, t) {
    this._readyCapability.promise.then(() => {
      for (const s of this._progressListeners)
        s(e, t);
    });
  }
  onDataProgressiveRead(e) {
    this._readyCapability.promise.then(() => {
      for (const t of this._progressiveReadListeners)
        t(e);
    });
  }
  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const e of this._progressiveDoneListeners)
        e();
    });
  }
  transportReady() {
    this._readyCapability.resolve();
  }
  requestDataRange(e, t) {
    Bt("Abstract method PDFDataRangeTransport.requestDataRange");
  }
  abort() {
  }
};
class TA {
  constructor(e, t) {
    this._pdfInfo = e, this._transport = t;
  }
  get annotationStorage() {
    return this._transport.annotationStorage;
  }
  get canvasFactory() {
    return this._transport.canvasFactory;
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get numPages() {
    return this._pdfInfo.numPages;
  }
  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }
  get isPureXfa() {
    return Mt(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }
  getPage(e) {
    return this._transport.getPage(e);
  }
  getPageIndex(e) {
    return this._transport.getPageIndex(e);
  }
  getDestinations() {
    return this._transport.getDestinations();
  }
  getDestination(e) {
    return this._transport.getDestination(e);
  }
  getPageLabels() {
    return this._transport.getPageLabels();
  }
  getPageLayout() {
    return this._transport.getPageLayout();
  }
  getPageMode() {
    return this._transport.getPageMode();
  }
  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }
  getOpenAction() {
    return this._transport.getOpenAction();
  }
  getAttachments() {
    return this._transport.getAttachments();
  }
  getJSActions() {
    return this._transport.getDocJSActions();
  }
  getOutline() {
    return this._transport.getOutline();
  }
  getOptionalContentConfig({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getOptionalContentConfig(t);
  }
  getPermissions() {
    return this._transport.getPermissions();
  }
  getMetadata() {
    return this._transport.getMetadata();
  }
  getMarkInfo() {
    return this._transport.getMarkInfo();
  }
  getData() {
    return this._transport.getData();
  }
  saveDocument() {
    return this._transport.saveDocument();
  }
  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }
  cleanup(e = !1) {
    return this._transport.startCleanup(e || this.isPureXfa);
  }
  destroy() {
    return this.loadingTask.destroy();
  }
  cachedPageNumber(e) {
    return this._transport.cachedPageNumber(e);
  }
  get loadingParams() {
    return this._transport.loadingParams;
  }
  get loadingTask() {
    return this._transport.loadingTask;
  }
  getFieldObjects() {
    return this._transport.getFieldObjects();
  }
  hasJSActions() {
    return this._transport.hasJSActions();
  }
  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }
}
var Ki, ii, Zi, Xn, Pa, Nc;
class IA {
  constructor(e, t, s, i = !1) {
    y(this, Zi);
    y(this, Pa);
    y(this, Ki, null);
    y(this, ii, !1);
    this._pageIndex = e, this._pageInfo = t, this._transport = s, this._stats = i ? new Tg() : null, this._pdfBug = i, this.commonObjs = s.commonObjs, this.objs = new kb(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
  }
  get pageNumber() {
    return this._pageIndex + 1;
  }
  get rotate() {
    return this._pageInfo.rotate;
  }
  get ref() {
    return this._pageInfo.ref;
  }
  get userUnit() {
    return this._pageInfo.userUnit;
  }
  get view() {
    return this._pageInfo.view;
  }
  getViewport({
    scale: e,
    rotation: t = this.rotate,
    offsetX: s = 0,
    offsetY: i = 0,
    dontFlip: r = !1
  } = {}) {
    return new oc({
      viewBox: this.view,
      scale: e,
      rotation: t,
      offsetX: s,
      offsetY: i,
      dontFlip: r
    });
  }
  getAnnotations({
    intent: e = "display"
  } = {}) {
    const {
      renderingIntent: t
    } = this._transport.getRenderingIntent(e);
    return this._transport.getAnnotations(this._pageIndex, t);
  }
  getJSActions() {
    return this._transport.getPageJSActions(this._pageIndex);
  }
  get filterFactory() {
    return this._transport.filterFactory;
  }
  get isPureXfa() {
    return Mt(this, "isPureXfa", !!this._transport._htmlForXfa);
  }
  async getXfa() {
    var e;
    return ((e = this._transport._htmlForXfa) == null ? void 0 : e.children[this._pageIndex]) || null;
  }
  render({
    canvasContext: e,
    viewport: t,
    intent: s = "display",
    annotationMode: i = Ni.ENABLE,
    transform: r = null,
    background: n = null,
    optionalContentConfigPromise: a = null,
    annotationCanvasMap: h = null,
    pageColors: c = null,
    printAnnotationStorage: d = null,
    isEditing: u = !1
  }) {
    var C, N;
    (C = this._stats) == null || C.time("Overall");
    const f = this._transport.getRenderingIntent(s, i, d, u), {
      renderingIntent: p,
      cacheKey: m
    } = f;
    E(this, ii, !1), x(this, Pa, Nc).call(this), a || (a = this._transport.getOptionalContentConfig(p));
    let g = this._intentStates.get(m);
    g || (g = /* @__PURE__ */ Object.create(null), this._intentStates.set(m, g)), g.streamReaderCancelTimeout && (clearTimeout(g.streamReaderCancelTimeout), g.streamReaderCancelTimeout = null);
    const w = !!(p & Qe.PRINT);
    g.displayReadyCapability || (g.displayReadyCapability = Promise.withResolvers(), g.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (N = this._stats) == null || N.time("Page Request"), this._pumpOperatorList(f));
    const b = (R) => {
      var P;
      g.renderTasks.delete(_), (this._maybeCleanupAfterRender || w) && E(this, ii, !0), x(this, Zi, Xn).call(this, !w), R ? (_.capability.reject(R), this._abortOperatorList({
        intentState: g,
        reason: R instanceof Error ? R : new Error(R)
      })) : _.capability.resolve(), this._stats && (this._stats.timeEnd("Rendering"), this._stats.timeEnd("Overall"), (P = globalThis.Stats) != null && P.enabled && globalThis.Stats.add(this.pageNumber, this._stats));
    }, _ = new np({
      callback: b,
      params: {
        canvasContext: e,
        viewport: t,
        transform: r,
        background: n
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap: h,
      operatorList: g.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: this._transport.canvasFactory,
      filterFactory: this._transport.filterFactory,
      useRequestAnimationFrame: !w,
      pdfBug: this._pdfBug,
      pageColors: c
    });
    (g.renderTasks || (g.renderTasks = /* @__PURE__ */ new Set())).add(_);
    const k = _.task;
    return Promise.all([g.displayReadyCapability.promise, a]).then(([R, P]) => {
      var M;
      if (this.destroyed) {
        b();
        return;
      }
      if ((M = this._stats) == null || M.time("Rendering"), !(P.renderingIntent & p))
        throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
      _.initializeGraphics({
        transparency: R,
        optionalContentConfig: P
      }), _.operatorListChanged();
    }).catch(b), k;
  }
  getOperatorList({
    intent: e = "display",
    annotationMode: t = Ni.ENABLE,
    printAnnotationStorage: s = null,
    isEditing: i = !1
  } = {}) {
    var c;
    function r() {
      a.operatorList.lastChunk && (a.opListReadCapability.resolve(a.operatorList), a.renderTasks.delete(h));
    }
    const n = this._transport.getRenderingIntent(e, t, s, i, !0);
    let a = this._intentStates.get(n.cacheKey);
    a || (a = /* @__PURE__ */ Object.create(null), this._intentStates.set(n.cacheKey, a));
    let h;
    return a.opListReadCapability || (h = /* @__PURE__ */ Object.create(null), h.operatorListChanged = r, a.opListReadCapability = Promise.withResolvers(), (a.renderTasks || (a.renderTasks = /* @__PURE__ */ new Set())).add(h), a.operatorList = {
      fnArray: [],
      argsArray: [],
      lastChunk: !1,
      separateAnnots: null
    }, (c = this._stats) == null || c.time("Page Request"), this._pumpOperatorList(n)), a.opListReadCapability.promise;
  }
  streamTextContent({
    includeMarkedContent: e = !1,
    disableNormalization: t = !1
  } = {}) {
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      includeMarkedContent: e === !0,
      disableNormalization: t === !0
    }, {
      highWaterMark: 100,
      size(i) {
        return i.items.length;
      }
    });
  }
  getTextContent(e = {}) {
    if (this._transport._htmlForXfa)
      return this.getXfa().then((s) => tl.textContent(s));
    const t = this.streamTextContent(e);
    return new Promise(function(s, i) {
      function r() {
        n.read().then(function({
          value: h,
          done: c
        }) {
          if (c) {
            s(a);
            return;
          }
          a.lang ?? (a.lang = h.lang), Object.assign(a.styles, h.styles), a.items.push(...h.items), r();
        }, i);
      }
      const n = t.getReader(), a = {
        items: [],
        styles: /* @__PURE__ */ Object.create(null),
        lang: null
      };
      r();
    });
  }
  getStructTree() {
    return this._transport.getStructTree(this._pageIndex);
  }
  _destroy() {
    this.destroyed = !0;
    const e = [];
    for (const t of this._intentStates.values())
      if (this._abortOperatorList({
        intentState: t,
        reason: new Error("Page was destroyed."),
        force: !0
      }), !t.opListReadCapability)
        for (const s of t.renderTasks)
          e.push(s.completed), s.cancel();
    return this.objs.clear(), E(this, ii, !1), x(this, Pa, Nc).call(this), Promise.all(e);
  }
  cleanup(e = !1) {
    E(this, ii, !0);
    const t = x(this, Zi, Xn).call(this, !1);
    return e && t && this._stats && (this._stats = new Tg()), t;
  }
  _startRenderPage(e, t) {
    var i, r;
    const s = this._intentStates.get(t);
    s && ((i = this._stats) == null || i.timeEnd("Page Request"), (r = s.displayReadyCapability) == null || r.resolve(e));
  }
  _renderPageChunk(e, t) {
    for (let s = 0, i = e.length; s < i; s++)
      t.operatorList.fnArray.push(e.fnArray[s]), t.operatorList.argsArray.push(e.argsArray[s]);
    t.operatorList.lastChunk = e.lastChunk, t.operatorList.separateAnnots = e.separateAnnots;
    for (const s of t.renderTasks)
      s.operatorListChanged();
    e.lastChunk && x(this, Zi, Xn).call(this, !0);
  }
  _pumpOperatorList({
    renderingIntent: e,
    cacheKey: t,
    annotationStorageSerializable: s,
    modifiedIds: i
  }) {
    const {
      map: r,
      transfer: n
    } = s, h = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: e,
      cacheKey: t,
      annotationStorage: r,
      modifiedIds: i
    }, n).getReader(), c = this._intentStates.get(t);
    c.streamReader = h;
    const d = () => {
      h.read().then(({
        value: u,
        done: f
      }) => {
        if (f) {
          c.streamReader = null;
          return;
        }
        this._transport.destroyed || (this._renderPageChunk(u, c), d());
      }, (u) => {
        if (c.streamReader = null, !this._transport.destroyed) {
          if (c.operatorList) {
            c.operatorList.lastChunk = !0;
            for (const f of c.renderTasks)
              f.operatorListChanged();
            x(this, Zi, Xn).call(this, !0);
          }
          if (c.displayReadyCapability)
            c.displayReadyCapability.reject(u);
          else if (c.opListReadCapability)
            c.opListReadCapability.reject(u);
          else
            throw u;
        }
      });
    };
    d();
  }
  _abortOperatorList({
    intentState: e,
    reason: t,
    force: s = !1
  }) {
    if (e.streamReader) {
      if (e.streamReaderCancelTimeout && (clearTimeout(e.streamReaderCancelTimeout), e.streamReaderCancelTimeout = null), !s) {
        if (e.renderTasks.size > 0)
          return;
        if (t instanceof Qp) {
          let i = wA;
          t.extraDelay > 0 && t.extraDelay < 1e3 && (i += t.extraDelay), e.streamReaderCancelTimeout = setTimeout(() => {
            e.streamReaderCancelTimeout = null, this._abortOperatorList({
              intentState: e,
              reason: t,
              force: !0
            });
          }, i);
          return;
        }
      }
      if (e.streamReader.cancel(new Un(t.message)).catch(() => {
      }), e.streamReader = null, !this._transport.destroyed) {
        for (const [i, r] of this._intentStates)
          if (r === e) {
            this._intentStates.delete(i);
            break;
          }
        this.cleanup();
      }
    }
  }
  get stats() {
    return this._stats;
  }
}
Ki = new WeakMap(), ii = new WeakMap(), Zi = new WeakSet(), Xn = function(e = !1) {
  if (x(this, Pa, Nc).call(this), !o(this, ii) || this.destroyed)
    return !1;
  if (e)
    return E(this, Ki, setTimeout(() => {
      E(this, Ki, null), x(this, Zi, Xn).call(this, !1);
    }, AA)), !1;
  for (const {
    renderTasks: t,
    operatorList: s
  } of this._intentStates.values())
    if (t.size > 0 || !s.lastChunk)
      return !1;
  return this._intentStates.clear(), this.objs.clear(), E(this, ii, !1), !0;
}, Pa = new WeakSet(), Nc = function() {
  o(this, Ki) && (clearTimeout(o(this, Ki)), E(this, Ki, null));
};
var ri, Vd;
class NA {
  constructor() {
    y(this, ri, /* @__PURE__ */ new Map());
    y(this, Vd, Promise.resolve());
  }
  postMessage(e, t) {
    const s = {
      data: structuredClone(e, t ? {
        transfer: t
      } : null)
    };
    o(this, Vd).then(() => {
      for (const [i] of o(this, ri))
        i.call(this, s);
    });
  }
  addEventListener(e, t, s = null) {
    let i = null;
    if ((s == null ? void 0 : s.signal) instanceof AbortSignal) {
      const {
        signal: r
      } = s;
      if (r.aborted) {
        xt("LoopbackPort - cannot use an `aborted` signal.");
        return;
      }
      const n = () => this.removeEventListener(e, t);
      i = () => r.removeEventListener("abort", n), r.addEventListener("abort", n);
    }
    o(this, ri).set(t, i);
  }
  removeEventListener(e, t) {
    const s = o(this, ri).get(t);
    s == null || s(), o(this, ri).delete(t);
  }
  terminate() {
    for (const [, e] of o(this, ri))
      e == null || e();
    o(this, ri).clear();
  }
}
ri = new WeakMap(), Vd = new WeakMap();
var Yd, sn, rn, La, Dc, Ra, Pc;
const Ut = class Ut {
  constructor({
    name: e = null,
    port: t = null,
    verbosity: s = hw()
  } = {}) {
    y(this, La);
    var i;
    if (this.name = e, this.destroyed = !1, this.verbosity = s, this._readyCapability = Promise.withResolvers(), this._port = null, this._webWorker = null, this._messageHandler = null, t) {
      if ((i = o(Ut, rn)) != null && i.has(t))
        throw new Error("Cannot use more than one PDFWorker per port.");
      (o(Ut, rn) || E(Ut, rn, /* @__PURE__ */ new WeakMap())).set(t, this), this._initializeFromPort(t);
      return;
    }
    this._initialize();
  }
  get promise() {
    return Ce ? Promise.all([gr.promise, this._readyCapability.promise]) : this._readyCapability.promise;
  }
  get port() {
    return this._port;
  }
  get messageHandler() {
    return this._messageHandler;
  }
  _initializeFromPort(e) {
    this._port = e, this._messageHandler = new Ho("main", "worker", e), this._messageHandler.on("ready", function() {
    }), x(this, La, Dc).call(this);
  }
  _initialize() {
    if (o(Ut, sn) || o(Ut, Ra, Pc)) {
      this._setupFakeWorker();
      return;
    }
    let {
      workerSrc: e
    } = Ut;
    try {
      Ut._isSameOrigin(window.location.href, e) || (e = Ut._createCDNWrapper(new URL(e, window.location).href));
      const t = new Worker(e, {
        type: "module"
      }), s = new Ho("main", "worker", t), i = () => {
        r.abort(), s.destroy(), t.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
      }, r = new AbortController();
      t.addEventListener("error", () => {
        this._webWorker || i();
      }, {
        signal: r.signal
      }), s.on("test", (a) => {
        if (r.abort(), this.destroyed || !a) {
          i();
          return;
        }
        this._messageHandler = s, this._port = t, this._webWorker = t, x(this, La, Dc).call(this);
      }), s.on("ready", (a) => {
        if (r.abort(), this.destroyed) {
          i();
          return;
        }
        try {
          n();
        } catch {
          this._setupFakeWorker();
        }
      });
      const n = () => {
        const a = new Uint8Array();
        s.send("test", a, [a.buffer]);
      };
      n();
      return;
    } catch {
      Ju("The worker has been disabled.");
    }
    this._setupFakeWorker();
  }
  _setupFakeWorker() {
    o(Ut, sn) || (xt("Setting up fake worker."), E(Ut, sn, !0)), Ut._setupFakeWorkerGlobal.then((e) => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));
        return;
      }
      const t = new NA();
      this._port = t;
      const s = `fake${Te(Ut, Yd)._++}`, i = new Ho(s + "_worker", s, t);
      e.setup(i, t), this._messageHandler = new Ho(s, s + "_worker", t), x(this, La, Dc).call(this);
    }).catch((e) => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${e.message}".`));
    });
  }
  destroy() {
    var e;
    this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (e = o(Ut, rn)) == null || e.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
  }
  static fromPort(e) {
    var s;
    if (!(e != null && e.port))
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    const t = (s = o(this, rn)) == null ? void 0 : s.get(e.port);
    if (t) {
      if (t._pendingDestroy)
        throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
      return t;
    }
    return new Ut(e);
  }
  static get workerSrc() {
    if (xi.workerSrc)
      return xi.workerSrc;
    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }
  static get _setupFakeWorkerGlobal() {
    return Mt(this, "_setupFakeWorkerGlobal", (async () => o(this, Ra, Pc) ? o(this, Ra, Pc) : (await import(
      /*webpackIgnore: true*/
      this.workerSrc
    )).WorkerMessageHandler)());
  }
};
Yd = new WeakMap(), sn = new WeakMap(), rn = new WeakMap(), La = new WeakSet(), Dc = function() {
  this._readyCapability.resolve(), this._messageHandler.send("configure", {
    verbosity: this.verbosity
  });
}, Ra = new WeakSet(), Pc = function() {
  var e;
  try {
    return ((e = globalThis.pdfjsWorker) == null ? void 0 : e.WorkerMessageHandler) || null;
  } catch {
    return null;
  }
}, y(Ut, Ra), y(Ut, Yd, 0), y(Ut, sn, !1), y(Ut, rn, void 0), Ce && (E(Ut, sn, !0), xi.workerSrc || (xi.workerSrc = "./pdf.worker.mjs")), Ut._isSameOrigin = (e, t) => {
  let s;
  try {
    if (s = new URL(e), !s.origin || s.origin === "null")
      return !1;
  } catch {
    return !1;
  }
  const i = new URL(t, s);
  return s.origin === i.origin;
}, Ut._createCDNWrapper = (e) => {
  const t = `await import("${e}");`;
  return URL.createObjectURL(new Blob([t], {
    type: "text/javascript"
  }));
};
let Jn = Ut;
var ni, Rs, Oa, Fa, Os, nn, Wo;
class DA {
  constructor(e, t, s, i, r) {
    y(this, nn);
    y(this, ni, /* @__PURE__ */ new Map());
    y(this, Rs, /* @__PURE__ */ new Map());
    y(this, Oa, /* @__PURE__ */ new Map());
    y(this, Fa, /* @__PURE__ */ new Map());
    y(this, Os, null);
    this.messageHandler = e, this.loadingTask = t, this.commonObjs = new kb(), this.fontLoader = new Tw({
      ownerDocument: i.ownerDocument,
      styleElement: i.styleElement
    }), this.loadingParams = i.loadingParams, this._params = i, this.canvasFactory = r.canvasFactory, this.filterFactory = r.filterFactory, this.cMapReaderFactory = r.cMapReaderFactory, this.standardFontDataFactory = r.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = s, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = Promise.withResolvers(), this.setupMessageHandler();
  }
  get annotationStorage() {
    return Mt(this, "annotationStorage", new tg());
  }
  getRenderingIntent(e, t = Ni.ENABLE, s = null, i = !1, r = !1) {
    let n = Qe.DISPLAY, a = Gf;
    switch (e) {
      case "any":
        n = Qe.ANY;
        break;
      case "display":
        break;
      case "print":
        n = Qe.PRINT;
        break;
      default:
        xt(`getRenderingIntent - invalid intent: ${e}`);
    }
    const h = n & Qe.PRINT && s instanceof ib ? s : this.annotationStorage;
    switch (t) {
      case Ni.DISABLE:
        n += Qe.ANNOTATIONS_DISABLE;
        break;
      case Ni.ENABLE:
        break;
      case Ni.ENABLE_FORMS:
        n += Qe.ANNOTATIONS_FORMS;
        break;
      case Ni.ENABLE_STORAGE:
        n += Qe.ANNOTATIONS_STORAGE, a = h.serializable;
        break;
      default:
        xt(`getRenderingIntent - invalid annotationMode: ${t}`);
    }
    i && (n += Qe.IS_EDITING), r && (n += Qe.OPLIST);
    const {
      ids: c,
      hash: d
    } = h.modifiedIds, u = [n, a.hash, d];
    return {
      renderingIntent: n,
      cacheKey: u.join("_"),
      annotationStorageSerializable: a,
      modifiedIds: c
    };
  }
  destroy() {
    var s;
    if (this.destroyCapability)
      return this.destroyCapability.promise;
    this.destroyed = !0, this.destroyCapability = Promise.withResolvers(), (s = o(this, Os)) == null || s.reject(new Error("Worker was destroyed during onPassword callback"));
    const e = [];
    for (const i of o(this, Rs).values())
      e.push(i._destroy());
    o(this, Rs).clear(), o(this, Oa).clear(), o(this, Fa).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
    const t = this.messageHandler.sendWithPromise("Terminate", null);
    return e.push(t), Promise.all(e).then(() => {
      var i;
      this.commonObjs.clear(), this.fontLoader.clear(), o(this, ni).clear(), this.filterFactory.destroy(), tp.cleanup(), (i = this._networkStream) == null || i.cancelAllRequests(new Un("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
    }, this.destroyCapability.reject), this.destroyCapability.promise;
  }
  setupMessageHandler() {
    const {
      messageHandler: e,
      loadingTask: t
    } = this;
    e.on("GetReader", (s, i) => {
      ae(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (r) => {
        this._lastProgress = {
          loaded: r.loaded,
          total: r.total
        };
      }, i.onPull = () => {
        this._fullReader.read().then(function({
          value: r,
          done: n
        }) {
          if (n) {
            i.close();
            return;
          }
          ae(r instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(r), 1, [r]);
        }).catch((r) => {
          i.error(r);
        });
      }, i.onCancel = (r) => {
        this._fullReader.cancel(r), i.ready.catch((n) => {
          if (!this.destroyed)
            throw n;
        });
      };
    }), e.on("ReaderHeadersReady", async (s) => {
      var a;
      await this._fullReader.headersReady;
      const {
        isStreamingSupported: i,
        isRangeSupported: r,
        contentLength: n
      } = this._fullReader;
      return (!i || !r) && (this._lastProgress && ((a = t.onProgress) == null || a.call(t, this._lastProgress)), this._fullReader.onProgress = (h) => {
        var c;
        (c = t.onProgress) == null || c.call(t, {
          loaded: h.loaded,
          total: h.total
        });
      }), {
        isStreamingSupported: i,
        isRangeSupported: r,
        contentLength: n
      };
    }), e.on("GetRangeReader", (s, i) => {
      ae(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
      const r = this._networkStream.getRangeReader(s.begin, s.end);
      if (!r) {
        i.close();
        return;
      }
      i.onPull = () => {
        r.read().then(function({
          value: n,
          done: a
        }) {
          if (a) {
            i.close();
            return;
          }
          ae(n instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), i.enqueue(new Uint8Array(n), 1, [n]);
        }).catch((n) => {
          i.error(n);
        });
      }, i.onCancel = (n) => {
        r.cancel(n), i.ready.catch((a) => {
          if (!this.destroyed)
            throw a;
        });
      };
    }), e.on("GetDoc", ({
      pdfInfo: s
    }) => {
      this._numPages = s.numPages, this._htmlForXfa = s.htmlForXfa, delete s.htmlForXfa, t._capability.resolve(new TA(s, this));
    }), e.on("DocException", function(s) {
      let i;
      switch (s.name) {
        case "PasswordException":
          i = new Ef(s.message, s.code);
          break;
        case "InvalidPDFException":
          i = new Tm(s.message);
          break;
        case "MissingPDFException":
          i = new Bn(s.message);
          break;
        case "UnexpectedResponseException":
          i = new tf(s.message, s.status);
          break;
        case "UnknownErrorException":
          i = new xf(s.message, s.details);
          break;
        default:
          Bt("DocException - expected a valid Error.");
      }
      t._capability.reject(i);
    }), e.on("PasswordRequest", (s) => {
      if (E(this, Os, Promise.withResolvers()), t.onPassword) {
        const i = (r) => {
          r instanceof Error ? o(this, Os).reject(r) : o(this, Os).resolve({
            password: r
          });
        };
        try {
          t.onPassword(i, s.code);
        } catch (r) {
          o(this, Os).reject(r);
        }
      } else
        o(this, Os).reject(new Ef(s.message, s.code));
      return o(this, Os).promise;
    }), e.on("DataLoaded", (s) => {
      var i;
      (i = t.onProgress) == null || i.call(t, {
        loaded: s.length,
        total: s.length
      }), this.downloadInfoCapability.resolve(s);
    }), e.on("StartRenderPage", (s) => {
      if (this.destroyed)
        return;
      o(this, Rs).get(s.pageIndex)._startRenderPage(s.transparency, s.cacheKey);
    }), e.on("commonobj", ([s, i, r]) => {
      var n;
      if (this.destroyed || this.commonObjs.has(s))
        return null;
      switch (i) {
        case "Font":
          const {
            disableFontFace: a,
            fontExtraProperties: h,
            pdfBug: c
          } = this._params;
          if ("error" in r) {
            const p = r.error;
            xt(`Error during font loading: ${p}`), this.commonObjs.resolve(s, p);
            break;
          }
          const d = c && ((n = globalThis.FontInspector) != null && n.enabled) ? (p, m) => globalThis.FontInspector.fontAdded(p, m) : null, u = new Iw(r, {
            disableFontFace: a,
            inspectFont: d
          });
          this.fontLoader.bind(u).catch(() => e.sendWithPromise("FontFallback", {
            id: s
          })).finally(() => {
            !h && u.data && (u.data = null), this.commonObjs.resolve(s, u);
          });
          break;
        case "CopyLocalImage":
          const {
            imageRef: f
          } = r;
          ae(f, "The imageRef must be defined.");
          for (const p of o(this, Rs).values())
            for (const [, m] of p.objs)
              if ((m == null ? void 0 : m.ref) === f)
                return m.dataLen ? (this.commonObjs.resolve(s, structuredClone(m)), m.dataLen) : null;
          break;
        case "FontPath":
        case "Image":
        case "Pattern":
          this.commonObjs.resolve(s, r);
          break;
        default:
          throw new Error(`Got unknown common object type ${i}`);
      }
      return null;
    }), e.on("obj", ([s, i, r, n]) => {
      var h;
      if (this.destroyed)
        return;
      const a = o(this, Rs).get(i);
      if (!a.objs.has(s)) {
        if (a._intentStates.size === 0) {
          (h = n == null ? void 0 : n.bitmap) == null || h.close();
          return;
        }
        switch (r) {
          case "Image":
            a.objs.resolve(s, n), (n == null ? void 0 : n.dataLen) > rw && (a._maybeCleanupAfterRender = !0);
            break;
          case "Pattern":
            a.objs.resolve(s, n);
            break;
          default:
            throw new Error(`Got unknown object type ${r}`);
        }
      }
    }), e.on("DocProgress", (s) => {
      var i;
      this.destroyed || (i = t.onProgress) == null || i.call(t, {
        loaded: s.loaded,
        total: s.total
      });
    }), e.on("FetchBuiltInCMap", async (s) => {
      if (this.destroyed)
        throw new Error("Worker was destroyed.");
      if (!this.cMapReaderFactory)
        throw new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.");
      return this.cMapReaderFactory.fetch(s);
    }), e.on("FetchStandardFontData", async (s) => {
      if (this.destroyed)
        throw new Error("Worker was destroyed.");
      if (!this.standardFontDataFactory)
        throw new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.");
      return this.standardFontDataFactory.fetch(s);
    });
  }
  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }
  saveDocument() {
    var s;
    this.annotationStorage.size <= 0 && xt("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
    const {
      map: e,
      transfer: t
    } = this.annotationStorage.serializable;
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: e,
      filename: ((s = this._fullReader) == null ? void 0 : s.filename) ?? null
    }, t).finally(() => {
      this.annotationStorage.resetModified();
    });
  }
  getPage(e) {
    if (!Number.isInteger(e) || e <= 0 || e > this._numPages)
      return Promise.reject(new Error("Invalid page request."));
    const t = e - 1, s = o(this, Oa).get(t);
    if (s)
      return s;
    const i = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex: t
    }).then((r) => {
      if (this.destroyed)
        throw new Error("Transport destroyed");
      r.refStr && o(this, Fa).set(r.refStr, e);
      const n = new IA(t, r, this, this._params.pdfBug);
      return o(this, Rs).set(t, n), n;
    });
    return o(this, Oa).set(t, i), i;
  }
  getPageIndex(e) {
    return Wg(e) ? this.messageHandler.sendWithPromise("GetPageIndex", {
      num: e.num,
      gen: e.gen
    }) : Promise.reject(new Error("Invalid pageIndex request."));
  }
  getAnnotations(e, t) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex: e,
      intent: t
    });
  }
  getFieldObjects() {
    return x(this, nn, Wo).call(this, "GetFieldObjects");
  }
  hasJSActions() {
    return x(this, nn, Wo).call(this, "HasJSActions");
  }
  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }
  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }
  getDestination(e) {
    return typeof e != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
      id: e
    });
  }
  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }
  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }
  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }
  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }
  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }
  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }
  getDocJSActions() {
    return x(this, nn, Wo).call(this, "GetDocJSActions");
  }
  getPageJSActions(e) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex: e
    });
  }
  getStructTree(e) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex: e
    });
  }
  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }
  getOptionalContentConfig(e) {
    return x(this, nn, Wo).call(this, "GetOptionalContentConfig").then((t) => new Zw(t, e));
  }
  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }
  getMetadata() {
    const e = "GetMetadata", t = o(this, ni).get(e);
    if (t)
      return t;
    const s = this.messageHandler.sendWithPromise(e, null).then((i) => {
      var r, n;
      return {
        info: i[0],
        metadata: i[1] ? new Qw(i[1]) : null,
        contentDispositionFilename: ((r = this._fullReader) == null ? void 0 : r.filename) ?? null,
        contentLength: ((n = this._fullReader) == null ? void 0 : n.contentLength) ?? null
      };
    });
    return o(this, ni).set(e, s), s;
  }
  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }
  async startCleanup(e = !1) {
    if (!this.destroyed) {
      await this.messageHandler.sendWithPromise("Cleanup", null);
      for (const t of o(this, Rs).values())
        if (!t.cleanup())
          throw new Error(`startCleanup: Page ${t.pageNumber} is currently rendering.`);
      this.commonObjs.clear(), e || this.fontLoader.clear(), o(this, ni).clear(), this.filterFactory.destroy(!0), tp.cleanup();
    }
  }
  cachedPageNumber(e) {
    if (!Wg(e))
      return null;
    const t = e.gen === 0 ? `${e.num}R` : `${e.num}R${e.gen}`;
    return o(this, Fa).get(t) ?? null;
  }
}
ni = new WeakMap(), Rs = new WeakMap(), Oa = new WeakMap(), Fa = new WeakMap(), Os = new WeakMap(), nn = new WeakSet(), Wo = function(e, t = null) {
  const s = o(this, ni).get(e);
  if (s)
    return s;
  const i = this.messageHandler.sendWithPromise(e, t);
  return o(this, ni).set(e, i), i;
};
const bc = Symbol("INITIAL_DATA");
var ps, rh, rp;
class kb {
  constructor() {
    y(this, rh);
    y(this, ps, /* @__PURE__ */ Object.create(null));
  }
  get(e, t = null) {
    if (t) {
      const i = x(this, rh, rp).call(this, e);
      return i.promise.then(() => t(i.data)), null;
    }
    const s = o(this, ps)[e];
    if (!s || s.data === bc)
      throw new Error(`Requesting object that isn't resolved yet ${e}.`);
    return s.data;
  }
  has(e) {
    const t = o(this, ps)[e];
    return !!t && t.data !== bc;
  }
  resolve(e, t = null) {
    const s = x(this, rh, rp).call(this, e);
    s.data = t, s.resolve();
  }
  clear() {
    var e;
    for (const t in o(this, ps)) {
      const {
        data: s
      } = o(this, ps)[t];
      (e = s == null ? void 0 : s.bitmap) == null || e.close();
    }
    E(this, ps, /* @__PURE__ */ Object.create(null));
  }
  *[Symbol.iterator]() {
    for (const e in o(this, ps)) {
      const {
        data: t
      } = o(this, ps)[e];
      t !== bc && (yield [e, t]);
    }
  }
}
ps = new WeakMap(), rh = new WeakSet(), rp = function(e) {
  var t;
  return (t = o(this, ps))[e] || (t[e] = {
    ...Promise.withResolvers(),
    data: bc
  });
};
var Ji;
class PA {
  constructor(e) {
    y(this, Ji, null);
    E(this, Ji, e), this.onContinue = null;
  }
  get promise() {
    return o(this, Ji).capability.promise;
  }
  cancel(e = 0) {
    o(this, Ji).cancel(null, e);
  }
  get separateAnnots() {
    const {
      separateAnnots: e
    } = o(this, Ji).operatorList;
    if (!e)
      return !1;
    const {
      annotationCanvasMap: t
    } = o(this, Ji);
    return e.form || e.canvas && (t == null ? void 0 : t.size) > 0;
  }
}
Ji = new WeakMap();
var tr, an;
const xr = class xr {
  constructor({
    callback: e,
    params: t,
    objs: s,
    commonObjs: i,
    annotationCanvasMap: r,
    operatorList: n,
    pageIndex: a,
    canvasFactory: h,
    filterFactory: c,
    useRequestAnimationFrame: d = !1,
    pdfBug: u = !1,
    pageColors: f = null
  }) {
    y(this, tr, null);
    this.callback = e, this.params = t, this.objs = s, this.commonObjs = i, this.annotationCanvasMap = r, this.operatorListIdx = null, this.operatorList = n, this._pageIndex = a, this.canvasFactory = h, this.filterFactory = c, this._pdfBug = u, this.pageColors = f, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = d === !0 && typeof window < "u", this.cancelled = !1, this.capability = Promise.withResolvers(), this.task = new PA(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = t.canvasContext.canvas;
  }
  get completed() {
    return this.capability.promise.catch(function() {
    });
  }
  initializeGraphics({
    transparency: e = !1,
    optionalContentConfig: t
  }) {
    var a, h;
    if (this.cancelled)
      return;
    if (this._canvas) {
      if (o(xr, an).has(this._canvas))
        throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
      o(xr, an).add(this._canvas);
    }
    this._pdfBug && ((a = globalThis.StepperManager) != null && a.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
    const {
      canvasContext: s,
      viewport: i,
      transform: r,
      background: n
    } = this.params;
    this.gfx = new Zn(s, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
      optionalContentConfig: t
    }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
      transform: r,
      viewport: i,
      transparency: e,
      background: n
    }), this.operatorListIdx = 0, this.graphicsReady = !0, (h = this.graphicsReadyCallback) == null || h.call(this);
  }
  cancel(e = null, t = 0) {
    var s;
    this.running = !1, this.cancelled = !0, (s = this.gfx) == null || s.endDrawing(), o(this, tr) && (window.cancelAnimationFrame(o(this, tr)), E(this, tr, null)), o(xr, an).delete(this._canvas), this.callback(e || new Qp(`Rendering cancelled, page ${this._pageIndex + 1}`, t));
  }
  operatorListChanged() {
    var e;
    if (!this.graphicsReady) {
      this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
      return;
    }
    (e = this.stepper) == null || e.updateOperatorList(this.operatorList), !this.running && this._continue();
  }
  _continue() {
    this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
  }
  _scheduleNext() {
    this._useRequestAnimationFrame ? E(this, tr, window.requestAnimationFrame(() => {
      E(this, tr, null), this._nextBound().catch(this._cancelBound);
    })) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
  }
  async _next() {
    this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), o(xr, an).delete(this._canvas), this.callback())));
  }
};
tr = new WeakMap(), an = new WeakMap(), y(xr, an, /* @__PURE__ */ new WeakSet());
let np = xr;
const LA = "4.8.69", RA = "3634dab10";
function $g(l) {
  return Math.floor(Math.max(0, Math.min(1, l)) * 255).toString(16).padStart(2, "0");
}
function Po(l) {
  return Math.max(0, Math.min(255, 255 * l));
}
class Gg {
  static CMYK_G([e, t, s, i]) {
    return ["G", 1 - Math.min(1, 0.3 * e + 0.59 * s + 0.11 * t + i)];
  }
  static G_CMYK([e]) {
    return ["CMYK", 0, 0, 0, 1 - e];
  }
  static G_RGB([e]) {
    return ["RGB", e, e, e];
  }
  static G_rgb([e]) {
    return e = Po(e), [e, e, e];
  }
  static G_HTML([e]) {
    const t = $g(e);
    return `#${t}${t}${t}`;
  }
  static RGB_G([e, t, s]) {
    return ["G", 0.3 * e + 0.59 * t + 0.11 * s];
  }
  static RGB_rgb(e) {
    return e.map(Po);
  }
  static RGB_HTML(e) {
    return `#${e.map($g).join("")}`;
  }
  static T_HTML() {
    return "#00000000";
  }
  static T_rgb() {
    return [null];
  }
  static CMYK_RGB([e, t, s, i]) {
    return ["RGB", 1 - Math.min(1, e + i), 1 - Math.min(1, s + i), 1 - Math.min(1, t + i)];
  }
  static CMYK_rgb([e, t, s, i]) {
    return [Po(1 - Math.min(1, e + i)), Po(1 - Math.min(1, s + i)), Po(1 - Math.min(1, t + i))];
  }
  static CMYK_HTML(e) {
    const t = this.CMYK_RGB(e).slice(1);
    return this.RGB_HTML(t);
  }
  static RGB_CMYK([e, t, s]) {
    const i = 1 - e, r = 1 - t, n = 1 - s, a = Math.min(i, r, n);
    return ["CMYK", i, r, n, a];
  }
}
class OA {
  create(e, t, s = !1) {
    if (e <= 0 || t <= 0)
      throw new Error("Invalid SVG dimensions");
    const i = this._createSVG("svg:svg");
    return i.setAttribute("version", "1.1"), s || (i.setAttribute("width", `${e}px`), i.setAttribute("height", `${t}px`)), i.setAttribute("preserveAspectRatio", "none"), i.setAttribute("viewBox", `0 0 ${e} ${t}`), i;
  }
  createElement(e) {
    if (typeof e != "string")
      throw new Error("Invalid SVG element type");
    return this._createSVG(e);
  }
  _createSVG(e) {
    Bt("Abstract method `_createSVG` called.");
  }
}
class ng extends OA {
  _createSVG(e) {
    return document.createElementNS(Ys, e);
  }
}
class Mb {
  static setupStorage(e, t, s, i, r) {
    const n = i.getValue(t, {
      value: null
    });
    switch (s.name) {
      case "textarea":
        if (n.value !== null && (e.textContent = n.value), r === "print")
          break;
        e.addEventListener("input", (a) => {
          i.setValue(t, {
            value: a.target.value
          });
        });
        break;
      case "input":
        if (s.attributes.type === "radio" || s.attributes.type === "checkbox") {
          if (n.value === s.attributes.xfaOn ? e.setAttribute("checked", !0) : n.value === s.attributes.xfaOff && e.removeAttribute("checked"), r === "print")
            break;
          e.addEventListener("change", (a) => {
            i.setValue(t, {
              value: a.target.checked ? a.target.getAttribute("xfaOn") : a.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (n.value !== null && e.setAttribute("value", n.value), r === "print")
            break;
          e.addEventListener("input", (a) => {
            i.setValue(t, {
              value: a.target.value
            });
          });
        }
        break;
      case "select":
        if (n.value !== null) {
          e.setAttribute("value", n.value);
          for (const a of s.children)
            a.attributes.value === n.value ? a.attributes.selected = !0 : a.attributes.hasOwnProperty("selected") && delete a.attributes.selected;
        }
        e.addEventListener("input", (a) => {
          const h = a.target.options, c = h.selectedIndex === -1 ? "" : h[h.selectedIndex].value;
          i.setValue(t, {
            value: c
          });
        });
        break;
    }
  }
  static setAttributes({
    html: e,
    element: t,
    storage: s = null,
    intent: i,
    linkService: r
  }) {
    const {
      attributes: n
    } = t, a = e instanceof HTMLAnchorElement;
    n.type === "radio" && (n.name = `${n.name}-${i}`);
    for (const [h, c] of Object.entries(n))
      if (c != null)
        switch (h) {
          case "class":
            c.length && e.setAttribute(h, c.join(" "));
            break;
          case "dataId":
            break;
          case "id":
            e.setAttribute("data-element-id", c);
            break;
          case "style":
            Object.assign(e.style, c);
            break;
          case "textContent":
            e.textContent = c;
            break;
          default:
            (!a || h !== "href" && h !== "newWindow") && e.setAttribute(h, c);
        }
    a && r.addLinkAttributes(e, n.href, n.newWindow), s && n.dataId && this.setupStorage(e, n.dataId, t, s);
  }
  static render(e) {
    var u, f;
    const t = e.annotationStorage, s = e.linkService, i = e.xfaHtml, r = e.intent || "display", n = document.createElement(i.name);
    i.attributes && this.setAttributes({
      html: n,
      element: i,
      intent: r,
      linkService: s
    });
    const a = r !== "richText", h = e.div;
    if (h.append(n), e.viewport) {
      const p = `matrix(${e.viewport.transform.join(",")})`;
      h.style.transform = p;
    }
    a && h.setAttribute("class", "xfaLayer xfaFont");
    const c = [];
    if (i.children.length === 0) {
      if (i.value) {
        const p = document.createTextNode(i.value);
        n.append(p), a && tl.shouldBuildText(i.name) && c.push(p);
      }
      return {
        textDivs: c
      };
    }
    const d = [[i, -1, n]];
    for (; d.length > 0; ) {
      const [p, m, g] = d.at(-1);
      if (m + 1 === p.children.length) {
        d.pop();
        continue;
      }
      const w = p.children[++d.at(-1)[1]];
      if (w === null)
        continue;
      const {
        name: b
      } = w;
      if (b === "#text") {
        const k = document.createTextNode(w.value);
        c.push(k), g.append(k);
        continue;
      }
      const _ = (u = w == null ? void 0 : w.attributes) != null && u.xmlns ? document.createElementNS(w.attributes.xmlns, b) : document.createElement(b);
      if (g.append(_), w.attributes && this.setAttributes({
        html: _,
        element: w,
        storage: t,
        intent: r,
        linkService: s
      }), ((f = w.children) == null ? void 0 : f.length) > 0)
        d.push([w, -1, _]);
      else if (w.value) {
        const k = document.createTextNode(w.value);
        a && tl.shouldBuildText(b) && c.push(k), _.append(k);
      }
    }
    for (const p of h.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
      p.setAttribute("readOnly", !0);
    return {
      textDivs: c
    };
  }
  static update(e) {
    const t = `matrix(${e.viewport.transform.join(",")})`;
    e.div.style.transform = t, e.div.hidden = !1;
  }
}
const hc = 1e3, FA = 9, Fn = /* @__PURE__ */ new WeakSet();
function ki(l) {
  return {
    width: l[2] - l[0],
    height: l[3] - l[1]
  };
}
class jA {
  static create(e) {
    switch (e.data.annotationType) {
      case se.LINK:
        return new Cb(e);
      case se.TEXT:
        return new zA(e);
      case se.WIDGET:
        switch (e.data.fieldType) {
          case "Tx":
            return new BA(e);
          case "Btn":
            return e.data.radioButton ? new Nb(e) : e.data.checkBox ? new HA(e) : new WA(e);
          case "Ch":
            return new $A(e);
          case "Sig":
            return new UA(e);
        }
        return new Hn(e);
      case se.POPUP:
        return new op(e);
      case se.FREETEXT:
        return new Ob(e);
      case se.LINE:
        return new VA(e);
      case se.SQUARE:
        return new YA(e);
      case se.CIRCLE:
        return new XA(e);
      case se.POLYLINE:
        return new Fb(e);
      case se.CARET:
        return new QA(e);
      case se.INK:
        return new ag(e);
      case se.POLYGON:
        return new qA(e);
      case se.HIGHLIGHT:
        return new jb(e);
      case se.UNDERLINE:
        return new KA(e);
      case se.SQUIGGLY:
        return new ZA(e);
      case se.STRIKEOUT:
        return new JA(e);
      case se.STAMP:
        return new zb(e);
      case se.FILEATTACHMENT:
        return new t_(e);
      default:
        return new Zt(e);
    }
  }
}
var on, ja, za, nh, ap;
const dg = class dg {
  constructor(e, {
    isRenderable: t = !1,
    ignoreBorder: s = !1,
    createQuadrilaterals: i = !1
  } = {}) {
    y(this, nh);
    y(this, on, null);
    y(this, ja, !1);
    y(this, za, null);
    this.isRenderable = t, this.data = e.data, this.layer = e.layer, this.linkService = e.linkService, this.downloadManager = e.downloadManager, this.imageResourcesPath = e.imageResourcesPath, this.renderForms = e.renderForms, this.svgFactory = e.svgFactory, this.annotationStorage = e.annotationStorage, this.enableScripting = e.enableScripting, this.hasJSActions = e.hasJSActions, this._fieldObjects = e.fieldObjects, this.parent = e.parent, t && (this.container = this._createContainer(s)), i && this._createQuadrilaterals();
  }
  static _hasPopupData({
    titleObj: e,
    contentsObj: t,
    richText: s
  }) {
    return !!(e != null && e.str || t != null && t.str || s != null && s.str);
  }
  get _isEditable() {
    return this.data.isEditable;
  }
  get hasPopupData() {
    return dg._hasPopupData(this.data);
  }
  updateEdited(e) {
    var s;
    if (!this.container)
      return;
    o(this, on) || E(this, on, {
      rect: this.data.rect.slice(0)
    });
    const {
      rect: t
    } = e;
    t && x(this, nh, ap).call(this, t), (s = o(this, za)) == null || s.popup.updateEdited(e);
  }
  resetEdited() {
    var e;
    o(this, on) && (x(this, nh, ap).call(this, o(this, on).rect), (e = o(this, za)) == null || e.popup.resetEdited(), E(this, on, null));
  }
  _createContainer(e) {
    const {
      data: t,
      parent: {
        page: s,
        viewport: i
      }
    } = this, r = document.createElement("section");
    r.setAttribute("data-annotation-id", t.id), this instanceof Hn || (r.tabIndex = hc);
    const {
      style: n
    } = r;
    if (n.zIndex = this.parent.zIndex++, t.alternativeText && (r.title = t.alternativeText), t.noRotate && r.classList.add("norotate"), !t.rect || this instanceof op) {
      const {
        rotation: g
      } = t;
      return !t.hasOwnCanvas && g !== 0 && this.setRotation(g, r), r;
    }
    const {
      width: a,
      height: h
    } = ki(t.rect);
    if (!e && t.borderStyle.width > 0) {
      n.borderWidth = `${t.borderStyle.width}px`;
      const g = t.borderStyle.horizontalCornerRadius, w = t.borderStyle.verticalCornerRadius;
      if (g > 0 || w > 0) {
        const _ = `calc(${g}px * var(--scale-factor)) / calc(${w}px * var(--scale-factor))`;
        n.borderRadius = _;
      } else if (this instanceof Nb) {
        const _ = `calc(${a}px * var(--scale-factor)) / calc(${h}px * var(--scale-factor))`;
        n.borderRadius = _;
      }
      switch (t.borderStyle.style) {
        case No.SOLID:
          n.borderStyle = "solid";
          break;
        case No.DASHED:
          n.borderStyle = "dashed";
          break;
        case No.BEVELED:
          xt("Unimplemented border style: beveled");
          break;
        case No.INSET:
          xt("Unimplemented border style: inset");
          break;
        case No.UNDERLINE:
          n.borderBottomStyle = "solid";
          break;
      }
      const b = t.borderColor || null;
      b ? (E(this, ja, !0), n.borderColor = pt.makeHexColor(b[0] | 0, b[1] | 0, b[2] | 0)) : n.borderWidth = 0;
    }
    const c = pt.normalizeRect([t.rect[0], s.view[3] - t.rect[1] + s.view[1], t.rect[2], s.view[3] - t.rect[3] + s.view[1]]), {
      pageWidth: d,
      pageHeight: u,
      pageX: f,
      pageY: p
    } = i.rawDims;
    n.left = `${100 * (c[0] - f) / d}%`, n.top = `${100 * (c[1] - p) / u}%`;
    const {
      rotation: m
    } = t;
    return t.hasOwnCanvas || m === 0 ? (n.width = `${100 * a / d}%`, n.height = `${100 * h / u}%`) : this.setRotation(m, r), r;
  }
  setRotation(e, t = this.container) {
    if (!this.data.rect)
      return;
    const {
      pageWidth: s,
      pageHeight: i
    } = this.parent.viewport.rawDims, {
      width: r,
      height: n
    } = ki(this.data.rect);
    let a, h;
    e % 180 === 0 ? (a = 100 * r / s, h = 100 * n / i) : (a = 100 * n / s, h = 100 * r / i), t.style.width = `${a}%`, t.style.height = `${h}%`, t.setAttribute("data-main-rotation", (360 - e) % 360);
  }
  get _commonActions() {
    const e = (t, s, i) => {
      const r = i.detail[t], n = r[0], a = r.slice(1);
      i.target.style[s] = Gg[`${n}_HTML`](a), this.annotationStorage.setValue(this.data.id, {
        [s]: Gg[`${n}_rgb`](a)
      });
    };
    return Mt(this, "_commonActions", {
      display: (t) => {
        const {
          display: s
        } = t.detail, i = s % 2 === 1;
        this.container.style.visibility = i ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noView: i,
          noPrint: s === 1 || s === 2
        });
      },
      print: (t) => {
        this.annotationStorage.setValue(this.data.id, {
          noPrint: !t.detail.print
        });
      },
      hidden: (t) => {
        const {
          hidden: s
        } = t.detail;
        this.container.style.visibility = s ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
          noPrint: s,
          noView: s
        });
      },
      focus: (t) => {
        setTimeout(() => t.target.focus({
          preventScroll: !1
        }), 0);
      },
      userName: (t) => {
        t.target.title = t.detail.userName;
      },
      readonly: (t) => {
        t.target.disabled = t.detail.readonly;
      },
      required: (t) => {
        this._setRequired(t.target, t.detail.required);
      },
      bgColor: (t) => {
        e("bgColor", "backgroundColor", t);
      },
      fillColor: (t) => {
        e("fillColor", "backgroundColor", t);
      },
      fgColor: (t) => {
        e("fgColor", "color", t);
      },
      textColor: (t) => {
        e("textColor", "color", t);
      },
      borderColor: (t) => {
        e("borderColor", "borderColor", t);
      },
      strokeColor: (t) => {
        e("strokeColor", "borderColor", t);
      },
      rotation: (t) => {
        const s = t.detail.rotation;
        this.setRotation(s), this.annotationStorage.setValue(this.data.id, {
          rotation: s
        });
      }
    });
  }
  _dispatchEventFromSandbox(e, t) {
    const s = this._commonActions;
    for (const i of Object.keys(t.detail)) {
      const r = e[i] || s[i];
      r == null || r(t);
    }
  }
  _setDefaultPropertiesFromJS(e) {
    if (!this.enableScripting)
      return;
    const t = this.annotationStorage.getRawValue(this.data.id);
    if (!t)
      return;
    const s = this._commonActions;
    for (const [i, r] of Object.entries(t)) {
      const n = s[i];
      if (n) {
        const a = {
          detail: {
            [i]: r
          },
          target: e
        };
        n(a), delete t[i];
      }
    }
  }
  _createQuadrilaterals() {
    if (!this.container)
      return;
    const {
      quadPoints: e
    } = this.data;
    if (!e)
      return;
    const [t, s, i, r] = this.data.rect.map((g) => Math.fround(g));
    if (e.length === 8) {
      const [g, w, b, _] = e.subarray(2, 6);
      if (i === g && r === w && t === b && s === _)
        return;
    }
    const {
      style: n
    } = this.container;
    let a;
    if (o(this, ja)) {
      const {
        borderColor: g,
        borderWidth: w
      } = n;
      n.borderWidth = 0, a = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${g}" stroke-width="${w}">`], this.container.classList.add("hasBorder");
    }
    const h = i - t, c = r - s, {
      svgFactory: d
    } = this, u = d.createElement("svg");
    u.classList.add("quadrilateralsContainer"), u.setAttribute("width", 0), u.setAttribute("height", 0);
    const f = d.createElement("defs");
    u.append(f);
    const p = d.createElement("clipPath"), m = `clippath_${this.data.id}`;
    p.setAttribute("id", m), p.setAttribute("clipPathUnits", "objectBoundingBox"), f.append(p);
    for (let g = 2, w = e.length; g < w; g += 8) {
      const b = e[g], _ = e[g + 1], k = e[g + 2], C = e[g + 3], N = d.createElement("rect"), R = (k - t) / h, P = (r - _) / c, M = (b - k) / h, S = (_ - C) / c;
      N.setAttribute("x", R), N.setAttribute("y", P), N.setAttribute("width", M), N.setAttribute("height", S), p.append(N), a == null || a.push(`<rect vector-effect="non-scaling-stroke" x="${R}" y="${P}" width="${M}" height="${S}"/>`);
    }
    o(this, ja) && (a.push("</g></svg>')"), n.backgroundImage = a.join("")), this.container.append(u), this.container.style.clipPath = `url(#${m})`;
  }
  _createPopup() {
    const {
      data: e
    } = this, t = E(this, za, new op({
      data: {
        color: e.color,
        titleObj: e.titleObj,
        modificationDate: e.modificationDate,
        contentsObj: e.contentsObj,
        richText: e.richText,
        parentRect: e.rect,
        borderStyle: 0,
        id: `popup_${e.id}`,
        rotation: e.rotation
      },
      parent: this.parent,
      elements: [this]
    }));
    this.parent.div.append(t.render());
  }
  render() {
    Bt("Abstract method `AnnotationElement.render` called");
  }
  _getElementsByName(e, t = null) {
    const s = [];
    if (this._fieldObjects) {
      const i = this._fieldObjects[e];
      if (i)
        for (const {
          page: r,
          id: n,
          exportValues: a
        } of i) {
          if (r === -1 || n === t)
            continue;
          const h = typeof a == "string" ? a : null, c = document.querySelector(`[data-element-id="${n}"]`);
          if (c && !Fn.has(c)) {
            xt(`_getElementsByName - element not allowed: ${n}`);
            continue;
          }
          s.push({
            id: n,
            exportValue: h,
            domElement: c
          });
        }
      return s;
    }
    for (const i of document.getElementsByName(e)) {
      const {
        exportValue: r
      } = i, n = i.getAttribute("data-element-id");
      n !== t && Fn.has(i) && s.push({
        id: n,
        exportValue: r,
        domElement: i
      });
    }
    return s;
  }
  show() {
    var e;
    this.container && (this.container.hidden = !1), (e = this.popup) == null || e.maybeShow();
  }
  hide() {
    var e;
    this.container && (this.container.hidden = !0), (e = this.popup) == null || e.forceHide();
  }
  getElementsToTriggerPopup() {
    return this.container;
  }
  addHighlightArea() {
    const e = this.getElementsToTriggerPopup();
    if (Array.isArray(e))
      for (const t of e)
        t.classList.add("highlightArea");
    else
      e.classList.add("highlightArea");
  }
  _editOnDoubleClick() {
    if (!this._isEditable)
      return;
    const {
      annotationEditorType: e,
      data: {
        id: t
      }
    } = this;
    this.container.addEventListener("dblclick", () => {
      var s;
      (s = this.linkService.eventBus) == null || s.dispatch("switchannotationeditormode", {
        source: this,
        mode: e,
        editId: t
      });
    });
  }
};
on = new WeakMap(), ja = new WeakMap(), za = new WeakMap(), nh = new WeakSet(), ap = function(e) {
  const {
    container: {
      style: t
    },
    data: {
      rect: s,
      rotation: i
    },
    parent: {
      viewport: {
        rawDims: {
          pageWidth: r,
          pageHeight: n,
          pageX: a,
          pageY: h
        }
      }
    }
  } = this;
  s == null || s.splice(0, 4, ...e);
  const {
    width: c,
    height: d
  } = ki(e);
  t.left = `${100 * (e[0] - a) / r}%`, t.top = `${100 * (n - e[3] + h) / n}%`, i === 0 ? (t.width = `${100 * c / r}%`, t.height = `${100 * d / n}%`) : this.setRotation(i);
};
let Zt = dg;
var ai, vr, Xd, Tb, qd, Ib;
class Cb extends Zt {
  constructor(t, s = null) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !!(s != null && s.ignoreBorder),
      createQuadrilaterals: !0
    });
    y(this, ai);
    y(this, Xd);
    y(this, qd);
    this.isTooltipOnly = t.data.isTooltipOnly;
  }
  render() {
    const {
      data: t,
      linkService: s
    } = this, i = document.createElement("a");
    i.setAttribute("data-element-id", t.id);
    let r = !1;
    return t.url ? (s.addLinkAttributes(i, t.url, t.newWindow), r = !0) : t.action ? (this._bindNamedAction(i, t.action), r = !0) : t.attachment ? (x(this, Xd, Tb).call(this, i, t.attachment, t.attachmentDest), r = !0) : t.setOCGState ? (x(this, qd, Ib).call(this, i, t.setOCGState), r = !0) : t.dest ? (this._bindLink(i, t.dest), r = !0) : (t.actions && (t.actions.Action || t.actions["Mouse Up"] || t.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(i, t), r = !0), t.resetForm ? (this._bindResetFormAction(i, t.resetForm), r = !0) : this.isTooltipOnly && !r && (this._bindLink(i, ""), r = !0)), this.container.classList.add("linkAnnotation"), r && this.container.append(i), this.container;
  }
  _bindLink(t, s) {
    t.href = this.linkService.getDestinationHash(s), t.onclick = () => (s && this.linkService.goToDestination(s), !1), (s || s === "") && x(this, ai, vr).call(this);
  }
  _bindNamedAction(t, s) {
    t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeNamedAction(s), !1), x(this, ai, vr).call(this);
  }
  _bindJSAction(t, s) {
    t.href = this.linkService.getAnchorUrl("");
    const i = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
    for (const r of Object.keys(s.actions)) {
      const n = i.get(r);
      n && (t[n] = () => {
        var a;
        return (a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: s.id,
            name: r
          }
        }), !1;
      });
    }
    t.onclick || (t.onclick = () => !1), x(this, ai, vr).call(this);
  }
  _bindResetFormAction(t, s) {
    const i = t.onclick;
    if (i || (t.href = this.linkService.getAnchorUrl("")), x(this, ai, vr).call(this), !this._fieldObjects) {
      xt('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), i || (t.onclick = () => !1);
      return;
    }
    t.onclick = () => {
      var u;
      i == null || i();
      const {
        fields: r,
        refs: n,
        include: a
      } = s, h = [];
      if (r.length !== 0 || n.length !== 0) {
        const f = new Set(n);
        for (const p of r) {
          const m = this._fieldObjects[p] || [];
          for (const {
            id: g
          } of m)
            f.add(g);
        }
        for (const p of Object.values(this._fieldObjects))
          for (const m of p)
            f.has(m.id) === a && h.push(m);
      } else
        for (const f of Object.values(this._fieldObjects))
          h.push(...f);
      const c = this.annotationStorage, d = [];
      for (const f of h) {
        const {
          id: p
        } = f;
        switch (d.push(p), f.type) {
          case "text": {
            const g = f.defaultValue || "";
            c.setValue(p, {
              value: g
            });
            break;
          }
          case "checkbox":
          case "radiobutton": {
            const g = f.defaultValue === f.exportValues;
            c.setValue(p, {
              value: g
            });
            break;
          }
          case "combobox":
          case "listbox": {
            const g = f.defaultValue || "";
            c.setValue(p, {
              value: g
            });
            break;
          }
          default:
            continue;
        }
        const m = document.querySelector(`[data-element-id="${p}"]`);
        if (m) {
          if (!Fn.has(m)) {
            xt(`_bindResetFormAction - element not allowed: ${p}`);
            continue;
          }
        } else
          continue;
        m.dispatchEvent(new Event("resetform"));
      }
      return this.enableScripting && ((u = this.linkService.eventBus) == null || u.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: "app",
          ids: d,
          name: "ResetForm"
        }
      })), !1;
    };
  }
}
ai = new WeakSet(), vr = function() {
  this.container.setAttribute("data-internal-link", "");
}, Xd = new WeakSet(), Tb = function(t, s, i = null) {
  t.href = this.linkService.getAnchorUrl(""), s.description && (t.title = s.description), t.onclick = () => {
    var r;
    return (r = this.downloadManager) == null || r.openOrDownloadData(s.content, s.filename, i), !1;
  }, x(this, ai, vr).call(this);
}, qd = new WeakSet(), Ib = function(t, s) {
  t.href = this.linkService.getAnchorUrl(""), t.onclick = () => (this.linkService.executeSetOCGState(s), !1), x(this, ai, vr).call(this);
};
class zA extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0
    });
  }
  render() {
    this.container.classList.add("textAnnotation");
    const e = document.createElement("img");
    return e.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", e.setAttribute("data-l10n-id", "pdfjs-text-annotation-type"), e.setAttribute("data-l10n-args", JSON.stringify({
      type: this.data.name
    })), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(e), this.container;
  }
}
class Hn extends Zt {
  render() {
    return this.container;
  }
  showElementAndHideCanvas(e) {
    var t;
    this.data.hasOwnCanvas && (((t = e.previousSibling) == null ? void 0 : t.nodeName) === "CANVAS" && (e.previousSibling.hidden = !0), e.hidden = !1);
  }
  _getKeyModifier(e) {
    return Pe.platform.isMac ? e.metaKey : e.ctrlKey;
  }
  _setEventListener(e, t, s, i, r) {
    s.includes("mouse") ? e.addEventListener(s, (n) => {
      var a;
      (a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: r(n),
          shift: n.shiftKey,
          modifier: this._getKeyModifier(n)
        }
      });
    }) : e.addEventListener(s, (n) => {
      var a;
      if (s === "blur") {
        if (!t.focused || !n.relatedTarget)
          return;
        t.focused = !1;
      } else if (s === "focus") {
        if (t.focused)
          return;
        t.focused = !0;
      }
      r && ((a = this.linkService.eventBus) == null || a.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: this.data.id,
          name: i,
          value: r(n)
        }
      }));
    });
  }
  _setEventListeners(e, t, s, i) {
    var r, n, a;
    for (const [h, c] of s)
      (c === "Action" || (r = this.data.actions) != null && r[c]) && ((c === "Focus" || c === "Blur") && (t || (t = {
        focused: !1
      })), this._setEventListener(e, t, h, c, i), c === "Focus" && !((n = this.data.actions) != null && n.Blur) ? this._setEventListener(e, t, "blur", "Blur", null) : c === "Blur" && !((a = this.data.actions) != null && a.Focus) && this._setEventListener(e, t, "focus", "Focus", null));
  }
  _setBackgroundColor(e) {
    const t = this.data.backgroundColor || null;
    e.style.backgroundColor = t === null ? "transparent" : pt.makeHexColor(t[0], t[1], t[2]);
  }
  _setTextStyle(e) {
    const t = ["left", "center", "right"], {
      fontColor: s
    } = this.data.defaultAppearanceData, i = this.data.defaultAppearanceData.fontSize || FA, r = e.style;
    let n;
    const a = 2, h = (c) => Math.round(10 * c) / 10;
    if (this.data.multiLine) {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - a), d = Math.round(c / (pf * i)) || 1, u = c / d;
      n = Math.min(i, h(u / pf));
    } else {
      const c = Math.abs(this.data.rect[3] - this.data.rect[1] - a);
      n = Math.min(i, h(c / pf));
    }
    r.fontSize = `calc(${n}px * var(--scale-factor))`, r.color = pt.makeHexColor(s[0], s[1], s[2]), this.data.textAlignment !== null && (r.textAlign = t[this.data.textAlignment]);
  }
  _setRequired(e, t) {
    t ? e.setAttribute("required", !0) : e.removeAttribute("required"), e.setAttribute("aria-required", t);
  }
}
class BA extends Hn {
  constructor(e) {
    const t = e.renderForms || e.data.hasOwnCanvas || !e.data.hasAppearance && !!e.data.fieldValue;
    super(e, {
      isRenderable: t
    });
  }
  setPropertyOnSiblings(e, t, s, i) {
    const r = this.annotationStorage;
    for (const n of this._getElementsByName(e.name, e.id))
      n.domElement && (n.domElement[t] = s), r.setValue(n.id, {
        [i]: s
      });
  }
  render() {
    var i, r;
    const e = this.annotationStorage, t = this.data.id;
    this.container.classList.add("textWidgetAnnotation");
    let s = null;
    if (this.renderForms) {
      const n = e.getValue(t, {
        value: this.data.fieldValue
      });
      let a = n.value || "";
      const h = e.getValue(t, {
        charLimit: this.data.maxLen
      }).charLimit;
      h && a.length > h && (a = a.slice(0, h));
      let c = n.formattedValue || ((i = this.data.textContent) == null ? void 0 : i.join(`
`)) || null;
      c && this.data.comb && (c = c.replaceAll(/\s+/g, ""));
      const d = {
        userValue: a,
        formattedValue: c,
        lastCommittedValue: null,
        commitKey: 1,
        focused: !1
      };
      this.data.multiLine ? (s = document.createElement("textarea"), s.textContent = c ?? a, this.data.doNotScroll && (s.style.overflowY = "hidden")) : (s = document.createElement("input"), s.type = "text", s.setAttribute("value", c ?? a), this.data.doNotScroll && (s.style.overflowX = "hidden")), this.data.hasOwnCanvas && (s.hidden = !0), Fn.add(s), s.setAttribute("data-element-id", t), s.disabled = this.data.readOnly, s.name = this.data.fieldName, s.tabIndex = hc, this._setRequired(s, this.data.required), h && (s.maxLength = h), s.addEventListener("input", (f) => {
        e.setValue(t, {
          value: f.target.value
        }), this.setPropertyOnSiblings(s, "value", f.target.value, "value"), d.formattedValue = null;
      }), s.addEventListener("resetform", (f) => {
        const p = this.data.defaultFieldValue ?? "";
        s.value = d.userValue = p, d.formattedValue = null;
      });
      let u = (f) => {
        const {
          formattedValue: p
        } = d;
        p != null && (f.target.value = p), f.target.scrollLeft = 0;
      };
      if (this.enableScripting && this.hasJSActions) {
        s.addEventListener("focus", (p) => {
          var g;
          if (d.focused)
            return;
          const {
            target: m
          } = p;
          d.userValue && (m.value = d.userValue), d.lastCommittedValue = m.value, d.commitKey = 1, (g = this.data.actions) != null && g.Focus || (d.focused = !0);
        }), s.addEventListener("updatefromsandbox", (p) => {
          this.showElementAndHideCanvas(p.target);
          const m = {
            value(g) {
              d.userValue = g.detail.value ?? "", e.setValue(t, {
                value: d.userValue.toString()
              }), g.target.value = d.userValue;
            },
            formattedValue(g) {
              const {
                formattedValue: w
              } = g.detail;
              d.formattedValue = w, w != null && g.target !== document.activeElement && (g.target.value = w), e.setValue(t, {
                formattedValue: w
              });
            },
            selRange(g) {
              g.target.setSelectionRange(...g.detail.selRange);
            },
            charLimit: (g) => {
              var k;
              const {
                charLimit: w
              } = g.detail, {
                target: b
              } = g;
              if (w === 0) {
                b.removeAttribute("maxLength");
                return;
              }
              b.setAttribute("maxLength", w);
              let _ = d.userValue;
              !_ || _.length <= w || (_ = _.slice(0, w), b.value = d.userValue = _, e.setValue(t, {
                value: _
              }), (k = this.linkService.eventBus) == null || k.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id: t,
                  name: "Keystroke",
                  value: _,
                  willCommit: !0,
                  commitKey: 1,
                  selStart: b.selectionStart,
                  selEnd: b.selectionEnd
                }
              }));
            }
          };
          this._dispatchEventFromSandbox(m, p);
        }), s.addEventListener("keydown", (p) => {
          var w;
          d.commitKey = 1;
          let m = -1;
          if (p.key === "Escape" ? m = 0 : p.key === "Enter" && !this.data.multiLine ? m = 2 : p.key === "Tab" && (d.commitKey = 3), m === -1)
            return;
          const {
            value: g
          } = p.target;
          d.lastCommittedValue !== g && (d.lastCommittedValue = g, d.userValue = g, (w = this.linkService.eventBus) == null || w.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: g,
              willCommit: !0,
              commitKey: m,
              selStart: p.target.selectionStart,
              selEnd: p.target.selectionEnd
            }
          }));
        });
        const f = u;
        u = null, s.addEventListener("blur", (p) => {
          var g, w;
          if (!d.focused || !p.relatedTarget)
            return;
          (g = this.data.actions) != null && g.Blur || (d.focused = !1);
          const {
            value: m
          } = p.target;
          d.userValue = m, d.lastCommittedValue !== m && ((w = this.linkService.eventBus) == null || w.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: m,
              willCommit: !0,
              commitKey: d.commitKey,
              selStart: p.target.selectionStart,
              selEnd: p.target.selectionEnd
            }
          })), f(p);
        }), (r = this.data.actions) != null && r.Keystroke && s.addEventListener("beforeinput", (p) => {
          var N;
          d.lastCommittedValue = null;
          const {
            data: m,
            target: g
          } = p, {
            value: w,
            selectionStart: b,
            selectionEnd: _
          } = g;
          let k = b, C = _;
          switch (p.inputType) {
            case "deleteWordBackward": {
              const R = w.substring(0, b).match(/\w*[^\w]*$/);
              R && (k -= R[0].length);
              break;
            }
            case "deleteWordForward": {
              const R = w.substring(b).match(/^[^\w]*\w*/);
              R && (C += R[0].length);
              break;
            }
            case "deleteContentBackward":
              b === _ && (k -= 1);
              break;
            case "deleteContentForward":
              b === _ && (C += 1);
              break;
          }
          p.preventDefault(), (N = this.linkService.eventBus) == null || N.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id: t,
              name: "Keystroke",
              value: w,
              change: m || "",
              willCommit: !1,
              selStart: k,
              selEnd: C
            }
          });
        }), this._setEventListeners(s, d, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (p) => p.target.value);
      }
      if (u && s.addEventListener("blur", u), this.data.comb) {
        const p = (this.data.rect[2] - this.data.rect[0]) / h;
        s.classList.add("comb"), s.style.letterSpacing = `calc(${p}px * var(--scale-factor) - 1ch)`;
      }
    } else
      s = document.createElement("div"), s.textContent = this.data.fieldValue, s.style.verticalAlign = "middle", s.style.display = "table-cell", this.data.hasOwnCanvas && (s.hidden = !0);
    return this._setTextStyle(s), this._setBackgroundColor(s), this._setDefaultPropertiesFromJS(s), this.container.append(s), this.container;
  }
}
class UA extends Hn {
  constructor(e) {
    super(e, {
      isRenderable: !!e.data.hasOwnCanvas
    });
  }
}
class HA extends Hn {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.exportValue === t.fieldValue
    }).value;
    typeof i == "string" && (i = i !== "Off", e.setValue(s, {
      value: i
    })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
    const r = document.createElement("input");
    return Fn.add(r), r.setAttribute("data-element-id", s), r.disabled = t.readOnly, this._setRequired(r, this.data.required), r.type = "checkbox", r.name = t.fieldName, i && r.setAttribute("checked", !0), r.setAttribute("exportValue", t.exportValue), r.tabIndex = hc, r.addEventListener("change", (n) => {
      const {
        name: a,
        checked: h
      } = n.target;
      for (const c of this._getElementsByName(a, s)) {
        const d = h && c.exportValue === t.exportValue;
        c.domElement && (c.domElement.checked = d), e.setValue(c.id, {
          value: d
        });
      }
      e.setValue(s, {
        value: h
      });
    }), r.addEventListener("resetform", (n) => {
      const a = t.defaultFieldValue || "Off";
      n.target.checked = a === t.exportValue;
    }), this.enableScripting && this.hasJSActions && (r.addEventListener("updatefromsandbox", (n) => {
      const a = {
        value(h) {
          h.target.checked = h.detail.value !== "Off", e.setValue(s, {
            value: h.target.checked
          });
        }
      };
      this._dispatchEventFromSandbox(a, n);
    }), this._setEventListeners(r, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (n) => n.target.checked)), this._setBackgroundColor(r), this._setDefaultPropertiesFromJS(r), this.container.append(r), this.container;
  }
}
class Nb extends Hn {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("buttonWidgetAnnotation", "radioButton");
    const e = this.annotationStorage, t = this.data, s = t.id;
    let i = e.getValue(s, {
      value: t.fieldValue === t.buttonValue
    }).value;
    if (typeof i == "string" && (i = i !== t.buttonValue, e.setValue(s, {
      value: i
    })), i)
      for (const n of this._getElementsByName(t.fieldName, s))
        e.setValue(n.id, {
          value: !1
        });
    const r = document.createElement("input");
    if (Fn.add(r), r.setAttribute("data-element-id", s), r.disabled = t.readOnly, this._setRequired(r, this.data.required), r.type = "radio", r.name = t.fieldName, i && r.setAttribute("checked", !0), r.tabIndex = hc, r.addEventListener("change", (n) => {
      const {
        name: a,
        checked: h
      } = n.target;
      for (const c of this._getElementsByName(a, s))
        e.setValue(c.id, {
          value: !1
        });
      e.setValue(s, {
        value: h
      });
    }), r.addEventListener("resetform", (n) => {
      const a = t.defaultFieldValue;
      n.target.checked = a != null && a === t.buttonValue;
    }), this.enableScripting && this.hasJSActions) {
      const n = t.buttonValue;
      r.addEventListener("updatefromsandbox", (a) => {
        const h = {
          value: (c) => {
            const d = n === c.detail.value;
            for (const u of this._getElementsByName(c.target.name)) {
              const f = d && u.id === s;
              u.domElement && (u.domElement.checked = f), e.setValue(u.id, {
                value: f
              });
            }
          }
        };
        this._dispatchEventFromSandbox(h, a);
      }), this._setEventListeners(r, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (a) => a.target.checked);
    }
    return this._setBackgroundColor(r), this._setDefaultPropertiesFromJS(r), this.container.append(r), this.container;
  }
}
class WA extends Cb {
  constructor(e) {
    super(e, {
      ignoreBorder: e.data.hasAppearance
    });
  }
  render() {
    const e = super.render();
    e.classList.add("buttonWidgetAnnotation", "pushButton");
    const t = e.lastChild;
    return this.enableScripting && this.hasJSActions && t && (this._setDefaultPropertiesFromJS(t), t.addEventListener("updatefromsandbox", (s) => {
      this._dispatchEventFromSandbox({}, s);
    })), e;
  }
}
class $A extends Hn {
  constructor(e) {
    super(e, {
      isRenderable: e.renderForms
    });
  }
  render() {
    this.container.classList.add("choiceWidgetAnnotation");
    const e = this.annotationStorage, t = this.data.id, s = e.getValue(t, {
      value: this.data.fieldValue
    }), i = document.createElement("select");
    Fn.add(i), i.setAttribute("data-element-id", t), i.disabled = this.data.readOnly, this._setRequired(i, this.data.required), i.name = this.data.fieldName, i.tabIndex = hc;
    let r = this.data.combo && this.data.options.length > 0;
    this.data.combo || (i.size = this.data.options.length, this.data.multiSelect && (i.multiple = !0)), i.addEventListener("resetform", (d) => {
      const u = this.data.defaultFieldValue;
      for (const f of i.options)
        f.selected = f.value === u;
    });
    for (const d of this.data.options) {
      const u = document.createElement("option");
      u.textContent = d.displayValue, u.value = d.exportValue, s.value.includes(d.exportValue) && (u.setAttribute("selected", !0), r = !1), i.append(u);
    }
    let n = null;
    if (r) {
      const d = document.createElement("option");
      d.value = " ", d.setAttribute("hidden", !0), d.setAttribute("selected", !0), i.prepend(d), n = () => {
        d.remove(), i.removeEventListener("input", n), n = null;
      }, i.addEventListener("input", n);
    }
    const a = (d) => {
      const u = d ? "value" : "textContent", {
        options: f,
        multiple: p
      } = i;
      return p ? Array.prototype.filter.call(f, (m) => m.selected).map((m) => m[u]) : f.selectedIndex === -1 ? null : f[f.selectedIndex][u];
    };
    let h = a(!1);
    const c = (d) => {
      const u = d.target.options;
      return Array.prototype.map.call(u, (f) => ({
        displayValue: f.textContent,
        exportValue: f.value
      }));
    };
    return this.enableScripting && this.hasJSActions ? (i.addEventListener("updatefromsandbox", (d) => {
      const u = {
        value(f) {
          n == null || n();
          const p = f.detail.value, m = new Set(Array.isArray(p) ? p : [p]);
          for (const g of i.options)
            g.selected = m.has(g.value);
          e.setValue(t, {
            value: a(!0)
          }), h = a(!1);
        },
        multipleSelection(f) {
          i.multiple = !0;
        },
        remove(f) {
          const p = i.options, m = f.detail.remove;
          p[m].selected = !1, i.remove(m), p.length > 0 && Array.prototype.findIndex.call(p, (w) => w.selected) === -1 && (p[0].selected = !0), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        clear(f) {
          for (; i.length !== 0; )
            i.remove(0);
          e.setValue(t, {
            value: null,
            items: []
          }), h = a(!1);
        },
        insert(f) {
          const {
            index: p,
            displayValue: m,
            exportValue: g
          } = f.detail.insert, w = i.children[p], b = document.createElement("option");
          b.textContent = m, b.value = g, w ? w.before(b) : i.append(b), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        items(f) {
          const {
            items: p
          } = f.detail;
          for (; i.length !== 0; )
            i.remove(0);
          for (const m of p) {
            const {
              displayValue: g,
              exportValue: w
            } = m, b = document.createElement("option");
            b.textContent = g, b.value = w, i.append(b);
          }
          i.options.length > 0 && (i.options[0].selected = !0), e.setValue(t, {
            value: a(!0),
            items: c(f)
          }), h = a(!1);
        },
        indices(f) {
          const p = new Set(f.detail.indices);
          for (const m of f.target.options)
            m.selected = p.has(m.index);
          e.setValue(t, {
            value: a(!0)
          }), h = a(!1);
        },
        editable(f) {
          f.target.disabled = !f.detail.editable;
        }
      };
      this._dispatchEventFromSandbox(u, d);
    }), i.addEventListener("input", (d) => {
      var p;
      const u = a(!0), f = a(!1);
      e.setValue(t, {
        value: u
      }), d.preventDefault(), (p = this.linkService.eventBus) == null || p.dispatch("dispatcheventinsandbox", {
        source: this,
        detail: {
          id: t,
          name: "Keystroke",
          value: h,
          change: f,
          changeEx: u,
          willCommit: !1,
          commitKey: 1,
          keyDown: !1
        }
      });
    }), this._setEventListeners(i, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (d) => d.target.value)) : i.addEventListener("input", function(d) {
      e.setValue(t, {
        value: a(!0)
      });
    }), this.data.combo && this._setTextStyle(i), this._setBackgroundColor(i), this._setDefaultPropertiesFromJS(i), this.container.append(i), this.container;
  }
}
class op extends Zt {
  constructor(e) {
    const {
      data: t,
      elements: s
    } = e;
    super(e, {
      isRenderable: Zt._hasPopupData(t)
    }), this.elements = s, this.popup = null;
  }
  render() {
    this.container.classList.add("popupAnnotation");
    const e = this.popup = new GA({
      container: this.container,
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText,
      rect: this.data.rect,
      parentRect: this.data.parentRect || null,
      parent: this.parent,
      elements: this.elements,
      open: this.data.open
    }), t = [];
    for (const s of this.elements)
      s.popup = e, s.container.ariaHasPopup = "dialog", t.push(s.data.id), s.addHighlightArea();
    return this.container.setAttribute("aria-controls", t.map((s) => `${qp}${s}`).join(",")), this.container;
  }
}
var Ba, Qd, Kd, Ua, ln, Yt, oi, Ha, ah, oh, Wa, li, gs, hi, lh, ci, hh, hn, cn, $a, Lc, ch, lp, Zd, Db, Jd, Pb, tu, Lb, eu, Rb, Ga, Rc, Va, Oc, dh, hp;
class GA {
  constructor({
    container: e,
    color: t,
    elements: s,
    titleObj: i,
    modificationDate: r,
    contentsObj: n,
    richText: a,
    parent: h,
    rect: c,
    parentRect: d,
    open: u
  }) {
    y(this, $a);
    y(this, ch);
    y(this, Zd);
    y(this, Jd);
    y(this, tu);
    y(this, eu);
    y(this, Ga);
    y(this, Va);
    y(this, dh);
    y(this, Ba, x(this, tu, Lb).bind(this));
    y(this, Qd, x(this, dh, hp).bind(this));
    y(this, Kd, x(this, Va, Oc).bind(this));
    y(this, Ua, x(this, Ga, Rc).bind(this));
    y(this, ln, null);
    y(this, Yt, null);
    y(this, oi, null);
    y(this, Ha, null);
    y(this, ah, null);
    y(this, oh, null);
    y(this, Wa, null);
    y(this, li, !1);
    y(this, gs, null);
    y(this, hi, null);
    y(this, lh, null);
    y(this, ci, null);
    y(this, hh, null);
    y(this, hn, null);
    y(this, cn, !1);
    var f;
    E(this, Yt, e), E(this, hh, i), E(this, oi, n), E(this, ci, a), E(this, oh, h), E(this, ln, t), E(this, lh, c), E(this, Wa, d), E(this, ah, s), E(this, Ha, Zp.toDateObject(r)), this.trigger = s.flatMap((p) => p.getElementsToTriggerPopup());
    for (const p of this.trigger)
      p.addEventListener("click", o(this, Ua)), p.addEventListener("mouseenter", o(this, Kd)), p.addEventListener("mouseleave", o(this, Qd)), p.classList.add("popupTriggerArea");
    for (const p of s)
      (f = p.container) == null || f.addEventListener("keydown", o(this, Ba));
    o(this, Yt).hidden = !0, u && x(this, Ga, Rc).call(this);
  }
  render() {
    if (o(this, gs))
      return;
    const e = E(this, gs, document.createElement("div"));
    if (e.className = "popup", o(this, ln)) {
      const r = e.style.outlineColor = pt.makeHexColor(...o(this, ln));
      CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? e.style.backgroundColor = `color-mix(in srgb, ${r} 30%, white)` : e.style.backgroundColor = pt.makeHexColor(...o(this, ln).map((a) => Math.floor(0.7 * (255 - a) + a)));
    }
    const t = document.createElement("span");
    t.className = "header";
    const s = document.createElement("h1");
    if (t.append(s), {
      dir: s.dir,
      str: s.textContent
    } = o(this, hh), e.append(t), o(this, Ha)) {
      const r = document.createElement("span");
      r.classList.add("popupDate"), r.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string"), r.setAttribute("data-l10n-args", JSON.stringify({
        dateObj: o(this, Ha).valueOf()
      })), t.append(r);
    }
    const i = o(this, $a, Lc);
    if (i)
      Mb.render({
        xfaHtml: i,
        intent: "richText",
        div: e
      }), e.lastChild.classList.add("richText", "popupContent");
    else {
      const r = this._formatContents(o(this, oi));
      e.append(r);
    }
    o(this, Yt).append(e);
  }
  _formatContents({
    str: e,
    dir: t
  }) {
    const s = document.createElement("p");
    s.classList.add("popupContent"), s.dir = t;
    const i = e.split(/(?:\r\n?|\n)/);
    for (let r = 0, n = i.length; r < n; ++r) {
      const a = i[r];
      s.append(document.createTextNode(a)), r < n - 1 && s.append(document.createElement("br"));
    }
    return s;
  }
  updateEdited({
    rect: e,
    popupContent: t
  }) {
    var s;
    o(this, hn) || E(this, hn, {
      contentsObj: o(this, oi),
      richText: o(this, ci)
    }), e && E(this, hi, null), t && (E(this, ci, x(this, Jd, Pb).call(this, t)), E(this, oi, null)), (s = o(this, gs)) == null || s.remove(), E(this, gs, null);
  }
  resetEdited() {
    var e;
    o(this, hn) && ({
      contentsObj: Te(this, oi)._,
      richText: Te(this, ci)._
    } = o(this, hn), E(this, hn, null), (e = o(this, gs)) == null || e.remove(), E(this, gs, null), E(this, hi, null));
  }
  forceHide() {
    E(this, cn, this.isVisible), o(this, cn) && (o(this, Yt).hidden = !0);
  }
  maybeShow() {
    o(this, cn) && (o(this, gs) || x(this, Va, Oc).call(this), E(this, cn, !1), o(this, Yt).hidden = !1);
  }
  get isVisible() {
    return o(this, Yt).hidden === !1;
  }
}
Ba = new WeakMap(), Qd = new WeakMap(), Kd = new WeakMap(), Ua = new WeakMap(), ln = new WeakMap(), Yt = new WeakMap(), oi = new WeakMap(), Ha = new WeakMap(), ah = new WeakMap(), oh = new WeakMap(), Wa = new WeakMap(), li = new WeakMap(), gs = new WeakMap(), hi = new WeakMap(), lh = new WeakMap(), ci = new WeakMap(), hh = new WeakMap(), hn = new WeakMap(), cn = new WeakMap(), $a = new WeakSet(), Lc = function() {
  const e = o(this, ci), t = o(this, oi);
  return e != null && e.str && (!(t != null && t.str) || t.str === e.str) && o(this, ci).html || null;
}, ch = new WeakSet(), lp = function() {
  var e, t, s;
  return ((s = (t = (e = o(this, $a, Lc)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.fontSize) || 0;
}, Zd = new WeakSet(), Db = function() {
  var e, t, s;
  return ((s = (t = (e = o(this, $a, Lc)) == null ? void 0 : e.attributes) == null ? void 0 : t.style) == null ? void 0 : s.color) || null;
}, Jd = new WeakSet(), Pb = function(e) {
  const t = [], s = {
    str: e,
    html: {
      name: "div",
      attributes: {
        dir: "auto"
      },
      children: [{
        name: "p",
        children: t
      }]
    }
  }, i = {
    style: {
      color: o(this, Zd, Db),
      fontSize: o(this, ch, lp) ? `calc(${o(this, ch, lp)}px * var(--scale-factor))` : ""
    }
  };
  for (const r of e.split(`
`))
    t.push({
      name: "span",
      value: r,
      attributes: i
    });
  return s;
}, tu = new WeakSet(), Lb = function(e) {
  e.altKey || e.shiftKey || e.ctrlKey || e.metaKey || (e.key === "Enter" || e.key === "Escape" && o(this, li)) && x(this, Ga, Rc).call(this);
}, eu = new WeakSet(), Rb = function() {
  if (o(this, hi) !== null)
    return;
  const {
    page: {
      view: e
    },
    viewport: {
      rawDims: {
        pageWidth: t,
        pageHeight: s,
        pageX: i,
        pageY: r
      }
    }
  } = o(this, oh);
  let n = !!o(this, Wa), a = n ? o(this, Wa) : o(this, lh);
  for (const m of o(this, ah))
    if (!a || pt.intersect(m.data.rect, a) !== null) {
      a = m.data.rect, n = !0;
      break;
    }
  const h = pt.normalizeRect([a[0], e[3] - a[1] + e[1], a[2], e[3] - a[3] + e[1]]), c = 5, d = n ? a[2] - a[0] + c : 0, u = h[0] + d, f = h[1];
  E(this, hi, [100 * (u - i) / t, 100 * (f - r) / s]);
  const {
    style: p
  } = o(this, Yt);
  p.left = `${o(this, hi)[0]}%`, p.top = `${o(this, hi)[1]}%`;
}, Ga = new WeakSet(), Rc = function() {
  E(this, li, !o(this, li)), o(this, li) ? (x(this, Va, Oc).call(this), o(this, Yt).addEventListener("click", o(this, Ua)), o(this, Yt).addEventListener("keydown", o(this, Ba))) : (x(this, dh, hp).call(this), o(this, Yt).removeEventListener("click", o(this, Ua)), o(this, Yt).removeEventListener("keydown", o(this, Ba)));
}, Va = new WeakSet(), Oc = function() {
  o(this, gs) || this.render(), this.isVisible ? o(this, li) && o(this, Yt).classList.add("focused") : (x(this, eu, Rb).call(this), o(this, Yt).hidden = !1, o(this, Yt).style.zIndex = parseInt(o(this, Yt).style.zIndex) + 1e3);
}, dh = new WeakSet(), hp = function() {
  o(this, Yt).classList.remove("focused"), !(o(this, li) || !this.isVisible) && (o(this, Yt).hidden = !0, o(this, Yt).style.zIndex = parseInt(o(this, Yt).style.zIndex) - 1e3);
};
class Ob extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.textContent = e.data.textContent, this.textPosition = e.data.textPosition, this.annotationEditorType = _t.FREETEXT;
  }
  render() {
    if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
      const e = document.createElement("div");
      e.classList.add("annotationTextContent"), e.setAttribute("role", "comment");
      for (const t of this.textContent) {
        const s = document.createElement("span");
        s.textContent = t, e.append(s);
      }
      this.container.append(e);
    }
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
var uh;
class VA extends Zt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, uh, null);
  }
  render() {
    this.container.classList.add("lineAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = ki(t.rect), r = this.svgFactory.create(s, i, !0), n = E(this, uh, this.svgFactory.createElement("svg:line"));
    return n.setAttribute("x1", t.rect[2] - t.lineCoordinates[0]), n.setAttribute("y1", t.rect[3] - t.lineCoordinates[1]), n.setAttribute("x2", t.rect[2] - t.lineCoordinates[2]), n.setAttribute("y2", t.rect[3] - t.lineCoordinates[3]), n.setAttribute("stroke-width", t.borderStyle.width || 1), n.setAttribute("stroke", "transparent"), n.setAttribute("fill", "transparent"), r.append(n), this.container.append(r), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, uh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
uh = new WeakMap();
var fh;
class YA extends Zt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, fh, null);
  }
  render() {
    this.container.classList.add("squareAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = ki(t.rect), r = this.svgFactory.create(s, i, !0), n = t.borderStyle.width, a = E(this, fh, this.svgFactory.createElement("svg:rect"));
    return a.setAttribute("x", n / 2), a.setAttribute("y", n / 2), a.setAttribute("width", s - n), a.setAttribute("height", i - n), a.setAttribute("stroke-width", n || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), r.append(a), this.container.append(r), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, fh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
fh = new WeakMap();
var ph;
class XA extends Zt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, ph, null);
  }
  render() {
    this.container.classList.add("circleAnnotation");
    const t = this.data, {
      width: s,
      height: i
    } = ki(t.rect), r = this.svgFactory.create(s, i, !0), n = t.borderStyle.width, a = E(this, ph, this.svgFactory.createElement("svg:ellipse"));
    return a.setAttribute("cx", s / 2), a.setAttribute("cy", i / 2), a.setAttribute("rx", s / 2 - n / 2), a.setAttribute("ry", i / 2 - n / 2), a.setAttribute("stroke-width", n || 1), a.setAttribute("stroke", "transparent"), a.setAttribute("fill", "transparent"), r.append(a), this.container.append(r), !t.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, ph);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
ph = new WeakMap();
var gh;
class Fb extends Zt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, gh, null);
    this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        vertices: s,
        borderStyle: i,
        popupRef: r
      }
    } = this;
    if (!s)
      return this.container;
    const {
      width: n,
      height: a
    } = ki(t), h = this.svgFactory.create(n, a, !0);
    let c = [];
    for (let u = 0, f = s.length; u < f; u += 2) {
      const p = s[u] - t[0], m = t[3] - s[u + 1];
      c.push(`${p},${m}`);
    }
    c = c.join(" ");
    const d = E(this, gh, this.svgFactory.createElement(this.svgElementName));
    return d.setAttribute("points", c), d.setAttribute("stroke-width", i.width || 1), d.setAttribute("stroke", "transparent"), d.setAttribute("fill", "transparent"), h.append(d), this.container.append(h), !r && this.hasPopupData && this._createPopup(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, gh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
gh = new WeakMap();
class qA extends Fb {
  constructor(e) {
    super(e), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
  }
}
class QA extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    });
  }
  render() {
    return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
  }
}
var mh;
class ag extends Zt {
  constructor(t) {
    super(t, {
      isRenderable: !0,
      ignoreBorder: !0
    });
    y(this, mh, []);
    this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = this.data.it === "InkHighlight" ? _t.HIGHLIGHT : _t.INK;
  }
  render() {
    this.container.classList.add(this.containerClassName);
    const {
      data: {
        rect: t,
        inkLists: s,
        borderStyle: i,
        popupRef: r
      }
    } = this, {
      width: n,
      height: a
    } = ki(t), h = this.svgFactory.create(n, a, !0);
    for (const c of s) {
      let d = [];
      for (let f = 0, p = c.length; f < p; f += 2) {
        const m = c[f] - t[0], g = t[3] - c[f + 1];
        d.push(`${m},${g}`);
      }
      d = d.join(" ");
      const u = this.svgFactory.createElement(this.svgElementName);
      o(this, mh).push(u), u.setAttribute("points", d), u.setAttribute("stroke-width", i.width || 1), u.setAttribute("stroke", "transparent"), u.setAttribute("fill", "transparent"), h.append(u);
    }
    return !r && this.hasPopupData && this._createPopup(), this.container.append(h), this._editOnDoubleClick(), this.container;
  }
  getElementsToTriggerPopup() {
    return o(this, mh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
mh = new WeakMap();
class jb extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    }), this.annotationEditorType = _t.HIGHLIGHT;
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this._editOnDoubleClick(), this.container;
  }
}
class KA extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
  }
}
class ZA extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
  }
}
class JA extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0,
      createQuadrilaterals: !0
    });
  }
  render() {
    return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
  }
}
class zb extends Zt {
  constructor(e) {
    super(e, {
      isRenderable: !0,
      ignoreBorder: !0
    }), this.annotationEditorType = _t.STAMP;
  }
  render() {
    return this.container.classList.add("stampAnnotation"), this.container.setAttribute("role", "img"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
  }
}
var bh, yh, cp;
class t_ extends Zt {
  constructor(t) {
    var i;
    super(t, {
      isRenderable: !0
    });
    y(this, yh);
    y(this, bh, null);
    const {
      file: s
    } = this.data;
    this.filename = s.filename, this.content = s.content, (i = this.linkService.eventBus) == null || i.dispatch("fileattachmentannotation", {
      source: this,
      ...s
    });
  }
  render() {
    this.container.classList.add("fileAttachmentAnnotation");
    const {
      container: t,
      data: s
    } = this;
    let i;
    s.hasAppearance || s.fillAlpha === 0 ? i = document.createElement("div") : (i = document.createElement("img"), i.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(s.name) ? "paperclip" : "pushpin"}.svg`, s.fillAlpha && s.fillAlpha < 1 && (i.style = `filter: opacity(${Math.round(s.fillAlpha * 100)}%);`)), i.addEventListener("dblclick", x(this, yh, cp).bind(this)), E(this, bh, i);
    const {
      isMac: r
    } = Pe.platform;
    return t.addEventListener("keydown", (n) => {
      n.key === "Enter" && (r ? n.metaKey : n.ctrlKey) && x(this, yh, cp).call(this);
    }), !s.popupRef && this.hasPopupData ? this._createPopup() : i.classList.add("popupTriggerArea"), t.append(i), t;
  }
  getElementsToTriggerPopup() {
    return o(this, bh);
  }
  addHighlightArea() {
    this.container.classList.add("highlightArea");
  }
}
bh = new WeakMap(), yh = new WeakSet(), cp = function() {
  var t;
  (t = this.downloadManager) == null || t.openOrDownloadData(this.content, this.filename);
};
var vh, dn, un, wh, su, Bb, Ah, dp, om;
let e_ = (om = class {
  constructor({
    div: e,
    accessibilityManager: t,
    annotationCanvasMap: s,
    annotationEditorUIManager: i,
    page: r,
    viewport: n,
    structTreeLayer: a
  }) {
    y(this, su);
    y(this, Ah);
    y(this, vh, null);
    y(this, dn, null);
    y(this, un, /* @__PURE__ */ new Map());
    y(this, wh, null);
    this.div = e, E(this, vh, t), E(this, dn, s), E(this, wh, a || null), this.page = r, this.viewport = n, this.zIndex = 0, this._annotationEditorUIManager = i;
  }
  hasEditableAnnotations() {
    return o(this, un).size > 0;
  }
  async render(e) {
    var n;
    const {
      annotations: t
    } = e, s = this.div;
    Rn(s, this.viewport);
    const i = /* @__PURE__ */ new Map(), r = {
      data: null,
      layer: s,
      linkService: e.linkService,
      downloadManager: e.downloadManager,
      imageResourcesPath: e.imageResourcesPath || "",
      renderForms: e.renderForms !== !1,
      svgFactory: new ng(),
      annotationStorage: e.annotationStorage || new tg(),
      enableScripting: e.enableScripting === !0,
      hasJSActions: e.hasJSActions,
      fieldObjects: e.fieldObjects,
      parent: this,
      elements: null
    };
    for (const a of t) {
      if (a.noHTML)
        continue;
      const h = a.annotationType === se.POPUP;
      if (h) {
        const u = i.get(a.id);
        if (!u)
          continue;
        r.elements = u;
      } else {
        const {
          width: u,
          height: f
        } = ki(a.rect);
        if (u <= 0 || f <= 0)
          continue;
      }
      r.data = a;
      const c = jA.create(r);
      if (!c.isRenderable)
        continue;
      if (!h && a.popupRef) {
        const u = i.get(a.popupRef);
        u ? u.push(c) : i.set(a.popupRef, [c]);
      }
      const d = c.render();
      a.hidden && (d.style.visibility = "hidden"), await x(this, su, Bb).call(this, d, a.id), c._isEditable && (o(this, un).set(c.data.id, c), (n = this._annotationEditorUIManager) == null || n.renderAnnotationElement(c));
    }
    x(this, Ah, dp).call(this);
  }
  update({
    viewport: e
  }) {
    const t = this.div;
    this.viewport = e, Rn(t, {
      rotation: e.rotation
    }), x(this, Ah, dp).call(this), t.hidden = !1;
  }
  getEditableAnnotations() {
    return Array.from(o(this, un).values());
  }
  getEditableAnnotation(e) {
    return o(this, un).get(e);
  }
}, vh = new WeakMap(), dn = new WeakMap(), un = new WeakMap(), wh = new WeakMap(), su = new WeakSet(), Bb = async function(e, t) {
  var n, a;
  const s = e.firstChild || e, i = s.id = `${qp}${t}`, r = await ((n = o(this, wh)) == null ? void 0 : n.getAriaAttributes(i));
  if (r)
    for (const [h, c] of r)
      s.setAttribute(h, c);
  this.div.append(e), (a = o(this, vh)) == null || a.moveElementInDOM(this.div, e, s, !1);
}, Ah = new WeakSet(), dp = function() {
  if (!o(this, dn))
    return;
  const e = this.div;
  for (const [t, s] of o(this, dn)) {
    const i = e.querySelector(`[data-annotation-id="${t}"]`);
    if (!i)
      continue;
    s.className = "annotationContent";
    const {
      firstChild: r
    } = i;
    r ? r.nodeName === "CANVAS" ? r.replaceWith(s) : r.classList.contains("annotationContent") ? r.after(s) : r.before(s) : i.append(s);
  }
  o(this, dn).clear();
}, om);
const yc = /\r\n?|\n/g;
var ms, $e, _h, fn, Ge, iu, Ub, ru, Hb, nu, Wb, Ya, Fc, Xa, jc, qa, zc, au, $b, Eh, fp, ou, Gb;
const Rt = class Rt extends Dt {
  constructor(t) {
    super({
      ...t,
      name: "freeTextEditor"
    });
    y(this, iu);
    y(this, ru);
    y(this, nu);
    y(this, Ya);
    y(this, qa);
    y(this, au);
    y(this, ou);
    y(this, ms, void 0);
    y(this, $e, "");
    y(this, _h, `${this.id}-editor`);
    y(this, fn, null);
    y(this, Ge, void 0);
    E(this, ms, t.color || Rt._defaultColor || Dt._defaultLineColor), E(this, Ge, t.fontSize || Rt._defaultFontSize);
  }
  static get _keyboardManager() {
    const t = Rt.prototype, s = (n) => n.isEmpty(), i = On.TRANSLATE_SMALL, r = On.TRANSLATE_BIG;
    return Mt(this, "_keyboardManager", new lc([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], t.commitOrRemove, {
      bubbles: !0
    }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], t.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], t._translateEmpty, {
      args: [-i, 0],
      checker: s
    }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], t._translateEmpty, {
      args: [-r, 0],
      checker: s
    }], [["ArrowRight", "mac+ArrowRight"], t._translateEmpty, {
      args: [i, 0],
      checker: s
    }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], t._translateEmpty, {
      args: [r, 0],
      checker: s
    }], [["ArrowUp", "mac+ArrowUp"], t._translateEmpty, {
      args: [0, -i],
      checker: s
    }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], t._translateEmpty, {
      args: [0, -r],
      checker: s
    }], [["ArrowDown", "mac+ArrowDown"], t._translateEmpty, {
      args: [0, i],
      checker: s
    }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], t._translateEmpty, {
      args: [0, r],
      checker: s
    }]]));
  }
  static initialize(t, s) {
    Dt.initialize(t, s);
    const i = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(i.getPropertyValue("--freetext-padding"));
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case wt.FREETEXT_SIZE:
        Rt._defaultFontSize = s;
        break;
      case wt.FREETEXT_COLOR:
        Rt._defaultColor = s;
        break;
    }
  }
  updateParams(t, s) {
    switch (t) {
      case wt.FREETEXT_SIZE:
        x(this, iu, Ub).call(this, s);
        break;
      case wt.FREETEXT_COLOR:
        x(this, ru, Hb).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[wt.FREETEXT_SIZE, Rt._defaultFontSize], [wt.FREETEXT_COLOR, Rt._defaultColor || Dt._defaultLineColor]];
  }
  get propertiesToUpdate() {
    return [[wt.FREETEXT_SIZE, o(this, Ge)], [wt.FREETEXT_COLOR, o(this, ms)]];
  }
  _translateEmpty(t, s) {
    this._uiManager.translateSelectedEditors(t, s, !0);
  }
  getInitialTranslation() {
    const t = this.parentScale;
    return [-Rt._internalPadding * t, -(Rt._internalPadding + o(this, Ge)) * t];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
  }
  enableEditMode() {
    if (this.isInEditMode())
      return;
    this.parent.setEditingState(!1), this.parent.updateToolbar(_t.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), E(this, fn, new AbortController());
    const t = this._uiManager.combinedSignal(o(this, fn));
    this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
      signal: t
    }), this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
      signal: t
    });
  }
  disableEditMode() {
    var t;
    this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", o(this, _h)), this._isDraggable = !0, (t = o(this, fn)) == null || t.abort(), E(this, fn, null), this.div.focus({
      preventScroll: !0
    }), this.isEditing = !1, this.parent.div.classList.add("freetextEditing"));
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), t.target !== this.editorDiv && this.editorDiv.focus());
  }
  onceAdded() {
    var t;
    this.width || (this.enableEditMode(), this.editorDiv.focus(), (t = this._initialOptions) != null && t.isCentered && this.center(), this._initialOptions = null);
  }
  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }
  remove() {
    this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freetextEditing")), super.remove();
  }
  commit() {
    if (!this.isInEditMode())
      return;
    super.commit(), this.disableEditMode();
    const t = o(this, $e), s = E(this, $e, x(this, nu, Wb).call(this).trimEnd());
    if (t === s)
      return;
    const i = (r) => {
      if (E(this, $e, r), !r) {
        this.remove();
        return;
      }
      x(this, qa, zc).call(this), this._uiManager.rebuild(this), x(this, Ya, Fc).call(this);
    };
    this.addCommands({
      cmd: () => {
        i(s);
      },
      undo: () => {
        i(t);
      },
      mustExec: !1
    }), x(this, Ya, Fc).call(this);
  }
  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }
  enterInEditMode() {
    this.enableEditMode(), this.editorDiv.focus();
  }
  dblclick(t) {
    this.enterInEditMode();
  }
  keydown(t) {
    t.target === this.div && t.key === "Enter" && (this.enterInEditMode(), t.preventDefault());
  }
  editorDivKeydown(t) {
    Rt._keyboardManager.exec(this, t);
  }
  editorDivFocus(t) {
    this.isEditing = !0;
  }
  editorDivBlur(t) {
    this.isEditing = !1;
  }
  editorDivInput(t) {
    this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
  }
  disableEditing() {
    this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
  }
  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    this.width && (t = this.x, s = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", o(this, _h)), this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2"), this.editorDiv.setAttribute("data-l10n-attrs", "default-content"), this.enableEditing(), this.editorDiv.contentEditable = !0;
    const {
      style: i
    } = this.editorDiv;
    if (i.fontSize = `calc(${o(this, Ge)}px * var(--scale-factor))`, i.color = o(this, ms), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), td(this, this.div, ["dblclick", "keydown"]), this.width) {
      const [r, n] = this.parentDimensions;
      if (this.annotationElementId) {
        const {
          position: a
        } = this._initialData;
        let [h, c] = this.getInitialTranslation();
        [h, c] = this.pageTranslationToScreen(h, c);
        const [d, u] = this.pageDimensions, [f, p] = this.pageTranslation;
        let m, g;
        switch (this.rotation) {
          case 0:
            m = t + (a[0] - f) / d, g = s + this.height - (a[1] - p) / u;
            break;
          case 90:
            m = t + (a[0] - f) / d, g = s - (a[1] - p) / u, [h, c] = [c, -h];
            break;
          case 180:
            m = t - this.width + (a[0] - f) / d, g = s - (a[1] - p) / u, [h, c] = [-h, -c];
            break;
          case 270:
            m = t + (a[0] - f - this.height * u) / d, g = s + (a[1] - p - this.width * d) / u, [h, c] = [-c, h];
            break;
        }
        this.setAt(m * r, g * n, h, c);
      } else
        this.setAt(t * r, s * n, this.width * r, this.height * n);
      x(this, qa, zc).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
    } else
      this._isDraggable = !1, this.editorDiv.contentEditable = !0;
    return this.div;
  }
  editorDivPaste(t) {
    var m, g, w;
    const s = t.clipboardData || window.clipboardData, {
      types: i
    } = s;
    if (i.length === 1 && i[0] === "text/plain")
      return;
    t.preventDefault();
    const r = x(m = Rt, Eh, fp).call(m, s.getData("text") || "").replaceAll(yc, `
`);
    if (!r)
      return;
    const n = window.getSelection();
    if (!n.rangeCount)
      return;
    this.editorDiv.normalize(), n.deleteFromDocument();
    const a = n.getRangeAt(0);
    if (!r.includes(`
`)) {
      a.insertNode(document.createTextNode(r)), this.editorDiv.normalize(), n.collapseToStart();
      return;
    }
    const {
      startContainer: h,
      startOffset: c
    } = a, d = [], u = [];
    if (h.nodeType === Node.TEXT_NODE) {
      const b = h.parentElement;
      if (u.push(h.nodeValue.slice(c).replaceAll(yc, "")), b !== this.editorDiv) {
        let _ = d;
        for (const k of this.editorDiv.childNodes) {
          if (k === b) {
            _ = u;
            continue;
          }
          _.push(x(g = Rt, Xa, jc).call(g, k));
        }
      }
      d.push(h.nodeValue.slice(0, c).replaceAll(yc, ""));
    } else if (h === this.editorDiv) {
      let b = d, _ = 0;
      for (const k of this.editorDiv.childNodes)
        _++ === c && (b = u), b.push(x(w = Rt, Xa, jc).call(w, k));
    }
    E(this, $e, `${d.join(`
`)}${r}${u.join(`
`)}`), x(this, qa, zc).call(this);
    const f = new Range();
    let p = d.reduce((b, _) => b + _.length, 0);
    for (const {
      firstChild: b
    } of this.editorDiv.childNodes)
      if (b.nodeType === Node.TEXT_NODE) {
        const _ = b.nodeValue.length;
        if (p <= _) {
          f.setStart(b, p), f.setEnd(b, p);
          break;
        }
        p -= _;
      }
    n.removeAllRanges(), n.addRange(f);
  }
  get contentDiv() {
    return this.editorDiv;
  }
  static async deserialize(t, s, i) {
    var a;
    let r = null;
    if (t instanceof Ob) {
      const {
        data: {
          defaultAppearanceData: {
            fontSize: h,
            fontColor: c
          },
          rect: d,
          rotation: u,
          id: f,
          popupRef: p
        },
        textContent: m,
        textPosition: g,
        parent: {
          page: {
            pageNumber: w
          }
        }
      } = t;
      if (!m || m.length === 0)
        return null;
      r = t = {
        annotationType: _t.FREETEXT,
        color: Array.from(c),
        fontSize: h,
        value: m.join(`
`),
        position: g,
        pageIndex: w - 1,
        rect: d.slice(0),
        rotation: u,
        id: f,
        deleted: !1,
        popupRef: p
      };
    }
    const n = await super.deserialize(t, s, i);
    return E(n, Ge, t.fontSize), E(n, ms, pt.makeHexColor(...t.color)), E(n, $e, x(a = Rt, Eh, fp).call(a, t.value)), n.annotationElementId = t.id || null, n._initialData = r, n;
  }
  serialize(t = !1) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const s = Rt._internalPadding * this.parentScale, i = this.getRect(s, s), r = Dt._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : o(this, ms)), n = {
      annotationType: _t.FREETEXT,
      color: r,
      fontSize: o(this, Ge),
      value: x(this, au, $b).call(this),
      pageIndex: this.pageIndex,
      rect: i,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
    return t ? n : this.annotationElementId && !x(this, ou, Gb).call(this, n) ? null : (n.id = this.annotationElementId, n);
  }
  renderAnnotationElement(t) {
    const s = super.renderAnnotationElement(t);
    if (this.deleted)
      return s;
    const {
      style: i
    } = s;
    i.fontSize = `calc(${o(this, Ge)}px * var(--scale-factor))`, i.color = o(this, ms), s.replaceChildren();
    for (const n of o(this, $e).split(`
`)) {
      const a = document.createElement("div");
      a.append(n ? document.createTextNode(n) : document.createElement("br")), s.append(a);
    }
    const r = Rt._internalPadding * this.parentScale;
    return t.updateEdited({
      rect: this.getRect(r, r),
      popupContent: o(this, $e)
    }), s;
  }
  resetAnnotationElement(t) {
    super.resetAnnotationElement(t), t.resetEdited();
  }
};
ms = new WeakMap(), $e = new WeakMap(), _h = new WeakMap(), fn = new WeakMap(), Ge = new WeakMap(), iu = new WeakSet(), Ub = function(t) {
  const s = (r) => {
    this.editorDiv.style.fontSize = `calc(${r}px * var(--scale-factor))`, this.translate(0, -(r - o(this, Ge)) * this.parentScale), E(this, Ge, r), x(this, Ya, Fc).call(this);
  }, i = o(this, Ge);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: wt.FREETEXT_SIZE,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, ru = new WeakSet(), Hb = function(t) {
  const s = (r) => {
    E(this, ms, this.editorDiv.style.color = r);
  }, i = o(this, ms);
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: wt.FREETEXT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, nu = new WeakSet(), Wb = function() {
  var i;
  const t = [];
  this.editorDiv.normalize();
  let s = null;
  for (const r of this.editorDiv.childNodes)
    (s == null ? void 0 : s.nodeType) === Node.TEXT_NODE && r.nodeName === "BR" || (t.push(x(i = Rt, Xa, jc).call(i, r)), s = r);
  return t.join(`
`);
}, Ya = new WeakSet(), Fc = function() {
  const [t, s] = this.parentDimensions;
  let i;
  if (this.isAttachedToDOM)
    i = this.div.getBoundingClientRect();
  else {
    const {
      currentLayer: r,
      div: n
    } = this, a = n.style.display, h = n.classList.contains("hidden");
    n.classList.remove("hidden"), n.style.display = "hidden", r.div.append(this.div), i = n.getBoundingClientRect(), n.remove(), n.style.display = a, n.classList.toggle("hidden", h);
  }
  this.rotation % 180 === this.parentRotation % 180 ? (this.width = i.width / t, this.height = i.height / s) : (this.width = i.height / t, this.height = i.width / s), this.fixAndSetPosition();
}, Xa = new WeakSet(), jc = function(t) {
  return (t.nodeType === Node.TEXT_NODE ? t.nodeValue : t.innerText).replaceAll(yc, "");
}, qa = new WeakSet(), zc = function() {
  if (this.editorDiv.replaceChildren(), !!o(this, $e))
    for (const t of o(this, $e).split(`
`)) {
      const s = document.createElement("div");
      s.append(t ? document.createTextNode(t) : document.createElement("br")), this.editorDiv.append(s);
    }
}, au = new WeakSet(), $b = function() {
  return o(this, $e).replaceAll("", " ");
}, Eh = new WeakSet(), fp = function(t) {
  return t.replaceAll(" ", "");
}, ou = new WeakSet(), Gb = function(t) {
  const {
    value: s,
    fontSize: i,
    color: r,
    pageIndex: n
  } = this._initialData;
  return this._hasBeenMoved || t.value !== s || t.fontSize !== i || t.color.some((a, h) => a !== r[h]) || t.pageIndex !== n;
}, y(Rt, Xa), y(Rt, Eh), vt(Rt, "_freeTextDefaultContent", ""), vt(Rt, "_internalPadding", 0), vt(Rt, "_defaultColor", null), vt(Rt, "_defaultFontSize", 10), vt(Rt, "_type", "freetext"), vt(Rt, "_editorType", _t.FREETEXT);
let up = Rt;
class Vb {
  toSVGPath() {
    Bt("Abstract method `toSVGPath` must be implemented.");
  }
  get box() {
    Bt("Abstract getter `box` must be implemented.");
  }
  serialize(e, t) {
    Bt("Abstract method `serialize` must be implemented.");
  }
  get classNamesForDrawing() {
    Bt("Abstract getter `classNamesForDrawing` must be implemented.");
  }
  get classNamesForOutlining() {
    Bt("Abstract getter `classNamesForOutlining` must be implemented.");
  }
  get mustRemoveSelfIntersections() {
    return !1;
  }
}
var Ve, bs, Qa, Ka, Fs, St, pn, gn, xh, Sh, Za, Ja, er, kh, lu, hu, mn, $o, cu, Yb, du, Xb, uu, qb, fu, Qb, pu, Kb, gu, Zb;
const qs = class qs {
  constructor({
    x: e,
    y: t
  }, s, i, r, n, a = 0) {
    y(this, mn);
    y(this, cu);
    y(this, du);
    y(this, uu);
    y(this, fu);
    y(this, pu);
    y(this, gu);
    y(this, Ve, void 0);
    y(this, bs, []);
    y(this, Qa, void 0);
    y(this, Ka, void 0);
    y(this, Fs, []);
    y(this, St, new Float64Array(18));
    y(this, pn, void 0);
    y(this, gn, void 0);
    y(this, xh, void 0);
    y(this, Sh, void 0);
    y(this, Za, void 0);
    y(this, Ja, void 0);
    y(this, er, []);
    E(this, Ve, s), E(this, Ja, r * i), E(this, Ka, n), o(this, St).set([NaN, NaN, NaN, NaN, e, t], 6), E(this, Qa, a), E(this, Sh, o(qs, kh) * i), E(this, xh, o(qs, hu) * i), E(this, Za, i), o(this, er).push(e, t);
  }
  isEmpty() {
    return isNaN(o(this, St)[8]);
  }
  add({
    x: e,
    y: t
  }) {
    var S;
    E(this, pn, e), E(this, gn, t);
    const [s, i, r, n] = o(this, Ve);
    let [a, h, c, d] = o(this, St).subarray(8, 12);
    const u = e - c, f = t - d, p = Math.hypot(u, f);
    if (p < o(this, xh))
      return !1;
    const m = p - o(this, Sh), g = m / p, w = g * u, b = g * f;
    let _ = a, k = h;
    a = c, h = d, c += w, d += b, (S = o(this, er)) == null || S.push(e, t);
    const C = -b / m, N = w / m, R = C * o(this, Ja), P = N * o(this, Ja);
    return o(this, St).set(o(this, St).subarray(2, 8), 0), o(this, St).set([c + R, d + P], 4), o(this, St).set(o(this, St).subarray(14, 18), 12), o(this, St).set([c - R, d - P], 16), isNaN(o(this, St)[6]) ? (o(this, Fs).length === 0 && (o(this, St).set([a + R, h + P], 2), o(this, Fs).push(NaN, NaN, NaN, NaN, (a + R - s) / r, (h + P - i) / n), o(this, St).set([a - R, h - P], 14), o(this, bs).push(NaN, NaN, NaN, NaN, (a - R - s) / r, (h - P - i) / n)), o(this, St).set([_, k, a, h, c, d], 6), !this.isEmpty()) : (o(this, St).set([_, k, a, h, c, d], 6), Math.abs(Math.atan2(k - h, _ - a) - Math.atan2(b, w)) < Math.PI / 2 ? ([a, h, c, d] = o(this, St).subarray(2, 6), o(this, Fs).push(NaN, NaN, NaN, NaN, ((a + c) / 2 - s) / r, ((h + d) / 2 - i) / n), [a, h, _, k] = o(this, St).subarray(14, 18), o(this, bs).push(NaN, NaN, NaN, NaN, ((_ + a) / 2 - s) / r, ((k + h) / 2 - i) / n), !0) : ([_, k, a, h, c, d] = o(this, St).subarray(0, 6), o(this, Fs).push(((_ + 5 * a) / 6 - s) / r, ((k + 5 * h) / 6 - i) / n, ((5 * a + c) / 6 - s) / r, ((5 * h + d) / 6 - i) / n, ((a + c) / 2 - s) / r, ((h + d) / 2 - i) / n), [c, d, a, h, _, k] = o(this, St).subarray(12, 18), o(this, bs).push(((_ + 5 * a) / 6 - s) / r, ((k + 5 * h) / 6 - i) / n, ((5 * a + c) / 6 - s) / r, ((5 * h + d) / 6 - i) / n, ((a + c) / 2 - s) / r, ((h + d) / 2 - i) / n), !0));
  }
  toSVGPath() {
    if (this.isEmpty())
      return "";
    const e = o(this, Fs), t = o(this, bs);
    if (isNaN(o(this, St)[6]) && !this.isEmpty())
      return x(this, cu, Yb).call(this);
    const s = [];
    s.push(`M${e[4]} ${e[5]}`);
    for (let i = 6; i < e.length; i += 6)
      isNaN(e[i]) ? s.push(`L${e[i + 4]} ${e[i + 5]}`) : s.push(`C${e[i]} ${e[i + 1]} ${e[i + 2]} ${e[i + 3]} ${e[i + 4]} ${e[i + 5]}`);
    x(this, uu, qb).call(this, s);
    for (let i = t.length - 6; i >= 6; i -= 6)
      isNaN(t[i]) ? s.push(`L${t[i + 4]} ${t[i + 5]}`) : s.push(`C${t[i]} ${t[i + 1]} ${t[i + 2]} ${t[i + 3]} ${t[i + 4]} ${t[i + 5]}`);
    return x(this, du, Xb).call(this, s), s.join(" ");
  }
  newFreeDrawOutline(e, t, s, i, r, n) {
    return new Jb(e, t, s, i, r, n);
  }
  getOutlines() {
    var u;
    const e = o(this, Fs), t = o(this, bs), s = o(this, St), [i, r, n, a] = o(this, Ve), h = new Float64Array((((u = o(this, er)) == null ? void 0 : u.length) ?? 0) + 2);
    for (let f = 0, p = h.length - 2; f < p; f += 2)
      h[f] = (o(this, er)[f] - i) / n, h[f + 1] = (o(this, er)[f + 1] - r) / a;
    if (h[h.length - 2] = (o(this, pn) - i) / n, h[h.length - 1] = (o(this, gn) - r) / a, isNaN(s[6]) && !this.isEmpty())
      return x(this, fu, Qb).call(this, h);
    const c = new Float64Array(o(this, Fs).length + 24 + o(this, bs).length);
    let d = e.length;
    for (let f = 0; f < d; f += 2) {
      if (isNaN(e[f])) {
        c[f] = c[f + 1] = NaN;
        continue;
      }
      c[f] = e[f], c[f + 1] = e[f + 1];
    }
    d = x(this, gu, Zb).call(this, c, d);
    for (let f = t.length - 6; f >= 6; f -= 6)
      for (let p = 0; p < 6; p += 2) {
        if (isNaN(t[f + p])) {
          c[d] = c[d + 1] = NaN, d += 2;
          continue;
        }
        c[d] = t[f + p], c[d + 1] = t[f + p + 1], d += 2;
      }
    return x(this, pu, Kb).call(this, c, d), this.newFreeDrawOutline(c, h, o(this, Ve), o(this, Za), o(this, Qa), o(this, Ka));
  }
};
Ve = new WeakMap(), bs = new WeakMap(), Qa = new WeakMap(), Ka = new WeakMap(), Fs = new WeakMap(), St = new WeakMap(), pn = new WeakMap(), gn = new WeakMap(), xh = new WeakMap(), Sh = new WeakMap(), Za = new WeakMap(), Ja = new WeakMap(), er = new WeakMap(), kh = new WeakMap(), lu = new WeakMap(), hu = new WeakMap(), mn = new WeakSet(), $o = function() {
  const e = o(this, St).subarray(4, 6), t = o(this, St).subarray(16, 18), [s, i, r, n] = o(this, Ve);
  return [(o(this, pn) + (e[0] - t[0]) / 2 - s) / r, (o(this, gn) + (e[1] - t[1]) / 2 - i) / n, (o(this, pn) + (t[0] - e[0]) / 2 - s) / r, (o(this, gn) + (t[1] - e[1]) / 2 - i) / n];
}, cu = new WeakSet(), Yb = function() {
  const [e, t, s, i] = o(this, Ve), [r, n, a, h] = x(this, mn, $o).call(this);
  return `M${(o(this, St)[2] - e) / s} ${(o(this, St)[3] - t) / i} L${(o(this, St)[4] - e) / s} ${(o(this, St)[5] - t) / i} L${r} ${n} L${a} ${h} L${(o(this, St)[16] - e) / s} ${(o(this, St)[17] - t) / i} L${(o(this, St)[14] - e) / s} ${(o(this, St)[15] - t) / i} Z`;
}, du = new WeakSet(), Xb = function(e) {
  const t = o(this, bs);
  e.push(`L${t[4]} ${t[5]} Z`);
}, uu = new WeakSet(), qb = function(e) {
  const [t, s, i, r] = o(this, Ve), n = o(this, St).subarray(4, 6), a = o(this, St).subarray(16, 18), [h, c, d, u] = x(this, mn, $o).call(this);
  e.push(`L${(n[0] - t) / i} ${(n[1] - s) / r} L${h} ${c} L${d} ${u} L${(a[0] - t) / i} ${(a[1] - s) / r}`);
}, fu = new WeakSet(), Qb = function(e) {
  const t = o(this, St), [s, i, r, n] = o(this, Ve), [a, h, c, d] = x(this, mn, $o).call(this), u = new Float64Array(36);
  return u.set([NaN, NaN, NaN, NaN, (t[2] - s) / r, (t[3] - i) / n, NaN, NaN, NaN, NaN, (t[4] - s) / r, (t[5] - i) / n, NaN, NaN, NaN, NaN, a, h, NaN, NaN, NaN, NaN, c, d, NaN, NaN, NaN, NaN, (t[16] - s) / r, (t[17] - i) / n, NaN, NaN, NaN, NaN, (t[14] - s) / r, (t[15] - i) / n], 0), this.newFreeDrawOutline(u, e, o(this, Ve), o(this, Za), o(this, Qa), o(this, Ka));
}, pu = new WeakSet(), Kb = function(e, t) {
  const s = o(this, bs);
  return e.set([NaN, NaN, NaN, NaN, s[4], s[5]], t), t += 6;
}, gu = new WeakSet(), Zb = function(e, t) {
  const s = o(this, St).subarray(4, 6), i = o(this, St).subarray(16, 18), [r, n, a, h] = o(this, Ve), [c, d, u, f] = x(this, mn, $o).call(this);
  return e.set([NaN, NaN, NaN, NaN, (s[0] - r) / a, (s[1] - n) / h, NaN, NaN, NaN, NaN, c, d, NaN, NaN, NaN, NaN, u, f, NaN, NaN, NaN, NaN, (i[0] - r) / a, (i[1] - n) / h], t), t += 24;
}, y(qs, kh, 8), y(qs, lu, 2), y(qs, hu, o(qs, kh) + o(qs, lu));
let sd = qs;
var to, bn, di, Mh, Ye, Ch, qt, yn, Go, vn, Vo, mu, ty;
class Jb extends Vb {
  constructor(t, s, i, r, n, a) {
    super();
    y(this, yn);
    y(this, vn);
    y(this, mu);
    y(this, to, void 0);
    y(this, bn, null);
    y(this, di, void 0);
    y(this, Mh, void 0);
    y(this, Ye, void 0);
    y(this, Ch, void 0);
    y(this, qt, void 0);
    E(this, qt, t), E(this, Ye, s), E(this, to, i), E(this, Ch, r), E(this, di, n), E(this, Mh, a), x(this, mu, ty).call(this, a);
    const {
      x: h,
      y: c,
      width: d,
      height: u
    } = o(this, bn);
    for (let f = 0, p = t.length; f < p; f += 2)
      t[f] = (t[f] - h) / d, t[f + 1] = (t[f + 1] - c) / u;
    for (let f = 0, p = s.length; f < p; f += 2)
      s[f] = (s[f] - h) / d, s[f + 1] = (s[f + 1] - c) / u;
  }
  toSVGPath() {
    const t = [`M${o(this, qt)[4]} ${o(this, qt)[5]}`];
    for (let s = 6, i = o(this, qt).length; s < i; s += 6) {
      if (isNaN(o(this, qt)[s])) {
        t.push(`L${o(this, qt)[s + 4]} ${o(this, qt)[s + 5]}`);
        continue;
      }
      t.push(`C${o(this, qt)[s]} ${o(this, qt)[s + 1]} ${o(this, qt)[s + 2]} ${o(this, qt)[s + 3]} ${o(this, qt)[s + 4]} ${o(this, qt)[s + 5]}`);
    }
    return t.push("Z"), t.join(" ");
  }
  serialize([t, s, i, r], n) {
    const a = i - t, h = r - s;
    let c, d;
    switch (n) {
      case 0:
        c = x(this, yn, Go).call(this, o(this, qt), t, r, a, -h), d = x(this, yn, Go).call(this, o(this, Ye), t, r, a, -h);
        break;
      case 90:
        c = x(this, vn, Vo).call(this, o(this, qt), t, s, a, h), d = x(this, vn, Vo).call(this, o(this, Ye), t, s, a, h);
        break;
      case 180:
        c = x(this, yn, Go).call(this, o(this, qt), i, s, -a, h), d = x(this, yn, Go).call(this, o(this, Ye), i, s, -a, h);
        break;
      case 270:
        c = x(this, vn, Vo).call(this, o(this, qt), i, r, -a, -h), d = x(this, vn, Vo).call(this, o(this, Ye), i, r, -a, -h);
        break;
    }
    return {
      outline: Array.from(c),
      points: [Array.from(d)]
    };
  }
  get box() {
    return o(this, bn);
  }
  newOutliner(t, s, i, r, n, a = 0) {
    return new sd(t, s, i, r, n, a);
  }
  getNewOutline(t, s) {
    const {
      x: i,
      y: r,
      width: n,
      height: a
    } = o(this, bn), [h, c, d, u] = o(this, to), f = n * d, p = a * u, m = i * d + h, g = r * u + c, w = this.newOutliner({
      x: o(this, Ye)[0] * f + m,
      y: o(this, Ye)[1] * p + g
    }, o(this, to), o(this, Ch), t, o(this, Mh), s ?? o(this, di));
    for (let b = 2; b < o(this, Ye).length; b += 2)
      w.add({
        x: o(this, Ye)[b] * f + m,
        y: o(this, Ye)[b + 1] * p + g
      });
    return w.getOutlines();
  }
  get mustRemoveSelfIntersections() {
    return !0;
  }
}
to = new WeakMap(), bn = new WeakMap(), di = new WeakMap(), Mh = new WeakMap(), Ye = new WeakMap(), Ch = new WeakMap(), qt = new WeakMap(), yn = new WeakSet(), Go = function(t, s, i, r, n) {
  const a = new Float64Array(t.length);
  for (let h = 0, c = t.length; h < c; h += 2)
    a[h] = s + t[h] * r, a[h + 1] = i + t[h + 1] * n;
  return a;
}, vn = new WeakSet(), Vo = function(t, s, i, r, n) {
  const a = new Float64Array(t.length);
  for (let h = 0, c = t.length; h < c; h += 2)
    a[h] = s + t[h + 1] * r, a[h + 1] = i + t[h] * n;
  return a;
}, mu = new WeakSet(), ty = function(t) {
  const s = o(this, qt);
  let i = s[4], r = s[5], n = i, a = r, h = i, c = r, d = i, u = r;
  const f = t ? Math.max : Math.min;
  for (let b = 6, _ = s.length; b < _; b += 6) {
    if (isNaN(s[b]))
      n = Math.min(n, s[b + 4]), a = Math.min(a, s[b + 5]), h = Math.max(h, s[b + 4]), c = Math.max(c, s[b + 5]), u < s[b + 5] ? (d = s[b + 4], u = s[b + 5]) : u === s[b + 5] && (d = f(d, s[b + 4]));
    else {
      const k = pt.bezierBoundingBox(i, r, ...s.slice(b, b + 6));
      n = Math.min(n, k[0]), a = Math.min(a, k[1]), h = Math.max(h, k[2]), c = Math.max(c, k[3]), u < k[3] ? (d = k[2], u = k[3]) : u === k[3] && (d = f(d, k[2]));
    }
    i = s[b + 4], r = s[b + 5];
  }
  const p = n - o(this, di), m = a - o(this, di), g = h - n + 2 * o(this, di), w = c - a + 2 * o(this, di);
  E(this, bn, {
    x: p,
    y: m,
    width: g,
    height: w,
    lastPoint: [d, u]
  });
};
var Th, sr, ys, bu, ey, eo, Bc, yu, sy, vu, iy, Ih, pp;
class Vg {
  constructor(e, t = 0, s = 0, i = !0) {
    y(this, bu);
    y(this, eo);
    y(this, yu);
    y(this, vu);
    y(this, Ih);
    y(this, Th, void 0);
    y(this, sr, []);
    y(this, ys, []);
    let r = 1 / 0, n = -1 / 0, a = 1 / 0, h = -1 / 0;
    const d = 10 ** -4;
    for (const {
      x: b,
      y: _,
      width: k,
      height: C
    } of e) {
      const N = Math.floor((b - t) / d) * d, R = Math.ceil((b + k + t) / d) * d, P = Math.floor((_ - t) / d) * d, M = Math.ceil((_ + C + t) / d) * d, S = [N, P, M, !0], L = [R, P, M, !1];
      o(this, sr).push(S, L), r = Math.min(r, N), n = Math.max(n, R), a = Math.min(a, P), h = Math.max(h, M);
    }
    const u = n - r + 2 * s, f = h - a + 2 * s, p = r - s, m = a - s, g = o(this, sr).at(i ? -1 : -2), w = [g[0], g[2]];
    for (const b of o(this, sr)) {
      const [_, k, C] = b;
      b[0] = (_ - p) / u, b[1] = (k - m) / f, b[2] = (C - m) / f;
    }
    E(this, Th, {
      x: p,
      y: m,
      width: u,
      height: f,
      lastPoint: w
    });
  }
  getOutlines() {
    o(this, sr).sort((t, s) => t[0] - s[0] || t[1] - s[1] || t[2] - s[2]);
    const e = [];
    for (const t of o(this, sr))
      t[3] ? (e.push(...x(this, Ih, pp).call(this, t)), x(this, yu, sy).call(this, t)) : (x(this, vu, iy).call(this, t), e.push(...x(this, Ih, pp).call(this, t)));
    return x(this, bu, ey).call(this, e);
  }
}
Th = new WeakMap(), sr = new WeakMap(), ys = new WeakMap(), bu = new WeakSet(), ey = function(e) {
  const t = [], s = /* @__PURE__ */ new Set();
  for (const n of e) {
    const [a, h, c] = n;
    t.push([a, h, n], [a, c, n]);
  }
  t.sort((n, a) => n[1] - a[1] || n[0] - a[0]);
  for (let n = 0, a = t.length; n < a; n += 2) {
    const h = t[n][2], c = t[n + 1][2];
    h.push(c), c.push(h), s.add(h), s.add(c);
  }
  const i = [];
  let r;
  for (; s.size > 0; ) {
    const n = s.values().next().value;
    let [a, h, c, d, u] = n;
    s.delete(n);
    let f = a, p = h;
    for (r = [a, c], i.push(r); ; ) {
      let m;
      if (s.has(d))
        m = d;
      else if (s.has(u))
        m = u;
      else
        break;
      s.delete(m), [a, h, c, d, u] = m, f !== a && (r.push(f, p, a, p === h ? h : c), f = a), p = p === h ? c : h;
    }
    r.push(f, p);
  }
  return new s_(i, o(this, Th));
}, eo = new WeakSet(), Bc = function(e) {
  const t = o(this, ys);
  let s = 0, i = t.length - 1;
  for (; s <= i; ) {
    const r = s + i >> 1, n = t[r][0];
    if (n === e)
      return r;
    n < e ? s = r + 1 : i = r - 1;
  }
  return i + 1;
}, yu = new WeakSet(), sy = function([, e, t]) {
  const s = x(this, eo, Bc).call(this, e);
  o(this, ys).splice(s, 0, [e, t]);
}, vu = new WeakSet(), iy = function([, e, t]) {
  const s = x(this, eo, Bc).call(this, e);
  for (let i = s; i < o(this, ys).length; i++) {
    const [r, n] = o(this, ys)[i];
    if (r !== e)
      break;
    if (r === e && n === t) {
      o(this, ys).splice(i, 1);
      return;
    }
  }
  for (let i = s - 1; i >= 0; i--) {
    const [r, n] = o(this, ys)[i];
    if (r !== e)
      break;
    if (r === e && n === t) {
      o(this, ys).splice(i, 1);
      return;
    }
  }
}, Ih = new WeakSet(), pp = function(e) {
  const [t, s, i] = e, r = [[t, s, i]], n = x(this, eo, Bc).call(this, i);
  for (let a = 0; a < n; a++) {
    const [h, c] = o(this, ys)[a];
    for (let d = 0, u = r.length; d < u; d++) {
      const [, f, p] = r[d];
      if (!(c <= f || p <= h)) {
        if (f >= h) {
          if (p > c)
            r[d][1] = c;
          else {
            if (u === 1)
              return [];
            r.splice(d, 1), d--, u--;
          }
          continue;
        }
        r[d][2] = h, p > c && r.push([t, c, p]);
      }
    }
  }
  return r;
};
var Nh, so;
class s_ extends Vb {
  constructor(t, s) {
    super();
    y(this, Nh, void 0);
    y(this, so, void 0);
    E(this, so, t), E(this, Nh, s);
  }
  toSVGPath() {
    const t = [];
    for (const s of o(this, so)) {
      let [i, r] = s;
      t.push(`M${i} ${r}`);
      for (let n = 2; n < s.length; n += 2) {
        const a = s[n], h = s[n + 1];
        a === i ? (t.push(`V${h}`), r = h) : h === r && (t.push(`H${a}`), i = a);
      }
      t.push("Z");
    }
    return t.join(" ");
  }
  serialize([t, s, i, r], n) {
    const a = [], h = i - t, c = r - s;
    for (const d of o(this, so)) {
      const u = new Array(d.length);
      for (let f = 0; f < d.length; f += 2)
        u[f] = t + d[f] * h, u[f + 1] = r - d[f + 1] * c;
      a.push(u);
    }
    return a;
  }
  get box() {
    return o(this, Nh);
  }
  get classNamesForDrawing() {
    return ["highlight"];
  }
  get classNamesForOutlining() {
    return ["highlightOutline"];
  }
}
Nh = new WeakMap(), so = new WeakMap();
class gp extends sd {
  newFreeDrawOutline(e, t, s, i, r, n) {
    return new i_(e, t, s, i, r, n);
  }
  get classNamesForDrawing() {
    return ["highlight", "free"];
  }
}
class i_ extends Jb {
  get classNamesForDrawing() {
    return ["highlight", "free"];
  }
  get classNamesForOutlining() {
    return ["highlightOutline", "free"];
  }
  newOutliner(e, t, s, i, r, n = 0) {
    return new gp(e, t, s, i, r, n);
  }
}
var vs, wn, io, re, Dh, ro, Ph, Lh, ir, ws, no, Rh, Oh, mp, Fh, bp, jh, yp, ui, wr, wu, ry, js, Ti;
const Re = class Re {
  constructor({
    editor: e = null,
    uiManager: t = null
  }) {
    y(this, Oh);
    y(this, Fh);
    y(this, jh);
    y(this, ui);
    y(this, wu);
    y(this, js);
    y(this, vs, null);
    y(this, wn, null);
    y(this, io, void 0);
    y(this, re, null);
    y(this, Dh, !1);
    y(this, ro, !1);
    y(this, Ph, null);
    y(this, Lh, void 0);
    y(this, ir, null);
    y(this, ws, null);
    y(this, no, void 0);
    var s;
    e ? (E(this, ro, !1), E(this, no, wt.HIGHLIGHT_COLOR), E(this, Ph, e)) : (E(this, ro, !0), E(this, no, wt.HIGHLIGHT_DEFAULT_COLOR)), E(this, ws, (e == null ? void 0 : e._uiManager) || t), E(this, Lh, o(this, ws)._eventBus), E(this, io, (e == null ? void 0 : e.color) || ((s = o(this, ws)) == null ? void 0 : s.highlightColors.values().next().value) || "#FFFF98"), o(Re, Rh) || E(Re, Rh, Object.freeze({
      blue: "pdfjs-editor-colorpicker-blue",
      green: "pdfjs-editor-colorpicker-green",
      pink: "pdfjs-editor-colorpicker-pink",
      red: "pdfjs-editor-colorpicker-red",
      yellow: "pdfjs-editor-colorpicker-yellow"
    }));
  }
  static get _keyboardManager() {
    return Mt(this, "_keyboardManager", new lc([[["Escape", "mac+Escape"], Re.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], Re.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], Re.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], Re.prototype._moveToPrevious], [["Home", "mac+Home"], Re.prototype._moveToBeginning], [["End", "mac+End"], Re.prototype._moveToEnd]]));
  }
  renderButton() {
    const e = E(this, vs, document.createElement("button"));
    e.className = "colorPicker", e.tabIndex = "0", e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button"), e.setAttribute("aria-haspopup", !0);
    const t = o(this, ws)._signal;
    e.addEventListener("click", x(this, ui, wr).bind(this), {
      signal: t
    }), e.addEventListener("keydown", x(this, jh, yp).bind(this), {
      signal: t
    });
    const s = E(this, wn, document.createElement("span"));
    return s.className = "swatch", s.setAttribute("aria-hidden", !0), s.style.backgroundColor = o(this, io), e.append(s), e;
  }
  renderMainDropdown() {
    const e = E(this, re, x(this, Oh, mp).call(this));
    return e.setAttribute("aria-orientation", "horizontal"), e.setAttribute("aria-labelledby", "highlightColorPickerLabel"), e;
  }
  _colorSelectFromKeyboard(e) {
    if (e.target === o(this, vs)) {
      x(this, ui, wr).call(this, e);
      return;
    }
    const t = e.target.getAttribute("data-color");
    t && x(this, Fh, bp).call(this, t, e);
  }
  _moveToNext(e) {
    var t, s;
    if (!o(this, js, Ti)) {
      x(this, ui, wr).call(this, e);
      return;
    }
    if (e.target === o(this, vs)) {
      (t = o(this, re).firstChild) == null || t.focus();
      return;
    }
    (s = e.target.nextSibling) == null || s.focus();
  }
  _moveToPrevious(e) {
    var t, s;
    if (e.target === ((t = o(this, re)) == null ? void 0 : t.firstChild) || e.target === o(this, vs)) {
      o(this, js, Ti) && this._hideDropdownFromKeyboard();
      return;
    }
    o(this, js, Ti) || x(this, ui, wr).call(this, e), (s = e.target.previousSibling) == null || s.focus();
  }
  _moveToBeginning(e) {
    var t;
    if (!o(this, js, Ti)) {
      x(this, ui, wr).call(this, e);
      return;
    }
    (t = o(this, re).firstChild) == null || t.focus();
  }
  _moveToEnd(e) {
    var t;
    if (!o(this, js, Ti)) {
      x(this, ui, wr).call(this, e);
      return;
    }
    (t = o(this, re).lastChild) == null || t.focus();
  }
  hideDropdown() {
    var e, t;
    (e = o(this, re)) == null || e.classList.add("hidden"), (t = o(this, ir)) == null || t.abort(), E(this, ir, null);
  }
  _hideDropdownFromKeyboard() {
    var e;
    if (!o(this, ro)) {
      if (!o(this, js, Ti)) {
        (e = o(this, Ph)) == null || e.unselect();
        return;
      }
      this.hideDropdown(), o(this, vs).focus({
        preventScroll: !0,
        focusVisible: o(this, Dh)
      });
    }
  }
  updateColor(e) {
    if (o(this, wn) && (o(this, wn).style.backgroundColor = e), !o(this, re))
      return;
    const t = o(this, ws).highlightColors.values();
    for (const s of o(this, re).children)
      s.setAttribute("aria-selected", t.next().value === e);
  }
  destroy() {
    var e, t;
    (e = o(this, vs)) == null || e.remove(), E(this, vs, null), E(this, wn, null), (t = o(this, re)) == null || t.remove(), E(this, re, null);
  }
};
vs = new WeakMap(), wn = new WeakMap(), io = new WeakMap(), re = new WeakMap(), Dh = new WeakMap(), ro = new WeakMap(), Ph = new WeakMap(), Lh = new WeakMap(), ir = new WeakMap(), ws = new WeakMap(), no = new WeakMap(), Rh = new WeakMap(), Oh = new WeakSet(), mp = function() {
  const e = document.createElement("div"), t = o(this, ws)._signal;
  e.addEventListener("contextmenu", as, {
    signal: t
  }), e.className = "dropdown", e.role = "listbox", e.setAttribute("aria-multiselectable", !1), e.setAttribute("aria-orientation", "vertical"), e.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
  for (const [s, i] of o(this, ws).highlightColors) {
    const r = document.createElement("button");
    r.tabIndex = "0", r.role = "option", r.setAttribute("data-color", i), r.title = s, r.setAttribute("data-l10n-id", o(Re, Rh)[s]);
    const n = document.createElement("span");
    r.append(n), n.className = "swatch", n.style.backgroundColor = i, r.setAttribute("aria-selected", i === o(this, io)), r.addEventListener("click", x(this, Fh, bp).bind(this, i), {
      signal: t
    }), e.append(r);
  }
  return e.addEventListener("keydown", x(this, jh, yp).bind(this), {
    signal: t
  }), e;
}, Fh = new WeakSet(), bp = function(e, t) {
  t.stopPropagation(), o(this, Lh).dispatch("switchannotationeditorparams", {
    source: this,
    type: o(this, no),
    value: e
  });
}, jh = new WeakSet(), yp = function(e) {
  Re._keyboardManager.exec(this, e);
}, ui = new WeakSet(), wr = function(e) {
  if (o(this, js, Ti)) {
    this.hideDropdown();
    return;
  }
  if (E(this, Dh, e.detail === 0), o(this, ir) || (E(this, ir, new AbortController()), window.addEventListener("pointerdown", x(this, wu, ry).bind(this), {
    signal: o(this, ws).combinedSignal(o(this, ir))
  })), o(this, re)) {
    o(this, re).classList.remove("hidden");
    return;
  }
  const t = E(this, re, x(this, Oh, mp).call(this));
  o(this, vs).append(t);
}, wu = new WeakSet(), ry = function(e) {
  var t;
  (t = o(this, re)) != null && t.contains(e.target) || this.hideDropdown();
}, js = new WeakSet(), Ti = function() {
  return o(this, re) && !o(this, re).classList.contains("hidden");
}, y(Re, Rh, null);
let id = Re;
var ao, zh, fi, An, oo, ss, Bh, Uh, _n, As, Se, je, lo, pi, ne, ho, is, Hh, Wh, vp, co, Uc, Au, ny, _u, ay, Eu, oy, $h, wp, gi, Ar, rr, qn, xu, ly, uo, Hc, En, Yo, Su, hy, ku, cy, Mu, dy, Cu, uy, Tu, fy;
const Ct = class Ct extends Dt {
  constructor(t) {
    super({
      ...t,
      name: "highlightEditor"
    });
    y(this, Wh);
    y(this, co);
    y(this, Au);
    y(this, _u);
    y(this, Eu);
    y(this, $h);
    y(this, gi);
    y(this, xu);
    y(this, uo);
    y(this, En);
    y(this, Su);
    y(this, ku);
    y(this, Tu);
    y(this, ao, null);
    y(this, zh, 0);
    y(this, fi, void 0);
    y(this, An, null);
    y(this, oo, null);
    y(this, ss, null);
    y(this, Bh, null);
    y(this, Uh, 0);
    y(this, _n, null);
    y(this, As, null);
    y(this, Se, null);
    y(this, je, !1);
    y(this, lo, null);
    y(this, pi, void 0);
    y(this, ne, null);
    y(this, ho, "");
    y(this, is, void 0);
    y(this, Hh, "");
    this.color = t.color || Ct._defaultColor, E(this, is, t.thickness || Ct._defaultThickness), E(this, pi, t.opacity || Ct._defaultOpacity), E(this, fi, t.boxes || null), E(this, Hh, t.methodOfCreation || ""), E(this, ho, t.text || ""), this._isDraggable = !1, t.highlightId > -1 ? (E(this, je, !0), x(this, co, Uc).call(this, t), x(this, gi, Ar).call(this)) : o(this, fi) && (E(this, ao, t.anchorNode), E(this, zh, t.anchorOffset), E(this, Bh, t.focusNode), E(this, Uh, t.focusOffset), x(this, Wh, vp).call(this), x(this, gi, Ar).call(this), this.rotate(this.rotation));
  }
  static get _keyboardManager() {
    const t = Ct.prototype;
    return Mt(this, "_keyboardManager", new lc([[["ArrowLeft", "mac+ArrowLeft"], t._moveCaret, {
      args: [0]
    }], [["ArrowRight", "mac+ArrowRight"], t._moveCaret, {
      args: [1]
    }], [["ArrowUp", "mac+ArrowUp"], t._moveCaret, {
      args: [2]
    }], [["ArrowDown", "mac+ArrowDown"], t._moveCaret, {
      args: [3]
    }]]));
  }
  get telemetryInitialData() {
    return {
      action: "added",
      type: o(this, je) ? "free_highlight" : "highlight",
      color: this._uiManager.highlightColorNames.get(this.color),
      thickness: o(this, is),
      methodOfCreation: o(this, Hh)
    };
  }
  get telemetryFinalData() {
    return {
      type: "highlight",
      color: this._uiManager.highlightColorNames.get(this.color)
    };
  }
  static computeTelemetryFinalData(t) {
    return {
      numberOfColors: t.get("color").size
    };
  }
  static initialize(t, s) {
    var i;
    Dt.initialize(t, s), Ct._defaultColor || (Ct._defaultColor = ((i = s.highlightColors) == null ? void 0 : i.values().next().value) || "#fff066");
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case wt.HIGHLIGHT_DEFAULT_COLOR:
        Ct._defaultColor = s;
        break;
      case wt.HIGHLIGHT_THICKNESS:
        Ct._defaultThickness = s;
        break;
    }
  }
  translateInPage(t, s) {
  }
  get toolbarPosition() {
    return o(this, lo);
  }
  updateParams(t, s) {
    switch (t) {
      case wt.HIGHLIGHT_COLOR:
        x(this, Au, ny).call(this, s);
        break;
      case wt.HIGHLIGHT_THICKNESS:
        x(this, _u, ay).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[wt.HIGHLIGHT_DEFAULT_COLOR, Ct._defaultColor], [wt.HIGHLIGHT_THICKNESS, Ct._defaultThickness]];
  }
  get propertiesToUpdate() {
    return [[wt.HIGHLIGHT_COLOR, this.color || Ct._defaultColor], [wt.HIGHLIGHT_THICKNESS, o(this, is) || Ct._defaultThickness], [wt.HIGHLIGHT_FREE, o(this, je)]];
  }
  async addEditToolbar() {
    const t = await super.addEditToolbar();
    return t ? (this._uiManager.highlightColors && (E(this, oo, new id({
      editor: this
    })), t.addColorPicker(o(this, oo))), t) : null;
  }
  disableEditing() {
    super.disableEditing(), this.div.classList.toggle("disabled", !0);
  }
  enableEditing() {
    super.enableEditing(), this.div.classList.toggle("disabled", !1);
  }
  fixAndSetPosition() {
    return super.fixAndSetPosition(x(this, En, Yo).call(this));
  }
  getBaseTranslation() {
    return [0, 0];
  }
  getRect(t, s) {
    return super.getRect(t, s, x(this, En, Yo).call(this));
  }
  onceAdded() {
    this.annotationElementId || this.parent.addUndoableEditor(this), this.div.focus();
  }
  remove() {
    x(this, $h, wp).call(this), this._reportTelemetry({
      action: "deleted"
    }), super.remove();
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (x(this, gi, Ar).call(this), this.isAttachedToDOM || this.parent.add(this)));
  }
  setParent(t) {
    var i;
    let s = !1;
    this.parent && !t ? x(this, $h, wp).call(this) : t && (x(this, gi, Ar).call(this, t), s = !this.parent && ((i = this.div) == null ? void 0 : i.classList.contains("selectedEditor"))), super.setParent(t), this.show(this._isVisible), s && this.select();
  }
  rotate(t) {
    var r, n, a;
    const {
      drawLayer: s
    } = this.parent;
    let i;
    o(this, je) ? (t = (t - this.rotation + 360) % 360, i = x(r = Ct, rr, qn).call(r, o(this, As).box, t)) : i = x(n = Ct, rr, qn).call(n, this, t), s.rotate(o(this, Se), t), s.rotate(o(this, ne), t), s.updateBox(o(this, Se), i), s.updateBox(o(this, ne), x(a = Ct, rr, qn).call(a, o(this, ss).box, t));
  }
  render() {
    if (this.div)
      return this.div;
    const t = super.render();
    o(this, ho) && (t.setAttribute("aria-label", o(this, ho)), t.setAttribute("role", "mark")), o(this, je) ? t.classList.add("free") : this.div.addEventListener("keydown", x(this, xu, ly).bind(this), {
      signal: this._uiManager._signal
    });
    const s = E(this, _n, document.createElement("div"));
    t.append(s), s.setAttribute("aria-hidden", "true"), s.className = "internal", s.style.clipPath = o(this, An);
    const [i, r] = this.parentDimensions;
    return this.setDims(this.width * i, this.height * r), td(this, o(this, _n), ["pointerover", "pointerleave"]), this.enableEditing(), t;
  }
  pointerover() {
    this.isSelected || this.parent.drawLayer.addClass(o(this, ne), "hovered");
  }
  pointerleave() {
    this.isSelected || this.parent.drawLayer.removeClass(o(this, ne), "hovered");
  }
  _moveCaret(t) {
    switch (this.parent.unselect(this), t) {
      case 0:
      case 2:
        x(this, uo, Hc).call(this, !0);
        break;
      case 1:
      case 3:
        x(this, uo, Hc).call(this, !1);
        break;
    }
  }
  select() {
    var t, s;
    super.select(), o(this, ne) && ((t = this.parent) == null || t.drawLayer.removeClass(o(this, ne), "hovered"), (s = this.parent) == null || s.drawLayer.addClass(o(this, ne), "selected"));
  }
  unselect() {
    var t;
    super.unselect(), o(this, ne) && ((t = this.parent) == null || t.drawLayer.removeClass(o(this, ne), "selected"), o(this, je) || x(this, uo, Hc).call(this, !1));
  }
  get _mustFixPosition() {
    return !o(this, je);
  }
  show(t = this._isVisible) {
    super.show(t), this.parent && (this.parent.drawLayer.show(o(this, Se), t), this.parent.drawLayer.show(o(this, ne), t));
  }
  static startHighlighting(t, s, {
    target: i,
    x: r,
    y: n
  }) {
    const {
      x: a,
      y: h,
      width: c,
      height: d
    } = i.getBoundingClientRect(), u = new AbortController(), f = t.combinedSignal(u), p = (g) => {
      g.preventDefault(), g.stopPropagation();
    }, m = (g) => {
      u.abort(), x(this, Cu, uy).call(this, t, g);
    };
    window.addEventListener("blur", m, {
      signal: f
    }), window.addEventListener("pointerup", m, {
      signal: f
    }), window.addEventListener("pointerdown", p, {
      capture: !0,
      passive: !1,
      signal: f
    }), window.addEventListener("contextmenu", as, {
      signal: f
    }), i.addEventListener("pointermove", x(this, Mu, dy).bind(this, t), {
      signal: f
    }), this._freeHighlight = new gp({
      x: r,
      y: n
    }, [a, h, c, d], t.scale, this._defaultThickness / 2, s, 1e-3), {
      id: this._freeHighlightId,
      clipPathId: this._freeHighlightClipId
    } = t.drawLayer.draw(this._freeHighlight, this._defaultColor, this._defaultOpacity, !0);
  }
  static async deserialize(t, s, i) {
    var g, w, b, _;
    let r = null;
    if (t instanceof jb) {
      const {
        data: {
          quadPoints: k,
          rect: C,
          rotation: N,
          id: R,
          color: P,
          opacity: M,
          popupRef: S
        },
        parent: {
          page: {
            pageNumber: L
          }
        }
      } = t;
      r = t = {
        annotationType: _t.HIGHLIGHT,
        color: Array.from(P),
        opacity: M,
        quadPoints: k,
        boxes: null,
        pageIndex: L - 1,
        rect: C.slice(0),
        rotation: N,
        id: R,
        deleted: !1,
        popupRef: S
      };
    } else if (t instanceof ag) {
      const {
        data: {
          inkLists: k,
          rect: C,
          rotation: N,
          id: R,
          color: P,
          borderStyle: {
            rawWidth: M
          },
          popupRef: S
        },
        parent: {
          page: {
            pageNumber: L
          }
        }
      } = t;
      r = t = {
        annotationType: _t.HIGHLIGHT,
        color: Array.from(P),
        thickness: M,
        inkLists: k,
        boxes: null,
        pageIndex: L - 1,
        rect: C.slice(0),
        rotation: N,
        id: R,
        deleted: !1,
        popupRef: S
      };
    }
    const {
      color: n,
      quadPoints: a,
      inkLists: h,
      opacity: c
    } = t, d = await super.deserialize(t, s, i);
    d.color = pt.makeHexColor(...n), E(d, pi, c || 1), h && E(d, is, t.thickness), d.annotationElementId = t.id || null, d._initialData = r;
    const [u, f] = d.pageDimensions, [p, m] = d.pageTranslation;
    if (a) {
      const k = E(d, fi, []);
      for (let C = 0; C < a.length; C += 8)
        k.push({
          x: (a[C] - p) / u,
          y: 1 - (a[C + 1] - m) / f,
          width: (a[C + 2] - a[C]) / u,
          height: (a[C + 1] - a[C + 5]) / f
        });
      x(g = d, Wh, vp).call(g), x(w = d, gi, Ar).call(w), d.rotate(d.rotation);
    } else if (h) {
      E(d, je, !0);
      const k = h[0], C = {
        x: k[0] - p,
        y: f - (k[1] - m)
      }, N = new gp(C, [0, 0, u, f], 1, o(d, is) / 2, !0, 1e-3);
      for (let M = 0, S = k.length; M < S; M += 2)
        C.x = k[M] - p, C.y = f - (k[M + 1] - m), N.add(C);
      const {
        id: R,
        clipPathId: P
      } = s.drawLayer.draw(N, d.color, d._defaultOpacity, !0);
      x(b = d, co, Uc).call(b, {
        highlightOutlines: N.getOutlines(),
        highlightId: R,
        clipPathId: P
      }), x(_ = d, gi, Ar).call(_);
    }
    return d;
  }
  serialize(t = !1) {
    if (this.isEmpty() || t)
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const s = this.getRect(0, 0), i = Dt._colorManager.convert(this.color), r = {
      annotationType: _t.HIGHLIGHT,
      color: i,
      opacity: o(this, pi),
      thickness: o(this, is),
      quadPoints: x(this, Su, hy).call(this),
      outlines: x(this, ku, cy).call(this, s),
      pageIndex: this.pageIndex,
      rect: s,
      rotation: x(this, En, Yo).call(this),
      structTreeParentId: this._structTreeParentId
    };
    return this.annotationElementId && !x(this, Tu, fy).call(this, r) ? null : (r.id = this.annotationElementId, r);
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getRect(0, 0)
    }), null;
  }
  static canCreateNewEmptyEditor() {
    return !1;
  }
};
ao = new WeakMap(), zh = new WeakMap(), fi = new WeakMap(), An = new WeakMap(), oo = new WeakMap(), ss = new WeakMap(), Bh = new WeakMap(), Uh = new WeakMap(), _n = new WeakMap(), As = new WeakMap(), Se = new WeakMap(), je = new WeakMap(), lo = new WeakMap(), pi = new WeakMap(), ne = new WeakMap(), ho = new WeakMap(), is = new WeakMap(), Hh = new WeakMap(), Wh = new WeakSet(), vp = function() {
  const t = new Vg(o(this, fi), 1e-3);
  E(this, As, t.getOutlines()), {
    x: this.x,
    y: this.y,
    width: this.width,
    height: this.height
  } = o(this, As).box;
  const s = new Vg(o(this, fi), 25e-4, 1e-3, this._uiManager.direction === "ltr");
  E(this, ss, s.getOutlines());
  const {
    lastPoint: i
  } = o(this, ss).box;
  E(this, lo, [(i[0] - this.x) / this.width, (i[1] - this.y) / this.height]);
}, co = new WeakSet(), Uc = function({
  highlightOutlines: t,
  highlightId: s,
  clipPathId: i
}) {
  var u, f;
  E(this, As, t);
  const r = 1.5;
  if (E(this, ss, t.getNewOutline(o(this, is) / 2 + r, 25e-4)), s >= 0)
    E(this, Se, s), E(this, An, i), this.parent.drawLayer.finalizeLine(s, t), E(this, ne, this.parent.drawLayer.drawOutline(o(this, ss)));
  else if (this.parent) {
    const p = this.parent.viewport.rotation;
    this.parent.drawLayer.updateLine(o(this, Se), t), this.parent.drawLayer.updateBox(o(this, Se), x(u = Ct, rr, qn).call(u, o(this, As).box, (p - this.rotation + 360) % 360)), this.parent.drawLayer.updateLine(o(this, ne), o(this, ss)), this.parent.drawLayer.updateBox(o(this, ne), x(f = Ct, rr, qn).call(f, o(this, ss).box, p));
  }
  const {
    x: n,
    y: a,
    width: h,
    height: c
  } = t.box;
  switch (this.rotation) {
    case 0:
      this.x = n, this.y = a, this.width = h, this.height = c;
      break;
    case 90: {
      const [p, m] = this.parentDimensions;
      this.x = a, this.y = 1 - n, this.width = h * m / p, this.height = c * p / m;
      break;
    }
    case 180:
      this.x = 1 - n, this.y = 1 - a, this.width = h, this.height = c;
      break;
    case 270: {
      const [p, m] = this.parentDimensions;
      this.x = 1 - a, this.y = n, this.width = h * m / p, this.height = c * p / m;
      break;
    }
  }
  const {
    lastPoint: d
  } = o(this, ss).box;
  E(this, lo, [(d[0] - n) / h, (d[1] - a) / c]);
}, Au = new WeakSet(), ny = function(t) {
  const s = (n, a) => {
    var h, c, d;
    this.color = n, (h = this.parent) == null || h.drawLayer.changeColor(o(this, Se), n), (c = o(this, oo)) == null || c.updateColor(n), E(this, pi, a), (d = this.parent) == null || d.drawLayer.changeOpacity(o(this, Se), a);
  }, i = this.color, r = o(this, pi);
  this.addCommands({
    cmd: s.bind(this, t, Ct._defaultOpacity),
    undo: s.bind(this, i, r),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: wt.HIGHLIGHT_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "color_changed",
    color: this._uiManager.highlightColorNames.get(t)
  }, !0);
}, _u = new WeakSet(), ay = function(t) {
  const s = o(this, is), i = (r) => {
    E(this, is, r), x(this, Eu, oy).call(this, r);
  };
  this.addCommands({
    cmd: i.bind(this, t),
    undo: i.bind(this, s),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: wt.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  }), this._reportTelemetry({
    action: "thickness_changed",
    thickness: t
  }, !0);
}, Eu = new WeakSet(), oy = function(t) {
  if (!o(this, je))
    return;
  x(this, co, Uc).call(this, {
    highlightOutlines: o(this, As).getNewOutline(t / 2)
  }), this.fixAndSetPosition();
  const [s, i] = this.parentDimensions;
  this.setDims(this.width * s, this.height * i);
}, $h = new WeakSet(), wp = function() {
  o(this, Se) === null || !this.parent || (this.parent.drawLayer.remove(o(this, Se)), E(this, Se, null), this.parent.drawLayer.remove(o(this, ne)), E(this, ne, null));
}, gi = new WeakSet(), Ar = function(t = this.parent) {
  o(this, Se) === null && ({
    id: Te(this, Se)._,
    clipPathId: Te(this, An)._
  } = t.drawLayer.draw(o(this, As), this.color, o(this, pi)), E(this, ne, t.drawLayer.drawOutline(o(this, ss))), o(this, _n) && (o(this, _n).style.clipPath = o(this, An)));
}, rr = new WeakSet(), qn = function({
  x: t,
  y: s,
  width: i,
  height: r
}, n) {
  switch (n) {
    case 90:
      return {
        x: 1 - s - r,
        y: t,
        width: r,
        height: i
      };
    case 180:
      return {
        x: 1 - t - i,
        y: 1 - s - r,
        width: i,
        height: r
      };
    case 270:
      return {
        x: s,
        y: 1 - t - i,
        width: r,
        height: i
      };
  }
  return {
    x: t,
    y: s,
    width: i,
    height: r
  };
}, xu = new WeakSet(), ly = function(t) {
  Ct._keyboardManager.exec(this, t);
}, uo = new WeakSet(), Hc = function(t) {
  if (!o(this, ao))
    return;
  const s = window.getSelection();
  t ? s.setPosition(o(this, ao), o(this, zh)) : s.setPosition(o(this, Bh), o(this, Uh));
}, En = new WeakSet(), Yo = function() {
  return o(this, je) ? this.rotation : 0;
}, Su = new WeakSet(), hy = function() {
  if (o(this, je))
    return null;
  const [t, s] = this.pageDimensions, [i, r] = this.pageTranslation, n = o(this, fi), a = new Float32Array(n.length * 8);
  let h = 0;
  for (const {
    x: c,
    y: d,
    width: u,
    height: f
  } of n) {
    const p = c * t + i, m = (1 - d - f) * s + r;
    a[h] = a[h + 4] = p, a[h + 1] = a[h + 3] = m, a[h + 2] = a[h + 6] = p + u * t, a[h + 5] = a[h + 7] = m + f * s, h += 8;
  }
  return a;
}, ku = new WeakSet(), cy = function(t) {
  return o(this, As).serialize(t, x(this, En, Yo).call(this));
}, Mu = new WeakSet(), dy = function(t, s) {
  this._freeHighlight.add(s) && t.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);
}, Cu = new WeakSet(), uy = function(t, s) {
  this._freeHighlight.isEmpty() ? t.drawLayer.remove(this._freeHighlightId) : t.createAndAddNewEditor(s, !1, {
    highlightId: this._freeHighlightId,
    highlightOutlines: this._freeHighlight.getOutlines(),
    clipPathId: this._freeHighlightClipId,
    methodOfCreation: "main_toolbar"
  }), this._freeHighlightId = -1, this._freeHighlight = null, this._freeHighlightClipId = "";
}, Tu = new WeakSet(), fy = function(t) {
  const {
    color: s
  } = this._initialData;
  return t.color.some((i, r) => i !== s[r]);
}, y(Ct, rr), y(Ct, Mu), y(Ct, Cu), vt(Ct, "_defaultColor", null), vt(Ct, "_defaultOpacity", 1), vt(Ct, "_defaultThickness", 12), vt(Ct, "_type", "highlight"), vt(Ct, "_editorType", _t.HIGHLIGHT), vt(Ct, "_freeHighlightId", -1), vt(Ct, "_freeHighlight", null), vt(Ct, "_freeHighlightClipId", "");
let rd = Ct;
var xn, Sn, zs, mi, rs, kn, Mn, Cn, bi, fo, Tn, In, nr, Iu, py, Nu, gy, Du, my, Pu, by, Gh, _p, Lu, yy, Vh, Ep, Ru, vy, Ou, wy, Fu, Ay, ju, _y, zu, Ey, yi, _r, Yh, xp, Xh, Sp, qh, kp, po, Wc, go, $c, ar, Qn, Qh, Mp, mo, Gc, Bu, xy, Kh, Cp, Uu, Sy, Hu, ky, Zh, Tp, bo, Vc, Nn, Xo;
const zt = class zt extends Dt {
  constructor(t) {
    super({
      ...t,
      name: "inkEditor"
    });
    y(this, Iu);
    y(this, Nu);
    y(this, Du);
    y(this, Pu);
    y(this, Gh);
    y(this, Lu);
    y(this, Vh);
    y(this, Ru);
    y(this, Ou);
    y(this, Fu);
    y(this, ju);
    y(this, zu);
    y(this, yi);
    y(this, Yh);
    y(this, Xh);
    y(this, qh);
    y(this, po);
    y(this, go);
    y(this, ar);
    y(this, Qh);
    y(this, mo);
    y(this, Hu);
    y(this, Zh);
    y(this, bo);
    y(this, Nn);
    y(this, xn, 0);
    y(this, Sn, 0);
    y(this, zs, null);
    y(this, mi, new Path2D());
    y(this, rs, !1);
    y(this, kn, null);
    y(this, Mn, !1);
    y(this, Cn, !1);
    y(this, bi, null);
    y(this, fo, null);
    y(this, Tn, 0);
    y(this, In, 0);
    y(this, nr, null);
    this.color = t.color || null, this.thickness = t.thickness || null, this.opacity = t.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
  }
  static initialize(t, s) {
    Dt.initialize(t, s);
  }
  static updateDefaultParams(t, s) {
    switch (t) {
      case wt.INK_THICKNESS:
        zt._defaultThickness = s;
        break;
      case wt.INK_COLOR:
        zt._defaultColor = s;
        break;
      case wt.INK_OPACITY:
        zt._defaultOpacity = s / 100;
        break;
    }
  }
  updateParams(t, s) {
    switch (t) {
      case wt.INK_THICKNESS:
        x(this, Iu, py).call(this, s);
        break;
      case wt.INK_COLOR:
        x(this, Nu, gy).call(this, s);
        break;
      case wt.INK_OPACITY:
        x(this, Du, my).call(this, s);
        break;
    }
  }
  static get defaultPropertiesToUpdate() {
    return [[wt.INK_THICKNESS, zt._defaultThickness], [wt.INK_COLOR, zt._defaultColor || Dt._defaultLineColor], [wt.INK_OPACITY, Math.round(zt._defaultOpacity * 100)]];
  }
  get propertiesToUpdate() {
    return [[wt.INK_THICKNESS, this.thickness || zt._defaultThickness], [wt.INK_COLOR, this.color || zt._defaultColor || Dt._defaultLineColor], [wt.INK_OPACITY, Math.round(100 * (this.opacity ?? zt._defaultOpacity))]];
  }
  rebuild() {
    this.parent && (super.rebuild(), this.div !== null && (this.canvas || (x(this, po, Wc).call(this), x(this, go, $c).call(this)), this.isAttachedToDOM || (this.parent.add(this), x(this, ar, Qn).call(this)), x(this, Nn, Xo).call(this)));
  }
  remove() {
    var t;
    this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, o(this, zs) && (clearTimeout(o(this, zs)), E(this, zs, null)), (t = o(this, bi)) == null || t.disconnect(), E(this, bi, null), super.remove());
  }
  setParent(t) {
    !this.parent && t ? this._uiManager.removeShouldRescale(this) : this.parent && t === null && this._uiManager.addShouldRescale(this), super.setParent(t);
  }
  onScaleChanging() {
    const [t, s] = this.parentDimensions, i = this.width * t, r = this.height * s;
    this.setDimensions(i, r);
  }
  enableEditMode() {
    o(this, rs) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, x(this, Yh, xp).call(this));
  }
  disableEditMode() {
    !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), x(this, Xh, Sp).call(this));
  }
  onceAdded() {
    this._isDraggable = !this.isEmpty();
  }
  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }
  commit() {
    o(this, rs) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), E(this, rs, !0), this.div.classList.add("disabled"), x(this, Nn, Xo).call(this, !0), this.select(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
      preventScroll: !0
    }));
  }
  focusin(t) {
    this._focusEventsAllowed && (super.focusin(t), this.enableEditMode());
  }
  canvasPointerdown(t) {
    t.button !== 0 || !this.isInEditMode() || o(this, rs) || (this.setInForeground(), t.preventDefault(), this.div.contains(document.activeElement) || this.div.focus({
      preventScroll: !0
    }), x(this, Lu, yy).call(this, t.offsetX, t.offsetY));
  }
  canvasPointermove(t) {
    t.preventDefault(), x(this, Vh, Ep).call(this, t.offsetX, t.offsetY);
  }
  canvasPointerup(t) {
    t.preventDefault(), x(this, qh, kp).call(this, t);
  }
  canvasPointerleave(t) {
    x(this, qh, kp).call(this, t);
  }
  get isResizable() {
    return !this.isEmpty() && o(this, rs);
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    this.width && (t = this.x, s = this.y), super.render(), this.div.setAttribute("data-l10n-id", "pdfjs-ink");
    const [i, r, n, a] = x(this, Pu, by).call(this);
    if (this.setAt(i, r, 0, 0), this.setDims(n, a), x(this, po, Wc).call(this), this.width) {
      const [h, c] = this.parentDimensions;
      this.setAspectRatio(this.width * h, this.height * c), this.setAt(t * h, s * c, this.width * h, this.height * c), E(this, Cn, !0), x(this, ar, Qn).call(this), this.setDims(this.width * h, this.height * c), x(this, yi, _r).call(this), this.div.classList.add("disabled");
    } else
      this.div.classList.add("editing"), this.enableEditMode();
    return x(this, go, $c).call(this), this.div;
  }
  setDimensions(t, s) {
    const i = Math.round(t), r = Math.round(s);
    if (o(this, Tn) === i && o(this, In) === r)
      return;
    E(this, Tn, i), E(this, In, r), this.canvas.style.visibility = "hidden";
    const [n, a] = this.parentDimensions;
    this.width = t / n, this.height = s / a, this.fixAndSetPosition(), o(this, rs) && x(this, Qh, Mp).call(this, t, s), x(this, ar, Qn).call(this), x(this, yi, _r).call(this), this.canvas.style.visibility = "visible", this.fixDims();
  }
  static async deserialize(t, s, i) {
    var w, b, _;
    if (t instanceof ag)
      return null;
    const r = await super.deserialize(t, s, i);
    r.thickness = t.thickness, r.color = pt.makeHexColor(...t.color), r.opacity = t.opacity;
    const [n, a] = r.pageDimensions, h = r.width * n, c = r.height * a, d = r.parentScale, u = t.thickness / 2;
    E(r, rs, !0), E(r, Tn, Math.round(h)), E(r, In, Math.round(c));
    const {
      paths: f,
      rect: p,
      rotation: m
    } = t;
    for (let {
      bezier: k
    } of f) {
      k = x(w = zt, Uu, Sy).call(w, k, p, m);
      const C = [];
      r.paths.push(C);
      let N = d * (k[0] - u), R = d * (k[1] - u);
      for (let M = 2, S = k.length; M < S; M += 6) {
        const L = d * (k[M] - u), H = d * (k[M + 1] - u), I = d * (k[M + 2] - u), F = d * (k[M + 3] - u), A = d * (k[M + 4] - u), G = d * (k[M + 5] - u);
        C.push([[N, R], [L, H], [I, F], [A, G]]), N = A, R = G;
      }
      const P = x(this, Bu, xy).call(this, C);
      r.bezierPath2D.push(P);
    }
    const g = x(b = r, Zh, Tp).call(b);
    return E(r, Sn, Math.max(Dt.MIN_SIZE, g[2] - g[0])), E(r, xn, Math.max(Dt.MIN_SIZE, g[3] - g[1])), x(_ = r, Qh, Mp).call(_, h, c), r;
  }
  serialize() {
    if (this.isEmpty())
      return null;
    const t = this.getRect(0, 0), s = Dt._colorManager.convert(this.ctx.strokeStyle);
    return {
      annotationType: _t.INK,
      color: s,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: x(this, Hu, ky).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, t),
      pageIndex: this.pageIndex,
      rect: t,
      rotation: this.rotation,
      structTreeParentId: this._structTreeParentId
    };
  }
};
xn = new WeakMap(), Sn = new WeakMap(), zs = new WeakMap(), mi = new WeakMap(), rs = new WeakMap(), kn = new WeakMap(), Mn = new WeakMap(), Cn = new WeakMap(), bi = new WeakMap(), fo = new WeakMap(), Tn = new WeakMap(), In = new WeakMap(), nr = new WeakMap(), Iu = new WeakSet(), py = function(t) {
  const s = (r) => {
    this.thickness = r, x(this, Nn, Xo).call(this);
  }, i = this.thickness;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: wt.INK_THICKNESS,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Nu = new WeakSet(), gy = function(t) {
  const s = (r) => {
    this.color = r, x(this, yi, _r).call(this);
  }, i = this.color;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: wt.INK_COLOR,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Du = new WeakSet(), my = function(t) {
  const s = (r) => {
    this.opacity = r, x(this, yi, _r).call(this);
  };
  t /= 100;
  const i = this.opacity;
  this.addCommands({
    cmd: s.bind(this, t),
    undo: s.bind(this, i),
    post: this._uiManager.updateUI.bind(this._uiManager, this),
    mustExec: !0,
    type: wt.INK_OPACITY,
    overwriteIfSameType: !0,
    keepUndo: !0
  });
}, Pu = new WeakSet(), by = function() {
  const {
    parentRotation: t,
    parentDimensions: [s, i]
  } = this;
  switch (t) {
    case 90:
      return [0, i, i, s];
    case 180:
      return [s, i, s, i];
    case 270:
      return [s, 0, i, s];
    default:
      return [0, 0, s, i];
  }
}, Gh = new WeakSet(), _p = function() {
  const {
    ctx: t,
    color: s,
    opacity: i,
    thickness: r,
    parentScale: n,
    scaleFactor: a
  } = this;
  t.lineWidth = r * n / a, t.lineCap = "round", t.lineJoin = "round", t.miterLimit = 10, t.strokeStyle = `${s}${Sw(i)}`;
}, Lu = new WeakSet(), yy = function(t, s) {
  this.canvas.addEventListener("contextmenu", as, {
    signal: this._uiManager._signal
  }), x(this, Xh, Sp).call(this), E(this, kn, new AbortController());
  const i = this._uiManager.combinedSignal(o(this, kn));
  this.canvas.addEventListener("pointerleave", this.canvasPointerleave.bind(this), {
    signal: i
  }), this.canvas.addEventListener("pointermove", this.canvasPointermove.bind(this), {
    signal: i
  }), this.canvas.addEventListener("pointerup", this.canvasPointerup.bind(this), {
    signal: i
  }), this.isEditing = !0, o(this, Cn) || (E(this, Cn, !0), x(this, ar, Qn).call(this), this.thickness || (this.thickness = zt._defaultThickness), this.color || (this.color = zt._defaultColor || Dt._defaultLineColor), this.opacity ?? (this.opacity = zt._defaultOpacity)), this.currentPath.push([t, s]), E(this, Mn, !1), x(this, Gh, _p).call(this), E(this, nr, () => {
    x(this, Fu, Ay).call(this), o(this, nr) && window.requestAnimationFrame(o(this, nr));
  }), window.requestAnimationFrame(o(this, nr));
}, Vh = new WeakSet(), Ep = function(t, s) {
  const [i, r] = this.currentPath.at(-1);
  if (this.currentPath.length > 1 && t === i && s === r)
    return;
  const n = this.currentPath;
  let a = o(this, mi);
  if (n.push([t, s]), E(this, Mn, !0), n.length <= 2) {
    a.moveTo(...n[0]), a.lineTo(t, s);
    return;
  }
  n.length === 3 && (E(this, mi, a = new Path2D()), a.moveTo(...n[0])), x(this, ju, _y).call(this, a, ...n.at(-3), ...n.at(-2), t, s);
}, Ru = new WeakSet(), vy = function() {
  if (this.currentPath.length === 0)
    return;
  const t = this.currentPath.at(-1);
  o(this, mi).lineTo(...t);
}, Ou = new WeakSet(), wy = function(t, s) {
  E(this, nr, null), t = Math.min(Math.max(t, 0), this.canvas.width), s = Math.min(Math.max(s, 0), this.canvas.height), x(this, Vh, Ep).call(this, t, s), x(this, Ru, vy).call(this);
  let i;
  if (this.currentPath.length !== 1)
    i = x(this, zu, Ey).call(this);
  else {
    const c = [t, s];
    i = [[c, c.slice(), c.slice(), c]];
  }
  const r = o(this, mi), n = this.currentPath;
  this.currentPath = [], E(this, mi, new Path2D());
  const a = () => {
    this.allRawPaths.push(n), this.paths.push(i), this.bezierPath2D.push(r), this._uiManager.rebuild(this);
  }, h = () => {
    this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (x(this, po, Wc).call(this), x(this, go, $c).call(this)), x(this, Nn, Xo).call(this));
  };
  this.addCommands({
    cmd: a,
    undo: h,
    mustExec: !0
  });
}, Fu = new WeakSet(), Ay = function() {
  if (!o(this, Mn))
    return;
  E(this, Mn, !1);
  const t = Math.ceil(this.thickness * this.parentScale), s = this.currentPath.slice(-3), i = s.map((a) => a[0]), r = s.map((a) => a[1]);
  Math.min(...i) - t, Math.max(...i) + t, Math.min(...r) - t, Math.max(...r) + t;
  const {
    ctx: n
  } = this;
  n.save(), n.clearRect(0, 0, this.canvas.width, this.canvas.height);
  for (const a of this.bezierPath2D)
    n.stroke(a);
  n.stroke(o(this, mi)), n.restore();
}, ju = new WeakSet(), _y = function(t, s, i, r, n, a, h) {
  const c = (s + r) / 2, d = (i + n) / 2, u = (r + a) / 2, f = (n + h) / 2;
  t.bezierCurveTo(c + 2 * (r - c) / 3, d + 2 * (n - d) / 3, u + 2 * (r - u) / 3, f + 2 * (n - f) / 3, u, f);
}, zu = new WeakSet(), Ey = function() {
  const t = this.currentPath;
  if (t.length <= 2)
    return [[t[0], t[0], t.at(-1), t.at(-1)]];
  const s = [];
  let i, [r, n] = t[0];
  for (i = 1; i < t.length - 2; i++) {
    const [p, m] = t[i], [g, w] = t[i + 1], b = (p + g) / 2, _ = (m + w) / 2, k = [r + 2 * (p - r) / 3, n + 2 * (m - n) / 3], C = [b + 2 * (p - b) / 3, _ + 2 * (m - _) / 3];
    s.push([[r, n], k, C, [b, _]]), [r, n] = [b, _];
  }
  const [a, h] = t[i], [c, d] = t[i + 1], u = [r + 2 * (a - r) / 3, n + 2 * (h - n) / 3], f = [c + 2 * (a - c) / 3, d + 2 * (h - d) / 3];
  return s.push([[r, n], u, f, [c, d]]), s;
}, yi = new WeakSet(), _r = function() {
  if (this.isEmpty()) {
    x(this, mo, Gc).call(this);
    return;
  }
  x(this, Gh, _p).call(this);
  const {
    canvas: t,
    ctx: s
  } = this;
  s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, t.width, t.height), x(this, mo, Gc).call(this);
  for (const i of this.bezierPath2D)
    s.stroke(i);
}, Yh = new WeakSet(), xp = function() {
  if (o(this, fo))
    return;
  E(this, fo, new AbortController());
  const t = this._uiManager.combinedSignal(o(this, fo));
  this.canvas.addEventListener("pointerdown", this.canvasPointerdown.bind(this), {
    signal: t
  });
}, Xh = new WeakSet(), Sp = function() {
  var t;
  (t = this.pointerdownAC) == null || t.abort(), this.pointerdownAC = null;
}, qh = new WeakSet(), kp = function(t) {
  var s;
  (s = o(this, kn)) == null || s.abort(), E(this, kn, null), x(this, Yh, xp).call(this), o(this, zs) && clearTimeout(o(this, zs)), E(this, zs, setTimeout(() => {
    E(this, zs, null), this.canvas.removeEventListener("contextmenu", as);
  }, 10)), x(this, Ou, wy).call(this, t.offsetX, t.offsetY), this.addToAnnotationStorage(), this.setInBackground();
}, po = new WeakSet(), Wc = function() {
  this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", this.canvas.setAttribute("data-l10n-id", "pdfjs-ink-canvas"), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
}, go = new WeakSet(), $c = function() {
  E(this, bi, new ResizeObserver((t) => {
    const s = t[0].contentRect;
    s.width && s.height && this.setDimensions(s.width, s.height);
  })), o(this, bi).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var t;
    (t = o(this, bi)) == null || t.disconnect(), E(this, bi, null);
  }, {
    once: !0
  });
}, ar = new WeakSet(), Qn = function() {
  if (!o(this, Cn))
    return;
  const [t, s] = this.parentDimensions;
  this.canvas.width = Math.ceil(this.width * t), this.canvas.height = Math.ceil(this.height * s), x(this, mo, Gc).call(this);
}, Qh = new WeakSet(), Mp = function(t, s) {
  const i = x(this, bo, Vc).call(this), r = (t - i) / o(this, Sn), n = (s - i) / o(this, xn);
  this.scaleFactor = Math.min(r, n);
}, mo = new WeakSet(), Gc = function() {
  const t = x(this, bo, Vc).call(this) / 2;
  this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + t, this.translationY * this.scaleFactor + t);
}, Bu = new WeakSet(), xy = function(t) {
  const s = new Path2D();
  for (let i = 0, r = t.length; i < r; i++) {
    const [n, a, h, c] = t[i];
    i === 0 && s.moveTo(...n), s.bezierCurveTo(a[0], a[1], h[0], h[1], c[0], c[1]);
  }
  return s;
}, Kh = new WeakSet(), Cp = function(t, s, i) {
  const [r, n, a, h] = s;
  switch (i) {
    case 0:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] += r, t[c + 1] = h - t[c + 1];
      break;
    case 90:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = t[c + 1] + r, t[c + 1] = u + n;
      }
      break;
    case 180:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] = a - t[c], t[c + 1] += n;
      break;
    case 270:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = a - t[c + 1], t[c + 1] = h - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return t;
}, Uu = new WeakSet(), Sy = function(t, s, i) {
  const [r, n, a, h] = s;
  switch (i) {
    case 0:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] -= r, t[c + 1] = h - t[c + 1];
      break;
    case 90:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = t[c + 1] - n, t[c + 1] = u - r;
      }
      break;
    case 180:
      for (let c = 0, d = t.length; c < d; c += 2)
        t[c] = a - t[c], t[c + 1] -= n;
      break;
    case 270:
      for (let c = 0, d = t.length; c < d; c += 2) {
        const u = t[c];
        t[c] = h - t[c + 1], t[c + 1] = a - u;
      }
      break;
    default:
      throw new Error("Invalid rotation");
  }
  return t;
}, Hu = new WeakSet(), ky = function(t, s, i, r) {
  var d, u;
  const n = [], a = this.thickness / 2, h = t * s + a, c = t * i + a;
  for (const f of this.paths) {
    const p = [], m = [];
    for (let g = 0, w = f.length; g < w; g++) {
      const [b, _, k, C] = f[g];
      if (b[0] === C[0] && b[1] === C[1] && w === 1) {
        const F = t * b[0] + h, A = t * b[1] + c;
        p.push(F, A), m.push(F, A);
        break;
      }
      const N = t * b[0] + h, R = t * b[1] + c, P = t * _[0] + h, M = t * _[1] + c, S = t * k[0] + h, L = t * k[1] + c, H = t * C[0] + h, I = t * C[1] + c;
      g === 0 && (p.push(N, R), m.push(N, R)), p.push(P, M, S, L, H, I), m.push(P, M), g === w - 1 && m.push(H, I);
    }
    n.push({
      bezier: x(d = zt, Kh, Cp).call(d, p, r, this.rotation),
      points: x(u = zt, Kh, Cp).call(u, m, r, this.rotation)
    });
  }
  return n;
}, Zh = new WeakSet(), Tp = function() {
  let t = 1 / 0, s = -1 / 0, i = 1 / 0, r = -1 / 0;
  for (const n of this.paths)
    for (const [a, h, c, d] of n) {
      const u = pt.bezierBoundingBox(...a, ...h, ...c, ...d);
      t = Math.min(t, u[0]), i = Math.min(i, u[1]), s = Math.max(s, u[2]), r = Math.max(r, u[3]);
    }
  return [t, i, s, r];
}, bo = new WeakSet(), Vc = function() {
  return o(this, rs) ? Math.ceil(this.thickness * this.parentScale) : 0;
}, Nn = new WeakSet(), Xo = function(t = !1) {
  if (this.isEmpty())
    return;
  if (!o(this, rs)) {
    x(this, yi, _r).call(this);
    return;
  }
  const s = x(this, Zh, Tp).call(this), i = x(this, bo, Vc).call(this);
  E(this, Sn, Math.max(Dt.MIN_SIZE, s[2] - s[0])), E(this, xn, Math.max(Dt.MIN_SIZE, s[3] - s[1]));
  const r = Math.ceil(i + o(this, Sn) * this.scaleFactor), n = Math.ceil(i + o(this, xn) * this.scaleFactor), [a, h] = this.parentDimensions;
  this.width = r / a, this.height = n / h, this.setAspectRatio(r, n);
  const c = this.translationX, d = this.translationY;
  this.translationX = -s[0], this.translationY = -s[1], x(this, ar, Qn).call(this), x(this, yi, _r).call(this), E(this, Tn, r), E(this, In, n), this.setDims(r, n);
  const u = t ? i / this.scaleFactor / 2 : 0;
  this.translate(c - this.translationX - u, d - this.translationY - u);
}, y(zt, Bu), y(zt, Kh), y(zt, Uu), vt(zt, "_defaultColor", null), vt(zt, "_defaultOpacity", 1), vt(zt, "_defaultThickness", 1), vt(zt, "_type", "ink"), vt(zt, "_editorType", _t.INK);
let Ap = zt;
var $t, ve, or, vi, lr, yo, Bs, wi, Us, Xe, vo, Dn, qo, Pn, Qo, wo, Yc, Jh, Np, Wu, My, Ao, Xc, tc, Dp, _o, qc, $u, Cy, Gu, Ty;
const Jo = class Jo extends Dt {
  constructor(t) {
    super({
      ...t,
      name: "stampEditor"
    });
    y(this, Dn);
    y(this, Pn);
    y(this, wo);
    y(this, Jh);
    y(this, Wu);
    y(this, Ao);
    y(this, tc);
    y(this, _o);
    y(this, $u);
    y(this, Gu);
    y(this, $t, null);
    y(this, ve, null);
    y(this, or, null);
    y(this, vi, null);
    y(this, lr, null);
    y(this, yo, "");
    y(this, Bs, null);
    y(this, wi, null);
    y(this, Us, null);
    y(this, Xe, !1);
    y(this, vo, !1);
    E(this, vi, t.bitmapUrl), E(this, lr, t.bitmapFile);
  }
  static initialize(t, s) {
    Dt.initialize(t, s);
  }
  static get supportedTypes() {
    return Mt(this, "supportedTypes", ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"].map((s) => `image/${s}`));
  }
  static get supportedTypesStr() {
    return Mt(this, "supportedTypesStr", this.supportedTypes.join(","));
  }
  static isHandlingMimeForPasting(t) {
    return this.supportedTypes.includes(t);
  }
  static paste(t, s) {
    s.pasteEditor(_t.STAMP, {
      bitmapFile: t.getAsFile()
    });
  }
  altTextFinish() {
    this._uiManager.useNewAltTextFlow && (this.div.hidden = !1), super.altTextFinish();
  }
  get telemetryFinalData() {
    var t;
    return {
      type: "stamp",
      hasAltText: !!((t = this.altTextData) != null && t.altText)
    };
  }
  static computeTelemetryFinalData(t) {
    const s = t.get("hasAltText");
    return {
      hasAltText: s.get(!0) ?? 0,
      hasNoAltText: s.get(!1) ?? 0
    };
  }
  async mlGuessAltText(t = null, s = !0) {
    if (this.hasAltTextData())
      return null;
    const {
      mlManager: i
    } = this._uiManager;
    if (!i)
      throw new Error("No ML.");
    if (!await i.isEnabledFor("altText"))
      throw new Error("ML isn't enabled for alt text.");
    const {
      data: r,
      width: n,
      height: a
    } = t || this.copyCanvas(null, null, !0).imageData, h = await i.guess({
      name: "altText",
      request: {
        data: r,
        width: n,
        height: a,
        channels: r.length / (n * a)
      }
    });
    if (!h)
      throw new Error("No response from the AI service.");
    if (h.error)
      throw new Error("Error from the AI service.");
    if (h.cancel)
      return null;
    if (!h.output)
      throw new Error("No valid response from the AI service.");
    const c = h.output;
    return await this.setGuessedAltText(c), s && !this.hasAltTextData() && (this.altTextData = {
      alt: c,
      decorative: !1
    }), c;
  }
  remove() {
    var t, s;
    o(this, ve) && (E(this, $t, null), this._uiManager.imageManager.deleteId(o(this, ve)), (t = o(this, Bs)) == null || t.remove(), E(this, Bs, null), (s = o(this, wi)) == null || s.disconnect(), E(this, wi, null), o(this, Us) && (clearTimeout(o(this, Us)), E(this, Us, null))), super.remove();
  }
  rebuild() {
    if (!this.parent) {
      o(this, ve) && x(this, wo, Yc).call(this);
      return;
    }
    super.rebuild(), this.div !== null && (o(this, ve) && o(this, Bs) === null && x(this, wo, Yc).call(this), this.isAttachedToDOM || this.parent.add(this));
  }
  onceAdded() {
    this._isDraggable = !0, this.div.focus();
  }
  isEmpty() {
    return !(o(this, or) || o(this, $t) || o(this, vi) || o(this, lr) || o(this, ve));
  }
  get isResizable() {
    return !0;
  }
  render() {
    if (this.div)
      return this.div;
    let t, s;
    if (this.width && (t = this.x, s = this.y), super.render(), this.div.hidden = !0, this.div.setAttribute("role", "figure"), this.addAltTextButton(), o(this, $t) ? x(this, Jh, Np).call(this) : x(this, wo, Yc).call(this), this.width && !this.annotationElementId) {
      const [i, r] = this.parentDimensions;
      this.setAt(t * i, s * r, this.width * i, this.height * r);
    }
    return this.div;
  }
  copyCanvas(t, s, i = !1) {
    var p;
    t || (t = 224);
    const {
      width: r,
      height: n
    } = o(this, $t), a = new kf();
    let h = o(this, $t), c = r, d = n, u = null;
    if (s) {
      if (r > s || n > s) {
        const M = Math.min(s / r, s / n);
        c = Math.floor(r * M), d = Math.floor(n * M);
      }
      u = document.createElement("canvas");
      const m = u.width = Math.ceil(c * a.sx), g = u.height = Math.ceil(d * a.sy);
      o(this, Xe) || (h = x(this, Ao, Xc).call(this, m, g));
      const w = u.getContext("2d");
      w.filter = this._uiManager.hcmFilter;
      let b = "white", _ = "#cfcfd8";
      this._uiManager.hcmFilter !== "none" ? _ = "black" : (p = window.matchMedia) != null && p.call(window, "(prefers-color-scheme: dark)").matches && (b = "#8f8f9d", _ = "#42414d");
      const k = 15, C = k * a.sx, N = k * a.sy, R = new OffscreenCanvas(C * 2, N * 2), P = R.getContext("2d");
      P.fillStyle = b, P.fillRect(0, 0, C * 2, N * 2), P.fillStyle = _, P.fillRect(0, 0, C, N), P.fillRect(C, N, C, N), w.fillStyle = w.createPattern(R, "repeat"), w.fillRect(0, 0, m, g), w.drawImage(h, 0, 0, h.width, h.height, 0, 0, m, g);
    }
    let f = null;
    if (i) {
      let m, g;
      if (a.symmetric && h.width < t && h.height < t)
        m = h.width, g = h.height;
      else if (h = o(this, $t), r > t || n > t) {
        const _ = Math.min(t / r, t / n);
        m = Math.floor(r * _), g = Math.floor(n * _), o(this, Xe) || (h = x(this, Ao, Xc).call(this, m, g));
      }
      const b = new OffscreenCanvas(m, g).getContext("2d", {
        willReadFrequently: !0
      });
      b.drawImage(h, 0, 0, h.width, h.height, 0, 0, m, g), f = {
        width: m,
        height: g,
        data: b.getImageData(0, 0, m, g).data
      };
    }
    return {
      canvas: u,
      width: c,
      height: d,
      imageData: f
    };
  }
  getImageForAltText() {
    return o(this, Bs);
  }
  static async deserialize(t, s, i) {
    var g;
    let r = null;
    if (t instanceof zb) {
      const {
        data: {
          rect: w,
          rotation: b,
          id: _,
          structParent: k,
          popupRef: C
        },
        container: N,
        parent: {
          page: {
            pageNumber: R
          }
        }
      } = t, P = N.querySelector("canvas"), M = i.imageManager.getFromCanvas(N.id, P);
      P.remove();
      const S = ((g = await s._structTree.getAriaAttributes(`${qp}${_}`)) == null ? void 0 : g.get("aria-label")) || "";
      r = t = {
        annotationType: _t.STAMP,
        bitmapId: M.id,
        bitmap: M.bitmap,
        pageIndex: R - 1,
        rect: w.slice(0),
        rotation: b,
        id: _,
        deleted: !1,
        accessibilityData: {
          decorative: !1,
          altText: S
        },
        isSvg: !1,
        structParent: k,
        popupRef: C
      };
    }
    const n = await super.deserialize(t, s, i), {
      rect: a,
      bitmap: h,
      bitmapUrl: c,
      bitmapId: d,
      isSvg: u,
      accessibilityData: f
    } = t;
    d && i.imageManager.isValidId(d) ? (E(n, ve, d), h && E(n, $t, h)) : E(n, vi, c), E(n, Xe, u);
    const [p, m] = n.pageDimensions;
    return n.width = (a[2] - a[0]) / p, n.height = (a[3] - a[1]) / m, n.annotationElementId = t.id || null, f && (n.altTextData = f), n._initialData = r, E(n, vo, !!r), n;
  }
  serialize(t = !1, s = null) {
    if (this.isEmpty())
      return null;
    if (this.deleted)
      return this.serializeDeleted();
    const i = {
      annotationType: _t.STAMP,
      bitmapId: o(this, ve),
      pageIndex: this.pageIndex,
      rect: this.getRect(0, 0),
      rotation: this.rotation,
      isSvg: o(this, Xe),
      structTreeParentId: this._structTreeParentId
    };
    if (t)
      return i.bitmapUrl = x(this, _o, qc).call(this, !0), i.accessibilityData = this.serializeAltText(!0), i;
    const {
      decorative: r,
      altText: n
    } = this.serializeAltText(!1);
    if (!r && n && (i.accessibilityData = {
      type: "Figure",
      alt: n
    }), this.annotationElementId) {
      const h = x(this, Gu, Ty).call(this, i);
      if (h.isSame)
        return null;
      h.isSameAltText ? delete i.accessibilityData : i.accessibilityData.structParent = this._initialData.structParent ?? -1;
    }
    if (i.id = this.annotationElementId, s === null)
      return i;
    s.stamps || (s.stamps = /* @__PURE__ */ new Map());
    const a = o(this, Xe) ? (i.rect[2] - i.rect[0]) * (i.rect[3] - i.rect[1]) : null;
    if (!s.stamps.has(o(this, ve)))
      s.stamps.set(o(this, ve), {
        area: a,
        serialized: i
      }), i.bitmap = x(this, _o, qc).call(this, !1);
    else if (o(this, Xe)) {
      const h = s.stamps.get(o(this, ve));
      a > h.area && (h.area = a, h.serialized.bitmap.close(), h.serialized.bitmap = x(this, _o, qc).call(this, !1));
    }
    return i;
  }
  renderAnnotationElement(t) {
    return t.updateEdited({
      rect: this.getRect(0, 0)
    }), null;
  }
};
$t = new WeakMap(), ve = new WeakMap(), or = new WeakMap(), vi = new WeakMap(), lr = new WeakMap(), yo = new WeakMap(), Bs = new WeakMap(), wi = new WeakMap(), Us = new WeakMap(), Xe = new WeakMap(), vo = new WeakMap(), Dn = new WeakSet(), qo = function(t, s = !1) {
  if (!t) {
    this.remove();
    return;
  }
  E(this, $t, t.bitmap), s || (E(this, ve, t.id), E(this, Xe, t.isSvg)), t.file && E(this, yo, t.file.name), x(this, Jh, Np).call(this);
}, Pn = new WeakSet(), Qo = function() {
  if (E(this, or, null), this._uiManager.enableWaiting(!1), !!o(this, Bs)) {
    if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && o(this, $t)) {
      this._editToolbar.hide(), this._uiManager.editAltText(this, !0);
      return;
    }
    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && o(this, $t)) {
      this._reportTelemetry({
        action: "pdfjs.image.image_added",
        data: {
          alt_text_modal: !1,
          alt_text_type: "empty"
        }
      });
      try {
        this.mlGuessAltText();
      } catch {
      }
    }
    this.div.focus();
  }
}, wo = new WeakSet(), Yc = function() {
  if (o(this, ve)) {
    this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(o(this, ve)).then((i) => x(this, Dn, qo).call(this, i, !0)).finally(() => x(this, Pn, Qo).call(this));
    return;
  }
  if (o(this, vi)) {
    const i = o(this, vi);
    E(this, vi, null), this._uiManager.enableWaiting(!0), E(this, or, this._uiManager.imageManager.getFromUrl(i).then((r) => x(this, Dn, qo).call(this, r)).finally(() => x(this, Pn, Qo).call(this)));
    return;
  }
  if (o(this, lr)) {
    const i = o(this, lr);
    E(this, lr, null), this._uiManager.enableWaiting(!0), E(this, or, this._uiManager.imageManager.getFromFile(i).then((r) => x(this, Dn, qo).call(this, r)).finally(() => x(this, Pn, Qo).call(this)));
    return;
  }
  const t = document.createElement("input");
  t.type = "file", t.accept = Jo.supportedTypesStr;
  const s = this._uiManager._signal;
  E(this, or, new Promise((i) => {
    t.addEventListener("change", async () => {
      if (!t.files || t.files.length === 0)
        this.remove();
      else {
        this._uiManager.enableWaiting(!0);
        const r = await this._uiManager.imageManager.getFromFile(t.files[0]);
        this._reportTelemetry({
          action: "pdfjs.image.image_selected",
          data: {
            alt_text_modal: this._uiManager.useNewAltTextFlow
          }
        }), x(this, Dn, qo).call(this, r);
      }
      i();
    }, {
      signal: s
    }), t.addEventListener("cancel", () => {
      this.remove(), i();
    }, {
      signal: s
    });
  }).finally(() => x(this, Pn, Qo).call(this))), t.click();
}, Jh = new WeakSet(), Np = function() {
  const {
    div: t
  } = this;
  let {
    width: s,
    height: i
  } = o(this, $t);
  const [r, n] = this.pageDimensions, a = 0.75;
  if (this.width)
    s = this.width * r, i = this.height * n;
  else if (s > a * r || i > a * n) {
    const u = Math.min(a * r / s, a * n / i);
    s *= u, i *= u;
  }
  const [h, c] = this.parentDimensions;
  this.setDims(s * h / r, i * c / n), this._uiManager.enableWaiting(!1);
  const d = E(this, Bs, document.createElement("canvas"));
  d.setAttribute("role", "img"), this.addContainer(d), (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) && (t.hidden = !1), x(this, tc, Dp).call(this, s, i), x(this, $u, Cy).call(this), o(this, vo) || (this.parent.addUndoableEditor(this), E(this, vo, !0)), this._reportTelemetry({
    action: "inserted_image"
  }), o(this, yo) && d.setAttribute("aria-label", o(this, yo));
}, Wu = new WeakSet(), My = function(t, s) {
  var a;
  const [i, r] = this.parentDimensions;
  this.width = t / i, this.height = s / r, (a = this._initialOptions) != null && a.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, o(this, Us) !== null && clearTimeout(o(this, Us)), E(this, Us, setTimeout(() => {
    E(this, Us, null), x(this, tc, Dp).call(this, t, s);
  }, 200));
}, Ao = new WeakSet(), Xc = function(t, s) {
  const {
    width: i,
    height: r
  } = o(this, $t);
  let n = i, a = r, h = o(this, $t);
  for (; n > 2 * t || a > 2 * s; ) {
    const c = n, d = a;
    n > 2 * t && (n = n >= 16384 ? Math.floor(n / 2) - 1 : Math.ceil(n / 2)), a > 2 * s && (a = a >= 16384 ? Math.floor(a / 2) - 1 : Math.ceil(a / 2));
    const u = new OffscreenCanvas(n, a);
    u.getContext("2d").drawImage(h, 0, 0, c, d, 0, 0, n, a), h = u.transferToImageBitmap();
  }
  return h;
}, tc = new WeakSet(), Dp = function(t, s) {
  const i = new kf(), r = Math.ceil(t * i.sx), n = Math.ceil(s * i.sy), a = o(this, Bs);
  if (!a || a.width === r && a.height === n)
    return;
  a.width = r, a.height = n;
  const h = o(this, Xe) ? o(this, $t) : x(this, Ao, Xc).call(this, r, n), c = a.getContext("2d");
  c.filter = this._uiManager.hcmFilter, c.drawImage(h, 0, 0, h.width, h.height, 0, 0, r, n);
}, _o = new WeakSet(), qc = function(t) {
  if (t) {
    if (o(this, Xe)) {
      const r = this._uiManager.imageManager.getSvgUrl(o(this, ve));
      if (r)
        return r;
    }
    const s = document.createElement("canvas");
    return {
      width: s.width,
      height: s.height
    } = o(this, $t), s.getContext("2d").drawImage(o(this, $t), 0, 0), s.toDataURL();
  }
  if (o(this, Xe)) {
    const [s, i] = this.pageDimensions, r = Math.round(this.width * s * pr.PDF_TO_CSS_UNITS), n = Math.round(this.height * i * pr.PDF_TO_CSS_UNITS), a = new OffscreenCanvas(r, n);
    return a.getContext("2d").drawImage(o(this, $t), 0, 0, o(this, $t).width, o(this, $t).height, 0, 0, r, n), a.transferToImageBitmap();
  }
  return structuredClone(o(this, $t));
}, $u = new WeakSet(), Cy = function() {
  this._uiManager._signal && (E(this, wi, new ResizeObserver((t) => {
    const s = t[0].contentRect;
    s.width && s.height && x(this, Wu, My).call(this, s.width, s.height);
  })), o(this, wi).observe(this.div), this._uiManager._signal.addEventListener("abort", () => {
    var t;
    (t = o(this, wi)) == null || t.disconnect(), E(this, wi, null);
  }, {
    once: !0
  }));
}, Gu = new WeakSet(), Ty = function(t) {
  var c;
  const {
    rect: s,
    pageIndex: i,
    accessibilityData: {
      altText: r
    }
  } = this._initialData, n = t.rect.every((d, u) => Math.abs(d - s[u]) < 1), a = t.pageIndex === i, h = (((c = t.accessibilityData) == null ? void 0 : c.alt) || "") === r;
  return {
    isSame: n && a && h,
    isSameAltText: h
  };
}, vt(Jo, "_type", "stamp"), vt(Jo, "_editorType", _t.STAMP);
let Ip = Jo;
var Ln, Eo, Hs, hr, Ai, qe, cr, xo, So, ke, _i, mt, dr, Vu, Iy, ec, Lp, sc, Rp, ic, Op, ko, Qc;
const os = class os {
  constructor({
    uiManager: e,
    pageIndex: t,
    div: s,
    structTreeLayer: i,
    accessibilityManager: r,
    annotationLayer: n,
    drawLayer: a,
    textLayer: h,
    viewport: c,
    l10n: d
  }) {
    y(this, Vu);
    y(this, ec);
    y(this, sc);
    y(this, ic);
    y(this, ko);
    y(this, Ln, void 0);
    y(this, Eo, !1);
    y(this, Hs, null);
    y(this, hr, null);
    y(this, Ai, null);
    y(this, qe, /* @__PURE__ */ new Map());
    y(this, cr, !1);
    y(this, xo, !1);
    y(this, So, !1);
    y(this, ke, null);
    y(this, _i, null);
    y(this, mt, void 0);
    const u = [...o(os, dr).values()];
    if (!os._initialized) {
      os._initialized = !0;
      for (const f of u)
        f.initialize(d, e);
    }
    e.registerEditorTypes(u), E(this, mt, e), this.pageIndex = t, this.div = s, E(this, Ln, r), E(this, Hs, n), this.viewport = c, E(this, ke, h), this.drawLayer = a, this._structTree = i, o(this, mt).addLayer(this);
  }
  get isEmpty() {
    return o(this, qe).size === 0;
  }
  get isInvisible() {
    return this.isEmpty && o(this, mt).getMode() === _t.NONE;
  }
  updateToolbar(e) {
    o(this, mt).updateToolbar(e);
  }
  updateMode(e = o(this, mt).getMode()) {
    switch (x(this, ko, Qc).call(this), e) {
      case _t.NONE:
        this.disableTextSelection(), this.togglePointerEvents(!1), this.toggleAnnotationLayerPointerEvents(!0), this.disableClick();
        return;
      case _t.INK:
        this.addInkEditorIfNeeded(!1), this.disableTextSelection(), this.togglePointerEvents(!0), this.disableClick();
        break;
      case _t.HIGHLIGHT:
        this.enableTextSelection(), this.togglePointerEvents(!1), this.disableClick();
        break;
      default:
        this.disableTextSelection(), this.togglePointerEvents(!0), this.enableClick();
    }
    this.toggleAnnotationLayerPointerEvents(!1);
    const {
      classList: t
    } = this.div;
    for (const s of o(os, dr).values())
      t.toggle(`${s._type}Editing`, e === s._editorType);
    this.div.hidden = !1;
  }
  hasTextLayer(e) {
    var t;
    return e === ((t = o(this, ke)) == null ? void 0 : t.div);
  }
  addInkEditorIfNeeded(e) {
    if (o(this, mt).getMode() !== _t.INK)
      return;
    if (!e) {
      for (const s of o(this, qe).values())
        if (s.isEmpty()) {
          s.setInBackground();
          return;
        }
    }
    this.createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    }, !1).setInBackground();
  }
  setEditingState(e) {
    o(this, mt).setEditingState(e);
  }
  addCommands(e) {
    o(this, mt).addCommands(e);
  }
  toggleDrawing(e = !1) {
    this.div.classList.toggle("drawing", !e);
  }
  togglePointerEvents(e = !1) {
    this.div.classList.toggle("disabled", !e);
  }
  toggleAnnotationLayerPointerEvents(e = !1) {
    var t;
    (t = o(this, Hs)) == null || t.div.classList.toggle("disabled", !e);
  }
  async enable() {
    this.div.tabIndex = 0, this.togglePointerEvents(!0);
    const e = /* @__PURE__ */ new Set();
    for (const s of o(this, qe).values())
      s.enableEditing(), s.show(!0), s.annotationElementId && (o(this, mt).removeChangedExistingAnnotation(s), e.add(s.annotationElementId));
    if (!o(this, Hs))
      return;
    const t = o(this, Hs).getEditableAnnotations();
    for (const s of t) {
      if (s.hide(), o(this, mt).isDeletedAnnotationElement(s.data.id) || e.has(s.data.id))
        continue;
      const i = await this.deserialize(s);
      i && (this.addOrRebuild(i), i.enableEditing());
    }
  }
  disable() {
    var i;
    E(this, So, !0), this.div.tabIndex = -1, this.togglePointerEvents(!1);
    const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
    for (const r of o(this, qe).values())
      if (r.disableEditing(), !!r.annotationElementId) {
        if (r.serialize() !== null) {
          e.set(r.annotationElementId, r);
          continue;
        } else
          t.set(r.annotationElementId, r);
        (i = this.getEditableAnnotation(r.annotationElementId)) == null || i.show(), r.remove();
      }
    if (o(this, Hs)) {
      const r = o(this, Hs).getEditableAnnotations();
      for (const n of r) {
        const {
          id: a
        } = n.data;
        if (o(this, mt).isDeletedAnnotationElement(a))
          continue;
        let h = t.get(a);
        if (h) {
          h.resetAnnotationElement(n), h.show(!1), n.show();
          continue;
        }
        h = e.get(a), h && (o(this, mt).addChangedExistingAnnotation(h), h.renderAnnotationElement(n) && h.show(!1)), n.show();
      }
    }
    x(this, ko, Qc).call(this), this.isEmpty && (this.div.hidden = !0);
    const {
      classList: s
    } = this.div;
    for (const r of o(os, dr).values())
      s.remove(`${r._type}Editing`);
    this.disableTextSelection(), this.toggleAnnotationLayerPointerEvents(!0), E(this, So, !1);
  }
  getEditableAnnotation(e) {
    var t;
    return ((t = o(this, Hs)) == null ? void 0 : t.getEditableAnnotation(e)) || null;
  }
  setActiveEditor(e) {
    o(this, mt).getActive() !== e && o(this, mt).setActiveEditor(e);
  }
  enableTextSelection() {
    var e;
    if (this.div.tabIndex = -1, (e = o(this, ke)) != null && e.div && !o(this, _i)) {
      E(this, _i, new AbortController());
      const t = o(this, mt).combinedSignal(o(this, _i));
      o(this, ke).div.addEventListener("pointerdown", x(this, Vu, Iy).bind(this), {
        signal: t
      }), o(this, ke).div.classList.add("highlighting");
    }
  }
  disableTextSelection() {
    var e;
    this.div.tabIndex = 0, (e = o(this, ke)) != null && e.div && o(this, _i) && (o(this, _i).abort(), E(this, _i, null), o(this, ke).div.classList.remove("highlighting"));
  }
  enableClick() {
    if (o(this, hr))
      return;
    E(this, hr, new AbortController());
    const e = o(this, mt).combinedSignal(o(this, hr));
    this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
      signal: e
    }), this.div.addEventListener("pointerup", this.pointerup.bind(this), {
      signal: e
    });
  }
  disableClick() {
    var e;
    (e = o(this, hr)) == null || e.abort(), E(this, hr, null);
  }
  attach(e) {
    o(this, qe).set(e.id, e);
    const {
      annotationElementId: t
    } = e;
    t && o(this, mt).isDeletedAnnotationElement(t) && o(this, mt).removeDeletedAnnotationElement(e);
  }
  detach(e) {
    var t;
    o(this, qe).delete(e.id), (t = o(this, Ln)) == null || t.removePointerInTextLayer(e.contentDiv), !o(this, So) && e.annotationElementId && o(this, mt).addDeletedAnnotationElement(e);
  }
  remove(e) {
    this.detach(e), o(this, mt).removeEditor(e), e.div.remove(), e.isAttachedToDOM = !1, o(this, xo) || this.addInkEditorIfNeeded(!1);
  }
  changeParent(e) {
    var t;
    e.parent !== this && (e.parent && e.annotationElementId && (o(this, mt).addDeletedAnnotationElement(e.annotationElementId), Dt.deleteAnnotationElement(e), e.annotationElementId = null), this.attach(e), (t = e.parent) == null || t.detach(e), e.setParent(this), e.div && e.isAttachedToDOM && (e.div.remove(), this.div.append(e.div)));
  }
  add(e) {
    if (!(e.parent === this && e.isAttachedToDOM)) {
      if (this.changeParent(e), o(this, mt).addEditor(e), this.attach(e), !e.isAttachedToDOM) {
        const t = e.render();
        this.div.append(t), e.isAttachedToDOM = !0;
      }
      e.fixAndSetPosition(), e.onceAdded(), o(this, mt).addToAnnotationStorage(e), e._reportTelemetry(e.telemetryInitialData);
    }
  }
  moveEditorInDOM(e) {
    var s;
    if (!e.isAttachedToDOM)
      return;
    const {
      activeElement: t
    } = document;
    e.div.contains(t) && !o(this, Ai) && (e._focusEventsAllowed = !1, E(this, Ai, setTimeout(() => {
      E(this, Ai, null), e.div.contains(document.activeElement) ? e._focusEventsAllowed = !0 : (e.div.addEventListener("focusin", () => {
        e._focusEventsAllowed = !0;
      }, {
        once: !0,
        signal: o(this, mt)._signal
      }), t.focus());
    }, 0))), e._structTreeParentId = (s = o(this, Ln)) == null ? void 0 : s.moveElementInDOM(this.div, e.div, e.contentDiv, !0);
  }
  addOrRebuild(e) {
    e.needsToBeRebuilt() ? (e.parent || (e.parent = this), e.rebuild(), e.show()) : this.add(e);
  }
  addUndoableEditor(e) {
    const t = () => e._uiManager.rebuild(e), s = () => {
      e.remove();
    };
    this.addCommands({
      cmd: t,
      undo: s,
      mustExec: !1
    });
  }
  getNextId() {
    return o(this, mt).getId();
  }
  combinedSignal(e) {
    return o(this, mt).combinedSignal(e);
  }
  canCreateNewEmptyEditor() {
    var e;
    return (e = o(this, ec, Lp)) == null ? void 0 : e.canCreateNewEmptyEditor();
  }
  pasteEditor(e, t) {
    o(this, mt).updateToolbar(e), o(this, mt).updateMode(e);
    const {
      offsetX: s,
      offsetY: i
    } = x(this, ic, Op).call(this), r = this.getNextId(), n = x(this, sc, Rp).call(this, {
      parent: this,
      id: r,
      x: s,
      y: i,
      uiManager: o(this, mt),
      isCentered: !0,
      ...t
    });
    n && this.add(n);
  }
  async deserialize(e) {
    var t;
    return await ((t = o(os, dr).get(e.annotationType ?? e.annotationEditorType)) == null ? void 0 : t.deserialize(e, this, o(this, mt))) || null;
  }
  createAndAddNewEditor(e, t, s = {}) {
    const i = this.getNextId(), r = x(this, sc, Rp).call(this, {
      parent: this,
      id: i,
      x: e.offsetX,
      y: e.offsetY,
      uiManager: o(this, mt),
      isCentered: t,
      ...s
    });
    return r && this.add(r), r;
  }
  addNewEditor() {
    this.createAndAddNewEditor(x(this, ic, Op).call(this), !0);
  }
  setSelected(e) {
    o(this, mt).setSelected(e);
  }
  toggleSelected(e) {
    o(this, mt).toggleSelected(e);
  }
  unselect(e) {
    o(this, mt).unselect(e);
  }
  pointerup(e) {
    const {
      isMac: t
    } = Pe.platform;
    if (!(e.button !== 0 || e.ctrlKey && t) && e.target === this.div && o(this, cr)) {
      if (E(this, cr, !1), !o(this, Eo)) {
        E(this, Eo, !0);
        return;
      }
      if (o(this, mt).getMode() === _t.STAMP) {
        o(this, mt).unselectAll();
        return;
      }
      this.createAndAddNewEditor(e, !1);
    }
  }
  pointerdown(e) {
    if (o(this, mt).getMode() === _t.HIGHLIGHT && this.enableTextSelection(), o(this, cr)) {
      E(this, cr, !1);
      return;
    }
    const {
      isMac: t
    } = Pe.platform;
    if (e.button !== 0 || e.ctrlKey && t || e.target !== this.div)
      return;
    E(this, cr, !0);
    const s = o(this, mt).getActive();
    E(this, Eo, !s || s.isEmpty());
  }
  findNewParent(e, t, s) {
    const i = o(this, mt).findParent(t, s);
    return i === null || i === this ? !1 : (i.changeParent(e), !0);
  }
  destroy() {
    var e, t;
    ((e = o(this, mt).getActive()) == null ? void 0 : e.parent) === this && (o(this, mt).commitOrRemove(), o(this, mt).setActiveEditor(null)), o(this, Ai) && (clearTimeout(o(this, Ai)), E(this, Ai, null));
    for (const s of o(this, qe).values())
      (t = o(this, Ln)) == null || t.removePointerInTextLayer(s.contentDiv), s.setParent(null), s.isAttachedToDOM = !1, s.div.remove();
    this.div = null, o(this, qe).clear(), o(this, mt).removeLayer(this);
  }
  render({
    viewport: e
  }) {
    this.viewport = e, Rn(this.div, e);
    for (const t of o(this, mt).getEditors(this.pageIndex))
      this.add(t), t.rebuild();
    this.updateMode();
  }
  update({
    viewport: e
  }) {
    o(this, mt).commitOrRemove(), x(this, ko, Qc).call(this);
    const t = this.viewport.rotation, s = e.rotation;
    if (this.viewport = e, Rn(this.div, {
      rotation: s
    }), t !== s)
      for (const i of o(this, qe).values())
        i.rotate(s);
    this.addInkEditorIfNeeded(!1);
  }
  get pageDimensions() {
    const {
      pageWidth: e,
      pageHeight: t
    } = this.viewport.rawDims;
    return [e, t];
  }
  get scale() {
    return o(this, mt).viewParameters.realScale;
  }
};
Ln = new WeakMap(), Eo = new WeakMap(), Hs = new WeakMap(), hr = new WeakMap(), Ai = new WeakMap(), qe = new WeakMap(), cr = new WeakMap(), xo = new WeakMap(), So = new WeakMap(), ke = new WeakMap(), _i = new WeakMap(), mt = new WeakMap(), dr = new WeakMap(), Vu = new WeakSet(), Iy = function(e) {
  o(this, mt).unselectAll();
  const {
    target: t
  } = e;
  if (t === o(this, ke).div || (t.getAttribute("role") === "img" || t.classList.contains("endOfContent")) && o(this, ke).div.contains(t)) {
    const {
      isMac: s
    } = Pe.platform;
    if (e.button !== 0 || e.ctrlKey && s)
      return;
    o(this, mt).showAllEditors("highlight", !0, !0), o(this, ke).div.classList.add("free"), this.toggleDrawing(), rd.startHighlighting(this, o(this, mt).direction === "ltr", {
      target: o(this, ke).div,
      x: e.x,
      y: e.y
    }), o(this, ke).div.addEventListener("pointerup", () => {
      o(this, ke).div.classList.remove("free"), this.toggleDrawing(!0);
    }, {
      once: !0,
      signal: o(this, mt)._signal
    }), e.preventDefault();
  }
}, ec = new WeakSet(), Lp = function() {
  return o(os, dr).get(o(this, mt).getMode());
}, sc = new WeakSet(), Rp = function(e) {
  const t = o(this, ec, Lp);
  return t ? new t.prototype.constructor(e) : null;
}, ic = new WeakSet(), Op = function() {
  const {
    x: e,
    y: t,
    width: s,
    height: i
  } = this.div.getBoundingClientRect(), r = Math.max(0, e), n = Math.max(0, t), a = Math.min(window.innerWidth, e + s), h = Math.min(window.innerHeight, t + i), c = (r + a) / 2 - e, d = (n + h) / 2 - t, [u, f] = this.viewport.rotation % 180 === 0 ? [c, d] : [d, c];
  return {
    offsetX: u,
    offsetY: f
  };
}, ko = new WeakSet(), Qc = function() {
  E(this, xo, !0);
  for (const e of o(this, qe).values())
    e.isEmpty() && e.remove();
  E(this, xo, !1);
}, vt(os, "_initialized", !1), y(os, dr, new Map([up, Ap, Ip, rd].map((e) => [e._editorType, e])));
let Pp = os;
var Ws, rc, ee, Ei, nc, jp, ac, zp, Yu, Ny;
const ge = class ge {
  constructor({
    pageIndex: e
  }) {
    y(this, ac);
    y(this, Yu);
    y(this, Ws, null);
    y(this, rc, 0);
    y(this, ee, /* @__PURE__ */ new Map());
    y(this, Ei, /* @__PURE__ */ new Map());
    this.pageIndex = e;
  }
  setParent(e) {
    if (!o(this, Ws)) {
      E(this, Ws, e);
      return;
    }
    if (o(this, Ws) !== e) {
      if (o(this, ee).size > 0)
        for (const t of o(this, ee).values())
          t.remove(), e.append(t);
      E(this, Ws, e);
    }
  }
  static get _svgFactory() {
    return Mt(this, "_svgFactory", new ng());
  }
  draw(e, t, s, i = !1) {
    const r = Te(this, rc)._++, n = x(this, ac, zp).call(this, e.box);
    n.classList.add(...e.classNamesForDrawing);
    const a = ge._svgFactory.createElement("defs");
    n.append(a);
    const h = ge._svgFactory.createElement("path");
    a.append(h);
    const c = `path_p${this.pageIndex}_${r}`;
    h.setAttribute("id", c), h.setAttribute("d", e.toSVGPath()), i && o(this, Ei).set(r, h);
    const d = x(this, Yu, Ny).call(this, a, c), u = ge._svgFactory.createElement("use");
    return n.append(u), n.setAttribute("fill", t), n.setAttribute("fill-opacity", s), u.setAttribute("href", `#${c}`), o(this, ee).set(r, n), {
      id: r,
      clipPathId: `url(#${d})`
    };
  }
  drawOutline(e) {
    const t = Te(this, rc)._++, s = x(this, ac, zp).call(this, e.box);
    s.classList.add(...e.classNamesForOutlining);
    const i = ge._svgFactory.createElement("defs");
    s.append(i);
    const r = ge._svgFactory.createElement("path");
    i.append(r);
    const n = `path_p${this.pageIndex}_${t}`;
    r.setAttribute("id", n), r.setAttribute("d", e.toSVGPath()), r.setAttribute("vector-effect", "non-scaling-stroke");
    let a;
    if (e.mustRemoveSelfIntersections) {
      const d = ge._svgFactory.createElement("mask");
      i.append(d), a = `mask_p${this.pageIndex}_${t}`, d.setAttribute("id", a), d.setAttribute("maskUnits", "objectBoundingBox");
      const u = ge._svgFactory.createElement("rect");
      d.append(u), u.setAttribute("width", "1"), u.setAttribute("height", "1"), u.setAttribute("fill", "white");
      const f = ge._svgFactory.createElement("use");
      d.append(f), f.setAttribute("href", `#${n}`), f.setAttribute("stroke", "none"), f.setAttribute("fill", "black"), f.setAttribute("fill-rule", "nonzero"), f.classList.add("mask");
    }
    const h = ge._svgFactory.createElement("use");
    s.append(h), h.setAttribute("href", `#${n}`), a && h.setAttribute("mask", `url(#${a})`);
    const c = h.cloneNode();
    return s.append(c), h.classList.add("mainOutline"), c.classList.add("secondaryOutline"), o(this, ee).set(t, s), t;
  }
  finalizeLine(e, t) {
    const s = o(this, Ei).get(e);
    o(this, Ei).delete(e), this.updateBox(e, t.box), s.setAttribute("d", t.toSVGPath());
  }
  updateLine(e, t) {
    o(this, ee).get(e).firstChild.firstChild.setAttribute("d", t.toSVGPath());
  }
  updatePath(e, t) {
    o(this, Ei).get(e).setAttribute("d", t.toSVGPath());
  }
  updateBox(e, t) {
    var s;
    x(s = ge, nc, jp).call(s, o(this, ee).get(e), t);
  }
  show(e, t) {
    o(this, ee).get(e).classList.toggle("hidden", !t);
  }
  rotate(e, t) {
    o(this, ee).get(e).setAttribute("data-main-rotation", t);
  }
  changeColor(e, t) {
    o(this, ee).get(e).setAttribute("fill", t);
  }
  changeOpacity(e, t) {
    o(this, ee).get(e).setAttribute("fill-opacity", t);
  }
  addClass(e, t) {
    o(this, ee).get(e).classList.add(t);
  }
  removeClass(e, t) {
    o(this, ee).get(e).classList.remove(t);
  }
  getSVGRoot(e) {
    return o(this, ee).get(e);
  }
  remove(e) {
    o(this, Ei).delete(e), o(this, Ws) !== null && (o(this, ee).get(e).remove(), o(this, ee).delete(e));
  }
  destroy() {
    E(this, Ws, null);
    for (const e of o(this, ee).values())
      e.remove();
    o(this, ee).clear(), o(this, Ei).clear();
  }
};
Ws = new WeakMap(), rc = new WeakMap(), ee = new WeakMap(), Ei = new WeakMap(), nc = new WeakSet(), jp = function(e, {
  x: t = 0,
  y: s = 0,
  width: i = 1,
  height: r = 1
} = {}) {
  const {
    style: n
  } = e;
  n.top = `${100 * s}%`, n.left = `${100 * t}%`, n.width = `${100 * i}%`, n.height = `${100 * r}%`;
}, ac = new WeakSet(), zp = function(e) {
  var s;
  const t = ge._svgFactory.create(1, 1, !0);
  return o(this, Ws).append(t), t.setAttribute("aria-hidden", !0), x(s = ge, nc, jp).call(s, t, e), t;
}, Yu = new WeakSet(), Ny = function(e, t) {
  const s = ge._svgFactory.createElement("clipPath");
  e.append(s);
  const i = `clip_${t}`;
  s.setAttribute("id", i), s.setAttribute("clipPathUnits", "objectBoundingBox");
  const r = ge._svgFactory.createElement("use");
  return s.append(r), r.setAttribute("href", `#${t}`), r.classList.add("clip"), i;
}, y(ge, nc);
let Fp = ge;
var r_ = At.AbortException, n_ = At.AnnotationEditorLayer, a_ = At.AnnotationEditorParamsType, o_ = At.AnnotationEditorType, l_ = At.AnnotationEditorUIManager, Dy = At.AnnotationLayer, Py = At.AnnotationMode, h_ = At.ColorPicker, c_ = At.DOMSVGFactory, d_ = At.DrawLayer, u_ = At.FeatureTest, og = At.GlobalWorkerOptions, f_ = At.ImageKind, p_ = At.InvalidPDFException, g_ = At.MissingPDFException, m_ = At.OPS, b_ = At.OutputScale, y_ = At.PDFDataRangeTransport, v_ = At.PDFDateString, w_ = At.PDFWorker, A_ = At.PasswordResponses, __ = At.PermissionFlag, E_ = At.PixelsPerInch, x_ = At.RenderingCancelledException, Ly = At.TextLayer, S_ = At.UnexpectedResponseException, k_ = At.Util, M_ = At.VerbosityLevel, C_ = At.XfaLayer, T_ = At.build, I_ = At.createValidAbsoluteUrl, N_ = At.fetchData, Ry = At.getDocument, D_ = At.getFilenameFromUrl, P_ = At.getPdfFilenameFromUrl, L_ = At.getXfaPageViewport, R_ = At.isDataScheme, O_ = At.isPdfFile, F_ = At.noContextMenu, j_ = At.normalizeUnicode, z_ = At.setLayerDimensions, B_ = At.shadow, Oy = At.version;
const U_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortException: r_,
  AnnotationEditorLayer: n_,
  AnnotationEditorParamsType: a_,
  AnnotationEditorType: o_,
  AnnotationEditorUIManager: l_,
  AnnotationLayer: Dy,
  AnnotationMode: Py,
  ColorPicker: h_,
  DOMSVGFactory: c_,
  DrawLayer: d_,
  FeatureTest: u_,
  GlobalWorkerOptions: og,
  ImageKind: f_,
  InvalidPDFException: p_,
  MissingPDFException: g_,
  OPS: m_,
  OutputScale: b_,
  PDFDataRangeTransport: y_,
  PDFDateString: v_,
  PDFWorker: w_,
  PasswordResponses: A_,
  PermissionFlag: __,
  PixelsPerInch: E_,
  RenderingCancelledException: x_,
  TextLayer: Ly,
  UnexpectedResponseException: S_,
  Util: k_,
  VerbosityLevel: M_,
  XfaLayer: C_,
  build: T_,
  createValidAbsoluteUrl: I_,
  fetchData: N_,
  getDocument: Ry,
  getFilenameFromUrl: D_,
  getPdfFilenameFromUrl: P_,
  getXfaPageViewport: L_,
  isDataScheme: R_,
  isPdfFile: O_,
  noContextMenu: F_,
  normalizeUnicode: j_,
  setLayerDimensions: z_,
  shadow: B_,
  version: Oy
}, Symbol.toStringTag, { value: "Module" }));
var oe = globalThis && globalThis.__spreadArray || function(l, e, t) {
  if (t || arguments.length === 2)
    for (var s = 0, i = e.length, r; s < i; s++)
      (r || !(s in e)) && (r || (r = Array.prototype.slice.call(e, 0, s)), r[s] = e[s]);
  return l.concat(r || Array.prototype.slice.call(e));
}, H_ = ["onCopy", "onCut", "onPaste"], W_ = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
], $_ = ["onFocus", "onBlur"], G_ = ["onInput", "onInvalid", "onReset", "onSubmit"], V_ = ["onLoad", "onError"], Y_ = ["onKeyDown", "onKeyPress", "onKeyUp"], X_ = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
], q_ = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
], Q_ = [
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop"
], K_ = ["onSelect"], Z_ = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], J_ = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
], tE = ["onScroll"], eE = ["onWheel"], sE = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
], iE = ["onTransitionEnd"], rE = ["onToggle"], nE = ["onChange"], aE = oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe(oe([], H_, !0), W_, !0), $_, !0), G_, !0), V_, !0), Y_, !0), X_, !0), q_, !0), Q_, !0), K_, !0), Z_, !0), J_, !0), tE, !0), eE, !0), sE, !0), iE, !0), nE, !0), rE, !0);
function Fy(l, e) {
  var t = {};
  return aE.forEach(function(s) {
    var i = l[s];
    i && (e ? t[s] = function(r) {
      return i(r, e(s));
    } : t[s] = i);
  }), t;
}
function cc(l) {
  var e = !1, t = new Promise(function(s, i) {
    l.then(function(r) {
      return !e && s(r);
    }).catch(function(r) {
      return !e && i(r);
    });
  });
  return {
    promise: t,
    cancel: function() {
      e = !0;
    }
  };
}
var oE = "production".NODE_ENV === "production", wf = "Invariant failed";
function Ot(l, e) {
  if (!l) {
    if (oE)
      throw new Error(wf);
    var t = typeof e == "function" ? e() : e, s = t ? "".concat(wf, ": ").concat(t) : wf;
    throw new Error(s);
  }
}
var lE = "production".NODE_ENV !== "production", jy = function() {
};
if (lE) {
  var hE = function(e, t) {
    var s = arguments.length;
    t = new Array(s > 1 ? s - 1 : 0);
    for (var i = 1; i < s; i++)
      t[i - 1] = arguments[i];
    var r = 0, n = "Warning: " + e.replace(/%s/g, function() {
      return t[r++];
    });
    typeof console < "u" && console.error(n);
    try {
      throw new Error(n);
    } catch {
    }
  };
  jy = function(l, e, t) {
    var s = arguments.length;
    t = new Array(s > 2 ? s - 2 : 0);
    for (var i = 2; i < s; i++)
      t[i - 2] = arguments[i];
    if (e === void 0)
      throw new Error(
        "`warning(condition, format, ...args)` requires a warning message argument"
      );
    l || hE.apply(null, [e].concat(t));
  };
}
var cE = jy;
const Me = /* @__PURE__ */ Wp(cE);
var Yg = Object.prototype.hasOwnProperty;
function Xg(l, e, t) {
  for (t of l.keys())
    if (ta(t, e))
      return t;
}
function ta(l, e) {
  var t, s, i;
  if (l === e)
    return !0;
  if (l && e && (t = l.constructor) === e.constructor) {
    if (t === Date)
      return l.getTime() === e.getTime();
    if (t === RegExp)
      return l.toString() === e.toString();
    if (t === Array) {
      if ((s = l.length) === e.length)
        for (; s-- && ta(l[s], e[s]); )
          ;
      return s === -1;
    }
    if (t === Set) {
      if (l.size !== e.size)
        return !1;
      for (s of l)
        if (i = s, i && typeof i == "object" && (i = Xg(e, i), !i) || !e.has(i))
          return !1;
      return !0;
    }
    if (t === Map) {
      if (l.size !== e.size)
        return !1;
      for (s of l)
        if (i = s[0], i && typeof i == "object" && (i = Xg(e, i), !i) || !ta(s[1], e.get(i)))
          return !1;
      return !0;
    }
    if (t === ArrayBuffer)
      l = new Uint8Array(l), e = new Uint8Array(e);
    else if (t === DataView) {
      if ((s = l.byteLength) === e.byteLength)
        for (; s-- && l.getInt8(s) === e.getInt8(s); )
          ;
      return s === -1;
    }
    if (ArrayBuffer.isView(l)) {
      if ((s = l.byteLength) === e.byteLength)
        for (; s-- && l[s] === e[s]; )
          ;
      return s === -1;
    }
    if (!t || typeof l == "object") {
      s = 0;
      for (t in l)
        if (Yg.call(l, t) && ++s && !Yg.call(e, t) || !(t in e) || !ta(l[t], e[t]))
          return !1;
      return Object.keys(e).length === s;
    }
  }
  return l !== l && e !== e;
}
const dE = hm(null), zy = dE;
function ea({ children: l, type: e }) {
  return rt.jsx("div", { className: `react-pdf__message react-pdf__message--${e}`, children: l });
}
const uE = "noopener noreferrer nofollow";
class fE {
  constructor() {
    this.externalLinkEnabled = !0, this.externalLinkRel = void 0, this.externalLinkTarget = void 0, this.isInPresentationMode = !1, this.pdfDocument = void 0, this.pdfViewer = void 0;
  }
  setDocument(e) {
    this.pdfDocument = e;
  }
  setViewer(e) {
    this.pdfViewer = e;
  }
  setExternalLinkRel(e) {
    this.externalLinkRel = e;
  }
  setExternalLinkTarget(e) {
    this.externalLinkTarget = e;
  }
  setHistory() {
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    return Ot(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber || 0;
  }
  set page(e) {
    Ot(this.pdfViewer, "PDF viewer is not initialized."), this.pdfViewer.currentPageNumber = e;
  }
  get rotation() {
    return 0;
  }
  set rotation(e) {
  }
  goToDestination(e) {
    return new Promise((t) => {
      Ot(this.pdfDocument, "PDF document not loaded."), Ot(e, "Destination is not specified."), typeof e == "string" ? this.pdfDocument.getDestination(e).then(t) : Array.isArray(e) ? t(e) : e.then(t);
    }).then((t) => {
      Ot(Array.isArray(t), `"${t}" is not a valid destination array.`);
      const s = t[0];
      new Promise((i) => {
        Ot(this.pdfDocument, "PDF document not loaded."), s instanceof Object ? this.pdfDocument.getPageIndex(s).then((r) => {
          i(r);
        }).catch(() => {
          Ot(!1, `"${s}" is not a valid page reference.`);
        }) : typeof s == "number" ? i(s) : Ot(!1, `"${s}" is not a valid destination reference.`);
      }).then((i) => {
        const r = i + 1;
        Ot(this.pdfViewer, "PDF viewer is not initialized."), Ot(r >= 1 && r <= this.pagesCount, `"${r}" is not a valid page number.`), this.pdfViewer.scrollPageIntoView({
          dest: t,
          pageIndex: i,
          pageNumber: r
        });
      });
    });
  }
  navigateTo(e) {
    this.goToDestination(e);
  }
  goToPage(e) {
    const t = e - 1;
    Ot(this.pdfViewer, "PDF viewer is not initialized."), Ot(e >= 1 && e <= this.pagesCount, `"${e}" is not a valid page number.`), this.pdfViewer.scrollPageIntoView({
      pageIndex: t,
      pageNumber: e
    });
  }
  addLinkAttributes(e, t, s) {
    e.href = t, e.rel = this.externalLinkRel || uE, e.target = s ? "_blank" : this.externalLinkTarget || "";
  }
  getDestinationHash() {
    return "#";
  }
  getAnchorUrl() {
    return "#";
  }
  setHash() {
  }
  executeNamedAction() {
  }
  cachePageRef() {
  }
  isPageVisible() {
    return !0;
  }
  isPageCached() {
    return !0;
  }
  executeSetOCGState() {
  }
}
const pE = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
}, qg = pE, af = typeof window < "u", By = af && window.location.protocol === "file:";
function gE(l) {
  return typeof l < "u";
}
function yr(l) {
  return gE(l) && l !== null;
}
function mE(l) {
  return typeof l == "string";
}
function bE(l) {
  return l instanceof ArrayBuffer;
}
function yE(l) {
  return Ot(af, "isBlob can only be used in a browser environment"), l instanceof Blob;
}
function Bp(l) {
  return mE(l) && /^data:/.test(l);
}
function Qg(l) {
  Ot(Bp(l), "Invalid data URI.");
  const [e = "", t = ""] = l.split(",");
  return e.split(";").indexOf("base64") !== -1 ? atob(t) : unescape(t);
}
function vE() {
  return af && window.devicePixelRatio || 1;
}
const Uy = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function Kg() {
  Me(!By, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${Uy}`);
}
function wE() {
  Me(!By, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${Uy}`);
}
function jn(l) {
  l != null && l.cancel && l.cancel();
}
function Up(l, e) {
  return Object.defineProperty(l, "width", {
    get() {
      return this.view[2] * e;
    },
    configurable: !0
  }), Object.defineProperty(l, "height", {
    get() {
      return this.view[3] * e;
    },
    configurable: !0
  }), Object.defineProperty(l, "originalWidth", {
    get() {
      return this.view[2];
    },
    configurable: !0
  }), Object.defineProperty(l, "originalHeight", {
    get() {
      return this.view[3];
    },
    configurable: !0
  }), l;
}
function AE(l) {
  return l.name === "RenderingCancelledException";
}
function _E(l) {
  return new Promise((e, t) => {
    const s = new FileReader();
    s.onload = () => {
      if (!s.result)
        return t(new Error("Error while reading a file."));
      e(s.result);
    }, s.onerror = (i) => {
      if (!i.target)
        return t(new Error("Error while reading a file."));
      const { error: r } = i.target;
      if (!r)
        return t(new Error("Error while reading a file."));
      switch (r.code) {
        case r.NOT_FOUND_ERR:
          return t(new Error("Error while reading a file: File not found."));
        case r.SECURITY_ERR:
          return t(new Error("Error while reading a file: Security error."));
        case r.ABORT_ERR:
          return t(new Error("Error while reading a file: Aborted."));
        default:
          return t(new Error("Error while reading a file."));
      }
    }, s.readAsArrayBuffer(l);
  });
}
function EE(l, e) {
  switch (e.type) {
    case "RESOLVE":
      return { value: e.value, error: void 0 };
    case "REJECT":
      return { value: !1, error: e.error };
    case "RESET":
      return { value: void 0, error: void 0 };
    default:
      return l;
  }
}
function Mo() {
  return i0(EE, { value: void 0, error: void 0 });
}
var xE = globalThis && globalThis.__awaiter || function(l, e, t, s) {
  function i(r) {
    return r instanceof t ? r : new t(function(n) {
      n(r);
    });
  }
  return new (t || (t = Promise))(function(r, n) {
    function a(d) {
      try {
        c(s.next(d));
      } catch (u) {
        n(u);
      }
    }
    function h(d) {
      try {
        c(s.throw(d));
      } catch (u) {
        n(u);
      }
    }
    function c(d) {
      d.done ? r(d.value) : i(d.value).then(a, h);
    }
    c((s = s.apply(l, e || [])).next());
  });
}, Zg = globalThis && globalThis.__rest || function(l, e) {
  var t = {};
  for (var s in l)
    Object.prototype.hasOwnProperty.call(l, s) && e.indexOf(s) < 0 && (t[s] = l[s]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, s = Object.getOwnPropertySymbols(l); i < s.length; i++)
      e.indexOf(s[i]) < 0 && Object.prototype.propertyIsEnumerable.call(l, s[i]) && (t[s[i]] = l[s[i]]);
  return t;
};
const { PDFDataRangeTransport: SE } = U_, kE = (l, e) => {
  switch (e) {
    case qg.NEED_PASSWORD: {
      const t = prompt("Enter the password to open this PDF file.");
      l(t);
      break;
    }
    case qg.INCORRECT_PASSWORD: {
      const t = prompt("Invalid password. Please try again.");
      l(t);
      break;
    }
  }
};
function Jg(l) {
  return typeof l == "object" && l !== null && ("data" in l || "range" in l || "url" in l);
}
const ME = lm(function(e, t) {
  var { children: s, className: i, error: r = "Failed to load PDF file.", externalLinkRel: n, externalLinkTarget: a, file: h, inputRef: c, imageResourcesPath: d, loading: u = "Loading PDF", noData: f = "No PDF file specified.", onItemClick: p, onLoadError: m, onLoadProgress: g, onLoadSuccess: w, onPassword: b = kE, onSourceError: _, onSourceSuccess: k, options: C, renderMode: N, rotate: R } = e, P = Zg(e, ["children", "className", "error", "externalLinkRel", "externalLinkTarget", "file", "inputRef", "imageResourcesPath", "loading", "noData", "onItemClick", "onLoadError", "onLoadProgress", "onLoadSuccess", "onPassword", "onSourceError", "onSourceSuccess", "options", "renderMode", "rotate"]);
  const [M, S] = Mo(), { value: L, error: H } = M, [I, F] = Mo(), { value: A, error: G } = I, et = _s(new fE()), z = _s([]), K = _s(void 0), Y = _s(void 0);
  h && h !== K.current && Jg(h) && (Me(!ta(h, K.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.`), K.current = h), C && C !== Y.current && (Me(!ta(C, Y.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.`), Y.current = C);
  const ot = _s({
    // Handling jumping to internal links target
    scrollPageIntoView: (gt) => {
      const { dest: v, pageNumber: V, pageIndex: U = V - 1 } = gt;
      if (p) {
        p({ dest: v, pageIndex: U, pageNumber: V });
        return;
      }
      const D = z.current[U];
      if (D) {
        D.scrollIntoView();
        return;
      }
      Me(!1, `An internal link leading to page ${V} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);
    }
  });
  r0(t, () => ({
    linkService: et,
    pages: z,
    viewer: ot
  }), []);
  function B() {
    k && k();
  }
  function O() {
    H && (Me(!1, H.toString()), _ && _(H));
  }
  function q() {
    S({ type: "RESET" });
  }
  Pt(q, [h, S]);
  const tt = Si(() => xE(this, void 0, void 0, function* () {
    if (!h)
      return null;
    if (typeof h == "string")
      return Bp(h) ? { data: Qg(h) } : (Kg(), { url: h });
    if (h instanceof SE)
      return { range: h };
    if (bE(h))
      return { data: h };
    if (af && yE(h))
      return { data: yield _E(h) };
    if (Ot(typeof h == "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object"), Ot(Jg(h), "Invalid parameter object: need either .data, .range or .url"), "url" in h && typeof h.url == "string") {
      if (Bp(h.url)) {
        const { url: gt } = h, v = Zg(h, ["url"]), V = Qg(gt);
        return Object.assign({ data: V }, v);
      }
      Kg();
    }
    return h;
  }), [h]);
  Pt(() => {
    const gt = cc(tt());
    return gt.promise.then((v) => {
      S({ type: "RESOLVE", value: v });
    }).catch((v) => {
      S({ type: "REJECT", error: v });
    }), () => {
      jn(gt);
    };
  }, [tt, S]), Pt(() => {
    if (!(typeof L > "u")) {
      if (L === !1) {
        O();
        return;
      }
      B();
    }
  }, [L]);
  function J() {
    A && (w && w(A), z.current = new Array(A.numPages), et.current.setDocument(A));
  }
  function ut() {
    G && (Me(!1, G.toString()), m && m(G));
  }
  Pt(function() {
    F({ type: "RESET" });
  }, [F, L]), Pt(function() {
    if (!L)
      return;
    const v = C ? Object.assign(Object.assign({}, L), C) : L, V = Ry(v);
    g && (V.onProgress = g), b && (V.onPassword = b);
    const U = V, D = U.promise.then((T) => {
      F({ type: "RESOLVE", value: T });
    }).catch((T) => {
      U.destroyed || F({ type: "REJECT", error: T });
    });
    return () => {
      D.finally(() => U.destroy());
    };
  }, [C, F, L]), Pt(() => {
    if (!(typeof A > "u")) {
      if (A === !1) {
        ut();
        return;
      }
      J();
    }
  }, [A]), Pt(function() {
    et.current.setViewer(ot.current), et.current.setExternalLinkRel(n), et.current.setExternalLinkTarget(a);
  }, [n, a]);
  const ft = Si((gt, v) => {
    z.current[gt] = v;
  }, []), at = Si((gt) => {
    delete z.current[gt];
  }, []), lt = ns(() => ({
    imageResourcesPath: d,
    linkService: et.current,
    onItemClick: p,
    pdf: A,
    registerPage: ft,
    renderMode: N,
    rotate: R,
    unregisterPage: at
  }), [d, p, A, ft, N, R, at]), dt = ns(
    () => Fy(P, () => A),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [P, A]
  );
  function ct() {
    return rt.jsx(zy.Provider, { value: lt, children: s });
  }
  function Et() {
    return h ? A == null ? rt.jsx(ea, { type: "loading", children: typeof u == "function" ? u() : u }) : A === !1 ? rt.jsx(ea, { type: "error", children: typeof r == "function" ? r() : r }) : ct() : rt.jsx(ea, { type: "no-data", children: typeof f == "function" ? f() : f });
  }
  return rt.jsx("div", Object.assign({
    className: Xu("react-pdf__Document", i),
    // Assertion is needed for React 18 compatibility
    ref: c,
    style: {
      "--scale-factor": "1"
    }
  }, dt, { children: Et() }));
}), CE = ME;
function Hy() {
  return cm(zy);
}
function Wy() {
  for (var l = [], e = 0; e < arguments.length; e++)
    l[e] = arguments[e];
  var t = l.filter(Boolean);
  if (t.length <= 1) {
    var s = t[0];
    return s || null;
  }
  return function(r) {
    t.forEach(function(n) {
      typeof n == "function" ? n(r) : n && (n.current = r);
    });
  };
}
const TE = hm(null), $y = TE, Gy = {
  // Document level structure types
  Document: null,
  // There's a "document" role, but it doesn't make sense here.
  DocumentFragment: null,
  // Grouping level structure types
  Part: "group",
  Sect: "group",
  // XXX: There's a "section" role, but it's abstract.
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  // Block level structure types
  P: null,
  // H<n>,
  H: "heading",
  Title: null,
  FENote: "note",
  // Sub-block level structure type
  Sub: "group",
  // General inline level structure types
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  // Ruby and Warichu structure types
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  // List standard structure types
  L: "list",
  LI: "listitem",
  LBody: null,
  // Table standard structure types
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  // Standard structure type Caption
  Caption: null,
  // Standard structure type Figure
  Figure: "figure",
  // Standard structure type Formula
  Formula: null,
  // standard structure type Artifact
  Artifact: null
}, IE = /^H(\d+)$/;
function NE(l) {
  return l in Gy;
}
function of(l) {
  return "children" in l;
}
function Vy(l) {
  return of(l) ? l.children.length === 1 && 0 in l.children && "id" in l.children[0] : !1;
}
function DE(l) {
  const e = {};
  if (of(l)) {
    const { role: t } = l, s = t.match(IE);
    if (s)
      e.role = "heading", e["aria-level"] = Number(s[1]);
    else if (NE(t)) {
      const i = Gy[t];
      i && (e.role = i);
    }
  }
  return e;
}
function Yy(l) {
  const e = {};
  if (of(l)) {
    if (l.alt !== void 0 && (e["aria-label"] = l.alt), l.lang !== void 0 && (e.lang = l.lang), Vy(l)) {
      const [t] = l.children;
      if (t) {
        const s = Yy(t);
        return Object.assign(Object.assign({}, e), s);
      }
    }
  } else
    "id" in l && (e["aria-owns"] = l.id);
  return e;
}
function PE(l) {
  return l ? Object.assign(Object.assign({}, DE(l)), Yy(l)) : null;
}
function Xy({ className: l, node: e }) {
  const t = ns(() => PE(e), [e]), s = ns(() => !of(e) || Vy(e) ? null : e.children.map((i, r) => (
    // biome-ignore lint/suspicious/noArrayIndexKey: index is stable here
    rt.jsx(Xy, { node: i }, r)
  )), [e]);
  return rt.jsx("span", Object.assign({ className: l }, t, { children: s }));
}
function lf() {
  return cm($y);
}
function LE() {
  const l = lf();
  Ot(l, "Unable to find Page context.");
  const { onGetStructTreeError: e, onGetStructTreeSuccess: t } = l, [s, i] = Mo(), { value: r, error: n } = s, { customTextRenderer: a, page: h } = l;
  function c() {
    r && t && t(r);
  }
  function d() {
    n && (Me(!1, n.toString()), e && e(n));
  }
  return Pt(function() {
    i({ type: "RESET" });
  }, [i, h]), Pt(function() {
    if (a || !h)
      return;
    const f = cc(h.getStructTree()), p = f;
    return f.promise.then((m) => {
      i({ type: "RESOLVE", value: m });
    }).catch((m) => {
      i({ type: "REJECT", error: m });
    }), () => jn(p);
  }, [a, h, i]), Pt(() => {
    if (r !== void 0) {
      if (r === !1) {
        d();
        return;
      }
      c();
    }
  }, [r]), r ? rt.jsx(Xy, { className: "react-pdf__Page__structTree structTree", node: r }) : null;
}
const tm = Py;
function RE(l) {
  const e = lf();
  Ot(e, "Unable to find Page context.");
  const t = Object.assign(Object.assign({}, e), l), { _className: s, canvasBackground: i, devicePixelRatio: r = vE(), onRenderError: n, onRenderSuccess: a, page: h, renderForms: c, renderTextLayer: d, rotate: u, scale: f } = t, { canvasRef: p } = l;
  Ot(h, "Attempted to render page canvas, but no page was specified.");
  const m = _s(null);
  function g() {
    h && a && a(Up(h, f));
  }
  function w(C) {
    AE(C) || (Me(!1, C.toString()), n && n(C));
  }
  const b = ns(() => h.getViewport({ scale: f * r, rotation: u }), [r, h, u, f]), _ = ns(() => h.getViewport({ scale: f, rotation: u }), [h, u, f]);
  Pt(function() {
    if (!h)
      return;
    h.cleanup();
    const { current: N } = m;
    if (!N)
      return;
    N.width = b.width, N.height = b.height, N.style.width = `${Math.floor(_.width)}px`, N.style.height = `${Math.floor(_.height)}px`, N.style.visibility = "hidden";
    const R = {
      annotationMode: c ? tm.ENABLE_FORMS : tm.ENABLE,
      canvasContext: N.getContext("2d", { alpha: !1 }),
      viewport: b
    };
    i && (R.background = i);
    const P = h.render(R), M = P;
    return P.promise.then(() => {
      N.style.visibility = "", g();
    }).catch(w), () => jn(M);
  }, [i, h, c, b, _]);
  const k = Si(() => {
    const { current: C } = m;
    C && (C.width = 0, C.height = 0);
  }, []);
  return Pt(() => k, [k]), rt.jsx("canvas", { className: `${s}__canvas`, dir: "ltr", ref: Wy(p, m), style: {
    display: "block",
    userSelect: "none"
  }, children: d ? rt.jsx(LE, {}) : null });
}
function OE(l) {
  return "str" in l;
}
function FE() {
  const l = lf();
  Ot(l, "Unable to find Page context.");
  const { customTextRenderer: e, onGetTextError: t, onGetTextSuccess: s, onRenderTextLayerError: i, onRenderTextLayerSuccess: r, page: n, pageIndex: a, pageNumber: h, rotate: c, scale: d } = l;
  Ot(n, "Attempted to load page text content, but no page was specified.");
  const [u, f] = Mo(), { value: p, error: m } = u, g = _s(null);
  Me(Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer");
  function w() {
    p && s && s(p);
  }
  function b() {
    m && (Me(!1, m.toString()), t && t(m));
  }
  Pt(function() {
    f({ type: "RESET" });
  }, [n, f]), Pt(function() {
    if (!n)
      return;
    const M = cc(n.getTextContent()), S = M;
    return M.promise.then((L) => {
      f({ type: "RESOLVE", value: L });
    }).catch((L) => {
      f({ type: "REJECT", error: L });
    }), () => jn(S);
  }, [n, f]), Pt(() => {
    if (p !== void 0) {
      if (p === !1) {
        b();
        return;
      }
      w();
    }
  }, [p]);
  const _ = Si(() => {
    r && r();
  }, [r]), k = Si((P) => {
    Me(!1, P.toString()), i && i(P);
  }, [i]);
  function C() {
    const P = g.current;
    P && P.classList.add("selecting");
  }
  function N() {
    const P = g.current;
    P && P.classList.remove("selecting");
  }
  const R = ns(() => n.getViewport({ scale: d, rotation: c }), [n, c, d]);
  return n0(function() {
    if (!n || !p)
      return;
    const { current: M } = g;
    if (!M)
      return;
    M.innerHTML = "";
    const S = n.streamTextContent({ includeMarkedContent: !0 }), L = {
      container: M,
      textContentSource: S,
      viewport: R
    }, H = new Ly(L), I = H;
    return H.render().then(() => {
      const F = document.createElement("div");
      F.className = "endOfContent", M.append(F);
      const A = M.querySelectorAll('[role="presentation"]');
      if (e) {
        let G = 0;
        p.items.forEach((et, z) => {
          if (!OE(et))
            return;
          const K = A[G];
          if (!K)
            return;
          const Y = e(Object.assign({
            pageIndex: a,
            pageNumber: h,
            itemIndex: z
          }, et));
          K.innerHTML = Y, G += et.str && et.hasEOL ? 2 : 1;
        });
      }
      _();
    }).catch(k), () => jn(I);
  }, [
    e,
    k,
    _,
    n,
    a,
    h,
    p,
    R
  ]), rt.jsx("div", { className: Xu("react-pdf__Page__textContent", "textLayer"), onMouseUp: N, onMouseDown: C, ref: g });
}
function jE() {
  const l = Hy(), e = lf();
  Ot(e, "Unable to find Page context.");
  const t = Object.assign(Object.assign({}, l), e), { imageResourcesPath: s, linkService: i, onGetAnnotationsError: r, onGetAnnotationsSuccess: n, onRenderAnnotationLayerError: a, onRenderAnnotationLayerSuccess: h, page: c, pdf: d, renderForms: u, rotate: f, scale: p = 1 } = t;
  Ot(d, "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop."), Ot(c, "Attempted to load page annotations, but no page was specified."), Ot(i, "Attempted to load page annotations, but no linkService was specified.");
  const [m, g] = Mo(), { value: w, error: b } = m, _ = _s(null);
  Me(Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations");
  function k() {
    w && n && n(w);
  }
  function C() {
    b && (Me(!1, b.toString()), r && r(b));
  }
  Pt(function() {
    g({ type: "RESET" });
  }, [g, c]), Pt(function() {
    if (!c)
      return;
    const S = cc(c.getAnnotations()), L = S;
    return S.promise.then((H) => {
      g({ type: "RESOLVE", value: H });
    }).catch((H) => {
      g({ type: "REJECT", error: H });
    }), () => {
      jn(L);
    };
  }, [g, c]), Pt(() => {
    if (w !== void 0) {
      if (w === !1) {
        C();
        return;
      }
      k();
    }
  }, [w]);
  function N() {
    h && h();
  }
  function R(M) {
    Me(!1, `${M}`), a && a(M);
  }
  const P = ns(() => c.getViewport({ scale: p, rotation: f }), [c, f, p]);
  return Pt(function() {
    if (!d || !c || !i || !w)
      return;
    const { current: S } = _;
    if (!S)
      return;
    const L = P.clone({ dontFlip: !0 }), H = {
      accessibilityManager: null,
      // TODO: Implement this
      annotationCanvasMap: null,
      // TODO: Implement this
      annotationEditorUIManager: null,
      // TODO: Implement this
      div: S,
      l10n: null,
      // TODO: Implement this
      page: c,
      structTreeLayer: null,
      // TODO: Implement this
      viewport: L
    }, I = {
      annotations: w,
      annotationStorage: d.annotationStorage,
      div: S,
      imageResourcesPath: s,
      linkService: i,
      page: c,
      renderForms: u,
      viewport: L
    };
    S.innerHTML = "";
    try {
      new Dy(H).render(I), N();
    } catch (F) {
      R(F);
    }
    return () => {
    };
  }, [w, s, i, c, d, u, P]), rt.jsx("div", { className: Xu("react-pdf__Page__annotations", "annotationLayer"), ref: _ });
}
var zE = globalThis && globalThis.__rest || function(l, e) {
  var t = {};
  for (var s in l)
    Object.prototype.hasOwnProperty.call(l, s) && e.indexOf(s) < 0 && (t[s] = l[s]);
  if (l != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, s = Object.getOwnPropertySymbols(l); i < s.length; i++)
      e.indexOf(s[i]) < 0 && Object.prototype.propertyIsEnumerable.call(l, s[i]) && (t[s[i]] = l[s[i]]);
  return t;
};
const em = 1;
function BE(l) {
  const e = Hy(), t = Object.assign(Object.assign({}, e), l), { _className: s = "react-pdf__Page", _enableRegisterUnregisterPage: i = !0, canvasBackground: r, canvasRef: n, children: a, className: h, customRenderer: c, customTextRenderer: d, devicePixelRatio: u, error: f = "Failed to load the page.", height: p, inputRef: m, loading: g = "Loading page", noData: w = "No page specified.", onGetAnnotationsError: b, onGetAnnotationsSuccess: _, onGetStructTreeError: k, onGetStructTreeSuccess: C, onGetTextError: N, onGetTextSuccess: R, onLoadError: P, onLoadSuccess: M, onRenderAnnotationLayerError: S, onRenderAnnotationLayerSuccess: L, onRenderError: H, onRenderSuccess: I, onRenderTextLayerError: F, onRenderTextLayerSuccess: A, pageIndex: G, pageNumber: et, pdf: z, registerPage: K, renderAnnotationLayer: Y = !0, renderForms: ot = !1, renderMode: B = "canvas", renderTextLayer: O = !0, rotate: q, scale: tt = em, unregisterPage: J, width: ut } = t, ft = zE(t, ["_className", "_enableRegisterUnregisterPage", "canvasBackground", "canvasRef", "children", "className", "customRenderer", "customTextRenderer", "devicePixelRatio", "error", "height", "inputRef", "loading", "noData", "onGetAnnotationsError", "onGetAnnotationsSuccess", "onGetStructTreeError", "onGetStructTreeSuccess", "onGetTextError", "onGetTextSuccess", "onLoadError", "onLoadSuccess", "onRenderAnnotationLayerError", "onRenderAnnotationLayerSuccess", "onRenderError", "onRenderSuccess", "onRenderTextLayerError", "onRenderTextLayerSuccess", "pageIndex", "pageNumber", "pdf", "registerPage", "renderAnnotationLayer", "renderForms", "renderMode", "renderTextLayer", "rotate", "scale", "unregisterPage", "width"]), [at, lt] = Mo(), { value: dt, error: ct } = at, Et = _s(null);
  Ot(z, "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
  const gt = yr(et) ? et - 1 : G ?? null, v = et ?? (yr(G) ? G + 1 : null), V = q ?? (dt ? dt.rotate : null), U = ns(() => {
    if (!dt)
      return null;
    let yt = 1;
    const bt = tt ?? em;
    if (ut || p) {
      const Xt = dt.getViewport({ scale: 1, rotation: V });
      ut ? yt = ut / Xt.width : p && (yt = p / Xt.height);
    }
    return bt * yt;
  }, [p, dt, V, tt, ut]);
  Pt(function() {
    return () => {
      yr(gt) && i && J && J(gt);
    };
  }, [i, z, gt, J]);
  function D() {
    if (M) {
      if (!dt || !U)
        return;
      M(Up(dt, U));
    }
    if (i && K) {
      if (!yr(gt) || !Et.current)
        return;
      K(gt, Et.current);
    }
  }
  function T() {
    ct && (Me(!1, ct.toString()), P && P(ct));
  }
  Pt(function() {
    lt({ type: "RESET" });
  }, [lt, z, gt]), Pt(function() {
    if (!z || !v)
      return;
    const bt = cc(z.getPage(v)), Xt = bt;
    return bt.promise.then((Ze) => {
      lt({ type: "RESOLVE", value: Ze });
    }).catch((Ze) => {
      lt({ type: "REJECT", error: Ze });
    }), () => jn(Xt);
  }, [lt, z, v]), Pt(() => {
    if (dt !== void 0) {
      if (dt === !1) {
        T();
        return;
      }
      D();
    }
  }, [dt, U]);
  const j = ns(() => (
    // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that
    dt && yr(gt) && v && yr(V) && yr(U) ? {
      _className: s,
      canvasBackground: r,
      customTextRenderer: d,
      devicePixelRatio: u,
      onGetAnnotationsError: b,
      onGetAnnotationsSuccess: _,
      onGetStructTreeError: k,
      onGetStructTreeSuccess: C,
      onGetTextError: N,
      onGetTextSuccess: R,
      onRenderAnnotationLayerError: S,
      onRenderAnnotationLayerSuccess: L,
      onRenderError: H,
      onRenderSuccess: I,
      onRenderTextLayerError: F,
      onRenderTextLayerSuccess: A,
      page: dt,
      pageIndex: gt,
      pageNumber: v,
      renderForms: ot,
      renderTextLayer: O,
      rotate: V,
      scale: U
    } : null
  ), [
    s,
    r,
    d,
    u,
    b,
    _,
    k,
    C,
    N,
    R,
    S,
    L,
    H,
    I,
    F,
    A,
    dt,
    gt,
    v,
    ot,
    O,
    V,
    U
  ]), Q = ns(
    () => Fy(ft, () => dt && (U ? Up(dt, U) : void 0)),
    // biome-ignore lint/correctness/useExhaustiveDependencies: FIXME
    [ft, dt, U]
  ), Z = `${gt}@${U}/${V}`;
  function $() {
    switch (B) {
      case "custom":
        return Ot(c, 'renderMode was set to "custom", but no customRenderer was passed.'), rt.jsx(c, {}, `${Z}_custom`);
      case "none":
        return null;
      case "canvas":
      default:
        return rt.jsx(RE, { canvasRef: n }, `${Z}_canvas`);
    }
  }
  function it() {
    return O ? rt.jsx(FE, {}, `${Z}_text`) : null;
  }
  function nt() {
    return Y ? rt.jsx(jE, {}, `${Z}_annotations`) : null;
  }
  function st() {
    return rt.jsxs($y.Provider, { value: j, children: [$(), it(), nt(), a] });
  }
  function ht() {
    return v ? z === null || dt === void 0 || dt === null ? rt.jsx(ea, { type: "loading", children: typeof g == "function" ? g() : g }) : z === !1 || dt === !1 ? rt.jsx(ea, { type: "error", children: typeof f == "function" ? f() : f }) : st() : rt.jsx(ea, { type: "no-data", children: typeof w == "function" ? w() : w });
  }
  return rt.jsx("div", Object.assign({
    className: Xu(s, h),
    "data-page-number": v,
    // Assertion is needed for React 18 compatibility
    ref: Wy(m, Et),
    style: {
      "--scale-factor": `${U}`,
      backgroundColor: r || "white",
      position: "relative",
      minWidth: "min-content",
      minHeight: "min-content"
    }
  }, Q, { children: ht() }));
}
wE();
og.workerSrc = "pdf.worker.mjs";
og.workerSrc = `//unpkg.com/pdfjs-dist@${Oy}/build/pdf.worker.min.mjs`;
const UE = ({ blob: l, scale: e, rotate: t }) => {
  const [s, i] = Mi(0), [r, n] = Mi(!1);
  return /* @__PURE__ */ rt.jsx(
    S0,
    {
      loaded: r,
      className: Kc({ "multi-page": s > 1 }),
      children: /* @__PURE__ */ rt.jsx(
        CE,
        {
          file: l,
          onLoadSuccess: ({ numPages: a }) => {
            i(a), n(!0);
          },
          loading: /* @__PURE__ */ rt.jsx($p, { size: 128 }),
          children: Array.from(new Array(s), (a, h) => /* @__PURE__ */ rt.jsx(
            k0,
            {
              className: Kc({ "multi-page": s > 1 }),
              children: /* @__PURE__ */ rt.jsx(
                BE,
                {
                  pageNumber: h + 1,
                  scale: e,
                  rotate: t
                }
              )
            },
            h
          ))
        }
      )
    }
  );
}, HE = ({ blob: l, rotate: e, scale: t, fileName: s }) => {
  const i = ns(() => URL.createObjectURL(l), [l]);
  return /* @__PURE__ */ rt.jsx(M0, { children: /* @__PURE__ */ rt.jsx(
    g0,
    {
      src: i,
      fileName: s,
      width: "auto",
      height: "auto",
      maxWidth: "calc(100vw - 136px)",
      maxHeight: "calc(100vh - 136px)",
      style: { transform: `rotate(${e}deg) scale(${t})` }
    }
  ) });
}, WE = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE0OTAyIDBIMTQuMTc2MUwyMC45NzUyIDcuMDkzNDRWMjAuODc0NEMyMC45NzUyIDIyLjU5OTYgMTkuNTc0OCAyNCAxNy44NDk2IDI0SDYuMTQ5MDJDNC40MjM4NiAyNCAzLjAyMzQ0IDIyLjU5OTYgMy4wMjM0NCAyMC44NzQ0VjMuMTI1NThDMy4wMjM0NCAxLjQwMDQyIDQuNDIzODYgMCA2LjE0OTAyIDBaIiBmaWxsPSIjNjdEMjg2Ii8+CjxwYXRoIG9wYWNpdHk9IjAuMzAyIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjE2NDEgMFY3LjAzMjU1SDIwLjk3MzRMMTQuMTY0MSAwWiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS4wNDgzIDExLjk5NTFIOC45NDkzNEM4LjQ5MjY5IDExLjk5NTEgOC4xMTcxOSAxMi4zNzA2IDguMTE3MTkgMTIuODI3M1YxNi43MDM4QzguMTE3MTkgMTcuMTYwNCA4LjQ5MjY2IDE3LjUzNTkgOC45NDkzNCAxNy41MzU5SDE1LjA0ODNDMTUuNTA0OSAxNy41MzU5IDE1Ljg3MDMgMTcuMTYwNSAxNS44NzAzIDE2LjcwMzhWMTIuODI3MkMxNS44NzAzIDEyLjM3MDYgMTUuNTA0OSAxMS45OTUxIDE1LjA0ODMgMTEuOTk1MVpNMTAuNjEzNiAxMy4wNDA0QzExLjExMDkgMTMuMDQwNCAxMS41MDY2IDEzLjQ0NjMgMTEuNTA2NiAxMy45MzM0QzExLjUwNjYgMTQuNDMwNiAxMS4xMTA5IDE0LjgzNjUgMTAuNjEzNiAxNC44MzY1QzEwLjExNjQgMTQuODM2NSA5LjcxMDQ0IDE0LjQzMDYgOS43MTA0NCAxMy45MzM0QzkuNzEwNDQgMTMuNDQ2MyAxMC4xMTY0IDEzLjA0MDQgMTAuNjEzNiAxMy4wNDA0Wk0xNS4zMjIzIDE2LjcwMzhDMTUuMzIyMyAxNi44NTYgMTUuMjAwNSAxNi45ODc5IDE1LjA0ODMgMTYuOTg3OUg4Ljk0OTM0QzguNzk3MTEgMTYuOTg3OSA4LjY3NTMzIDE2Ljg1NiA4LjY3NTMzIDE2LjcwMzhWMTYuNTQxNEw5Ljc4MTQ2IDE1LjQzNTNMMTAuNjk0OCAxNi4zNDg2QzEwLjgwNjQgMTYuNDYwMyAxMC45Nzg5IDE2LjQ2MDMgMTEuMDkwNSAxNi4zNDg2TDEzLjM4NCAxNC4wNTUyTDE1LjMyMjMgMTUuOTkzNFYxNi43MDM4WiIgZmlsbD0id2hpdGUiLz4KPC9zdmc+Cg==", $E = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE1MTc3IDBIMTQuMTc1OEwyMC45NzY0IDcuMDg4NDZWMjAuODc1NkMyMC45NzY0IDIyLjYwMjcgMTkuNTc5MSAyNCAxNy44NTc5IDI0SDYuMTUxNzdDNC40MjQ2NCAyNCAzLjAyNzM0IDIyLjYwMjcgMy4wMjczNCAyMC44NzU2VjMuMTI0NDNDMy4wMjczMSAxLjM5NzMgNC40MjQ2MSAwIDYuMTUxNzcgMFoiIGZpbGw9IiNFMTZENkQiLz4KPHBhdGggb3BhY2l0eT0iMC4zMDIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMTcxOSAwVjcuMDM0NDlIMjAuOTc4NUwxNC4xNzE5IDBaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNi41IDE3LjkwNzJWMTMuNTIzNEg4LjM2NTA3QzguODI2ODUgMTMuNTIzNCA5LjE5MjY3IDEzLjY0OTQgOS40Njg1MyAxMy45MDcyQzkuNzQ0MzkgMTQuMTU5MSA5Ljg4MjMzIDE0LjUwMSA5Ljg4MjMzIDE0LjkyNjdDOS44ODIzMyAxNS4zNTI1IDkuNzQ0MzkgMTUuNjk0NCA5LjQ2ODUzIDE1Ljk0NjJDOS4xOTI2NyAxNi4yMDQxIDguODI2ODUgMTYuMzMgOC4zNjUwNyAxNi4zM0g3LjYyMTQ0VjE3LjkwNzJINi41Wk03LjYyMTQ0IDE1LjM3NjVIOC4yMzkxNEM4LjQwNzA0IDE1LjM3NjUgOC41Mzg5OCAxNS4zNDA1IDguNjI4OTUgMTUuMjU2NkM4LjcxODg5IDE1LjE3ODYgOC43NjY5IDE1LjA3MDcgOC43NjY5IDE0LjkyNjhDOC43NjY5IDE0Ljc4MjkgOC43MTg5MiAxNC42NzQ5IDguNjI4OTUgMTQuNTk2OUM4LjUzOTAxIDE0LjUxMyA4LjQwNzA3IDE0LjQ3NyA4LjIzOTE0IDE0LjQ3N0g3LjYyMTQ0VjE1LjM3NjVaTTEwLjM0NDEgMTcuOTA3MlYxMy41MjM0SDExLjg5NzNDMTIuMjAzMSAxMy41MjM0IDEyLjQ5MSAxMy41NjU0IDEyLjc2MDkgMTMuNjU1NEMxMy4wMzA3IDEzLjc0NTMgMTMuMjc2NiAxMy44NzEzIDEzLjQ5MjUgMTQuMDQ1MkMxMy43MDg0IDE0LjIxMzEgMTMuODgyMyAxNC40NDEgMTQuMDA4MiAxNC43Mjg4QzE0LjEyODIgMTUuMDE2NyAxNC4xOTQyIDE1LjM0NjUgMTQuMTk0MiAxNS43MTgzQzE0LjE5NDIgMTYuMDg0MiAxNC4xMjgyIDE2LjQxNCAxNC4wMDgyIDE2LjcwMThDMTMuODgyMyAxNi45ODk3IDEzLjcwODQgMTcuMjE3NiAxMy40OTI1IDE3LjM4NTVDMTMuMjc2NiAxNy41NTk0IDEzLjAzMDcgMTcuNjg1MyAxMi43NjA5IDE3Ljc3NTNDMTIuNDkxIDE3Ljg2NTIgMTIuMjAzMSAxNy45MDcyIDExLjg5NzMgMTcuOTA3MkgxMC4zNDQxWk0xMS40NDE1IDE2Ljk1MzdIMTEuNzY1NEMxMS45MzkzIDE2Ljk1MzcgMTIuMTAxMiAxNi45MzU4IDEyLjI1MTEgMTYuODkzOEMxMi4zOTUgMTYuODUxOCAxMi41MzMgMTYuNzg1OCAxMi42NjQ5IDE2LjY5NTlDMTIuNzkwOSAxNi42MDU5IDEyLjg5MjggMTYuNDggMTIuOTY0OCAxNi4zMTIxQzEzLjAzNjcgMTYuMTQ0MiAxMy4wNzI3IDE1Ljk0NjIgMTMuMDcyNyAxNS43MTgzQzEzLjA3MjcgMTUuNDg0NSAxMy4wMzY3IDE1LjI4NjYgMTIuOTY0OCAxNS4xMTg3QzEyLjg5MjggMTQuOTUwOCAxMi43OTA5IDE0LjgyNDggMTIuNjY0OSAxNC43MzQ4QzEyLjUzMyAxNC42NDQ5IDEyLjM5NTEgMTQuNTc4OSAxMi4yNTExIDE0LjUzN0MxMi4xMDEyIDE0LjQ5NSAxMS45MzkzIDE0LjQ3NyAxMS43NjU0IDE0LjQ3N0gxMS40NDE1VjE2Ljk1MzdaTTE0Ljc1NzkgMTcuOTA3MlYxMy41MjM0SDE3Ljg3NjNWMTQuNDc3SDE1Ljg3OTNWMTUuMTc4NkgxNy40NzQ1VjE2LjEyNjFIMTUuODc5M1YxNy45MDcySDE0Ljc1NzlaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K", sm = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTYuMTIyMTIgMEgxNC4xNTIzTDIwLjk0OTkgNy4wOTE5NVYyMC44Nzc5QzIwLjk0OTkgMjIuNjAyMyAxOS41NTIyIDI0IDE3LjgyNzcgMjRINi4xMjIxMkM0LjM5NzY2IDI0IDMgMjIuNjAyMyAzIDIwLjg3NzlWMy4xMjIxMkMzIDEuMzk3NjkgNC4zOTc2NiAwIDYuMTIyMTIgMFoiIGZpbGw9IiM2RjZGNkYiLz4KPHBhdGggb3BhY2l0eT0iMC4zIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0LjE0NDUgMFY3LjAzMzdIMjAuOTUxOEwxNC4xNDQ1IDBaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMTQuOTMzMSAxNS4wODcxTDExLjU1MjMgMTguNDY4QzEwLjc4MzQgMTkuMjM2OCA5LjUzNjg4IDE5LjIzNjggOC43NjgwNCAxOC40NjhDNy45OTkyIDE3LjY5OTEgNy45OTkyIDE2LjQ1MjYgOC43NjgwNCAxNS42ODM3TDEyLjE0ODkgMTIuMzAyOUMxMi42NjE1IDExLjc5MDMgMTMuNDkyNSAxMS43OTAzIDE0LjAwNSAxMi4zMDI5QzE0LjUxNzYgMTIuODE1NCAxNC41MTc2IDEzLjY0NjUgMTQuMDA1IDE0LjE1OUwxMC43NTY4IDE3LjQwNzNDMTAuNTAwNSAxNy42NjM2IDEwLjA4NSAxNy42NjM2IDkuODI4NyAxNy40MDczQzkuNTcyNDIgMTcuMTUxIDkuNTcyNDIgMTYuNzM1NSA5LjgyODcgMTYuNDc5MkwxMi42NzkyIDEzLjYyODciIHN0cm9rZT0id2hpdGUiIHN0cm9rZS13aWR0aD0iMC43IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+Cg==", GE = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAxOCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMuMTQ1NTYgMEgxMS4xNzU4TDE3Ljk3MzMgNy4wOTE5NVYyMC44Nzc5QzE3Ljk3MzMgMjIuNjAyMyAxNi41NzU2IDI0IDE0Ljg1MTIgMjRIMy4xNDU1NkMxLjQyMTEgMjQgMC4wMjM0Mzc1IDIyLjYwMjMgMC4wMjM0Mzc1IDIwLjg3NzlWMy4xMjIxMkMwLjAyMzQzNzUgMS4zOTc2OSAxLjQyMTEgMCAzLjE0NTU2IDBaIiBmaWxsPSIjMzM5OERCIi8+CjxwYXRoIG9wYWNpdHk9IjAuMzAyIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjE2NDEgMFY3LjAzMzdIMTcuOTcxM0wxMS4xNjQxIDBaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMi45MjE4OCAxNy4xMjQ4VjEzLjE1MTdINC4zMjkyN0M0LjYxMDc0IDEzLjE1MTcgNC44NzI4MyAxMy4xOTM4IDUuMTE1NDggMTMuMjcxNUM1LjM1ODEzIDEzLjM1MjMgNS41NzgxMyAxMy40Njg4IDUuNzc1NTEgMTMuNjI0MUM1Ljk3Mjg2IDEzLjc3OTQgNi4xMjgxOCAxMy45ODY1IDYuMjQxNDEgMTQuMjQ1M0M2LjM1NDY0IDE0LjUwNDEgNi40MTI4OSAxNC44MDE4IDYuNDEyODkgMTUuMTM4M0M2LjQxMjg5IDE1LjQ3NDcgNi4zNTQ2NCAxNS43NzI0IDYuMjQxNDEgMTYuMDMxMkM2LjEyODE4IDE2LjI5IDUuOTcyODYgMTYuNDk3MSA1Ljc3NTUxIDE2LjY1MjRDNS41NzgxNiAxNi44MDc3IDUuMzU4MTMgMTYuOTI0MiA1LjExNTQ4IDE3LjAwNTFDNC44NzI4MyAxNy4wODI3IDQuNjEwNzcgMTcuMTI0OCA0LjMyOTI3IDE3LjEyNDhIMi45MjE4OFpNMy45MTUxNCAxNi4yNjFINC4yMDk1NUM0LjM2ODA4IDE2LjI2MSA0LjUxNjkxIDE2LjI0MTUgNC42NDk1NSAxNi4yMDU5QzQuNzg1NDMgMTYuMTY3MSA0LjkwODM3IDE2LjEwNTcgNS4wMjQ4NCAxNi4wMjQ4QzUuMTQxMzEgMTUuOTQzOSA1LjIzMTg5IDE1LjgyNzQgNS4yOTY2IDE1LjY3NTNDNS4zNjQ1NiAxNS41MjY1IDUuMzk2ODggMTUuMzQ1MyA1LjM5Njg4IDE1LjEzODNDNS4zOTY4OCAxNC45MzEyIDUuMzY0NTMgMTQuNzUgNS4yOTY2IDE0LjU5OEM1LjIzMTg5IDE0LjQ0OTEgNS4xNDEzMSAxNC4zMzI3IDUuMDI0ODQgMTQuMjUxOEM0LjkwODM3IDE0LjE2NzcgNC43ODU0MyAxNC4xMDk0IDQuNjQ5NTUgMTQuMDcwNkM0LjUxNjkxIDE0LjAzNSA0LjM2ODA4IDE0LjAxNTYgNC4yMDk1NSAxNC4wMTU2SDMuOTE1MTRWMTYuMjYxWk04LjgyMzIyIDE3LjE3MDFDOC4yMjQ2OCAxNy4xNzAxIDcuNzI5NjcgMTYuOTc2IDcuMzM4MTkgMTYuNTkxQzYuOTQ2NzEgMTYuMjA1OSA2Ljc1MjU4IDE1LjcyMDYgNi43NTI1OCAxNS4xMzgzQzYuNzUyNTggMTQuNTU1OSA2Ljk0NjcxIDE0LjA3MDYgNy4zMzgxOSAxMy42ODU2QzcuNzI5NjcgMTMuMzAwNiA4LjIyNDY4IDEzLjEwNjUgOC44MjMyMiAxMy4xMDY1QzkuNDEyMDUgMTMuMTA2NSA5LjkwMDU5IDEzLjMwMDYgMTAuMjkyMSAxMy42ODU2QzEwLjY4MDMgMTQuMDcwNyAxMC44NzQ0IDE0LjU1NiAxMC44NzQ0IDE1LjEzODNDMTAuODc0NCAxNS43MjA2IDEwLjY4MDMgMTYuMjA2IDEwLjI5MjEgMTYuNTkxQzkuOTAwNTkgMTYuOTc2IDkuNDEyMDUgMTcuMTcwMSA4LjgyMzIyIDE3LjE3MDFaTTguMDU5NjYgMTUuOTc2MkM4LjI1NzAxIDE2LjE5NjIgOC41MDkzNiAxNi4zMDYzIDguODE2NzMgMTYuMzA2M0M5LjEyNDA5IDE2LjMwNjMgOS4zNzMyIDE2LjE5NjIgOS41NzA1OCAxNS45NzYyQzkuNzY3OTMgMTUuNzUzIDkuODY1IDE1LjQ3NDcgOS44NjUgMTUuMTM4M0M5Ljg2NSAxNC44MDE4IDkuNzY3OTMgMTQuNTIzNSA5LjU3MDU4IDE0LjMwMDNDOS4zNzMyMyAxNC4wODAzIDkuMTI0MDkgMTMuOTcwMyA4LjgxNjczIDEzLjk3MDNDOC41MDkzNiAxMy45NzAzIDguMjU3MDEgMTQuMDgwMyA4LjA1OTY2IDE0LjMwMDNDNy44NjIzMSAxNC41MjM1IDcuNzYyIDE0LjgwMTggNy43NjIgMTUuMTM4M0M3Ljc2MiAxNS40NzQ3IDcuODYyMzEgMTUuNzUzIDguMDU5NjYgMTUuOTc2MlpNMTMuMjM2MyAxNy4xNzAxQzEyLjY1NzEgMTcuMTcwMSAxMi4xNzUgMTYuOTg4OSAxMS43OTMzIDE2LjYzM0MxMS40MDgzIDE2LjI3MzkgMTEuMjE3NCAxNS43NzU2IDExLjIxNzQgMTUuMTM4M0MxMS4yMTc0IDE0LjUwNDEgMTEuNDExNSAxNC4wMDU5IDExLjc5OTggMTMuNjQ2OEMxMi4xOTEzIDEzLjI4NzYgMTIuNjY2OSAxMy4xMDY0IDEzLjIzNjMgMTMuMTA2NEMxMy43NTA3IDEzLjEwNjQgMTQuMTcxMyAxMy4yMzI2IDE0LjUwNDYgMTMuNDg4MkMxNC44MzQ2IDEzLjc0MDYgMTUuMDI1NSAxNC4wNzcxIDE1LjA3NCAxNC40OTc2TDE0LjA3MSAxNC43MDE1QzE0LjAyOSAxNC40ODE1IDEzLjkyODYgMTQuMzAzNSAxMy43NzM0IDE0LjE3MDlDMTMuNjE4MSAxNC4wMzgyIDEzLjQzNjkgMTMuOTcwMyAxMy4yMjk4IDEzLjk3MDNDMTIuOTQ1MSAxMy45NzAzIDEyLjcwODkgMTQuMDcwNiAxMi41MTggMTQuMjc0NEMxMi4zMjcxIDE0LjQ4MTUgMTIuMjMgMTQuNzY2MiAxMi4yMyAxNS4xMzgyQzEyLjIzIDE1LjUxMDMgMTIuMzI3MSAxNS43OTUgMTIuNTE0OCAxNS45OTg5QzEyLjcwNTYgMTYuMjA1OSAxMi45NDE4IDE2LjMwNjIgMTMuMjI5OCAxNi4zMDYyQzEzLjQzNjggMTYuMzA2MiAxMy42MTQ4IDE2LjI0OCAxMy43NjA0IDE2LjEzMTVDMTMuOTA2IDE2LjAxNTEgMTMuOTk2NiAxNS44NTk4IDE0LjAzNTQgMTUuNjY1NkwxNS4wNjEgMTUuODk4NkMxNC45NjcyIDE2LjI5OTggMTQuNzYwMSAxNi42MTA0IDE0LjQzNjYgMTYuODMzNkMxNC4xMTYzIDE3LjA1NjkgMTMuNzE1MSAxNy4xNzAxIDEzLjIzNjMgMTcuMTcwMVoiIGZpbGw9IndoaXRlIi8+Cjwvc3ZnPgo=", VE = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAxOCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgaWQ9Ikdyb3VwIj4KPGcgaWQ9IlZyc3R2YV94MDAyMF8xXzEzXyI+CjxwYXRoIGlkPSJWZWN0b3IiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMy4xNTE3NyAwSDExLjE3NThMMTcuOTc2NCA3LjA4ODQ2VjIwLjg3NTZDMTcuOTc2NCAyMi42MDI3IDE2LjU3OTEgMjQgMTQuODU3OSAyNEgzLjE1MTc3QzEuNDI0NjQgMjQgMC4wMjczNDM4IDIyLjYwMjcgMC4wMjczNDM4IDIwLjg3NTZWMy4xMjQ0M0MwLjAyNzMxMzQgMS4zOTczIDEuNDI0NjEgMCAzLjE1MTc3IDBaIiBmaWxsPSIjRTE2RDZEIi8+CjxnIGlkPSJHcm91cF8yIj4KPHBhdGggaWQ9IlZlY3Rvcl8yIiBvcGFjaXR5PSIwLjMwMiIgZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMS4xNzE5IDBWNy4wMzQ0OUgxNy45Nzg1TDExLjE3MTkgMFoiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGlkPSJWZWN0b3JfMyIgZD0iTTkuMDA1MDcgMTAuODkwNkM2Ljg2NDE0IDEwLjg5MDYgNS4xMjUgMTIuNjI5OCA1LjEyNSAxNC43NzA3QzUuMTI1IDE2LjkxMTYgNi44NjQxNCAxOC42NDQ3IDkuMDA1MDcgMTguNjQ0N0MxMS4xNDYgMTguNjQ0NyAxMi44NzkxIDE2LjkxMTYgMTIuODc5MSAxNC43NzA3QzEyLjg3OTEgMTIuNjI5NyAxMS4xNCAxMC44OTY2IDkuMDA1MDcgMTAuODkwNlpNMTAuNjM2MyAxNC44OTA2QzEwLjYwNjMgMTQuOTQ0NiAxMC41NjQzIDE0Ljk4NjYgMTAuNTEwMyAxNS4wMTY2TDguMjk3NDMgMTYuMTI2QzguMTU5NDkgMTYuMTkxOSA3Ljk5MTU4IDE2LjEzOCA3LjkyNTYzIDE2LjAwMDFDNy45MDE2NCAxNS45NjQxIDcuODk1NjQgMTUuOTIyMSA3Ljg5NTY0IDE1Ljg3NDFWMTMuNjYxMkM3Ljg5NTY0IDEzLjUwNTMgOC4wMjE1NyAxMy4zODU0IDguMTcxNDkgMTMuMzg1NEM4LjIxMzQ2IDEzLjM4NTQgOC4yNTU0NiAxMy4zOTE0IDguMjk3NDMgMTMuNDE1NEwxMC41MTAzIDE0LjUxODhDMTAuNjQ4MyAxNC41OTA4IDEwLjcwMjIgMTQuNzUyNyAxMC42MzYzIDE0Ljg5MDZaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjwvZz4KPC9nPgo8L3N2Zz4K", YE = Jt(Be)(() => ({
  '&[data-size="small"], &[data-size="small"] img': { width: "24px", height: "24px" },
  '&[data-size="medium"], &[data-size="medium"] img': { width: "48px", height: "48px" },
  '&[data-size="large"], &[data-size="large"] img': { width: "72px", height: "72px" },
  "& img": { objectFit: "contain" }
})), qy = ({
  thumbnail: l,
  size: e = Qu.Small,
  fallback: t = Vt.Image
}) => {
  const s = {
    [Vt.Image]: WE,
    [Vt.Pdf]: $E,
    [Vt.Doc]: GE,
    [Vt.Video]: VE,
    [Vt.General]: sm,
    [Vt.Csv]: sm
  }[t], i = l ? `data:image/png;base64,${l}` : s;
  return /* @__PURE__ */ rt.jsx(YE, { "data-size": e, children: /* @__PURE__ */ rt.jsx(
    "img",
    {
      alt: "Attachment icon",
      src: i
    }
  ) });
}, XE = Jt(Be)(({ theme: l }) => ({
  gap: "16px",
  display: "flex",
  alignItems: "center",
  flexDirection: "column",
  justifyContent: "center",
  "& .MuiTypography-root": { color: l.palette.common.white }
})), qE = ({ attachmentType: l }) => /* @__PURE__ */ rt.jsxs(XE, { children: [
  /* @__PURE__ */ rt.jsx(qu, { variant: "body-lg-medium", children: "Failed to load preview" }),
  /* @__PURE__ */ rt.jsx(
    qy,
    {
      fallback: l,
      size: Qu.Large
    }
  )
] }), QE = (l) => ({
  image: A0,
  pdf: UE,
  video: HE,
  doc: iw,
  csv: D0,
  general: null
})[l], KE = ({ activeFile: l, isError: e, isLoading: t, rotate: s, scale: i, type: r }) => {
  if (t)
    return /* @__PURE__ */ rt.jsx($p, { size: 128 });
  if (e)
    return /* @__PURE__ */ rt.jsx(qE, { attachmentType: r });
  const n = QE(r);
  return !l.blob || n === null ? /* @__PURE__ */ rt.jsx(
    qy,
    {
      size: Qu.Large,
      fallback: r
    }
  ) : /* @__PURE__ */ rt.jsx(
    n,
    {
      blob: l.blob,
      scale: i,
      rotate: s,
      fileName: l.name
    }
  );
}, ZE = (l) => {
  Pt(() => {
    const e = (t) => {
      l(t);
    };
    return document.addEventListener("wheel", e), () => {
      document.removeEventListener("wheel", e);
    };
  }, [l]);
}, JE = 90, tx = () => {
  const [l, e] = Mi(0), t = () => {
    e((i) => i + JE);
  }, s = Si(() => {
    e(0);
  }, []);
  return {
    rotate: l,
    rotateRight: t,
    rotateReset: s
  };
}, im = 0.25, rm = 1, nm = 4, ex = () => {
  const [l, e] = Mi(1), t = () => {
    e((r) => {
      const n = r + im;
      return n > nm ? nm : n;
    });
  }, s = () => {
    e((r) => {
      const n = r - im;
      return n < rm ? rm : n;
    });
  }, i = Si(() => {
    e(1);
  }, []);
  return {
    scale: l,
    scaleUp: t,
    scaleDown: s,
    scaleReset: i
  };
}, sx = Jt(Be)(() => ({
  width: "100vw",
  height: "100vh",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
})), ix = Jt(Be)(({ theme: l }) => ({
  width: "100vw",
  height: "100vh",
  outline: "none",
  position: "relative",
  fontFamily: "Poppins",
  background: l.palette.grey[600]
})), rx = Jt(Be)(() => ({
  width: "100%",
  height: "100%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
})), nx = (l) => gg.find((e) => e.includes(l)) ?? gg[0], ax = Jt(s0)(({ theme: l }) => ({
  gap: "8px",
  minHeight: "36px",
  padding: "8px 12px",
  borderRadius: "8px",
  alignItems: "center",
  backgroundColor: Zc.grey[550],
  color: l.palette.common.white,
  zIndex: 999,
  "&:hover": { background: l.palette.grey[500] },
  "&.active": { background: nx(l.palette.primary.main) },
  "&.Mui-disabled": { backgroundColor: l.palette.grey[400], color: l.palette.common.black },
  "&.arrow-button": { width: "40px", height: "40px", "& .MuiSvgIcon-root": { width: "20px", height: "20px" } },
  "& .MuiSvgIcon-root": { width: "16px", height: "16px" },
  "& .MuiTypography-root": { color: l.palette.common.white }
})), lg = Jt(Be)(() => ({
  width: "100%",
  padding: "16px",
  display: "flex",
  position: "absolute",
  justifyContent: "space-between"
})), Hp = Jt(Be)(() => ({
  gap: "12px",
  display: "flex",
  alignItems: "center"
})), ox = Jt(Be)(({ theme: l }) => ({
  gap: "8px",
  display: "flex",
  borderRadius: "8px",
  alignItems: "center",
  justifyContent: "center",
  backgroundColor: Zc.grey[550],
  zIndex: 999,
  "& .MuiTypography-root": { color: l.palette.common.white }
})), lx = Jt(qu)(({ theme: l }) => ({
  color: l.palette.common.white,
  zIndex: 1
})), hx = Jt(o0)(({ style: l }) => ({
  transform: "translateY(4px)",
  "& .MuiPaper-root": { backgroundColor: Zc.grey[550] },
  "& .MuiList-root": {
    padding: "8px",
    width: "214px",
    display: "flex",
    borderRadius: "4px",
    flexDirection: "column",
    backgroundColor: Zc.grey[550],
    ...l
  }
})), cx = Jt(l0)(({ theme: l }) => ({
  gap: "8px",
  lineHeight: 2,
  display: "flex",
  fontSize: "12px",
  minHeight: "auto",
  padding: "6px 8px",
  transition: "0.2s",
  borderRadius: "4px",
  alignItems: "center",
  color: l.palette.common.white,
  "&:hover": { backgroundColor: l.palette.grey[500] },
  "& .MuiSvgIcon-root": { width: "16px", height: "16px" },
  "&.delete .MuiSvgIcon-root": { color: l.palette.error.main },
  "& + .MuiDivider-root": { marginTop: 0, marginBottom: 0 }
})), dx = Jt(h0)(({ theme: l }) => ({
  borderColor: l.palette.grey[500],
  margin: "8px 0 !important"
})), ux = ({ anchorEl: l, handleClose: e, options: t, activeFileId: s }) => {
  const i = Si(
    (r) => {
      var n;
      (n = r.callback) == null || n.call(r, s), e();
    },
    [s, e]
  );
  return /* @__PURE__ */ rt.jsx(
    hx,
    {
      elevation: 0,
      open: !!l,
      anchorEl: l,
      onClose: e,
      anchorOrigin: { vertical: "top", horizontal: "center" },
      transformOrigin: { vertical: "bottom", horizontal: "center" },
      sx: {
        transform: "translateY(-4px)"
      },
      children: t.map(
        (r, n) => r.divider ? /* @__PURE__ */ rt.jsx(dx, {}, `${r.label}-${n}`) : /* @__PURE__ */ rt.jsxs(
          cx,
          {
            className: Kc({ delete: r.delete }),
            onClick: () => i(r),
            children: [
              r.icon && /* @__PURE__ */ rt.jsx(dm, { icon: r.icon }),
              r.label
            ]
          },
          `${r.label}-${n}`
        )
      )
    }
  );
}, fr = (l) => /* @__PURE__ */ rt.jsxs(
  ax,
  {
    disabled: l.disabled,
    onClick: l.onClick,
    className: `${l.className}${l.isActive ? " active" : ""}`,
    children: [
      l.icon && /* @__PURE__ */ rt.jsx(dm, { icon: l.icon }),
      l.text && /* @__PURE__ */ rt.jsx(qu, { variant: "body-xs-medium", children: l.text })
    ]
  }
), fx = 100, px = ({ activeFile: l, options: e, scale: t, type: s, onScaleUp: i, onScaleDown: r }) => {
  const [n, a] = Mi(null), h = (g) => {
    a(g.currentTarget);
  }, c = () => {
    a(null);
  }, d = () => {
    i == null || i();
  }, u = () => {
    r == null || r();
  }, f = e[s], p = t * fx, m = s === Vt.Doc;
  return /* @__PURE__ */ rt.jsxs(lg, { sx: { bottom: 0 }, children: [
    /* @__PURE__ */ rt.jsxs(Hp, { children: [
      /* @__PURE__ */ rt.jsx(
        fr,
        {
          isActive: !!n,
          onClick: h,
          icon: ur.DotsVertical
        }
      ),
      /* @__PURE__ */ rt.jsx(lx, { variant: "body-sm-regular", children: l.name }),
      /* @__PURE__ */ rt.jsx(
        ux,
        {
          anchorEl: n,
          handleClose: c,
          options: f,
          activeFileId: l.id
        }
      )
    ] }),
    m ? null : /* @__PURE__ */ rt.jsxs(ox, { children: [
      /* @__PURE__ */ rt.jsx(
        fr,
        {
          icon: ur.Minus,
          onClick: u
        }
      ),
      /* @__PURE__ */ rt.jsxs(qu, { variant: "body-sm-medium", children: [
        p,
        "%"
      ] }),
      /* @__PURE__ */ rt.jsx(
        fr,
        {
          icon: ur.Plus,
          onClick: d
        }
      )
    ] })
  ] });
}, gx = ({ onNext: l, onPrev: e }) => /* @__PURE__ */ rt.jsxs(lg, { sx: { top: "50%" }, children: [
  /* @__PURE__ */ rt.jsx(
    fr,
    {
      className: "arrow-button",
      icon: ur.ChevronLeft,
      onClick: e
    }
  ),
  /* @__PURE__ */ rt.jsx(
    fr,
    {
      className: "arrow-button",
      icon: ur.ChevronRight,
      onClick: l
    }
  )
] }), mx = ({ onClose: l, onRotate: e, activeFile: t }) => {
  const s = () => {
    var a;
    if (!t.blob)
      return;
    const i = URL.createObjectURL(t.blob), r = document.createElement("a");
    r.href = i;
    const n = t.name;
    r.setAttribute("download", n), document.body.appendChild(r), r.click(), (a = r.parentNode) == null || a.removeChild(r), URL.revokeObjectURL(i);
  };
  return /* @__PURE__ */ rt.jsxs(lg, { sx: { top: 0 }, children: [
    /* @__PURE__ */ rt.jsxs(Hp, { children: [
      /* @__PURE__ */ rt.jsx(
        fr,
        {
          text: "Rotate",
          icon: ur.Refresh,
          onClick: () => e()
        }
      ),
      /* @__PURE__ */ rt.jsx(
        fr,
        {
          text: "Download",
          icon: ur.DownloadCloud,
          onClick: s,
          disabled: !t.blob
        }
      )
    ] }),
    /* @__PURE__ */ rt.jsx(Hp, { children: /* @__PURE__ */ rt.jsx(
      fr,
      {
        icon: ur.XClose,
        onClick: l
      }
    ) })
  ] });
}, Sx = ({
  isOpened: l,
  activeFile: e,
  options: t,
  onClose: s,
  showArrows: i,
  onNext: r,
  onPrev: n,
  isLoading: a,
  isError: h
}) => {
  const { rotate: c, rotateRight: d, rotateReset: u } = tx(), { scale: f, scaleUp: p, scaleDown: m, scaleReset: g } = ex(), w = m0(e.name), b = () => {
    g(), u(), r == null || r();
  }, _ = () => {
    g(), u(), n == null || n();
  }, k = (C) => {
    C.key === "Escape" ? s() : C.key === "ArrowRight" ? i && b() : C.key === "ArrowLeft" && i && _();
  };
  return ZE((C) => {
    w === Vt.Image && (C.deltaY < 0 ? p() : m());
  }), Pt(() => {
    g(), u();
  }, [l, g, u]), /* @__PURE__ */ rt.jsx(
    c0,
    {
      onKeyDown: k,
      open: l,
      children: /* @__PURE__ */ rt.jsx(sx, { children: /* @__PURE__ */ rt.jsxs(ix, { children: [
        /* @__PURE__ */ rt.jsx(
          mx,
          {
            onClose: s,
            onRotate: d,
            activeFile: e
          }
        ),
        i && /* @__PURE__ */ rt.jsx(
          gx,
          {
            onNext: b,
            onPrev: _
          }
        ),
        /* @__PURE__ */ rt.jsx(
          px,
          {
            activeFile: e,
            scale: f,
            type: w,
            options: t,
            onScaleUp: p,
            onScaleDown: m
          }
        ),
        /* @__PURE__ */ rt.jsx(rx, { children: /* @__PURE__ */ rt.jsx(
          KE,
          {
            activeFile: e,
            isLoading: a,
            isError: h,
            rotate: c,
            scale: f,
            type: w
          }
        ) })
      ] }) })
    }
  );
};
export {
  Qu as AttachmentIconSize,
  Vt as AttachmentType,
  Sx as PuiFileViewer
};
//# sourceMappingURL=file-viewer.js.map
