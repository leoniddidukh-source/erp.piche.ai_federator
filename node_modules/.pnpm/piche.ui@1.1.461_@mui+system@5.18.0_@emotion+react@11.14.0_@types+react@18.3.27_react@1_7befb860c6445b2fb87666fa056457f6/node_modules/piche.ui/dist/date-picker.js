(function(){"use strict";try{if(typeof document<"u"){var t=document.createElement("style");t.appendChild(document.createTextNode(`:root{--react-pdf-text-layer: 1;--highlight-bg-color: rgba(180, 0, 170, 1);--highlight-selected-bg-color: rgba(0, 100, 0, 1)}@media screen and (forced-colors: active){:root{--highlight-bg-color: Highlight;--highlight-selected-bg-color: ButtonText}}[data-main-rotation="90"]{transform:rotate(90deg) translateY(-100%)}[data-main-rotation="180"]{transform:rotate(180deg) translate(-100%,-100%)}[data-main-rotation="270"]{transform:rotate(270deg) translate(-100%)}.textLayer{position:absolute;text-align:initial;top:0;right:0;bottom:0;left:0;overflow:hidden;line-height:1;text-size-adjust:none;forced-color-adjust:none;transform-origin:0 0;z-index:2}.textLayer :is(span,br){color:transparent;position:absolute;white-space:pre;cursor:text;margin:0;transform-origin:0 0}.textLayer span.markedContent{top:0;height:0}.textLayer .highlight{margin:-1px;padding:1px;background-color:var(--highlight-bg-color);border-radius:4px}.textLayer .highlight.appended{position:initial}.textLayer .highlight.begin{border-radius:4px 0 0 4px}.textLayer .highlight.end{border-radius:0 4px 4px 0}.textLayer .highlight.middle{border-radius:0}.textLayer .highlight.selected{background-color:var(--highlight-selected-bg-color)}.textLayer br::selection{background:transparent}.textLayer .endOfContent{display:block;position:absolute;top:100%;right:0;bottom:0;left:0;z-index:-1;cursor:default;-webkit-user-select:none;user-select:none}.textLayer.selecting .endOfContent{top:0}.hiddenCanvasElement{position:absolute;top:0;left:0;width:0;height:0;display:none}:root{--react-pdf-annotation-layer: 1;--annotation-unfocused-field-background: url("data:image/svg+xml;charset=UTF-8,<svg width='1px' height='1px' xmlns='http://www.w3.org/2000/svg'><rect width='100%' height='100%' style='fill:rgba(0, 54, 255, 0.13);'/></svg>");--input-focus-border-color: Highlight;--input-focus-outline: 1px solid Canvas;--input-unfocused-border-color: transparent;--input-disabled-border-color: transparent;--input-hover-border-color: black;--link-outline: none}@media screen and (forced-colors: active){:root{--input-focus-border-color: CanvasText;--input-unfocused-border-color: ActiveText;--input-disabled-border-color: GrayText;--input-hover-border-color: Highlight;--link-outline: 1.5px solid LinkText}.annotationLayer .textWidgetAnnotation :is(input,textarea):required,.annotationLayer .choiceWidgetAnnotation select:required,.annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid selectedItem}.annotationLayer .linkAnnotation:hover{-webkit-backdrop-filter:invert(100%);backdrop-filter:invert(100%)}}.annotationLayer{position:absolute;top:0;left:0;pointer-events:none;transform-origin:0 0;z-index:3}.annotationLayer[data-main-rotation="90"] .norotate{transform:rotate(270deg) translate(-100%)}.annotationLayer[data-main-rotation="180"] .norotate{transform:rotate(180deg) translate(-100%,-100%)}.annotationLayer[data-main-rotation="270"] .norotate{transform:rotate(90deg) translateY(-100%)}.annotationLayer canvas{position:absolute;width:100%;height:100%}.annotationLayer section{position:absolute;text-align:initial;pointer-events:auto;box-sizing:border-box;margin:0;transform-origin:0 0}.annotationLayer .linkAnnotation{outline:var(--link-outline)}.textLayer.selecting~.annotationLayer section{pointer-events:none}.annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a{position:absolute;font-size:1em;top:0;left:0;width:100%;height:100%}.annotationLayer :is(.linkAnnotation,.buttonWidgetAnnotation.pushButton)>a:hover{opacity:.2;background:rgba(255,255,0,1);box-shadow:0 2px 10px #ff0}.annotationLayer .textAnnotation img{position:absolute;cursor:pointer;width:100%;height:100%;top:0;left:0}.annotationLayer .textWidgetAnnotation :is(input,textarea),.annotationLayer .choiceWidgetAnnotation select,.annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{background-image:var(--annotation-unfocused-field-background);border:2px solid var(--input-unfocused-border-color);box-sizing:border-box;font:calc(9px * var(--scale-factor)) sans-serif;height:100%;margin:0;vertical-align:top;width:100%}.annotationLayer .textWidgetAnnotation :is(input,textarea):required,.annotationLayer .choiceWidgetAnnotation select:required,.annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:required{outline:1.5px solid red}.annotationLayer .choiceWidgetAnnotation select option{padding:0}.annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.annotationLayer .textWidgetAnnotation textarea{resize:none}.annotationLayer .textWidgetAnnotation :is(input,textarea)[disabled],.annotationLayer .choiceWidgetAnnotation select[disabled],.annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input[disabled]{background:none;border:2px solid var(--input-disabled-border-color);cursor:not-allowed}.annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.annotationLayer .choiceWidgetAnnotation select:hover,.annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input:hover{border:2px solid var(--input-hover-border-color)}.annotationLayer .textWidgetAnnotation :is(input,textarea):hover,.annotationLayer .choiceWidgetAnnotation select:hover,.annotationLayer .buttonWidgetAnnotation.checkBox input:hover{border-radius:2px}.annotationLayer .textWidgetAnnotation :is(input,textarea):focus,.annotationLayer .choiceWidgetAnnotation select:focus{background:none;border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) :focus{background-image:none;background-color:transparent}.annotationLayer .buttonWidgetAnnotation.checkBox :focus{border:2px solid var(--input-focus-border-color);border-radius:2px;outline:var(--input-focus-outline)}.annotationLayer .buttonWidgetAnnotation.radioButton :focus{border:2px solid var(--input-focus-border-color);outline:var(--input-focus-outline)}.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:CanvasText;content:"";display:block;position:absolute}.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{height:80%;left:45%;width:1px}.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:30%;top:20%;width:50%}.annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.annotationLayer .textWidgetAnnotation input.comb:focus{width:103%}.annotationLayer .buttonWidgetAnnotation:is(.checkBox,.radioButton) input{-webkit-appearance:none;-moz-appearance:none;appearance:none}.annotationLayer .popupTriggerArea{height:100%;width:100%}.annotationLayer .fileAttachmentAnnotation .popupTriggerArea{position:absolute}.annotationLayer .popupWrapper{position:absolute;font-size:calc(9px * var(--scale-factor));width:100%;min-width:calc(180px * var(--scale-factor));pointer-events:none}.annotationLayer .popup{position:absolute;max-width:calc(180px * var(--scale-factor));background-color:#ff9;box-shadow:0 calc(2px * var(--scale-factor)) calc(5px * var(--scale-factor)) #888;border-radius:calc(2px * var(--scale-factor));padding:calc(6px * var(--scale-factor));margin-left:calc(5px * var(--scale-factor));cursor:pointer;font:message-box;white-space:normal;word-wrap:break-word;pointer-events:auto}.annotationLayer .popup>*{font-size:calc(9px * var(--scale-factor))}.annotationLayer .popup h1{display:inline-block}.annotationLayer .popupDate{display:inline-block;margin-left:calc(5px * var(--scale-factor))}.annotationLayer .popupContent{border-top:1px solid rgba(51,51,51,1);margin-top:calc(2px * var(--scale-factor));padding-top:calc(2px * var(--scale-factor))}.annotationLayer .richText>*{white-space:pre-wrap;font-size:calc(9px * var(--scale-factor))}.annotationLayer .highlightAnnotation,.annotationLayer .underlineAnnotation,.annotationLayer .squigglyAnnotation,.annotationLayer .strikeoutAnnotation,.annotationLayer .freeTextAnnotation,.annotationLayer .lineAnnotation svg line,.annotationLayer .squareAnnotation svg rect,.annotationLayer .circleAnnotation svg ellipse,.annotationLayer .polylineAnnotation svg polyline,.annotationLayer .polygonAnnotation svg polygon,.annotationLayer .caretAnnotation,.annotationLayer .inkAnnotation svg polyline,.annotationLayer .stampAnnotation,.annotationLayer .fileAttachmentAnnotation{cursor:pointer}.annotationLayer section svg{position:absolute;width:100%;height:100%;top:0;left:0}.annotationLayer .annotationTextContent{position:absolute;width:100%;height:100%;opacity:0;color:transparent;-webkit-user-select:none;user-select:none;pointer-events:none}.annotationLayer .annotationTextContent span{width:100%;display:inline-block}`)),document.head.appendChild(t)}}catch(n){console.error("vite-plugin-css-injected-by-js",n)}})();
var bt = Object.defineProperty;
var gt = (t, r, e) => r in t ? bt(t, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[r] = e;
var u = (t, r, e) => (gt(t, typeof r != "symbol" ? r + "" : r, e), e);
import { P as O, j as l, w as Dt } from "./Button-518a0ca9.js";
import { createContext as Mt, useContext as pt, useMemo as De, useRef as ce, useCallback as b, useEffect as Me, useState as L } from "react";
import { z as S, hA as te, ai as Tt } from "./utils-98f79634.js";
import { C as kt } from "./ClickAwayListener-0ed1644c.js";
import "react-dom";
const Ue = Mt(null), A = () => {
  const t = pt(Ue);
  if (!t)
    throw new Error("useCalendarContext must be used within a CalendarProvider");
  return t;
}, et = 6048e5, Pt = 864e5, Et = 6e4, Ot = 36e5, Ct = 1e3, Ie = Symbol.for("constructDateFrom");
function N(t, r) {
  return typeof t == "function" ? t(r) : t && typeof t == "object" && Ie in t ? t[Ie](r) : t instanceof Date ? new t.constructor(r) : new Date(r);
}
function E(t, r) {
  return N(r || t, t);
}
function tt(t, r, e) {
  const n = E(t, e == null ? void 0 : e.in);
  return isNaN(r) ? N((e == null ? void 0 : e.in) || t, NaN) : (r && n.setDate(n.getDate() + r), n);
}
function rt(t, r, e) {
  const n = E(t, e == null ? void 0 : e.in);
  if (isNaN(r))
    return N((e == null ? void 0 : e.in) || t, NaN);
  if (!r)
    return n;
  const a = n.getDate(), s = N((e == null ? void 0 : e.in) || t, n.getTime());
  s.setMonth(n.getMonth() + r + 1, 0);
  const i = s.getDate();
  return a >= i ? s : (n.setFullYear(
    s.getFullYear(),
    s.getMonth(),
    a
  ), n);
}
let _t = {};
function ne() {
  return _t;
}
function J(t, r) {
  var o, d, m, c;
  const e = ne(), n = (r == null ? void 0 : r.weekStartsOn) ?? ((d = (o = r == null ? void 0 : r.locale) == null ? void 0 : o.options) == null ? void 0 : d.weekStartsOn) ?? e.weekStartsOn ?? ((c = (m = e.locale) == null ? void 0 : m.options) == null ? void 0 : c.weekStartsOn) ?? 0, a = E(t, r == null ? void 0 : r.in), s = a.getDay(), i = (s < n ? 7 : 0) + s - n;
  return a.setDate(a.getDate() - i), a.setHours(0, 0, 0, 0), a;
}
function re(t, r) {
  return J(t, { ...r, weekStartsOn: 1 });
}
function nt(t, r) {
  const e = E(t, r == null ? void 0 : r.in), n = e.getFullYear(), a = N(e, 0);
  a.setFullYear(n + 1, 0, 4), a.setHours(0, 0, 0, 0);
  const s = re(a), i = N(e, 0);
  i.setFullYear(n, 0, 4), i.setHours(0, 0, 0, 0);
  const o = re(i);
  return e.getTime() >= s.getTime() ? n + 1 : e.getTime() >= o.getTime() ? n : n - 1;
}
function de(t) {
  const r = E(t), e = new Date(
    Date.UTC(
      r.getFullYear(),
      r.getMonth(),
      r.getDate(),
      r.getHours(),
      r.getMinutes(),
      r.getSeconds(),
      r.getMilliseconds()
    )
  );
  return e.setUTCFullYear(r.getFullYear()), +t - +e;
}
function Yt(t, ...r) {
  const e = N.bind(
    null,
    t || r.find((n) => typeof n == "object")
  );
  return r.map(e);
}
function qe(t, r) {
  const e = E(t, r == null ? void 0 : r.in);
  return e.setHours(0, 0, 0, 0), e;
}
function Ft(t, r, e) {
  const [n, a] = Yt(
    e == null ? void 0 : e.in,
    t,
    r
  ), s = qe(n), i = qe(a), o = +s - de(s), d = +i - de(i);
  return Math.round((o - d) / Pt);
}
function Wt(t, r) {
  const e = nt(t, r), n = N((r == null ? void 0 : r.in) || t, 0);
  return n.setFullYear(e, 0, 4), n.setHours(0, 0, 0, 0), re(n);
}
function vt(t) {
  return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]";
}
function me(t) {
  return !(!vt(t) && typeof t != "number" || isNaN(+E(t)));
}
function Ht(t, r) {
  const e = E(t, r == null ? void 0 : r.in);
  return e.setFullYear(e.getFullYear(), 0, 1), e.setHours(0, 0, 0, 0), e;
}
const Nt = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, St = (t, r, e) => {
  let n;
  const a = Nt[t];
  return typeof a == "string" ? n = a : r === 1 ? n = a.one : n = a.other.replace("{{count}}", r.toString()), e != null && e.addSuffix ? e.comparison && e.comparison > 0 ? "in " + n : n + " ago" : n;
};
function we(t) {
  return (r = {}) => {
    const e = r.width ? String(r.width) : t.defaultWidth;
    return t.formats[e] || t.formats[t.defaultWidth];
  };
}
const jt = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, It = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, qt = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, Lt = {
  date: we({
    formats: jt,
    defaultWidth: "full"
  }),
  time: we({
    formats: It,
    defaultWidth: "full"
  }),
  dateTime: we({
    formats: qt,
    defaultWidth: "full"
  })
}, At = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, Rt = (t, r, e, n) => At[t];
function se(t) {
  return (r, e) => {
    const n = e != null && e.context ? String(e.context) : "standalone";
    let a;
    if (n === "formatting" && t.formattingValues) {
      const i = t.defaultFormattingWidth || t.defaultWidth, o = e != null && e.width ? String(e.width) : i;
      a = t.formattingValues[o] || t.formattingValues[i];
    } else {
      const i = t.defaultWidth, o = e != null && e.width ? String(e.width) : t.defaultWidth;
      a = t.values[o] || t.values[i];
    }
    const s = t.argumentCallback ? t.argumentCallback(r) : r;
    return a[s];
  };
}
const Qt = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, $t = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, Bt = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, Gt = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, Xt = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, zt = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, Vt = (t, r) => {
  const e = Number(t), n = e % 100;
  if (n > 20 || n < 10)
    switch (n % 10) {
      case 1:
        return e + "st";
      case 2:
        return e + "nd";
      case 3:
        return e + "rd";
    }
  return e + "th";
}, Kt = {
  ordinalNumber: Vt,
  era: se({
    values: Qt,
    defaultWidth: "wide"
  }),
  quarter: se({
    values: $t,
    defaultWidth: "wide",
    argumentCallback: (t) => t - 1
  }),
  month: se({
    values: Bt,
    defaultWidth: "wide"
  }),
  day: se({
    values: Gt,
    defaultWidth: "wide"
  }),
  dayPeriod: se({
    values: Xt,
    defaultWidth: "wide",
    formattingValues: zt,
    defaultFormattingWidth: "wide"
  })
};
function ie(t) {
  return (r, e = {}) => {
    const n = e.width, a = n && t.matchPatterns[n] || t.matchPatterns[t.defaultMatchWidth], s = r.match(a);
    if (!s)
      return null;
    const i = s[0], o = n && t.parsePatterns[n] || t.parsePatterns[t.defaultParseWidth], d = Array.isArray(o) ? Zt(o, (y) => y.test(i)) : (
      // [TODO] -- I challenge you to fix the type
      Jt(o, (y) => y.test(i))
    );
    let m;
    m = t.valueCallback ? t.valueCallback(d) : d, m = e.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      e.valueCallback(m)
    ) : m;
    const c = r.slice(i.length);
    return { value: m, rest: c };
  };
}
function Jt(t, r) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e) && r(t[e]))
      return e;
}
function Zt(t, r) {
  for (let e = 0; e < t.length; e++)
    if (r(t[e]))
      return e;
}
function Ut(t) {
  return (r, e = {}) => {
    const n = r.match(t.matchPattern);
    if (!n)
      return null;
    const a = n[0], s = r.match(t.parsePattern);
    if (!s)
      return null;
    let i = t.valueCallback ? t.valueCallback(s[0]) : s[0];
    i = e.valueCallback ? e.valueCallback(i) : i;
    const o = r.slice(a.length);
    return { value: i, rest: o };
  };
}
const er = /^(\d+)(th|st|nd|rd)?/i, tr = /\d+/i, rr = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, nr = {
  any: [/^b/i, /^(a|c)/i]
}, ar = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, sr = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, ir = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, or = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, cr = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, ur = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, dr = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, lr = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, mr = {
  ordinalNumber: Ut({
    matchPattern: er,
    parsePattern: tr,
    valueCallback: (t) => parseInt(t, 10)
  }),
  era: ie({
    matchPatterns: rr,
    defaultMatchWidth: "wide",
    parsePatterns: nr,
    defaultParseWidth: "any"
  }),
  quarter: ie({
    matchPatterns: ar,
    defaultMatchWidth: "wide",
    parsePatterns: sr,
    defaultParseWidth: "any",
    valueCallback: (t) => t + 1
  }),
  month: ie({
    matchPatterns: ir,
    defaultMatchWidth: "wide",
    parsePatterns: or,
    defaultParseWidth: "any"
  }),
  day: ie({
    matchPatterns: cr,
    defaultMatchWidth: "wide",
    parsePatterns: ur,
    defaultParseWidth: "any"
  }),
  dayPeriod: ie({
    matchPatterns: dr,
    defaultMatchWidth: "any",
    parsePatterns: lr,
    defaultParseWidth: "any"
  })
}, at = {
  code: "en-US",
  formatDistance: St,
  formatLong: Lt,
  formatRelative: Rt,
  localize: Kt,
  match: mr,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function fr(t, r) {
  const e = E(t, r == null ? void 0 : r.in);
  return Ft(e, Ht(e)) + 1;
}
function st(t, r) {
  const e = E(t, r == null ? void 0 : r.in), n = +re(e) - +Wt(e);
  return Math.round(n / et) + 1;
}
function pe(t, r) {
  var c, y, h, D;
  const e = E(t, r == null ? void 0 : r.in), n = e.getFullYear(), a = ne(), s = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((y = (c = r == null ? void 0 : r.locale) == null ? void 0 : c.options) == null ? void 0 : y.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((D = (h = a.locale) == null ? void 0 : h.options) == null ? void 0 : D.firstWeekContainsDate) ?? 1, i = N((r == null ? void 0 : r.in) || t, 0);
  i.setFullYear(n + 1, 0, s), i.setHours(0, 0, 0, 0);
  const o = J(i, r), d = N((r == null ? void 0 : r.in) || t, 0);
  d.setFullYear(n, 0, s), d.setHours(0, 0, 0, 0);
  const m = J(d, r);
  return +e >= +o ? n + 1 : +e >= +m ? n : n - 1;
}
function hr(t, r) {
  var o, d, m, c;
  const e = ne(), n = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((d = (o = r == null ? void 0 : r.locale) == null ? void 0 : o.options) == null ? void 0 : d.firstWeekContainsDate) ?? e.firstWeekContainsDate ?? ((c = (m = e.locale) == null ? void 0 : m.options) == null ? void 0 : c.firstWeekContainsDate) ?? 1, a = pe(t, r), s = N((r == null ? void 0 : r.in) || t, 0);
  return s.setFullYear(a, 0, n), s.setHours(0, 0, 0, 0), J(s, r);
}
function it(t, r) {
  const e = E(t, r == null ? void 0 : r.in), n = +J(e, r) - +hr(e, r);
  return Math.round(n / et) + 1;
}
function k(t, r) {
  const e = t < 0 ? "-" : "", n = Math.abs(t).toString().padStart(r, "0");
  return e + n;
}
const K = {
  // Year
  y(t, r) {
    const e = t.getFullYear(), n = e > 0 ? e : 1 - e;
    return k(r === "yy" ? n % 100 : n, r.length);
  },
  // Month
  M(t, r) {
    const e = t.getMonth();
    return r === "M" ? String(e + 1) : k(e + 1, 2);
  },
  // Day of the month
  d(t, r) {
    return k(t.getDate(), r.length);
  },
  // AM or PM
  a(t, r) {
    const e = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (r) {
      case "a":
      case "aa":
        return e.toUpperCase();
      case "aaa":
        return e;
      case "aaaaa":
        return e[0];
      case "aaaa":
      default:
        return e === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(t, r) {
    return k(t.getHours() % 12 || 12, r.length);
  },
  // Hour [0-23]
  H(t, r) {
    return k(t.getHours(), r.length);
  },
  // Minute
  m(t, r) {
    return k(t.getMinutes(), r.length);
  },
  // Second
  s(t, r) {
    return k(t.getSeconds(), r.length);
  },
  // Fraction of second
  S(t, r) {
    const e = r.length, n = t.getMilliseconds(), a = Math.trunc(
      n * Math.pow(10, e - 3)
    );
    return k(a, r.length);
  }
}, ee = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, Le = {
  // Era
  G: function(t, r, e) {
    const n = t.getFullYear() > 0 ? 1 : 0;
    switch (r) {
      case "G":
      case "GG":
      case "GGG":
        return e.era(n, { width: "abbreviated" });
      case "GGGGG":
        return e.era(n, { width: "narrow" });
      case "GGGG":
      default:
        return e.era(n, { width: "wide" });
    }
  },
  // Year
  y: function(t, r, e) {
    if (r === "yo") {
      const n = t.getFullYear(), a = n > 0 ? n : 1 - n;
      return e.ordinalNumber(a, { unit: "year" });
    }
    return K.y(t, r);
  },
  // Local week-numbering year
  Y: function(t, r, e, n) {
    const a = pe(t, n), s = a > 0 ? a : 1 - a;
    if (r === "YY") {
      const i = s % 100;
      return k(i, 2);
    }
    return r === "Yo" ? e.ordinalNumber(s, { unit: "year" }) : k(s, r.length);
  },
  // ISO week-numbering year
  R: function(t, r) {
    const e = nt(t);
    return k(e, r.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t, r) {
    const e = t.getFullYear();
    return k(e, r.length);
  },
  // Quarter
  Q: function(t, r, e) {
    const n = Math.ceil((t.getMonth() + 1) / 3);
    switch (r) {
      case "Q":
        return String(n);
      case "QQ":
        return k(n, 2);
      case "Qo":
        return e.ordinalNumber(n, { unit: "quarter" });
      case "QQQ":
        return e.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return e.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return e.quarter(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t, r, e) {
    const n = Math.ceil((t.getMonth() + 1) / 3);
    switch (r) {
      case "q":
        return String(n);
      case "qq":
        return k(n, 2);
      case "qo":
        return e.ordinalNumber(n, { unit: "quarter" });
      case "qqq":
        return e.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return e.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return e.quarter(n, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t, r, e) {
    const n = t.getMonth();
    switch (r) {
      case "M":
      case "MM":
        return K.M(t, r);
      case "Mo":
        return e.ordinalNumber(n + 1, { unit: "month" });
      case "MMM":
        return e.month(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return e.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return e.month(n, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(t, r, e) {
    const n = t.getMonth();
    switch (r) {
      case "L":
        return String(n + 1);
      case "LL":
        return k(n + 1, 2);
      case "Lo":
        return e.ordinalNumber(n + 1, { unit: "month" });
      case "LLL":
        return e.month(n, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return e.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return e.month(n, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(t, r, e, n) {
    const a = it(t, n);
    return r === "wo" ? e.ordinalNumber(a, { unit: "week" }) : k(a, r.length);
  },
  // ISO week of year
  I: function(t, r, e) {
    const n = st(t);
    return r === "Io" ? e.ordinalNumber(n, { unit: "week" }) : k(n, r.length);
  },
  // Day of the month
  d: function(t, r, e) {
    return r === "do" ? e.ordinalNumber(t.getDate(), { unit: "date" }) : K.d(t, r);
  },
  // Day of year
  D: function(t, r, e) {
    const n = fr(t);
    return r === "Do" ? e.ordinalNumber(n, { unit: "dayOfYear" }) : k(n, r.length);
  },
  // Day of week
  E: function(t, r, e) {
    const n = t.getDay();
    switch (r) {
      case "E":
      case "EE":
      case "EEE":
        return e.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return e.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return e.day(n, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return e.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t, r, e, n) {
    const a = t.getDay(), s = (a - n.weekStartsOn + 8) % 7 || 7;
    switch (r) {
      case "e":
        return String(s);
      case "ee":
        return k(s, 2);
      case "eo":
        return e.ordinalNumber(s, { unit: "day" });
      case "eee":
        return e.day(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return e.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return e.day(a, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return e.day(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t, r, e, n) {
    const a = t.getDay(), s = (a - n.weekStartsOn + 8) % 7 || 7;
    switch (r) {
      case "c":
        return String(s);
      case "cc":
        return k(s, r.length);
      case "co":
        return e.ordinalNumber(s, { unit: "day" });
      case "ccc":
        return e.day(a, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return e.day(a, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return e.day(a, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return e.day(a, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t, r, e) {
    const n = t.getDay(), a = n === 0 ? 7 : n;
    switch (r) {
      case "i":
        return String(a);
      case "ii":
        return k(a, r.length);
      case "io":
        return e.ordinalNumber(a, { unit: "day" });
      case "iii":
        return e.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return e.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return e.day(n, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return e.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t, r, e) {
    const a = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (r) {
      case "a":
      case "aa":
        return e.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return e.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return e.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return e.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t, r, e) {
    const n = t.getHours();
    let a;
    switch (n === 12 ? a = ee.noon : n === 0 ? a = ee.midnight : a = n / 12 >= 1 ? "pm" : "am", r) {
      case "b":
      case "bb":
        return e.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return e.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return e.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return e.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t, r, e) {
    const n = t.getHours();
    let a;
    switch (n >= 17 ? a = ee.evening : n >= 12 ? a = ee.afternoon : n >= 4 ? a = ee.morning : a = ee.night, r) {
      case "B":
      case "BB":
      case "BBB":
        return e.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return e.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return e.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t, r, e) {
    if (r === "ho") {
      let n = t.getHours() % 12;
      return n === 0 && (n = 12), e.ordinalNumber(n, { unit: "hour" });
    }
    return K.h(t, r);
  },
  // Hour [0-23]
  H: function(t, r, e) {
    return r === "Ho" ? e.ordinalNumber(t.getHours(), { unit: "hour" }) : K.H(t, r);
  },
  // Hour [0-11]
  K: function(t, r, e) {
    const n = t.getHours() % 12;
    return r === "Ko" ? e.ordinalNumber(n, { unit: "hour" }) : k(n, r.length);
  },
  // Hour [1-24]
  k: function(t, r, e) {
    let n = t.getHours();
    return n === 0 && (n = 24), r === "ko" ? e.ordinalNumber(n, { unit: "hour" }) : k(n, r.length);
  },
  // Minute
  m: function(t, r, e) {
    return r === "mo" ? e.ordinalNumber(t.getMinutes(), { unit: "minute" }) : K.m(t, r);
  },
  // Second
  s: function(t, r, e) {
    return r === "so" ? e.ordinalNumber(t.getSeconds(), { unit: "second" }) : K.s(t, r);
  },
  // Fraction of second
  S: function(t, r) {
    return K.S(t, r);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t, r, e) {
    const n = t.getTimezoneOffset();
    if (n === 0)
      return "Z";
    switch (r) {
      case "X":
        return Re(n);
      case "XXXX":
      case "XX":
        return U(n);
      case "XXXXX":
      case "XXX":
      default:
        return U(n, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t, r, e) {
    const n = t.getTimezoneOffset();
    switch (r) {
      case "x":
        return Re(n);
      case "xxxx":
      case "xx":
        return U(n);
      case "xxxxx":
      case "xxx":
      default:
        return U(n, ":");
    }
  },
  // Timezone (GMT)
  O: function(t, r, e) {
    const n = t.getTimezoneOffset();
    switch (r) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + Ae(n, ":");
      case "OOOO":
      default:
        return "GMT" + U(n, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t, r, e) {
    const n = t.getTimezoneOffset();
    switch (r) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + Ae(n, ":");
      case "zzzz":
      default:
        return "GMT" + U(n, ":");
    }
  },
  // Seconds timestamp
  t: function(t, r, e) {
    const n = Math.trunc(+t / 1e3);
    return k(n, r.length);
  },
  // Milliseconds timestamp
  T: function(t, r, e) {
    return k(+t, r.length);
  }
};
function Ae(t, r = "") {
  const e = t > 0 ? "-" : "+", n = Math.abs(t), a = Math.trunc(n / 60), s = n % 60;
  return s === 0 ? e + String(a) : e + String(a) + r + k(s, 2);
}
function Re(t, r) {
  return t % 60 === 0 ? (t > 0 ? "-" : "+") + k(Math.abs(t) / 60, 2) : U(t, r);
}
function U(t, r = "") {
  const e = t > 0 ? "-" : "+", n = Math.abs(t), a = k(Math.trunc(n / 60), 2), s = k(n % 60, 2);
  return e + a + r + s;
}
const Qe = (t, r) => {
  switch (t) {
    case "P":
      return r.date({ width: "short" });
    case "PP":
      return r.date({ width: "medium" });
    case "PPP":
      return r.date({ width: "long" });
    case "PPPP":
    default:
      return r.date({ width: "full" });
  }
}, ot = (t, r) => {
  switch (t) {
    case "p":
      return r.time({ width: "short" });
    case "pp":
      return r.time({ width: "medium" });
    case "ppp":
      return r.time({ width: "long" });
    case "pppp":
    default:
      return r.time({ width: "full" });
  }
}, yr = (t, r) => {
  const e = t.match(/(P+)(p+)?/) || [], n = e[1], a = e[2];
  if (!a)
    return Qe(t, r);
  let s;
  switch (n) {
    case "P":
      s = r.dateTime({ width: "short" });
      break;
    case "PP":
      s = r.dateTime({ width: "medium" });
      break;
    case "PPP":
      s = r.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      s = r.dateTime({ width: "full" });
      break;
  }
  return s.replace("{{date}}", Qe(n, r)).replace("{{time}}", ot(a, r));
}, xe = {
  p: ot,
  P: yr
}, wr = /^D+$/, xr = /^Y+$/, br = ["D", "DD", "YY", "YYYY"];
function ct(t) {
  return wr.test(t);
}
function ut(t) {
  return xr.test(t);
}
function be(t, r, e) {
  const n = gr(t, r, e);
  if (console.warn(n), br.includes(t))
    throw new RangeError(n);
}
function gr(t, r, e) {
  const n = t[0] === "Y" ? "years" : "days of the month";
  return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${r}\`) for formatting ${n} to the input \`${e}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const Dr = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, Mr = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, pr = /^'([^]*?)'?$/, Tr = /''/g, kr = /[a-zA-Z]/;
function Z(t, r, e) {
  var c, y, h, D, g, Y, F, H;
  const n = ne(), a = (e == null ? void 0 : e.locale) ?? n.locale ?? at, s = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((y = (c = e == null ? void 0 : e.locale) == null ? void 0 : c.options) == null ? void 0 : y.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((D = (h = n.locale) == null ? void 0 : h.options) == null ? void 0 : D.firstWeekContainsDate) ?? 1, i = (e == null ? void 0 : e.weekStartsOn) ?? ((Y = (g = e == null ? void 0 : e.locale) == null ? void 0 : g.options) == null ? void 0 : Y.weekStartsOn) ?? n.weekStartsOn ?? ((H = (F = n.locale) == null ? void 0 : F.options) == null ? void 0 : H.weekStartsOn) ?? 0, o = E(t, e == null ? void 0 : e.in);
  if (!me(o))
    throw new RangeError("Invalid time value");
  let d = r.match(Mr).map((p) => {
    const f = p[0];
    if (f === "p" || f === "P") {
      const j = xe[f];
      return j(p, a.formatLong);
    }
    return p;
  }).join("").match(Dr).map((p) => {
    if (p === "''")
      return { isToken: !1, value: "'" };
    const f = p[0];
    if (f === "'")
      return { isToken: !1, value: Pr(p) };
    if (Le[f])
      return { isToken: !0, value: p };
    if (f.match(kr))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + f + "`"
      );
    return { isToken: !1, value: p };
  });
  a.localize.preprocessor && (d = a.localize.preprocessor(o, d));
  const m = {
    firstWeekContainsDate: s,
    weekStartsOn: i,
    locale: a
  };
  return d.map((p) => {
    if (!p.isToken)
      return p.value;
    const f = p.value;
    (!(e != null && e.useAdditionalWeekYearTokens) && ut(f) || !(e != null && e.useAdditionalDayOfYearTokens) && ct(f)) && be(f, r, String(t));
    const j = Le[f[0]];
    return j(o, f, a.localize, m);
  }).join("");
}
function Pr(t) {
  const r = t.match(pr);
  return r ? r[1].replace(Tr, "'") : t;
}
function Er() {
  return Object.assign({}, ne());
}
function Or(t, r) {
  const e = E(t, r == null ? void 0 : r.in).getDay();
  return e === 0 ? 7 : e;
}
function Cr(t, r) {
  return +E(t) > +E(r);
}
function _r(t, r) {
  const e = Yr(r) ? new r(0) : N(r, 0);
  return e.setFullYear(t.getFullYear(), t.getMonth(), t.getDate()), e.setHours(
    t.getHours(),
    t.getMinutes(),
    t.getSeconds(),
    t.getMilliseconds()
  ), e;
}
function Yr(t) {
  var r;
  return typeof t == "function" && ((r = t.prototype) == null ? void 0 : r.constructor) === t;
}
const Fr = 10;
class dt {
  constructor() {
    u(this, "subPriority", 0);
  }
  validate(r, e) {
    return !0;
  }
}
class Wr extends dt {
  constructor(r, e, n, a, s) {
    super(), this.value = r, this.validateValue = e, this.setValue = n, this.priority = a, s && (this.subPriority = s);
  }
  validate(r, e) {
    return this.validateValue(r, this.value, e);
  }
  set(r, e, n) {
    return this.setValue(r, e, this.value, n);
  }
}
class vr extends dt {
  constructor(e, n) {
    super();
    u(this, "priority", Fr);
    u(this, "subPriority", -1);
    this.context = e || ((a) => N(n, a));
  }
  set(e, n) {
    return n.timestampIsSet ? e : N(e, _r(e, this.context));
  }
}
class M {
  run(r, e, n, a) {
    const s = this.parse(r, e, n, a);
    return s ? {
      setter: new Wr(
        s.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: s.rest
    } : null;
  }
  validate(r, e, n) {
    return !0;
  }
}
class Hr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 140);
    u(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "G":
      case "GG":
      case "GGG":
        return a.era(e, { width: "abbreviated" }) || a.era(e, { width: "narrow" });
      case "GGGGG":
        return a.era(e, { width: "narrow" });
      case "GGGG":
      default:
        return a.era(e, { width: "wide" }) || a.era(e, { width: "abbreviated" }) || a.era(e, { width: "narrow" });
    }
  }
  set(e, n, a) {
    return n.era = a, e.setFullYear(a, 0, 1), e.setHours(0, 0, 0, 0), e;
  }
}
const W = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, Q = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function v(t, r) {
  return t && {
    value: r(t.value),
    rest: t.rest
  };
}
function C(t, r) {
  const e = r.match(t);
  return e ? {
    value: parseInt(e[0], 10),
    rest: r.slice(e[0].length)
  } : null;
}
function $(t, r) {
  const e = r.match(t);
  if (!e)
    return null;
  if (e[0] === "Z")
    return {
      value: 0,
      rest: r.slice(1)
    };
  const n = e[1] === "+" ? 1 : -1, a = e[2] ? parseInt(e[2], 10) : 0, s = e[3] ? parseInt(e[3], 10) : 0, i = e[5] ? parseInt(e[5], 10) : 0;
  return {
    value: n * (a * Ot + s * Et + i * Ct),
    rest: r.slice(e[0].length)
  };
}
function lt(t) {
  return C(W.anyDigitsSigned, t);
}
function _(t, r) {
  switch (t) {
    case 1:
      return C(W.singleDigit, r);
    case 2:
      return C(W.twoDigits, r);
    case 3:
      return C(W.threeDigits, r);
    case 4:
      return C(W.fourDigits, r);
    default:
      return C(new RegExp("^\\d{1," + t + "}"), r);
  }
}
function le(t, r) {
  switch (t) {
    case 1:
      return C(W.singleDigitSigned, r);
    case 2:
      return C(W.twoDigitsSigned, r);
    case 3:
      return C(W.threeDigitsSigned, r);
    case 4:
      return C(W.fourDigitsSigned, r);
    default:
      return C(new RegExp("^-?\\d{1," + t + "}"), r);
  }
}
function Te(t) {
  switch (t) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function mt(t, r) {
  const e = r > 0, n = e ? r : 1 - r;
  let a;
  if (n <= 50)
    a = t || 100;
  else {
    const s = n + 50, i = Math.trunc(s / 100) * 100, o = t >= s % 100;
    a = t + i - (o ? 100 : 0);
  }
  return e ? a : 1 - a;
}
function ft(t) {
  return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0;
}
class Nr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 130);
    u(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(e, n, a) {
    const s = (i) => ({
      year: i,
      isTwoDigitYear: n === "yy"
    });
    switch (n) {
      case "y":
        return v(_(4, e), s);
      case "yo":
        return v(
          a.ordinalNumber(e, {
            unit: "year"
          }),
          s
        );
      default:
        return v(_(n.length, e), s);
    }
  }
  validate(e, n) {
    return n.isTwoDigitYear || n.year > 0;
  }
  set(e, n, a) {
    const s = e.getFullYear();
    if (a.isTwoDigitYear) {
      const o = mt(
        a.year,
        s
      );
      return e.setFullYear(o, 0, 1), e.setHours(0, 0, 0, 0), e;
    }
    const i = !("era" in n) || n.era === 1 ? a.year : 1 - a.year;
    return e.setFullYear(i, 0, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Sr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 130);
    u(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    const s = (i) => ({
      year: i,
      isTwoDigitYear: n === "YY"
    });
    switch (n) {
      case "Y":
        return v(_(4, e), s);
      case "Yo":
        return v(
          a.ordinalNumber(e, {
            unit: "year"
          }),
          s
        );
      default:
        return v(_(n.length, e), s);
    }
  }
  validate(e, n) {
    return n.isTwoDigitYear || n.year > 0;
  }
  set(e, n, a, s) {
    const i = pe(e, s);
    if (a.isTwoDigitYear) {
      const d = mt(
        a.year,
        i
      );
      return e.setFullYear(
        d,
        0,
        s.firstWeekContainsDate
      ), e.setHours(0, 0, 0, 0), J(e, s);
    }
    const o = !("era" in n) || n.era === 1 ? a.year : 1 - a.year;
    return e.setFullYear(o, 0, s.firstWeekContainsDate), e.setHours(0, 0, 0, 0), J(e, s);
  }
}
class jr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 130);
    u(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n) {
    return le(n === "R" ? 4 : n.length, e);
  }
  set(e, n, a) {
    const s = N(e, 0);
    return s.setFullYear(a, 0, 4), s.setHours(0, 0, 0, 0), re(s);
  }
}
class Ir extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 130);
    u(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(e, n) {
    return le(n === "u" ? 4 : n.length, e);
  }
  set(e, n, a) {
    return e.setFullYear(a, 0, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class qr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 120);
    u(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    switch (n) {
      case "Q":
      case "QQ":
        return _(n.length, e);
      case "Qo":
        return a.ordinalNumber(e, { unit: "quarter" });
      case "QQQ":
        return a.quarter(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.quarter(e, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return a.quarter(e, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return a.quarter(e, {
          width: "wide",
          context: "formatting"
        }) || a.quarter(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.quarter(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(e, n) {
    return n >= 1 && n <= 4;
  }
  set(e, n, a) {
    return e.setMonth((a - 1) * 3, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Lr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 120);
    u(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    switch (n) {
      case "q":
      case "qq":
        return _(n.length, e);
      case "qo":
        return a.ordinalNumber(e, { unit: "quarter" });
      case "qqq":
        return a.quarter(e, {
          width: "abbreviated",
          context: "standalone"
        }) || a.quarter(e, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return a.quarter(e, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return a.quarter(e, {
          width: "wide",
          context: "standalone"
        }) || a.quarter(e, {
          width: "abbreviated",
          context: "standalone"
        }) || a.quarter(e, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(e, n) {
    return n >= 1 && n <= 4;
  }
  set(e, n, a) {
    return e.setMonth((a - 1) * 3, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Ar extends M {
  constructor() {
    super(...arguments);
    u(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    u(this, "priority", 110);
  }
  parse(e, n, a) {
    const s = (i) => i - 1;
    switch (n) {
      case "M":
        return v(
          C(W.month, e),
          s
        );
      case "MM":
        return v(_(2, e), s);
      case "Mo":
        return v(
          a.ordinalNumber(e, {
            unit: "month"
          }),
          s
        );
      case "MMM":
        return a.month(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.month(e, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return a.month(e, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return a.month(e, { width: "wide", context: "formatting" }) || a.month(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.month(e, { width: "narrow", context: "formatting" });
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 11;
  }
  set(e, n, a) {
    return e.setMonth(a, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Rr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 110);
    u(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    const s = (i) => i - 1;
    switch (n) {
      case "L":
        return v(
          C(W.month, e),
          s
        );
      case "LL":
        return v(_(2, e), s);
      case "Lo":
        return v(
          a.ordinalNumber(e, {
            unit: "month"
          }),
          s
        );
      case "LLL":
        return a.month(e, {
          width: "abbreviated",
          context: "standalone"
        }) || a.month(e, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return a.month(e, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return a.month(e, { width: "wide", context: "standalone" }) || a.month(e, {
          width: "abbreviated",
          context: "standalone"
        }) || a.month(e, { width: "narrow", context: "standalone" });
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 11;
  }
  set(e, n, a) {
    return e.setMonth(a, 1), e.setHours(0, 0, 0, 0), e;
  }
}
function Qr(t, r, e) {
  const n = E(t, e == null ? void 0 : e.in), a = it(n, e) - r;
  return n.setDate(n.getDate() - a * 7), E(n, e == null ? void 0 : e.in);
}
class $r extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 100);
    u(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    switch (n) {
      case "w":
        return C(W.week, e);
      case "wo":
        return a.ordinalNumber(e, { unit: "week" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 1 && n <= 53;
  }
  set(e, n, a, s) {
    return J(Qr(e, a, s), s);
  }
}
function Br(t, r, e) {
  const n = E(t, e == null ? void 0 : e.in), a = st(n, e) - r;
  return n.setDate(n.getDate() - a * 7), n;
}
class Gr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 100);
    u(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    switch (n) {
      case "I":
        return C(W.week, e);
      case "Io":
        return a.ordinalNumber(e, { unit: "week" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 1 && n <= 53;
  }
  set(e, n, a) {
    return re(Br(e, a));
  }
}
const Xr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], zr = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class Vr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 90);
    u(this, "subPriority", 1);
    u(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    switch (n) {
      case "d":
        return C(W.date, e);
      case "do":
        return a.ordinalNumber(e, { unit: "date" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    const a = e.getFullYear(), s = ft(a), i = e.getMonth();
    return s ? n >= 1 && n <= zr[i] : n >= 1 && n <= Xr[i];
  }
  set(e, n, a) {
    return e.setDate(a), e.setHours(0, 0, 0, 0), e;
  }
}
class Kr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 90);
    u(this, "subpriority", 1);
    u(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    switch (n) {
      case "D":
      case "DD":
        return C(W.dayOfYear, e);
      case "Do":
        return a.ordinalNumber(e, { unit: "date" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    const a = e.getFullYear();
    return ft(a) ? n >= 1 && n <= 366 : n >= 1 && n <= 365;
  }
  set(e, n, a) {
    return e.setMonth(0, a), e.setHours(0, 0, 0, 0), e;
  }
}
function ke(t, r, e) {
  var y, h, D, g;
  const n = ne(), a = (e == null ? void 0 : e.weekStartsOn) ?? ((h = (y = e == null ? void 0 : e.locale) == null ? void 0 : y.options) == null ? void 0 : h.weekStartsOn) ?? n.weekStartsOn ?? ((g = (D = n.locale) == null ? void 0 : D.options) == null ? void 0 : g.weekStartsOn) ?? 0, s = E(t, e == null ? void 0 : e.in), i = s.getDay(), d = (r % 7 + 7) % 7, m = 7 - a, c = r < 0 || r > 6 ? r - (i + m) % 7 : (d + m) % 7 - (i + m) % 7;
  return tt(s, c, e);
}
class Jr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 90);
    u(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "E":
      case "EE":
      case "EEE":
        return a.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(e, { width: "short", context: "formatting" }) || a.day(e, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return a.day(e, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return a.day(e, { width: "short", context: "formatting" }) || a.day(e, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return a.day(e, { width: "wide", context: "formatting" }) || a.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(e, { width: "short", context: "formatting" }) || a.day(e, { width: "narrow", context: "formatting" });
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 6;
  }
  set(e, n, a, s) {
    return e = ke(e, a, s), e.setHours(0, 0, 0, 0), e;
  }
}
class Zr extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 90);
    u(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a, s) {
    const i = (o) => {
      const d = Math.floor((o - 1) / 7) * 7;
      return (o + s.weekStartsOn + 6) % 7 + d;
    };
    switch (n) {
      case "e":
      case "ee":
        return v(_(n.length, e), i);
      case "eo":
        return v(
          a.ordinalNumber(e, {
            unit: "day"
          }),
          i
        );
      case "eee":
        return a.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(e, { width: "short", context: "formatting" }) || a.day(e, { width: "narrow", context: "formatting" });
      case "eeeee":
        return a.day(e, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return a.day(e, { width: "short", context: "formatting" }) || a.day(e, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return a.day(e, { width: "wide", context: "formatting" }) || a.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.day(e, { width: "short", context: "formatting" }) || a.day(e, { width: "narrow", context: "formatting" });
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 6;
  }
  set(e, n, a, s) {
    return e = ke(e, a, s), e.setHours(0, 0, 0, 0), e;
  }
}
class Ur extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 90);
    u(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(e, n, a, s) {
    const i = (o) => {
      const d = Math.floor((o - 1) / 7) * 7;
      return (o + s.weekStartsOn + 6) % 7 + d;
    };
    switch (n) {
      case "c":
      case "cc":
        return v(_(n.length, e), i);
      case "co":
        return v(
          a.ordinalNumber(e, {
            unit: "day"
          }),
          i
        );
      case "ccc":
        return a.day(e, {
          width: "abbreviated",
          context: "standalone"
        }) || a.day(e, { width: "short", context: "standalone" }) || a.day(e, { width: "narrow", context: "standalone" });
      case "ccccc":
        return a.day(e, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return a.day(e, { width: "short", context: "standalone" }) || a.day(e, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return a.day(e, { width: "wide", context: "standalone" }) || a.day(e, {
          width: "abbreviated",
          context: "standalone"
        }) || a.day(e, { width: "short", context: "standalone" }) || a.day(e, { width: "narrow", context: "standalone" });
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 6;
  }
  set(e, n, a, s) {
    return e = ke(e, a, s), e.setHours(0, 0, 0, 0), e;
  }
}
function en(t, r, e) {
  const n = E(t, e == null ? void 0 : e.in), a = Or(n, e), s = r - a;
  return tt(n, s, e);
}
class tn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 90);
    u(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, n, a) {
    const s = (i) => i === 0 ? 7 : i;
    switch (n) {
      case "i":
      case "ii":
        return _(n.length, e);
      case "io":
        return a.ordinalNumber(e, { unit: "day" });
      case "iii":
        return v(
          a.day(e, {
            width: "abbreviated",
            context: "formatting"
          }) || a.day(e, {
            width: "short",
            context: "formatting"
          }) || a.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
      case "iiiii":
        return v(
          a.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
      case "iiiiii":
        return v(
          a.day(e, {
            width: "short",
            context: "formatting"
          }) || a.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
      case "iiii":
      default:
        return v(
          a.day(e, {
            width: "wide",
            context: "formatting"
          }) || a.day(e, {
            width: "abbreviated",
            context: "formatting"
          }) || a.day(e, {
            width: "short",
            context: "formatting"
          }) || a.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
    }
  }
  validate(e, n) {
    return n >= 1 && n <= 7;
  }
  set(e, n, a) {
    return e = en(e, a), e.setHours(0, 0, 0, 0), e;
  }
}
class rn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 80);
    u(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "a":
      case "aa":
      case "aaa":
        return a.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return a.dayPeriod(e, {
          width: "wide",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(e, n, a) {
    return e.setHours(Te(a), 0, 0, 0), e;
  }
}
class nn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 80);
    u(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "b":
      case "bb":
      case "bbb":
        return a.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return a.dayPeriod(e, {
          width: "wide",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(e, n, a) {
    return e.setHours(Te(a), 0, 0, 0), e;
  }
}
class an extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 80);
    u(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "B":
      case "BB":
      case "BBB":
        return a.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return a.dayPeriod(e, {
          width: "wide",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || a.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(e, n, a) {
    return e.setHours(Te(a), 0, 0, 0), e;
  }
}
class sn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 70);
    u(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "h":
        return C(W.hour12h, e);
      case "ho":
        return a.ordinalNumber(e, { unit: "hour" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 1 && n <= 12;
  }
  set(e, n, a) {
    const s = e.getHours() >= 12;
    return s && a < 12 ? e.setHours(a + 12, 0, 0, 0) : !s && a === 12 ? e.setHours(0, 0, 0, 0) : e.setHours(a, 0, 0, 0), e;
  }
}
class on extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 70);
    u(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "H":
        return C(W.hour23h, e);
      case "Ho":
        return a.ordinalNumber(e, { unit: "hour" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 23;
  }
  set(e, n, a) {
    return e.setHours(a, 0, 0, 0), e;
  }
}
class cn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 70);
    u(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "K":
        return C(W.hour11h, e);
      case "Ko":
        return a.ordinalNumber(e, { unit: "hour" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 11;
  }
  set(e, n, a) {
    return e.getHours() >= 12 && a < 12 ? e.setHours(a + 12, 0, 0, 0) : e.setHours(a, 0, 0, 0), e;
  }
}
class un extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 70);
    u(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "k":
        return C(W.hour24h, e);
      case "ko":
        return a.ordinalNumber(e, { unit: "hour" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 1 && n <= 24;
  }
  set(e, n, a) {
    const s = a <= 24 ? a % 24 : a;
    return e.setHours(s, 0, 0, 0), e;
  }
}
class dn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 60);
    u(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "m":
        return C(W.minute, e);
      case "mo":
        return a.ordinalNumber(e, { unit: "minute" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 59;
  }
  set(e, n, a) {
    return e.setMinutes(a, 0, 0), e;
  }
}
class ln extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 50);
    u(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(e, n, a) {
    switch (n) {
      case "s":
        return C(W.second, e);
      case "so":
        return a.ordinalNumber(e, { unit: "second" });
      default:
        return _(n.length, e);
    }
  }
  validate(e, n) {
    return n >= 0 && n <= 59;
  }
  set(e, n, a) {
    return e.setSeconds(a, 0), e;
  }
}
class mn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 30);
    u(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(e, n) {
    const a = (s) => Math.trunc(s * Math.pow(10, -n.length + 3));
    return v(_(n.length, e), a);
  }
  set(e, n, a) {
    return e.setMilliseconds(a), e;
  }
}
class fn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 10);
    u(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(e, n) {
    switch (n) {
      case "X":
        return $(
          Q.basicOptionalMinutes,
          e
        );
      case "XX":
        return $(Q.basic, e);
      case "XXXX":
        return $(
          Q.basicOptionalSeconds,
          e
        );
      case "XXXXX":
        return $(
          Q.extendedOptionalSeconds,
          e
        );
      case "XXX":
      default:
        return $(Q.extended, e);
    }
  }
  set(e, n, a) {
    return n.timestampIsSet ? e : N(
      e,
      e.getTime() - de(e) - a
    );
  }
}
class hn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 10);
    u(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(e, n) {
    switch (n) {
      case "x":
        return $(
          Q.basicOptionalMinutes,
          e
        );
      case "xx":
        return $(Q.basic, e);
      case "xxxx":
        return $(
          Q.basicOptionalSeconds,
          e
        );
      case "xxxxx":
        return $(
          Q.extendedOptionalSeconds,
          e
        );
      case "xxx":
      default:
        return $(Q.extended, e);
    }
  }
  set(e, n, a) {
    return n.timestampIsSet ? e : N(
      e,
      e.getTime() - de(e) - a
    );
  }
}
class yn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 40);
    u(this, "incompatibleTokens", "*");
  }
  parse(e) {
    return lt(e);
  }
  set(e, n, a) {
    return [N(e, a * 1e3), { timestampIsSet: !0 }];
  }
}
class wn extends M {
  constructor() {
    super(...arguments);
    u(this, "priority", 20);
    u(this, "incompatibleTokens", "*");
  }
  parse(e) {
    return lt(e);
  }
  set(e, n, a) {
    return [N(e, a), { timestampIsSet: !0 }];
  }
}
const xn = {
  G: new Hr(),
  y: new Nr(),
  Y: new Sr(),
  R: new jr(),
  u: new Ir(),
  Q: new qr(),
  q: new Lr(),
  M: new Ar(),
  L: new Rr(),
  w: new $r(),
  I: new Gr(),
  d: new Vr(),
  D: new Kr(),
  E: new Jr(),
  e: new Zr(),
  c: new Ur(),
  i: new tn(),
  a: new rn(),
  b: new nn(),
  B: new an(),
  h: new sn(),
  H: new on(),
  K: new cn(),
  k: new un(),
  m: new dn(),
  s: new ln(),
  S: new mn(),
  X: new fn(),
  x: new hn(),
  t: new yn(),
  T: new wn()
}, bn = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, gn = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Dn = /^'([^]*?)'?$/, Mn = /''/g, pn = /\S/, Tn = /[a-zA-Z]/;
function ht(t, r, e, n) {
  var F, H, p, f, j, B, G, X;
  const a = () => N((n == null ? void 0 : n.in) || e, NaN), s = Er(), i = (n == null ? void 0 : n.locale) ?? s.locale ?? at, o = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((H = (F = n == null ? void 0 : n.locale) == null ? void 0 : F.options) == null ? void 0 : H.firstWeekContainsDate) ?? s.firstWeekContainsDate ?? ((f = (p = s.locale) == null ? void 0 : p.options) == null ? void 0 : f.firstWeekContainsDate) ?? 1, d = (n == null ? void 0 : n.weekStartsOn) ?? ((B = (j = n == null ? void 0 : n.locale) == null ? void 0 : j.options) == null ? void 0 : B.weekStartsOn) ?? s.weekStartsOn ?? ((X = (G = s.locale) == null ? void 0 : G.options) == null ? void 0 : X.weekStartsOn) ?? 0;
  if (!r)
    return t ? a() : E(e, n == null ? void 0 : n.in);
  const m = {
    firstWeekContainsDate: o,
    weekStartsOn: d,
    locale: i
  }, c = [new vr(n == null ? void 0 : n.in, e)], y = r.match(gn).map((w) => {
    const T = w[0];
    if (T in xe) {
      const x = xe[T];
      return x(w, i.formatLong);
    }
    return w;
  }).join("").match(bn), h = [];
  for (let w of y) {
    !(n != null && n.useAdditionalWeekYearTokens) && ut(w) && be(w, r, t), !(n != null && n.useAdditionalDayOfYearTokens) && ct(w) && be(w, r, t);
    const T = w[0], x = xn[T];
    if (x) {
      const { incompatibleTokens: z } = x;
      if (Array.isArray(z)) {
        const V = h.find(
          (R) => z.includes(R.token) || R.token === T
        );
        if (V)
          throw new RangeError(
            `The format string mustn't contain \`${V.fullToken}\` and \`${w}\` at the same time`
          );
      } else if (x.incompatibleTokens === "*" && h.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${w}\` and any other token at the same time`
        );
      h.push({ token: T, fullToken: w });
      const q = x.run(
        t,
        w,
        i.match,
        m
      );
      if (!q)
        return a();
      c.push(q.setter), t = q.rest;
    } else {
      if (T.match(Tn))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + T + "`"
        );
      if (w === "''" ? w = "'" : T === "'" && (w = kn(w)), t.indexOf(w) === 0)
        t = t.slice(w.length);
      else
        return a();
    }
  }
  if (t.length > 0 && pn.test(t))
    return a();
  const D = c.map((w) => w.priority).sort((w, T) => T - w).filter((w, T, x) => x.indexOf(w) === T).map(
    (w) => c.filter((T) => T.priority === w).sort((T, x) => x.subPriority - T.subPriority)
  ).map((w) => w[0]);
  let g = E(e, n == null ? void 0 : n.in);
  if (isNaN(+g))
    return a();
  const Y = {};
  for (const w of D) {
    if (!w.validate(g, m))
      return a();
    const T = w.set(g, Y, m);
    Array.isArray(T) ? (g = T[0], Object.assign(Y, T[1])) : g = T;
  }
  return g;
}
function kn(t) {
  return t.match(Dn)[1].replace(Mn, "'");
}
function Pn(t, r, e) {
  const n = +E(t, e == null ? void 0 : e.in), [a, s] = [
    +E(r.start, e == null ? void 0 : e.in),
    +E(r.end, e == null ? void 0 : e.in)
  ].sort((i, o) => i - o);
  return n >= a && n <= s;
}
function En(t, r, e) {
  return rt(t, -r, e);
}
const On = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], $e = {
  WIDTH: 7,
  HEIGHT: 6
}, fe = (t) => t.timeFormat === "12h" ? "12:00 AM" : "0:00", Cn = (t) => t >= 0 && t < 12 ? On[t] : (console.error("Can't get month name. Wrong month id range"), ""), _n = (t) => {
  const r = new Date(t);
  r.setDate(1);
  const e = r.getDay();
  r.setDate(r.getDate() - e);
  const n = [];
  for (let a = 0; a < $e.HEIGHT; a++) {
    const s = [];
    for (let i = 0; i < $e.WIDTH; i++) {
      const o = new Date(r);
      o.setDate(r.getDate() + i + a * 7), s.push(o);
    }
    n.push(s);
  }
  return n;
}, he = (t) => t ? Z(t, "d MMM yyyy") : "", Yn = (t, r, e) => {
  const n = /* @__PURE__ */ new Date();
  return t.isRange && e ? e.from ?? e.to : !t.isRange && r ? r.date : n;
}, Pe = (t) => {
  const r = new Date(t);
  return r.setHours(0, 0, 0, 0), r;
}, Fn = (t) => t != null && t.date ? Pe(t.date) : null, Wn = (t) => t != null && t.from ? Pe(t.from) : null, vn = (t) => t != null && t.to ? Pe(t.to) : null, Hn = (t, r) => t.hasTime && !(r != null && r.date) ? fe(t) : r != null && r.date && t.timeFormat === "12h" ? Z(r.date, "hh:mm a") : r != null && r.date ? Z(r.date, "HH:mm") : null, Nn = (t, r) => t.hasTime && !(r != null && r.from) ? fe(t) : r != null && r.from && t.timeFormat === "12h" ? Z(r.from, "hh:mm a") : r != null && r.from ? Z(r.from, "HH:mm") : null, Sn = (t, r) => t.hasTime && !(r != null && r.to) ? fe(t) : r != null && r.to && t.timeFormat === "12h" ? Z(r.to, "hh:mm a") : r != null && r.to ? Z(r.to, "HH:mm") : null, Be = (t, r) => t && r && Cr(t, r) ? { from: r, to: t } : { from: t, to: r }, ge = (t, r) => {
  if (r === "12h") {
    const e = t.trim().split(" "), [n, a] = e, [s, i] = n.split(":");
    let o = parseInt(s);
    const d = parseInt(i);
    return isNaN(o) || isNaN(d) ? (console.error("Invalid time format"), { hours: 0, minutes: 0 }) : ((a == null ? void 0 : a.toUpperCase()) === "PM" && o !== 12 ? o += 12 : (a == null ? void 0 : a.toUpperCase()) === "AM" && o === 12 && (o = 0), { hours: o, minutes: d });
  } else {
    const [e, n] = t.split(":"), a = parseInt(e), s = parseInt(n);
    return isNaN(a) || isNaN(s) ? (console.error("Invalid time format"), { hours: 0, minutes: 0 }) : { hours: a, minutes: s };
  }
}, Ge = (t, r) => {
  const e = t.date ? new Date(t.date) : null;
  if (e && t.time) {
    const { hours: n, minutes: a } = ge(t.time, r);
    e.setHours(n, a);
  }
  return e;
}, ue = (t, r) => {
  const e = t.from ? new Date(t.from) : null, n = t.to ? new Date(t.to) : null;
  if (e && t.fromTime) {
    const { hours: a, minutes: s } = ge(t.fromTime, r);
    e.setHours(a, s);
  }
  if (n && t.toTime) {
    const { hours: a, minutes: s } = ge(t.toTime, r);
    n.setHours(a, s);
  }
  return {
    from: e,
    to: n
  };
}, jn = O(S)(({ theme: t }) => ({
  display: "none",
  position: "absolute",
  top: 0,
  left: "-6px",
  right: "-6px",
  height: "100%",
  backgroundColor: t.palette.primary.light,
  zIndex: 0,
  "&.calendar_day_inside_range": {
    display: "block"
  },
  "&.rounded_left_side": {
    left: 0,
    borderRadius: "8px 0 0 8px"
  },
  "&.rounded_right_side": {
    right: 0,
    borderRadius: "0 8px 8px 0"
  }
})), In = O(S)(() => ({
  display: "grid",
  width: "100%",
  gap: "8px"
})), qn = O(S)(() => ({
  display: "flex",
  justifyContent: "space-between"
})), Ln = O(S)(({ theme: t }) => ({
  position: "relative",
  "&.calendar_day_inside_range": {
    backgroundColor: t.palette.primary.light,
    borderRadius: "8px"
  }
})), An = O("button")(
  ({ theme: t }) => ({
    position: "relative",
    width: "24px",
    height: "24px",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    border: "none",
    borderRadius: "8px",
    background: "none",
    boxShadow: "none",
    padding: "0",
    margin: "0",
    cursor: "pointer",
    outline: "none",
    color: t.palette.text.primary,
    fontSize: "12px",
    zIndex: 1,
    "&:hover": {
      border: `1px solid ${t.palette.primary.main}`,
      backgroundColor: t.palette.primary.light
    },
    "&.calendar_day_today": {
      border: `1px solid ${t.palette.grey[300]}`
    },
    "&.calendar_day_muted": {
      color: t.palette.grey[300]
    },
    "&.calendar_day_selected": {
      backgroundColor: `${t.palette.primary.main} !important`,
      color: `${t.palette.common.white} !important`
    }
  })
), Rn = ({ value: t }) => {
  const { date: r, singleDate: e, onCalendarDaySelect: n, startDate: a, endDate: s } = A(), i = (Y) => (/* @__PURE__ */ new Date()).toDateString() === Y.toDateString(), o = !(r.getMonth() === t.getMonth() && r.getFullYear() === t.getFullYear()), d = () => [e == null ? void 0 : e.toISOString(), a == null ? void 0 : a.toISOString(), s == null ? void 0 : s.toISOString()].includes(t.toISOString()), m = () => a && s ? Pn(t, {
    start: a,
    end: s
  }) : !1, c = () => {
    n(t);
  }, y = t.getDay() === 0, h = t.getDay() === 6, D = (a == null ? void 0 : a.toISOString()) === t.toISOString(), g = (s == null ? void 0 : s.toISOString()) === t.toISOString();
  return /* @__PURE__ */ l.jsxs(Ln, { className: te(m() && "calendar_day_inside_range"), children: [
    /* @__PURE__ */ l.jsx(
      An,
      {
        onClick: c,
        className: te(
          o && "calendar_day_muted",
          i(t) && "calendar_day_today",
          d() && "calendar_day_selected"
        ),
        children: t.getDate()
      }
    ),
    /* @__PURE__ */ l.jsx(
      jn,
      {
        className: te(
          m() && "calendar_day_inside_range",
          (y || D) && "rounded_left_side",
          (h || g) && "rounded_right_side"
        )
      }
    )
  ] });
}, Qn = ({ days: t }) => /* @__PURE__ */ l.jsx(qn, { children: t.map((r) => /* @__PURE__ */ l.jsx(
  Rn,
  {
    value: r
  },
  r.toISOString()
)) }), $n = () => {
  const { date: t } = A(), r = De(() => _n(t), [t]), e = (n) => `${t.toISOString()}_${n}`;
  return /* @__PURE__ */ l.jsx(In, { children: r.map((n, a) => /* @__PURE__ */ l.jsx(
    Qn,
    {
      days: n
    },
    e(a)
  )) });
}, Bn = O(S)(() => ({
  display: "flex",
  justifyContent: "flex-end"
})), Gn = O(Tt)(({ theme: t }) => ({
  minWidth: "49px",
  height: "24px",
  color: t.palette.primary.main,
  fontSize: "12px",
  fontWeight: 500,
  cursor: "pointer",
  borderRadius: "8px",
  "&:hover": {
    color: t.palette.primary.main
  }
})), Xn = () => {
  const { onCalendarClear: t } = A();
  return /* @__PURE__ */ l.jsx(Bn, { children: /* @__PURE__ */ l.jsx(
    Gn,
    {
      variant: "text",
      size: "xsmall",
      onClick: () => {
        t();
      },
      children: "Clear"
    }
  ) });
}, zn = () => /* @__PURE__ */ l.jsx(
  "svg",
  {
    width: "8",
    height: "12",
    viewBox: "0 0 8 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ l.jsx(
      "path",
      {
        d: "M6.5 11L1.5 6L6.5 1",
        stroke: "#6F6F6F",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), Vn = () => /* @__PURE__ */ l.jsx(
  "svg",
  {
    width: "8",
    height: "12",
    viewBox: "0 0 8 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ l.jsx(
      "path",
      {
        d: "M1.5 11L6.5 6L1.5 1",
        stroke: "#6F6F6F",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  }
), Kn = O(S)(() => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  height: "22px"
})), Jn = O(S)(({ theme: t }) => ({
  display: "flex",
  alignItems: "center",
  gap: "4px",
  height: "100%",
  fontWeight: "500",
  fontSize: "14px",
  color: t.palette.grey[600]
})), Zn = O(S)(() => ({
  display: "flex",
  gap: "16px"
})), Xe = O(
  "button"
)(({ theme: t }) => ({
  width: "20px",
  height: "20px",
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "center",
  alignItems: "center",
  margin: "0",
  padding: "0",
  border: "none",
  background: "none",
  outline: "none",
  borderRadius: "8px",
  "&:hover": {
    backgroundColor: t.palette.grey[50]
  }
})), Un = () => {
  const { date: t, toNextMonth: r, toPrevMonth: e } = A(), n = t.getFullYear(), a = Cn(t.getMonth());
  return /* @__PURE__ */ l.jsxs(Kn, { children: [
    /* @__PURE__ */ l.jsxs(Jn, { children: [
      /* @__PURE__ */ l.jsx("span", { children: a }),
      /* @__PURE__ */ l.jsx("span", { children: n })
    ] }),
    /* @__PURE__ */ l.jsxs(Zn, { children: [
      /* @__PURE__ */ l.jsx(Xe, { onClick: () => e(), children: /* @__PURE__ */ l.jsx(zn, {}) }),
      /* @__PURE__ */ l.jsx(Xe, { onClick: () => r(), children: /* @__PURE__ */ l.jsx(Vn, {}) })
    ] })
  ] });
}, yt = O(S)(() => ({
  display: "grid",
  gap: "8px"
})), ea = O(S)(() => ({
  display: "grid",
  gap: "8px",
  gridTemplateColumns: "1fr 1fr"
})), ta = O(S)(({ theme: t }) => ({
  display: "flex",
  justifyContent: "start",
  alignItems: "center",
  background: t.palette.background.default,
  border: `1px solid ${t.palette.grey[50]}`,
  borderRadius: "8px",
  fontSize: "14px",
  margin: 0,
  padding: "6px 8px",
  width: "100%",
  height: "31px",
  "&.calendar_slot_selected": {
    borderColor: t.palette.primary.main,
    backgroundColor: t.palette.primary.light
  },
  "&.calendar_slot_error": {
    borderColor: t.palette.error.main,
    backgroundColor: t.palette.background.default
  }
})), wt = O("input")(
  ({ theme: t }) => ({
    width: "100%",
    height: "19px",
    margin: "1px 0 0 0",
    padding: 0,
    border: "none",
    outline: "none",
    background: "none",
    backgroundColor: "transparent",
    fontFamily: "inherit",
    color: t.palette.grey[600],
    fontSize: "12px",
    appearance: "none",
    "&.has_error": {
      color: t.palette.error.main
    }
  })
), ra = O(S)(({ theme: t }) => ({
  flexShrink: "0",
  width: "1px",
  height: "20px",
  margin: "0 12px",
  backgroundColor: t.palette.grey[100]
})), na = O(S)(() => ({
  width: "100%",
  position: "relative"
})), aa = [
  "yyyy-MM-dd",
  "yyyy-M-d",
  "yyyy/MM/dd",
  "yyyy/M/d",
  "yyyyMMdd",
  "EEEE, dd MMMM yyyy",
  "EEEE dd MMMM yyyy",
  "EEE, dd MMMM yyyy",
  "EEE dd MMMM yyyy",
  "dd MMMM yyyy",
  "dd-MMMM-yyyy",
  "d MMM yyyy",
  "d-MMM-yyyy",
  "dd MMM yy",
  "d MMM yy",
  "MMMM d yyyy",
  "MMM d yyyy",
  "MMM d, yyyy",
  "MM/dd/yyyy",
  "M/d/yyyy",
  "MM-dd-yyyy",
  "M-d-yyyy",
  "MM/dd/yy",
  "MM-dd-yy",
  "dd/MM/yyyy",
  "d/M/yyyy",
  "d M yyyy",
  "d MM yyyy",
  "dd.MM.yyyy",
  "d.M.yyyy",
  "dd/MM/yy",
  "dd.MM.yy",
  "d/M/yy",
  "d.M.yy"
], sa = ["HH:mm:ss", "HH:mm", "HH mm", "h:mm:ss a", "h:mm a", "h mm a", "h a"], ia = (t) => {
  for (const r of aa) {
    const e = ht(t.trim(), r, /* @__PURE__ */ new Date());
    if (me(e))
      return e;
  }
  return null;
}, Ee = (t) => t.replace(/\s*([AaPp])\.?([Mm])?\.?\b/g, " $1$2").trim(), oa = (t) => {
  const r = Ee(t.trim()), e = /(\d{1,2})(?::(\d{1,2}))?/.exec(r);
  if (!e)
    return "";
  const [, n, a = "00"] = e, s = Number(n), i = Number(a);
  return s > 12 ? `${s}:${i}` : r;
}, ca = (t) => {
  const r = Ee(t.trim()), e = /(\d{1,2})(?::(\d{1,2}))?/.exec(r);
  if (!e)
    return "";
  const [, n, a = "00"] = e;
  let s = Number(n);
  const i = Number(a), o = /\b[Aa]\.?[Mm]?\.?\b/.test(r);
  /\b[Pp]\.?[Mm]?\.?\b/.test(r) && s < 12 && (s += 12), o && s === 12 && (s = 0);
  const m = s.toString().padStart(2, "0"), c = i.toString().padStart(2, "0");
  return `${m}:${c}`;
}, ze = (t) => {
  const r = Ee(t.trim());
  for (const e of sa) {
    const n = ht(r, e, /* @__PURE__ */ new Date());
    if (me(n))
      return n;
  }
  return null;
}, ua = (t) => me(t), da = ({ slotId: t, value: r, placeholder: e, name: n, onSelect: a, onChange: s }) => {
  const { slotFields: i, slotErrors: o } = A(), d = i.getDateField(t), m = ce(!1), c = b(
    (f) => {
      i.updateDateField(t, f);
    },
    [i, t]
  ), y = b(
    (f) => {
      o.updateDateError(t, f);
    },
    [o, t]
  ), h = b(() => o.getDateError(t), [o, t]), D = b(() => {
    o.clearDateError(t);
  }, [o, t]);
  Me(() => {
    d !== r && !m.current && !h() && (c(r), D());
  }, [r, c, d, D, h, o, t]);
  const g = (f) => {
    if (f === "") {
      c(r), D();
      return;
    }
    const j = ia(f);
    j && ua(j) ? (c(he(j)), s == null || s(j), D()) : y("Invalid date");
  }, Y = () => {
    m.current = !0, a == null || a();
  }, F = (f) => {
    m.current = !1, g(f.currentTarget.value);
  }, H = (f) => {
    f.key === "Enter" ? g(f.currentTarget.value) : f.key === "Escape" && (c(r), D(), f.currentTarget.blur());
  }, p = (f) => {
    c(f.target.value);
  };
  return /* @__PURE__ */ l.jsx(
    wt,
    {
      className: te(h() && "has_error"),
      autoComplete: "off",
      type: "text",
      name: n,
      value: d,
      placeholder: e,
      "aria-label": e,
      onChange: p,
      onKeyDown: H,
      onFocus: Y,
      onBlur: F
    }
  );
}, la = () => {
  const t = ce(null);
  return Me(() => {
    const r = t.current;
    if (!r)
      return;
    const e = (n) => {
      n.stopPropagation();
    };
    return t.current.addEventListener("wheel", e), () => {
      r.removeEventListener("wheel", e);
    };
  }), {
    scrollRef: t
  };
}, ma = O(S)(({ theme: t }) => ({
  fontFamily: "Poppins",
  position: "relative",
  padding: "4px 4px",
  backgroundColor: t.palette.common.white,
  borderRadius: "8px",
  border: `1px solid ${t.palette.grey[50]}`,
  boxShadow: "0px 4px 12px 0px rgba(0, 0, 0, 0.05), -4px 8px 16px -2px rgba(27, 33, 44, 0.12)"
})), fa = O(S)(() => ({
  display: "flex",
  flexDirection: "column",
  gap: "8px",
  paddingTop: "4px",
  width: "96px",
  height: "268px",
  overflowY: "auto",
  overflowX: "hidden"
})), ha = O(S)(({ theme: t }) => ({
  display: "flex",
  alignItems: "center",
  justifyContent: "start",
  height: "23px",
  maxWidth: "80px",
  padding: "2px 8px",
  fontSize: "12px",
  borderRadius: "4px",
  color: t.palette.grey[600],
  cursor: "pointer",
  "&:hover": {
    backgroundColor: t.palette.primary.light
  },
  "&.selected": {
    backgroundColor: `${t.palette.primary.main} !important`,
    color: `${t.palette.common.white} !important`
  }
})), ya = ({ value: t, isSelected: r = !1, onChange: e }) => /* @__PURE__ */ l.jsx(
  ha,
  {
    onClick: () => e == null ? void 0 : e(t),
    className: r ? "selected" : "",
    children: /* @__PURE__ */ l.jsx("span", { children: t })
  }
), wa = (t, r = "12h") => {
  const e = [];
  for (let a = 0; a < 1440; a += t) {
    const s = Math.floor(a / 60), i = a % 60;
    let o;
    if (r === "12h") {
      const d = s % 12 === 0 ? 12 : s % 12, m = s < 12 ? "AM" : "PM";
      o = `${d.toString()}:${i.toString().padStart(2, "0")} ${m}`;
    } else
      o = `${s.toString()}:${i.toString().padStart(2, "0")}`;
    e.push(o);
  }
  return e;
}, xa = {
  steps: {
    minutes: 30
  }
}, ba = ({ selected: t, timeFormat: r = "12h", onChange: e }) => {
  const n = De(() => wa(xa.steps.minutes, r), [r]), { scrollRef: a } = la();
  return /* @__PURE__ */ l.jsx(ma, { children: /* @__PURE__ */ l.jsx(fa, { ref: a, children: n.map((s, i) => /* @__PURE__ */ l.jsx(
    ya,
    {
      value: s,
      isSelected: t === s,
      onChange: e
    },
    `${s}-index-${i}`
  )) }) });
}, ga = ({ slotId: t, value: r, timeFormat: e, name: n, onSelect: a, onChange: s }) => {
  const { slotFields: i, slotErrors: o } = A(), [d, m] = L(!1), c = ce(!1), y = ce(null), h = ce(!1), D = i.getTimeField(t), g = b(
    (x) => {
      i.updateTimeField(t, x);
    },
    [i, t]
  ), Y = b(
    (x) => {
      o.updateTimeError(t, x);
    },
    [o, t]
  ), F = b(() => {
    o.clearTimeError(t);
  }, [o, t]), H = b(() => o.getTimeError(t), [o, t]);
  Me(() => {
    D !== r && !c.current && !H() && g(r);
  }, [r, g, D, H]);
  const p = (x) => {
    if (x === "") {
      g(r), F();
      return;
    }
    const z = oa(x), q = ze(e === "12h" ? z : ca(z));
    if (q) {
      const R = Z(q, e === "12h" ? "h:mm a" : "H:mm");
      g(R), s == null || s(R), F();
    } else
      Y("Invalid time");
  }, f = () => {
    c.current = !0, h.current = !1, a == null || a();
  }, j = (x) => {
    c.current = !1, h.current = !0, p(x.currentTarget.value);
  }, B = (x) => {
    x.key === "Enter" ? p(x.currentTarget.value) : x.key === "Escape" && (g(r), F(), x.currentTarget.blur());
  }, G = (x) => {
    g(x.target.value), m(!1);
  }, X = () => {
    m((x) => !x);
  }, w = (x) => {
    p(x), m(!1);
  }, T = () => {
    h.current && m(!1);
  };
  return /* @__PURE__ */ l.jsxs(na, { ref: y, children: [
    /* @__PURE__ */ l.jsx(
      wt,
      {
        className: te(H() && "has_error"),
        type: "text",
        autoComplete: "off",
        name: n,
        value: D,
        onFocus: f,
        onBlur: j,
        onKeyDown: B,
        onChange: G,
        onClick: X
      }
    ),
    y.current && /* @__PURE__ */ l.jsx(kt, { onClickAway: T, children: /* @__PURE__ */ l.jsx(
      Dt,
      {
        sx: { zIndex: 2 },
        open: d,
        anchorEl: y.current,
        placement: "bottom-start",
        modifiers: [{ name: "offset", options: { offset: [-12, 8] } }],
        disablePortal: !0,
        children: /* @__PURE__ */ l.jsx(
          ba,
          {
            selected: D,
            timeFormat: e,
            onChange: w
          }
        )
      }
    ) })
  ] });
}, Oe = ({
  isActive: t = !1,
  time: r,
  value: e,
  id: n,
  placeholder: a,
  onDateChange: s,
  onSelect: i,
  onTimeChange: o
}) => {
  const { config: d, slotErrors: m } = A(), c = m.hasErrors(n);
  return /* @__PURE__ */ l.jsxs(ta, { className: te(t && "calendar_slot_selected", c && "calendar_slot_error"), children: [
    /* @__PURE__ */ l.jsx(
      da,
      {
        slotId: n,
        value: e ?? "",
        name: `${n}-slot-date-field`,
        placeholder: a,
        onSelect: () => i == null ? void 0 : i(n),
        onChange: s
      }
    ),
    d.hasTime ? /* @__PURE__ */ l.jsxs(l.Fragment, { children: [
      /* @__PURE__ */ l.jsx(ra, {}),
      /* @__PURE__ */ l.jsx(
        ga,
        {
          slotId: n,
          value: r ?? fe(d),
          timeFormat: d.timeFormat,
          name: `${n}-slot-time-field`,
          onSelect: () => i == null ? void 0 : i(n),
          onChange: o
        }
      )
    ] }) : null
  ] });
}, Ve = () => {
  const { activeRangeSlot: t, setActiveRangeSlot: r, endDate: e, endTime: n, onEndTimeChange: a, onEndDateChange: s } = A(), i = {
    key: "end-date"
  }, o = (t == null ? void 0 : t.key) === i.key;
  return /* @__PURE__ */ l.jsx(
    Oe,
    {
      id: i.key,
      value: he(e),
      time: n ?? void 0,
      placeholder: "Select End",
      isActive: o,
      onSelect: () => {
        r(i);
      },
      onTimeChange: (d) => {
        a(d);
      },
      onDateChange: (d) => {
        s(d);
      }
    },
    i.key
  );
}, Ke = () => {
  const { activeRangeSlot: t, setActiveRangeSlot: r, startDate: e, startTime: n, onStartTimeChange: a, onStartDateChange: s } = A(), i = {
    key: "start-date"
  };
  return /* @__PURE__ */ l.jsx(
    Oe,
    {
      id: i.key,
      value: he(e),
      time: n ?? void 0,
      placeholder: "Select Start",
      isActive: (t == null ? void 0 : t.key) === i.key,
      onSelect: () => {
        r(i);
      },
      onTimeChange: (o) => {
        a(o);
      },
      onDateChange: (o) => {
        s(o);
      }
    }
  );
}, Da = () => {
  const { config: t } = A();
  return t.hasTime ? /* @__PURE__ */ l.jsxs(yt, { children: [
    /* @__PURE__ */ l.jsx(Ke, {}),
    /* @__PURE__ */ l.jsx(Ve, {})
  ] }) : /* @__PURE__ */ l.jsxs(ea, { children: [
    /* @__PURE__ */ l.jsx(Ke, {}),
    /* @__PURE__ */ l.jsx(Ve, {})
  ] });
}, Ma = () => {
  const { singleDate: t, singleTime: r, onSingleTimeChange: e, onSingleDateChange: n } = A(), a = {
    key: "single-date"
  };
  return /* @__PURE__ */ l.jsx(yt, { children: /* @__PURE__ */ l.jsx(
    Oe,
    {
      id: a.key,
      value: he(t),
      time: r ?? void 0,
      placeholder: "Select Date",
      onTimeChange: (s) => {
        e(s);
      },
      onDateChange: (s) => {
        n(s);
      }
    }
  ) });
}, pa = O(S)(() => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  fontSize: "12px"
})), Ta = O(S)(({ theme: t }) => ({
  width: "24px",
  height: "24px",
  color: t.palette.grey[400],
  fontSize: "10px",
  lineHeight: "150%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
})), ka = () => {
  const t = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
  return /* @__PURE__ */ l.jsx(pa, { children: t.map((r) => /* @__PURE__ */ l.jsx(Ta, { children: r }, r)) });
}, Pa = (t) => {
  const r = () => {
    const o = t ? new Date(t) : /* @__PURE__ */ new Date(), d = o.getFullYear(), m = o.getMonth(), c = o.getDate();
    return new Date(d, m, c);
  }, [e, n] = L(r), a = b(() => {
    const o = rt(e, 1);
    n(o);
  }, [e]), s = b(() => {
    const o = En(e, 1);
    n(o);
  }, [e]), i = b(() => {
    n(/* @__PURE__ */ new Date());
  }, []);
  return {
    date: e,
    setDate: n,
    toNextMonth: a,
    toPrevMonth: s,
    setToday: i
  };
}, Je = {
  "start-date": { date: "", time: "" },
  "end-date": { date: "", time: "" },
  "single-date": { date: "", time: "" }
}, Ea = () => {
  const [t, r] = L(Je), e = b(() => {
    r(Je);
  }, []), n = b((c, y) => {
    r((h) => ({ ...h, [c]: { ...h[c], date: y } }));
  }, []), a = b((c, y) => {
    r((h) => ({ ...h, [c]: { ...h[c], time: y } }));
  }, []), s = b((c) => {
    r((y) => ({ ...y, [c]: { ...y[c], date: "" } }));
  }, []), i = b((c) => {
    r((y) => ({ ...y, [c]: { ...y[c], time: "" } }));
  }, []), o = b(
    (c) => t[c].date,
    [t]
  ), d = b(
    (c) => t[c].time,
    [t]
  ), m = b(
    (c) => t[c].date !== "" || t[c].time !== "",
    [t]
  );
  return {
    errors: t,
    updateDateError: n,
    updateTimeError: a,
    resetErrors: e,
    clearDateError: s,
    clearTimeError: i,
    hasErrors: m,
    getDateError: o,
    getTimeError: d
  };
}, Oa = (t, r) => {
  const [e, n] = L(() => ({
    key: t.isDueDate ? "end-date" : "start-date"
  })), [a, s] = L(Wn(r)), [i, o] = L(vn(r)), [d, m] = L(Nn(t, r)), [c, y] = L(Sn(t, r));
  return {
    activeRangeSlot: e,
    startDate: a,
    endDate: i,
    startTime: d,
    endTime: c,
    setActiveRangeSlot: n,
    setStartDate: s,
    setEndDate: o,
    setStartTime: m,
    setEndTime: y
  };
}, Ca = (t, r) => {
  const [e, n] = L(Fn(r)), [a, s] = L(Hn(t, r));
  return { singleDate: e, setSingleDate: n, singleTime: a, setSingleTime: s };
}, Ze = {
  "start-date": { date: "", time: "" },
  "end-date": { date: "", time: "" },
  "single-date": { date: "", time: "" }
}, _a = () => {
  const [t, r] = L(Ze), e = b((o, d) => {
    r((m) => ({ ...m, [o]: { ...m[o], date: d } }));
  }, []), n = b((o, d) => {
    r((m) => ({ ...m, [o]: { ...m[o], time: d } }));
  }, []), a = b(() => {
    r(Ze);
  }, []), s = b(
    (o) => t[o].date,
    [t]
  ), i = b(
    (o) => t[o].time,
    [t]
  );
  return { fields: t, updateDateField: e, updateTimeField: n, resetFields: a, getDateField: s, getTimeField: i };
}, Ya = ({
  children: t,
  config: r,
  single: e,
  range: n,
  onSingleChange: a,
  onRangeChange: s,
  onClear: i
}) => {
  const { date: o, toNextMonth: d, toPrevMonth: m, setDate: c, setToday: y } = Pa(
    Yn(r, e, n)
  ), {
    activeRangeSlot: h,
    setActiveRangeSlot: D,
    startDate: g,
    startTime: Y,
    endDate: F,
    endTime: H,
    setStartDate: p,
    setEndDate: f,
    setStartTime: j,
    setEndTime: B
  } = Oa(r, n), { singleDate: G, setSingleDate: X, singleTime: w, setSingleTime: T } = Ca(r, e), x = Ea(), z = _a(), q = b(
    (P) => {
      const { from: I, to: ae } = Be(P, F);
      p(I), f(ae);
      const ye = ue(
        {
          from: I,
          fromTime: Y,
          to: ae,
          toTime: H
        },
        r.timeFormat
      );
      s == null || s(ye);
    },
    [r.timeFormat, F, H, s, f, p, Y]
  ), V = b(
    (P) => {
      const { from: I, to: ae } = Be(g, P);
      p(I), f(ae);
      const ye = ue(
        {
          from: I,
          fromTime: Y,
          to: ae,
          toTime: H
        },
        r.timeFormat
      );
      s == null || s(ye);
    },
    [r.timeFormat, H, s, f, p, g, Y]
  ), R = b(
    (P) => {
      X(P);
      const I = Ge(
        {
          date: P,
          time: w
        },
        r.timeFormat
      );
      a == null || a(I);
    },
    [r.timeFormat, a, X, w]
  ), Ce = b(() => {
    X(null), T(null), p(null), j(null), f(null), B(null);
  }, [f, B, X, T, p, j]), _e = b(() => {
    if (r.isRange && r.isDueDate) {
      D({
        key: "end-date"
      });
      return;
    }
    if (r.isRange) {
      D({
        key: "start-date"
      });
      return;
    }
    D({
      key: "single-date"
    });
  }, [r.isDueDate, r.isRange, D]), Ye = b(
    (P) => {
      if (r.isRange && (h == null ? void 0 : h.key) === "start-date") {
        q(P), D({
          key: "end-date"
        }), x.clearDateError("start-date");
        return;
      }
      if (r.isRange && (h == null ? void 0 : h.key) === "end-date") {
        V(P), x.clearDateError("end-date");
        return;
      }
      R(P), x.clearDateError("single-date");
    },
    [
      r.isRange,
      h == null ? void 0 : h.key,
      R,
      x,
      q,
      D,
      V
    ]
  ), Fe = b(() => {
    Ce(), _e(), y(), s == null || s({
      from: null,
      to: null
    }), a == null || a(null), x.resetErrors(), i == null || i();
  }, [i, s, a, _e, Ce, y, x]), We = b(
    (P) => {
      j(P);
      const I = ue(
        {
          from: g,
          fromTime: P,
          to: F,
          toTime: H
        },
        r.timeFormat
      );
      s == null || s(I);
    },
    [r.timeFormat, F, H, s, j, g]
  ), ve = b(
    (P) => {
      B(P);
      const I = ue(
        {
          from: g,
          fromTime: Y,
          to: F,
          toTime: P
        },
        r.timeFormat
      );
      s == null || s(I);
    },
    [r.timeFormat, F, s, B, g, Y]
  ), He = b(
    (P) => {
      T(P);
      const I = Ge(
        {
          date: G,
          time: P
        },
        r.timeFormat
      );
      a == null || a(I);
    },
    [r.timeFormat, a, T, G]
  ), Ne = b(
    (P) => {
      q(P), c(P);
    },
    [c, q]
  ), Se = b(
    (P) => {
      V(P), c(P);
    },
    [c, V]
  ), je = b(
    (P) => {
      R(P), c(P);
    },
    [R, c]
  ), xt = De(
    () => ({
      activeRangeSlot: h,
      config: r,
      date: o,
      endDate: F,
      endTime: H,
      singleDate: G,
      singleTime: w,
      startDate: g,
      startTime: Y,
      slotErrors: x,
      slotFields: z,
      toNextMonth: d,
      toPrevMonth: m,
      onCalendarClear: Fe,
      onCalendarDaySelect: Ye,
      setActiveRangeSlot: D,
      onStartTimeChange: We,
      onEndTimeChange: ve,
      onSingleTimeChange: He,
      onStartDateChange: Ne,
      onEndDateChange: Se,
      onSingleDateChange: je
    }),
    [
      h,
      r,
      o,
      F,
      H,
      G,
      w,
      g,
      Y,
      x,
      z,
      d,
      m,
      Fe,
      Ye,
      D,
      We,
      ve,
      He,
      Ne,
      Se,
      je
    ]
  );
  return /* @__PURE__ */ l.jsx(Ue.Provider, { value: xt, children: t });
}, Fa = O(S)(({ theme: t }) => ({
  fontFamily: "Poppins",
  width: "240px",
  padding: "12px",
  backgroundColor: t.palette.common.white,
  border: "1px solid " + t.palette.grey[50],
  borderRadius: "16px",
  display: "grid",
  gap: "12px",
  boxShadow: "0px 0px 12px 0px rgba(0, 0, 0, 0.05)"
})), Wa = O(S)(({ theme: t }) => ({
  width: "100%",
  height: "1px",
  backgroundColor: t.palette.grey[50]
})), oe = {
  isRange: !1,
  isDueDate: !1,
  hasSlots: !1,
  hasTime: !1,
  timeFormat: "12h"
}, qa = ({
  single: t,
  range: r,
  isRange: e,
  isDueDate: n,
  hasSlots: a,
  hasTime: s,
  timeFormat: i,
  onSingleChange: o,
  onRangeChange: d,
  onClear: m
}) => {
  const c = {
    isRange: e ?? oe.isRange,
    isDueDate: n ?? oe.isDueDate,
    hasSlots: a ?? oe.hasSlots,
    hasTime: s ?? oe.hasTime,
    timeFormat: i ?? oe.timeFormat
  }, y = c.isRange ? /* @__PURE__ */ l.jsx(Da, {}) : /* @__PURE__ */ l.jsx(Ma, {});
  return /* @__PURE__ */ l.jsx(
    Ya,
    {
      config: c,
      single: t,
      range: r,
      onSingleChange: o,
      onRangeChange: d,
      onClear: m,
      children: /* @__PURE__ */ l.jsxs(Fa, { children: [
        c.hasSlots && y,
        /* @__PURE__ */ l.jsx(Un, {}),
        /* @__PURE__ */ l.jsx(ka, {}),
        /* @__PURE__ */ l.jsx($n, {}),
        /* @__PURE__ */ l.jsx(Wa, {}),
        /* @__PURE__ */ l.jsx(Xn, {})
      ] })
    }
  );
};
export {
  qa as Calendar
};
//# sourceMappingURL=date-picker.js.map
