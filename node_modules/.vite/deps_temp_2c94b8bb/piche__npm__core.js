import {
  require_react_dom
} from "./chunk-HS657EWY.js";
import {
  require_react
} from "./chunk-WMOGTAPH.js";
import {
  __toESM
} from "./chunk-ZC22LKFR.js";

// node_modules/.pnpm/piche.npm.core@1.1.113_vite@4.5.14_@types+node@20.19.25_sass@1.94.2_/node_modules/piche.npm.core/dist/index.js
var import_react = __toESM(require_react());

// node_modules/.pnpm/mobx@6.15.0/node_modules/mobx/dist/mobx.esm.js
var niceErrors = {
  0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
  1: function _(annotationType, key) {
    return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
  },
  /*
  2(prop) {
      return `invalid decorator for '${prop.toString()}'`
  },
  3(prop) {
      return `Cannot decorate '${prop.toString()}': action can only be used on properties with a function value.`
  },
  4(prop) {
      return `Cannot decorate '${prop.toString()}': computed can only be used on getter properties.`
  },
  */
  5: "'keys()' can only be used on observable objects, arrays, sets and maps",
  6: "'values()' can only be used on observable objects, arrays, sets and maps",
  7: "'entries()' can only be used on observable objects, arrays and maps",
  8: "'set()' can only be used on observable objects, arrays and maps",
  9: "'remove()' can only be used on observable objects, arrays and maps",
  10: "'has()' can only be used on observable objects, arrays and maps",
  11: "'get()' can only be used on observable objects, arrays and maps",
  12: "Invalid annotation",
  13: "Dynamic observable objects cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  14: "Intercept handlers should return nothing or a change object",
  15: "Observable arrays cannot be frozen. If you're passing observables to 3rd party component/function that calls Object.freeze, pass copy instead: toJS(observable)",
  16: "Modification exception: the internal structure of an observable array was changed.",
  17: function _2(index, length) {
    return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
  },
  18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
  19: function _3(other) {
    return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
  },
  20: function _4(other) {
    return "Cannot initialize map from " + other;
  },
  21: function _5(dataStructure) {
    return "Cannot convert to map from '" + dataStructure + "'";
  },
  22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
  23: "It is not possible to get index atoms from arrays",
  24: function _6(thing) {
    return "Cannot obtain administration from " + thing;
  },
  25: function _7(property, name) {
    return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
  },
  26: "please specify a property",
  27: function _8(property, name) {
    return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
  },
  28: function _9(thing) {
    return "Cannot obtain atom from " + thing;
  },
  29: "Expecting some object",
  30: "invalid action stack. did you forget to finish an action?",
  31: "missing option for computed: get",
  32: function _10(name, derivation) {
    return "Cycle detected in computation " + name + ": " + derivation;
  },
  33: function _11(name) {
    return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
  },
  34: function _12(name) {
    return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
  },
  35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
  36: "isolateGlobalState should be called before MobX is running any reactions",
  37: function _13(method) {
    return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
  },
  38: "'ownKeys()' can only be used on observable objects",
  39: "'defineProperty()' can only be used on observable objects"
};
var errors = true ? niceErrors : {};
function die(error) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (true) {
    var e = typeof error === "string" ? error : errors[error];
    if (typeof e === "function")
      e = e.apply(null, args);
    throw new Error("[MobX] " + e);
  }
  throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
}
var mockGlobal = {};
function getGlobal() {
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof self !== "undefined") {
    return self;
  }
  return mockGlobal;
}
var assign = Object.assign;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var objectPrototype = Object.prototype;
var EMPTY_ARRAY = [];
Object.freeze(EMPTY_ARRAY);
var EMPTY_OBJECT = {};
Object.freeze(EMPTY_OBJECT);
var hasProxy = typeof Proxy !== "undefined";
var plainObjectString = Object.toString();
function assertProxies() {
  if (!hasProxy) {
    die(true ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
  }
}
function warnAboutProxyRequirement(msg) {
  if (globalState.verifyProxies) {
    die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
  }
}
function getNextId() {
  return ++globalState.mobxGuid;
}
function once(func) {
  var invoked = false;
  return function() {
    if (invoked) {
      return;
    }
    invoked = true;
    return func.apply(this, arguments);
  };
}
var noop = function noop2() {
};
function isFunction(fn2) {
  return typeof fn2 === "function";
}
function isStringish(value) {
  var t = typeof value;
  switch (t) {
    case "string":
    case "symbol":
    case "number":
      return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function isPlainObject(value) {
  if (!isObject(value)) {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto == null) {
    return true;
  }
  var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
}
function isGenerator(obj) {
  var constructor = obj == null ? void 0 : obj.constructor;
  if (!constructor) {
    return false;
  }
  if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
    return true;
  }
  return false;
}
function addHiddenProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: true,
    configurable: true,
    value
  });
}
function addHiddenFinalProp(object2, propName, value) {
  defineProperty(object2, propName, {
    enumerable: false,
    writable: false,
    configurable: true,
    value
  });
}
function createInstanceofPredicate(name, theClass) {
  var propName = "isMobX" + name;
  theClass.prototype[propName] = true;
  return function(x) {
    return isObject(x) && x[propName] === true;
  };
}
function isES6Map(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Map]";
}
function isPlainES6Map(thing) {
  var mapProto = Object.getPrototypeOf(thing);
  var objectProto = Object.getPrototypeOf(mapProto);
  var nullProto = Object.getPrototypeOf(objectProto);
  return nullProto === null;
}
function isES6Set(thing) {
  return thing != null && Object.prototype.toString.call(thing) === "[object Set]";
}
var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
function getPlainObjectKeys(object2) {
  var keys = Object.keys(object2);
  if (!hasGetOwnPropertySymbols) {
    return keys;
  }
  var symbols = Object.getOwnPropertySymbols(object2);
  if (!symbols.length) {
    return keys;
  }
  return [].concat(keys, symbols.filter(function(s) {
    return objectPrototype.propertyIsEnumerable.call(object2, s);
  }));
}
var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
} : (
  /* istanbul ignore next */
  Object.getOwnPropertyNames
);
function stringifyKey(key) {
  if (typeof key === "string") {
    return key;
  }
  if (typeof key === "symbol") {
    return key.toString();
  }
  return new String(key).toString();
}
function toPrimitive(value) {
  return value === null ? null : typeof value === "object" ? "" + value : value;
}
function hasProp(target, prop) {
  return objectPrototype.hasOwnProperty.call(target, prop);
}
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
  var res = {};
  ownKeys(target).forEach(function(key) {
    res[key] = getDescriptor(target, key);
  });
  return res;
};
function getFlag(flags, mask) {
  return !!(flags & mask);
}
function setFlag(flags, mask, newValue) {
  if (newValue) {
    flags |= mask;
  } else {
    flags &= ~mask;
  }
  return flags;
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++)
    n[e] = r[e];
  return n;
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelperLoose(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (t)
    return (t = t.call(r)).next.bind(t);
  if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
    t && (r = t);
    var o = 0;
    return function() {
      return o >= r.length ? {
        done: true
      } : {
        done: false,
        value: r[o++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r)
      return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var storedAnnotationsSymbol = Symbol("mobx-stored-annotations");
function createDecoratorAnnotation(annotation) {
  function decorator(target, property) {
    if (is20223Decorator(property)) {
      return annotation.decorate_20223_(target, property);
    } else {
      storeAnnotation(target, property, annotation);
    }
  }
  return Object.assign(decorator, annotation);
}
function storeAnnotation(prototype, key, annotation) {
  if (!hasProp(prototype, storedAnnotationsSymbol)) {
    addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
  }
  if (isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
  }
  assertNotDecorated(prototype, annotation, key);
  if (!isOverride(annotation)) {
    prototype[storedAnnotationsSymbol][key] = annotation;
  }
}
function assertNotDecorated(prototype, annotation, key) {
  if (!isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
    var fieldName = prototype.constructor.name + ".prototype." + key.toString();
    var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already decorated with '@" + currentAnnotationType + "'.") + "\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overridden by subclass.");
  }
}
function is20223Decorator(context) {
  return typeof context == "object" && typeof context["kind"] == "string";
}
function assert20223DecoratorType(context, types) {
  if (!types.includes(context.kind)) {
    die("The decorator applied to '" + String(context.name) + "' cannot be used on a " + context.kind + " element");
  }
}
var $mobx = Symbol("mobx administration");
var Atom = function() {
  function Atom2(name_) {
    if (name_ === void 0) {
      name_ = true ? "Atom@" + getNextId() : "Atom";
    }
    this.name_ = void 0;
    this.flags_ = 0;
    this.observers_ = /* @__PURE__ */ new Set();
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    this.name_ = name_;
  }
  var _proto = Atom2.prototype;
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.reportObserved = function reportObserved$1() {
    return reportObserved(this);
  };
  _proto.reportChanged = function reportChanged() {
    startBatch();
    propagateChanged(this);
    endBatch();
  };
  _proto.toString = function toString2() {
    return this.name_;
  };
  return _createClass(Atom2, [{
    key: "isBeingObserved",
    get: function get3() {
      return getFlag(this.flags_, Atom2.isBeingObservedMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get3() {
      return getFlag(this.flags_, Atom2.isPendingUnobservationMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get3() {
      return getFlag(this.flags_, Atom2.diffValueMask_) ? 1 : 0;
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Atom2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Atom.isBeingObservedMask_ = 1;
Atom.isPendingUnobservationMask_ = 2;
Atom.diffValueMask_ = 4;
var isAtom = createInstanceofPredicate("Atom", Atom);
function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
  if (onBecomeObservedHandler === void 0) {
    onBecomeObservedHandler = noop;
  }
  if (onBecomeUnobservedHandler === void 0) {
    onBecomeUnobservedHandler = noop;
  }
  var atom = new Atom(name);
  if (onBecomeObservedHandler !== noop) {
    onBecomeObserved(atom, onBecomeObservedHandler);
  }
  if (onBecomeUnobservedHandler !== noop) {
    onBecomeUnobserved(atom, onBecomeUnobservedHandler);
  }
  return atom;
}
function identityComparer(a, b) {
  return a === b;
}
function structuralComparer(a, b) {
  return deepEqual(a, b);
}
function shallowComparer(a, b) {
  return deepEqual(a, b, 1);
}
function defaultComparer(a, b) {
  if (Object.is) {
    return Object.is(a, b);
  }
  return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
}
var comparer = {
  identity: identityComparer,
  structural: structuralComparer,
  "default": defaultComparer,
  shallow: shallowComparer
};
function deepEnhancer(v, _14, name) {
  if (isObservable(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name
    });
  }
  if (isPlainObject(v)) {
    return observable.object(v, void 0, {
      name
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name
    });
  }
  if (typeof v === "function" && !isAction(v) && !isFlow(v)) {
    if (isGenerator(v)) {
      return flow(v);
    } else {
      return autoAction(name, v);
    }
  }
  return v;
}
function shallowEnhancer(v, _14, name) {
  if (v === void 0 || v === null) {
    return v;
  }
  if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) {
    return v;
  }
  if (Array.isArray(v)) {
    return observable.array(v, {
      name,
      deep: false
    });
  }
  if (isPlainObject(v)) {
    return observable.object(v, void 0, {
      name,
      deep: false
    });
  }
  if (isES6Map(v)) {
    return observable.map(v, {
      name,
      deep: false
    });
  }
  if (isES6Set(v)) {
    return observable.set(v, {
      name,
      deep: false
    });
  }
  if (true) {
    die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
  }
}
function referenceEnhancer(newValue) {
  return newValue;
}
function refStructEnhancer(v, oldValue) {
  if (isObservable(v)) {
    die("observable.struct should not be used with observable values");
  }
  if (deepEqual(v, oldValue)) {
    return oldValue;
  }
  return v;
}
var OVERRIDE = "override";
var override = createDecoratorAnnotation({
  annotationType_: OVERRIDE,
  make_,
  extend_,
  decorate_20223_
});
function isOverride(annotation) {
  return annotation.annotationType_ === OVERRIDE;
}
function make_(adm, key) {
  if (adm.isPlainObject_) {
    die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + this.annotationType_ + "' cannot be used on plain objects."));
  }
  if (!hasProp(adm.appliedAnnotations_, key)) {
    die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', but no such annotated member was found on prototype.");
  }
  return 0;
}
function extend_(adm, key, descriptor, proxyTrap) {
  die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
}
function decorate_20223_(desc, context) {
  console.warn("'" + this.annotationType_ + "' cannot be used with decorators - this is a no-op");
}
function createActionAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$1,
    extend_: extend_$1,
    decorate_20223_: decorate_20223_$1
  };
}
function make_$1(adm, key, descriptor, source) {
  var _this$options_;
  if ((_this$options_ = this.options_) != null && _this$options_.bound) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if (isAction(descriptor.value)) {
    return 1;
  }
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
  defineProperty(source, key, actionDescriptor);
  return 2;
}
function extend_$1(adm, key, descriptor, proxyTrap) {
  var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
  return adm.defineProperty_(key, actionDescriptor, proxyTrap);
}
function decorate_20223_$1(mthd, context) {
  if (true) {
    assert20223DecoratorType(context, ["method", "field"]);
  }
  var kind = context.kind, name = context.name, addInitializer = context.addInitializer;
  var ann = this;
  var _createAction = function _createAction2(m2) {
    var _ann$options_$name, _ann$options_, _ann$options_$autoAct, _ann$options_2;
    return createAction((_ann$options_$name = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.name) != null ? _ann$options_$name : name.toString(), m2, (_ann$options_$autoAct = (_ann$options_2 = ann.options_) == null ? void 0 : _ann$options_2.autoAction) != null ? _ann$options_$autoAct : false);
  };
  if (kind == "field") {
    return function(initMthd) {
      var _ann$options_3;
      var mthd2 = initMthd;
      if (!isAction(mthd2)) {
        mthd2 = _createAction(mthd2);
      }
      if ((_ann$options_3 = ann.options_) != null && _ann$options_3.bound) {
        mthd2 = mthd2.bind(this);
        mthd2.isMobxAction = true;
      }
      return mthd2;
    };
  }
  if (kind == "method") {
    var _this$options_2;
    if (!isAction(mthd)) {
      mthd = _createAction(mthd);
    }
    if ((_this$options_2 = this.options_) != null && _this$options_2.bound) {
      addInitializer(function() {
        var self2 = this;
        var bound = self2[name].bind(self2);
        bound.isMobxAction = true;
        self2[name] = bound;
      });
    }
    return mthd;
  }
  die("Cannot apply '" + ann.annotationType_ + "' to '" + String(name) + "' (kind: " + kind + "):" + ("\n'" + ann.annotationType_ + "' can only be used on properties with a function value."));
}
function assertActionDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a function value."));
  }
}
function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
  var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertActionDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return {
    value: createAction(
      (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
      value,
      (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
      // https://github.com/mobxjs/mobx/discussions/3140
      (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
    ),
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createFlowAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$2,
    extend_: extend_$2,
    decorate_20223_: decorate_20223_$2
  };
}
function make_$2(adm, key, descriptor, source) {
  var _this$options_;
  if (source === adm.target_) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
  }
  if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
    if (this.extend_(adm, key, descriptor, false) === null) {
      return 0;
    }
  }
  if (isFlow(descriptor.value)) {
    return 1;
  }
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
  defineProperty(source, key, flowDescriptor);
  return 2;
}
function extend_$2(adm, key, descriptor, proxyTrap) {
  var _this$options_2;
  var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
  return adm.defineProperty_(key, flowDescriptor, proxyTrap);
}
function decorate_20223_$2(mthd, context) {
  var _this$options_3;
  if (true) {
    assert20223DecoratorType(context, ["method"]);
  }
  var name = context.name, addInitializer = context.addInitializer;
  if (!isFlow(mthd)) {
    mthd = flow(mthd);
  }
  if ((_this$options_3 = this.options_) != null && _this$options_3.bound) {
    addInitializer(function() {
      var self2 = this;
      var bound = self2[name].bind(self2);
      bound.isMobXFlow = true;
      self2[name] = bound;
    });
  }
  return mthd;
}
function assertFlowDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var value = _ref2.value;
  if (!isFunction(value)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on properties with a generator function value."));
  }
}
function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
  if (safeDescriptors === void 0) {
    safeDescriptors = globalState.safeDescriptors;
  }
  assertFlowDescriptor(adm, annotation, key, descriptor);
  var value = descriptor.value;
  if (!isFlow(value)) {
    value = flow(value);
  }
  if (bound) {
    var _adm$proxy_;
    value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    value.isMobXFlow = true;
  }
  return {
    value,
    // Non-configurable for classes
    // prevents accidental field redefinition in subclass
    configurable: safeDescriptors ? adm.isPlainObject_ : true,
    // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
    enumerable: false,
    // Non-obsevable, therefore non-writable
    // Also prevents rewriting in subclass constructor
    writable: safeDescriptors ? false : true
  };
}
function createComputedAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$3,
    extend_: extend_$3,
    decorate_20223_: decorate_20223_$3
  };
}
function make_$3(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$3(adm, key, descriptor, proxyTrap) {
  assertComputedDescriptor(adm, this, key, descriptor);
  return adm.defineComputedProperty_(key, _extends({}, this.options_, {
    get: descriptor.get,
    set: descriptor.set
  }), proxyTrap);
}
function decorate_20223_$3(get3, context) {
  if (true) {
    assert20223DecoratorType(context, ["getter"]);
  }
  var ann = this;
  var key = context.name, addInitializer = context.addInitializer;
  addInitializer(function() {
    var adm = asObservableObject(this)[$mobx];
    var options = _extends({}, ann.options_, {
      get: get3,
      context: this
    });
    options.name || (options.name = true ? adm.name_ + "." + key.toString() : "ObservableObject." + key.toString());
    adm.values_.set(key, new ComputedValue(options));
  });
  return function() {
    return this[$mobx].getObservablePropValue_(key);
  };
}
function assertComputedDescriptor(adm, _ref, key, _ref2) {
  var annotationType_ = _ref.annotationType_;
  var get3 = _ref2.get;
  if (!get3) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' can only be used on getter(+setter) properties."));
  }
}
function createObservableAnnotation(name, options) {
  return {
    annotationType_: name,
    options_: options,
    make_: make_$4,
    extend_: extend_$4,
    decorate_20223_: decorate_20223_$4
  };
}
function make_$4(adm, key, descriptor) {
  return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
}
function extend_$4(adm, key, descriptor, proxyTrap) {
  var _this$options_$enhanc, _this$options_;
  assertObservableDescriptor(adm, this, key, descriptor);
  return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
}
function decorate_20223_$4(desc, context) {
  if (true) {
    if (context.kind === "field") {
      throw die("Please use `@observable accessor " + String(context.name) + "` instead of `@observable " + String(context.name) + "`");
    }
    assert20223DecoratorType(context, ["accessor"]);
  }
  var ann = this;
  var kind = context.kind, name = context.name;
  var initializedObjects = /* @__PURE__ */ new WeakSet();
  function initializeObservable(target, value) {
    var _ann$options_$enhance, _ann$options_;
    var adm = asObservableObject(target)[$mobx];
    var observable2 = new ObservableValue(value, (_ann$options_$enhance = (_ann$options_ = ann.options_) == null ? void 0 : _ann$options_.enhancer) != null ? _ann$options_$enhance : deepEnhancer, true ? adm.name_ + "." + name.toString() : "ObservableObject." + name.toString(), false);
    adm.values_.set(name, observable2);
    initializedObjects.add(target);
  }
  if (kind == "accessor") {
    return {
      get: function get3() {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, desc.get.call(this));
        }
        return this[$mobx].getObservablePropValue_(name);
      },
      set: function set4(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return this[$mobx].setObservablePropValue_(name, value);
      },
      init: function init(value) {
        if (!initializedObjects.has(this)) {
          initializeObservable(this, value);
        }
        return value;
      }
    };
  }
  return;
}
function assertObservableDescriptor(adm, _ref, key, descriptor) {
  var annotationType_ = _ref.annotationType_;
  if (!("value" in descriptor)) {
    die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':" + ("\n'" + annotationType_ + "' cannot be used on getter/setter properties"));
  }
}
var AUTO = "true";
var autoAnnotation = createAutoAnnotation();
function createAutoAnnotation(options) {
  return {
    annotationType_: AUTO,
    options_: options,
    make_: make_$5,
    extend_: extend_$5,
    decorate_20223_: decorate_20223_$5
  };
}
function make_$5(adm, key, descriptor, source) {
  var _this$options_3, _this$options_4;
  if (descriptor.get) {
    return computed.make_(adm, key, descriptor, source);
  }
  if (descriptor.set) {
    var set4 = isAction(descriptor.set) ? descriptor.set : createAction(key.toString(), descriptor.set);
    if (source === adm.target_) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: set4
      }) === null ? 0 : 2;
    }
    defineProperty(source, key, {
      configurable: true,
      set: set4
    });
    return 2;
  }
  if (source !== adm.target_ && typeof descriptor.value === "function") {
    var _this$options_2;
    if (isGenerator(descriptor.value)) {
      var _this$options_;
      var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
      return flowAnnotation2.make_(adm, key, descriptor, source);
    }
    var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
    return actionAnnotation2.make_(adm, key, descriptor, source);
  }
  var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
  if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
    var _adm$proxy_;
    descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
  }
  return observableAnnotation2.make_(adm, key, descriptor, source);
}
function extend_$5(adm, key, descriptor, proxyTrap) {
  var _this$options_5, _this$options_6;
  if (descriptor.get) {
    return computed.extend_(adm, key, descriptor, proxyTrap);
  }
  if (descriptor.set) {
    return adm.defineProperty_(key, {
      configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
      set: createAction(key.toString(), descriptor.set)
    }, proxyTrap);
  }
  if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
    var _adm$proxy_2;
    descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
  }
  var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
  return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
}
function decorate_20223_$5(desc, context) {
  die("'" + this.annotationType_ + "' cannot be used as a decorator");
}
var OBSERVABLE = "observable";
var OBSERVABLE_REF = "observable.ref";
var OBSERVABLE_SHALLOW = "observable.shallow";
var OBSERVABLE_STRUCT = "observable.struct";
var defaultCreateObservableOptions = {
  deep: true,
  name: void 0,
  defaultDecorator: void 0,
  proxy: true
};
Object.freeze(defaultCreateObservableOptions);
function asCreateObservableOptions(thing) {
  return thing || defaultCreateObservableOptions;
}
var observableAnnotation = createObservableAnnotation(OBSERVABLE);
var observableRefAnnotation = createObservableAnnotation(OBSERVABLE_REF, {
  enhancer: referenceEnhancer
});
var observableShallowAnnotation = createObservableAnnotation(OBSERVABLE_SHALLOW, {
  enhancer: shallowEnhancer
});
var observableStructAnnotation = createObservableAnnotation(OBSERVABLE_STRUCT, {
  enhancer: refStructEnhancer
});
var observableDecoratorAnnotation = createDecoratorAnnotation(observableAnnotation);
function getEnhancerFromOptions(options) {
  return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
}
function getAnnotationFromOptions(options) {
  var _options$defaultDecor;
  return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
}
function getEnhancerFromAnnotation(annotation) {
  var _annotation$options_$, _annotation$options_;
  return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
}
function createObservable(v, arg2, arg3) {
  if (is20223Decorator(arg2)) {
    return observableAnnotation.decorate_20223_(v, arg2);
  }
  if (isStringish(arg2)) {
    storeAnnotation(v, arg2, observableAnnotation);
    return;
  }
  if (isObservable(v)) {
    return v;
  }
  if (isPlainObject(v)) {
    return observable.object(v, arg2, arg3);
  }
  if (Array.isArray(v)) {
    return observable.array(v, arg2);
  }
  if (isES6Map(v)) {
    return observable.map(v, arg2);
  }
  if (isES6Set(v)) {
    return observable.set(v, arg2);
  }
  if (typeof v === "object" && v !== null) {
    return v;
  }
  return observable.box(v, arg2);
}
assign(createObservable, observableDecoratorAnnotation);
var observableFactories = {
  box: function box(value, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
  },
  array: function array(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
  },
  map: function map(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
  },
  set: function set(initialValues, options) {
    var o = asCreateObservableOptions(options);
    return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
  },
  object: function object(props, decorators, options) {
    return initObservable(function() {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    });
  },
  ref: createDecoratorAnnotation(observableRefAnnotation),
  shallow: createDecoratorAnnotation(observableShallowAnnotation),
  deep: observableDecoratorAnnotation,
  struct: createDecoratorAnnotation(observableStructAnnotation)
};
var observable = assign(createObservable, observableFactories);
var COMPUTED = "computed";
var COMPUTED_STRUCT = "computed.struct";
var computedAnnotation = createComputedAnnotation(COMPUTED);
var computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {
  equals: comparer.structural
});
var computed = function computed2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return computedAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, computedAnnotation);
  }
  if (isPlainObject(arg1)) {
    return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
  }
  if (true) {
    if (!isFunction(arg1)) {
      die("First argument to `computed` should be an expression.");
    }
    if (isFunction(arg2)) {
      die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
    }
  }
  var opts = isPlainObject(arg2) ? arg2 : {};
  opts.get = arg1;
  opts.name || (opts.name = arg1.name || "");
  return new ComputedValue(opts);
};
Object.assign(computed, computedAnnotation);
computed.struct = createDecoratorAnnotation(computedStructAnnotation);
var _getDescriptor$config;
var _getDescriptor;
var currentActionId = 0;
var nextActionId = 1;
var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = getDescriptor(function() {
}, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
var tmpNameDescriptor = {
  value: "action",
  configurable: true,
  writable: false,
  enumerable: false
};
function createAction(actionName, fn2, autoAction2, ref) {
  if (autoAction2 === void 0) {
    autoAction2 = false;
  }
  if (true) {
    if (!isFunction(fn2)) {
      die("`action` can only be invoked on functions");
    }
    if (typeof actionName !== "string" || !actionName) {
      die("actions should have valid names, got: '" + actionName + "'");
    }
  }
  function res() {
    return executeAction(actionName, autoAction2, fn2, ref || this, arguments);
  }
  res.isMobxAction = true;
  res.toString = function() {
    return fn2.toString();
  };
  if (isFunctionNameConfigurable) {
    tmpNameDescriptor.value = actionName;
    defineProperty(res, "name", tmpNameDescriptor);
  }
  return res;
}
function executeAction(actionName, canRunAsDerivation, fn2, scope, args) {
  var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
  try {
    return fn2.apply(scope, args);
  } catch (err) {
    runInfo.error_ = err;
    throw err;
  } finally {
    _endAction(runInfo);
  }
}
function _startAction(actionName, canRunAsDerivation, scope, args) {
  var notifySpy_ = isSpyEnabled() && !!actionName;
  var startTime_ = 0;
  if (notifySpy_) {
    startTime_ = Date.now();
    var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
    spyReportStart({
      type: ACTION,
      name: actionName,
      object: scope,
      arguments: flattenedArgs
    });
  }
  var prevDerivation_ = globalState.trackingDerivation;
  var runAsAction = !canRunAsDerivation || !prevDerivation_;
  startBatch();
  var prevAllowStateChanges_ = globalState.allowStateChanges;
  if (runAsAction) {
    untrackedStart();
    prevAllowStateChanges_ = allowStateChangesStart(true);
  }
  var prevAllowStateReads_ = allowStateReadsStart(true);
  var runInfo = {
    runAsAction_: runAsAction,
    prevDerivation_,
    prevAllowStateChanges_,
    prevAllowStateReads_,
    notifySpy_,
    startTime_,
    actionId_: nextActionId++,
    parentActionId_: currentActionId
  };
  currentActionId = runInfo.actionId_;
  return runInfo;
}
function _endAction(runInfo) {
  if (currentActionId !== runInfo.actionId_) {
    die(30);
  }
  currentActionId = runInfo.parentActionId_;
  if (runInfo.error_ !== void 0) {
    globalState.suppressReactionErrors = true;
  }
  allowStateChangesEnd(runInfo.prevAllowStateChanges_);
  allowStateReadsEnd(runInfo.prevAllowStateReads_);
  endBatch();
  if (runInfo.runAsAction_) {
    untrackedEnd(runInfo.prevDerivation_);
  }
  if (runInfo.notifySpy_) {
    spyReportEnd({
      time: Date.now() - runInfo.startTime_
    });
  }
  globalState.suppressReactionErrors = false;
}
function allowStateChangesStart(allowStateChanges) {
  var prev = globalState.allowStateChanges;
  globalState.allowStateChanges = allowStateChanges;
  return prev;
}
function allowStateChangesEnd(prev) {
  globalState.allowStateChanges = prev;
}
var CREATE = "create";
var ObservableValue = function(_Atom) {
  function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
    var _this;
    if (name_ === void 0) {
      name_ = true ? "ObservableValue@" + getNextId() : "ObservableValue";
    }
    if (notifySpy === void 0) {
      notifySpy = true;
    }
    if (equals === void 0) {
      equals = comparer["default"];
    }
    _this = _Atom.call(this, name_) || this;
    _this.enhancer = void 0;
    _this.name_ = void 0;
    _this.equals = void 0;
    _this.hasUnreportedChange_ = false;
    _this.interceptors_ = void 0;
    _this.changeListeners_ = void 0;
    _this.value_ = void 0;
    _this.dehancer = void 0;
    _this.enhancer = enhancer;
    _this.name_ = name_;
    _this.equals = equals;
    _this.value_ = enhancer(value, void 0, name_);
    if (notifySpy && isSpyEnabled()) {
      var _this$value_;
      spyReport({
        type: CREATE,
        object: _this,
        observableKind: "value",
        debugObjectName: _this.name_,
        newValue: "" + ((_this$value_ = _this.value_) == null ? void 0 : _this$value_.toString())
      });
    }
    return _this;
  }
  _inheritsLoose(ObservableValue2, _Atom);
  var _proto = ObservableValue2.prototype;
  _proto.dehanceValue = function dehanceValue(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.set = function set4(newValue) {
    var oldValue = this.value_;
    newValue = this.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      if (notifySpy) {
        spyReportStart({
          type: UPDATE,
          object: this,
          observableKind: "value",
          debugObjectName: this.name_,
          newValue,
          oldValue
        });
      }
      this.setNewValue_(newValue);
      if (notifySpy) {
        spyReportEnd();
      }
    }
  };
  _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
    checkIfStateModificationsAreAllowed(this);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this,
        type: UPDATE,
        newValue
      });
      if (!change) {
        return globalState.UNCHANGED;
      }
      newValue = change.newValue;
    }
    newValue = this.enhancer(newValue, this.value_, this.name_);
    return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
  };
  _proto.setNewValue_ = function setNewValue_(newValue) {
    var oldValue = this.value_;
    this.value_ = newValue;
    this.reportChanged();
    if (hasListeners(this)) {
      notifyListeners(this, {
        type: UPDATE,
        object: this,
        newValue,
        oldValue
      });
    }
  };
  _proto.get = function get3() {
    this.reportObserved();
    return this.dehanceValue(this.value_);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately) {
      listener({
        observableKind: "value",
        debugObjectName: this.name_,
        object: this,
        type: UPDATE,
        newValue: this.value_,
        oldValue: void 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.raw = function raw() {
    return this.value_;
  };
  _proto.toJSON = function toJSON2() {
    return this.get();
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.value_ + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return ObservableValue2;
}(Atom);
var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);
var ComputedValue = function() {
  function ComputedValue2(options) {
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.observing_ = [];
    this.newObserving_ = null;
    this.observers_ = /* @__PURE__ */ new Set();
    this.runId_ = 0;
    this.lastAccessedBy_ = 0;
    this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    this.unboundDepsCount_ = 0;
    this.value_ = new CaughtException(null);
    this.name_ = void 0;
    this.triggeredBy_ = void 0;
    this.flags_ = 0;
    this.derivation = void 0;
    this.setter_ = void 0;
    this.isTracing_ = TraceMode.NONE;
    this.scope_ = void 0;
    this.equals_ = void 0;
    this.requiresReaction_ = void 0;
    this.keepAlive_ = void 0;
    this.onBOL = void 0;
    this.onBUOL = void 0;
    if (!options.get) {
      die(31);
    }
    this.derivation = options.get;
    this.name_ = options.name || (true ? "ComputedValue@" + getNextId() : "ComputedValue");
    if (options.set) {
      this.setter_ = createAction(true ? this.name_ + "-setter" : "ComputedValue-setter", options.set);
    }
    this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
    this.scope_ = options.context;
    this.requiresReaction_ = options.requiresReaction;
    this.keepAlive_ = !!options.keepAlive;
  }
  var _proto = ComputedValue2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    propagateMaybeChanged(this);
  };
  _proto.onBO = function onBO() {
    if (this.onBOL) {
      this.onBOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.onBUO = function onBUO() {
    if (this.onBUOL) {
      this.onBUOL.forEach(function(listener) {
        return listener();
      });
    }
  };
  _proto.get = function get3() {
    if (this.isComputing) {
      die(32, this.name_, this.derivation);
    }
    if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
    this.observers_.size === 0 && !this.keepAlive_) {
      if (shouldCompute(this)) {
        this.warnAboutUntrackedRead_();
        startBatch();
        this.value_ = this.computeValue_(false);
        endBatch();
      }
    } else {
      reportObserved(this);
      if (shouldCompute(this)) {
        var prevTrackingContext = globalState.trackingContext;
        if (this.keepAlive_ && !prevTrackingContext) {
          globalState.trackingContext = this;
        }
        if (this.trackAndCompute()) {
          propagateChangeConfirmed(this);
        }
        globalState.trackingContext = prevTrackingContext;
      }
    }
    var result = this.value_;
    if (isCaughtException(result)) {
      throw result.cause;
    }
    return result;
  };
  _proto.set = function set4(value) {
    if (this.setter_) {
      if (this.isRunningSetter) {
        die(33, this.name_);
      }
      this.isRunningSetter = true;
      try {
        this.setter_.call(this.scope_, value);
      } finally {
        this.isRunningSetter = false;
      }
    } else {
      die(34, this.name_);
    }
  };
  _proto.trackAndCompute = function trackAndCompute() {
    var oldValue = this.value_;
    var wasSuspended = (
      /* see #1208 */
      this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
    );
    var newValue = this.computeValue_(true);
    var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
    if (changed) {
      this.value_ = newValue;
      if (isSpyEnabled()) {
        spyReport({
          observableKind: "computed",
          debugObjectName: this.name_,
          object: this.scope_,
          type: "update",
          oldValue,
          newValue
        });
      }
    }
    return changed;
  };
  _proto.computeValue_ = function computeValue_(track) {
    this.isComputing = true;
    var prev = allowStateChangesStart(false);
    var res;
    if (track) {
      res = trackDerivedFunction(this, this.derivation, this.scope_);
    } else {
      if (globalState.disableErrorBoundaries === true) {
        res = this.derivation.call(this.scope_);
      } else {
        try {
          res = this.derivation.call(this.scope_);
        } catch (e) {
          res = new CaughtException(e);
        }
      }
    }
    allowStateChangesEnd(prev);
    this.isComputing = false;
    return res;
  };
  _proto.suspend_ = function suspend_() {
    if (!this.keepAlive_) {
      clearObserving(this);
      this.value_ = void 0;
      if (this.isTracing_ !== TraceMode.NONE) {
        console.log("[mobx.trace] Computed value '" + this.name_ + "' was suspended and it will recompute on the next access.");
      }
    }
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    var _this = this;
    var firstTime = true;
    var prevValue = void 0;
    return autorun(function() {
      var newValue = _this.get();
      if (!firstTime || fireImmediately) {
        var prevU = untrackedStart();
        listener({
          observableKind: "computed",
          debugObjectName: _this.name_,
          type: UPDATE,
          object: _this,
          newValue,
          oldValue: prevValue
        });
        untrackedEnd(prevU);
      }
      firstTime = false;
      prevValue = newValue;
    });
  };
  _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
    if (false) {
      return;
    }
    if (this.isTracing_ !== TraceMode.NONE) {
      console.log("[mobx.trace] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
    if (typeof this.requiresReaction_ === "boolean" ? this.requiresReaction_ : globalState.computedRequiresReaction) {
      console.warn("[mobx] Computed value '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute.");
    }
  };
  _proto.toString = function toString2() {
    return this.name_ + "[" + this.derivation.toString() + "]";
  };
  _proto.valueOf = function valueOf() {
    return toPrimitive(this.get());
  };
  _proto[Symbol.toPrimitive] = function() {
    return this.valueOf();
  };
  return _createClass(ComputedValue2, [{
    key: "isComputing",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isComputingMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isComputingMask_, newValue);
    }
  }, {
    key: "isRunningSetter",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isRunningSetterMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isRunningSetterMask_, newValue);
    }
  }, {
    key: "isBeingObserved",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isBeingObservedMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isBeingObservedMask_, newValue);
    }
  }, {
    key: "isPendingUnobservation",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.isPendingUnobservationMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get3() {
      return getFlag(this.flags_, ComputedValue2.diffValueMask_) ? 1 : 0;
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, ComputedValue2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
ComputedValue.isComputingMask_ = 1;
ComputedValue.isRunningSetterMask_ = 2;
ComputedValue.isBeingObservedMask_ = 4;
ComputedValue.isPendingUnobservationMask_ = 8;
ComputedValue.diffValueMask_ = 16;
var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
var IDerivationState_;
(function(IDerivationState_2) {
  IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
  IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
  IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
  IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
})(IDerivationState_ || (IDerivationState_ = {}));
var TraceMode;
(function(TraceMode2) {
  TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
  TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
  TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
})(TraceMode || (TraceMode = {}));
var CaughtException = function CaughtException2(cause) {
  this.cause = void 0;
  this.cause = cause;
};
function isCaughtException(e) {
  return e instanceof CaughtException;
}
function shouldCompute(derivation) {
  switch (derivation.dependenciesState_) {
    case IDerivationState_.UP_TO_DATE_:
      return false;
    case IDerivationState_.NOT_TRACKING_:
    case IDerivationState_.STALE_:
      return true;
    case IDerivationState_.POSSIBLY_STALE_: {
      var prevAllowStateReads = allowStateReadsStart(true);
      var prevUntracked = untrackedStart();
      var obs = derivation.observing_, l = obs.length;
      for (var i = 0; i < l; i++) {
        var obj = obs[i];
        if (isComputedValue(obj)) {
          if (globalState.disableErrorBoundaries) {
            obj.get();
          } else {
            try {
              obj.get();
            } catch (e) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
          if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
            untrackedEnd(prevUntracked);
            allowStateReadsEnd(prevAllowStateReads);
            return true;
          }
        }
      }
      changeDependenciesStateTo0(derivation);
      untrackedEnd(prevUntracked);
      allowStateReadsEnd(prevAllowStateReads);
      return false;
    }
  }
}
function checkIfStateModificationsAreAllowed(atom) {
  if (false) {
    return;
  }
  var hasObservers = atom.observers_.size > 0;
  if (!globalState.allowStateChanges && (hasObservers || globalState.enforceActions === "always")) {
    console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
  }
}
function checkIfStateReadsAreAllowed(observable2) {
  if (!globalState.allowStateReads && globalState.observableRequiresReaction) {
    console.warn("[mobx] Observable '" + observable2.name_ + "' being read outside a reactive context.");
  }
}
function trackDerivedFunction(derivation, f, context) {
  var prevAllowStateReads = allowStateReadsStart(true);
  changeDependenciesStateTo0(derivation);
  derivation.newObserving_ = new Array(
    // Reserve constant space for initial dependencies, dynamic space otherwise.
    // See https://github.com/mobxjs/mobx/pull/3833
    derivation.runId_ === 0 ? 100 : derivation.observing_.length
  );
  derivation.unboundDepsCount_ = 0;
  derivation.runId_ = ++globalState.runId;
  var prevTracking = globalState.trackingDerivation;
  globalState.trackingDerivation = derivation;
  globalState.inBatch++;
  var result;
  if (globalState.disableErrorBoundaries === true) {
    result = f.call(context);
  } else {
    try {
      result = f.call(context);
    } catch (e) {
      result = new CaughtException(e);
    }
  }
  globalState.inBatch--;
  globalState.trackingDerivation = prevTracking;
  bindDependencies(derivation);
  warnAboutDerivationWithoutDependencies(derivation);
  allowStateReadsEnd(prevAllowStateReads);
  return result;
}
function warnAboutDerivationWithoutDependencies(derivation) {
  if (false) {
    return;
  }
  if (derivation.observing_.length !== 0) {
    return;
  }
  if (typeof derivation.requiresObservable_ === "boolean" ? derivation.requiresObservable_ : globalState.reactionRequiresObservable) {
    console.warn("[mobx] Derivation '" + derivation.name_ + "' is created/updated without reading any observable value.");
  }
}
function bindDependencies(derivation) {
  var prevObserving = derivation.observing_;
  var observing = derivation.observing_ = derivation.newObserving_;
  var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
  var i0 = 0, l = derivation.unboundDepsCount_;
  for (var i = 0; i < l; i++) {
    var dep = observing[i];
    if (dep.diffValue === 0) {
      dep.diffValue = 1;
      if (i0 !== i) {
        observing[i0] = dep;
      }
      i0++;
    }
    if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
      lowestNewObservingDerivationState = dep.dependenciesState_;
    }
  }
  observing.length = i0;
  derivation.newObserving_ = null;
  l = prevObserving.length;
  while (l--) {
    var _dep = prevObserving[l];
    if (_dep.diffValue === 0) {
      removeObserver(_dep, derivation);
    }
    _dep.diffValue = 0;
  }
  while (i0--) {
    var _dep2 = observing[i0];
    if (_dep2.diffValue === 1) {
      _dep2.diffValue = 0;
      addObserver(_dep2, derivation);
    }
  }
  if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
    derivation.dependenciesState_ = lowestNewObservingDerivationState;
    derivation.onBecomeStale_();
  }
}
function clearObserving(derivation) {
  var obs = derivation.observing_;
  derivation.observing_ = [];
  var i = obs.length;
  while (i--) {
    removeObserver(obs[i], derivation);
  }
  derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
}
function untracked(action2) {
  var prev = untrackedStart();
  try {
    return action2();
  } finally {
    untrackedEnd(prev);
  }
}
function untrackedStart() {
  var prev = globalState.trackingDerivation;
  globalState.trackingDerivation = null;
  return prev;
}
function untrackedEnd(prev) {
  globalState.trackingDerivation = prev;
}
function allowStateReadsStart(allowStateReads) {
  var prev = globalState.allowStateReads;
  globalState.allowStateReads = allowStateReads;
  return prev;
}
function allowStateReadsEnd(prev) {
  globalState.allowStateReads = prev;
}
function changeDependenciesStateTo0(derivation) {
  if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
    return;
  }
  derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
  var obs = derivation.observing_;
  var i = obs.length;
  while (i--) {
    obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
  }
}
var MobXGlobals = function MobXGlobals2() {
  this.version = 6;
  this.UNCHANGED = {};
  this.trackingDerivation = null;
  this.trackingContext = null;
  this.runId = 0;
  this.mobxGuid = 0;
  this.inBatch = 0;
  this.pendingUnobservations = [];
  this.pendingReactions = [];
  this.isRunningReactions = false;
  this.allowStateChanges = false;
  this.allowStateReads = true;
  this.enforceActions = true;
  this.spyListeners = [];
  this.globalReactionErrorHandlers = [];
  this.computedRequiresReaction = false;
  this.reactionRequiresObservable = false;
  this.observableRequiresReaction = false;
  this.disableErrorBoundaries = false;
  this.suppressReactionErrors = false;
  this.useProxies = true;
  this.verifyProxies = false;
  this.safeDescriptors = true;
};
var canMergeGlobalState = true;
var isolateCalled = false;
var globalState = function() {
  var global2 = getGlobal();
  if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
    canMergeGlobalState = false;
  }
  if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
    canMergeGlobalState = false;
  }
  if (!canMergeGlobalState) {
    setTimeout(function() {
      if (!isolateCalled) {
        die(35);
      }
    }, 1);
    return new MobXGlobals();
  } else if (global2.__mobxGlobals) {
    global2.__mobxInstanceCount += 1;
    if (!global2.__mobxGlobals.UNCHANGED) {
      global2.__mobxGlobals.UNCHANGED = {};
    }
    return global2.__mobxGlobals;
  } else {
    global2.__mobxInstanceCount = 1;
    return global2.__mobxGlobals = new MobXGlobals();
  }
}();
function addObserver(observable2, node) {
  observable2.observers_.add(node);
  if (observable2.lowestObserverState_ > node.dependenciesState_) {
    observable2.lowestObserverState_ = node.dependenciesState_;
  }
}
function removeObserver(observable2, node) {
  observable2.observers_["delete"](node);
  if (observable2.observers_.size === 0) {
    queueForUnobservation(observable2);
  }
}
function queueForUnobservation(observable2) {
  if (observable2.isPendingUnobservation === false) {
    observable2.isPendingUnobservation = true;
    globalState.pendingUnobservations.push(observable2);
  }
}
function startBatch() {
  globalState.inBatch++;
}
function endBatch() {
  if (--globalState.inBatch === 0) {
    runReactions();
    var list = globalState.pendingUnobservations;
    for (var i = 0; i < list.length; i++) {
      var observable2 = list[i];
      observable2.isPendingUnobservation = false;
      if (observable2.observers_.size === 0) {
        if (observable2.isBeingObserved) {
          observable2.isBeingObserved = false;
          observable2.onBUO();
        }
        if (observable2 instanceof ComputedValue) {
          observable2.suspend_();
        }
      }
    }
    globalState.pendingUnobservations = [];
  }
}
function reportObserved(observable2) {
  checkIfStateReadsAreAllowed(observable2);
  var derivation = globalState.trackingDerivation;
  if (derivation !== null) {
    if (derivation.runId_ !== observable2.lastAccessedBy_) {
      observable2.lastAccessedBy_ = derivation.runId_;
      derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
      if (!observable2.isBeingObserved && globalState.trackingContext) {
        observable2.isBeingObserved = true;
        observable2.onBO();
      }
    }
    return observable2.isBeingObserved;
  } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
    queueForUnobservation(observable2);
  }
  return false;
}
function propagateChanged(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      if (d2.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d2, observable2);
      }
      d2.onBecomeStale_();
    }
    d2.dependenciesState_ = IDerivationState_.STALE_;
  });
}
function propagateChangeConfirmed(observable2) {
  if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
      d2.dependenciesState_ = IDerivationState_.STALE_;
      if (d2.isTracing_ !== TraceMode.NONE) {
        logTraceInfo(d2, observable2);
      }
    } else if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  });
}
function propagateMaybeChanged(observable2) {
  if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
    return;
  }
  observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
  observable2.observers_.forEach(function(d2) {
    if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      d2.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
      d2.onBecomeStale_();
    }
  });
}
function logTraceInfo(derivation, observable2) {
  console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable2.name_ + "'");
  if (derivation.isTracing_ === TraceMode.BREAK) {
    var lines = [];
    printDepTree(getDependencyTree(derivation), lines, 1);
    new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable2.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
  }
}
function printDepTree(tree, lines, depth) {
  if (lines.length >= 1e3) {
    lines.push("(and many more)");
    return;
  }
  lines.push("" + "	".repeat(depth - 1) + tree.name);
  if (tree.dependencies) {
    tree.dependencies.forEach(function(child) {
      return printDepTree(child, lines, depth + 1);
    });
  }
}
var Reaction = function() {
  function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
    if (name_ === void 0) {
      name_ = true ? "Reaction@" + getNextId() : "Reaction";
    }
    this.name_ = void 0;
    this.onInvalidate_ = void 0;
    this.errorHandler_ = void 0;
    this.requiresObservable_ = void 0;
    this.observing_ = [];
    this.newObserving_ = [];
    this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
    this.runId_ = 0;
    this.unboundDepsCount_ = 0;
    this.flags_ = 0;
    this.isTracing_ = TraceMode.NONE;
    this.name_ = name_;
    this.onInvalidate_ = onInvalidate_;
    this.errorHandler_ = errorHandler_;
    this.requiresObservable_ = requiresObservable_;
  }
  var _proto = Reaction2.prototype;
  _proto.onBecomeStale_ = function onBecomeStale_() {
    this.schedule_();
  };
  _proto.schedule_ = function schedule_() {
    if (!this.isScheduled) {
      this.isScheduled = true;
      globalState.pendingReactions.push(this);
      runReactions();
    }
  };
  _proto.runReaction_ = function runReaction_() {
    if (!this.isDisposed) {
      startBatch();
      this.isScheduled = false;
      var prev = globalState.trackingContext;
      globalState.trackingContext = this;
      if (shouldCompute(this)) {
        this.isTrackPending = true;
        try {
          this.onInvalidate_();
          if (this.isTrackPending && isSpyEnabled()) {
            spyReport({
              name: this.name_,
              type: "scheduled-reaction"
            });
          }
        } catch (e) {
          this.reportExceptionInDerivation_(e);
        }
      }
      globalState.trackingContext = prev;
      endBatch();
    }
  };
  _proto.track = function track(fn2) {
    if (this.isDisposed) {
      return;
    }
    startBatch();
    var notify = isSpyEnabled();
    var startTime;
    if (notify) {
      startTime = Date.now();
      spyReportStart({
        name: this.name_,
        type: "reaction"
      });
    }
    this.isRunning = true;
    var prevReaction = globalState.trackingContext;
    globalState.trackingContext = this;
    var result = trackDerivedFunction(this, fn2, void 0);
    globalState.trackingContext = prevReaction;
    this.isRunning = false;
    this.isTrackPending = false;
    if (this.isDisposed) {
      clearObserving(this);
    }
    if (isCaughtException(result)) {
      this.reportExceptionInDerivation_(result.cause);
    }
    if (notify) {
      spyReportEnd({
        time: Date.now() - startTime
      });
    }
    endBatch();
  };
  _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
    var _this = this;
    if (this.errorHandler_) {
      this.errorHandler_(error, this);
      return;
    }
    if (globalState.disableErrorBoundaries) {
      throw error;
    }
    var message = true ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
    if (!globalState.suppressReactionErrors) {
      console.error(message, error);
    } else if (true) {
      console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)");
    }
    if (isSpyEnabled()) {
      spyReport({
        type: "error",
        name: this.name_,
        message,
        error: "" + error
      });
    }
    globalState.globalReactionErrorHandlers.forEach(function(f) {
      return f(error, _this);
    });
  };
  _proto.dispose = function dispose() {
    if (!this.isDisposed) {
      this.isDisposed = true;
      if (!this.isRunning) {
        startBatch();
        clearObserving(this);
        endBatch();
      }
    }
  };
  _proto.getDisposer_ = function getDisposer_(abortSignal) {
    var _this2 = this;
    var dispose = function dispose2() {
      _this2.dispose();
      abortSignal == null || abortSignal.removeEventListener == null || abortSignal.removeEventListener("abort", dispose2);
    };
    abortSignal == null || abortSignal.addEventListener == null || abortSignal.addEventListener("abort", dispose);
    dispose[$mobx] = this;
    if ("dispose" in Symbol && typeof Symbol.dispose === "symbol") {
      dispose[Symbol.dispose] = dispose;
    }
    return dispose;
  };
  _proto.toString = function toString2() {
    return "Reaction[" + this.name_ + "]";
  };
  _proto.trace = function trace$1(enterBreakPoint) {
    if (enterBreakPoint === void 0) {
      enterBreakPoint = false;
    }
    trace(this, enterBreakPoint);
  };
  return _createClass(Reaction2, [{
    key: "isDisposed",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isDisposedMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isDisposedMask_, newValue);
    }
  }, {
    key: "isScheduled",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isScheduledMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isScheduledMask_, newValue);
    }
  }, {
    key: "isTrackPending",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isTrackPendingMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isTrackPendingMask_, newValue);
    }
  }, {
    key: "isRunning",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.isRunningMask_);
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.isRunningMask_, newValue);
    }
  }, {
    key: "diffValue",
    get: function get3() {
      return getFlag(this.flags_, Reaction2.diffValueMask_) ? 1 : 0;
    },
    set: function set4(newValue) {
      this.flags_ = setFlag(this.flags_, Reaction2.diffValueMask_, newValue === 1 ? true : false);
    }
  }]);
}();
Reaction.isDisposedMask_ = 1;
Reaction.isScheduledMask_ = 2;
Reaction.isTrackPendingMask_ = 4;
Reaction.isRunningMask_ = 8;
Reaction.diffValueMask_ = 16;
var MAX_REACTION_ITERATIONS = 100;
var reactionScheduler = function reactionScheduler2(f) {
  return f();
};
function runReactions() {
  if (globalState.inBatch > 0 || globalState.isRunningReactions) {
    return;
  }
  reactionScheduler(runReactionsHelper);
}
function runReactionsHelper() {
  globalState.isRunningReactions = true;
  var allReactions = globalState.pendingReactions;
  var iterations = 0;
  while (allReactions.length > 0) {
    if (++iterations === MAX_REACTION_ITERATIONS) {
      console.error(true ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations." + (" Probably there is a cycle in the reactive function: " + allReactions[0]) : "[mobx] cycle in reaction: " + allReactions[0]);
      allReactions.splice(0);
    }
    var remainingReactions = allReactions.splice(0);
    for (var i = 0, l = remainingReactions.length; i < l; i++) {
      remainingReactions[i].runReaction_();
    }
  }
  globalState.isRunningReactions = false;
}
var isReaction = createInstanceofPredicate("Reaction", Reaction);
function isSpyEnabled() {
  return !!globalState.spyListeners.length;
}
function spyReport(event) {
  if (false) {
    return;
  }
  if (!globalState.spyListeners.length) {
    return;
  }
  var listeners = globalState.spyListeners;
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](event);
  }
}
function spyReportStart(event) {
  if (false) {
    return;
  }
  var change = _extends({}, event, {
    spyReportStart: true
  });
  spyReport(change);
}
var END_EVENT = {
  type: "report-end",
  spyReportEnd: true
};
function spyReportEnd(change) {
  if (false) {
    return;
  }
  if (change) {
    spyReport(_extends({}, change, {
      type: "report-end",
      spyReportEnd: true
    }));
  } else {
    spyReport(END_EVENT);
  }
}
function spy(listener) {
  if (false) {
    console.warn("[mobx.spy] Is a no-op in production builds");
    return function() {
    };
  } else {
    globalState.spyListeners.push(listener);
    return once(function() {
      globalState.spyListeners = globalState.spyListeners.filter(function(l) {
        return l !== listener;
      });
    });
  }
}
var ACTION = "action";
var ACTION_BOUND = "action.bound";
var AUTOACTION = "autoAction";
var AUTOACTION_BOUND = "autoAction.bound";
var DEFAULT_ACTION_NAME = "<unnamed action>";
var actionAnnotation = createActionAnnotation(ACTION);
var actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, {
  bound: true
});
var autoActionAnnotation = createActionAnnotation(AUTOACTION, {
  autoAction: true
});
var autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, {
  autoAction: true,
  bound: true
});
function createActionFactory(autoAction2) {
  var res = function action2(arg1, arg2) {
    if (isFunction(arg1)) {
      return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
    }
    if (isFunction(arg2)) {
      return createAction(arg1, arg2, autoAction2);
    }
    if (is20223Decorator(arg2)) {
      return (autoAction2 ? autoActionAnnotation : actionAnnotation).decorate_20223_(arg1, arg2);
    }
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
    }
    if (isStringish(arg1)) {
      return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
        name: arg1,
        autoAction: autoAction2
      }));
    }
    if (true) {
      die("Invalid arguments for `action`");
    }
  };
  return res;
}
var action = createActionFactory(false);
Object.assign(action, actionAnnotation);
var autoAction = createActionFactory(true);
Object.assign(autoAction, autoActionAnnotation);
action.bound = createDecoratorAnnotation(actionBoundAnnotation);
autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation);
function runInAction(fn2) {
  return executeAction(fn2.name || DEFAULT_ACTION_NAME, false, fn2, this, void 0);
}
function isAction(thing) {
  return isFunction(thing) && thing.isMobxAction === true;
}
function autorun(view, opts) {
  var _opts$name, _opts, _opts2, _opts3;
  if (opts === void 0) {
    opts = EMPTY_OBJECT;
  }
  if (true) {
    if (!isFunction(view)) {
      die("Autorun expects a function as first argument");
    }
    if (isAction(view)) {
      die("Autorun does not accept actions since actions are untrackable");
    }
  }
  var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : true ? view.name || "Autorun@" + getNextId() : "Autorun";
  var runSync = !opts.scheduler && !opts.delay;
  var reaction;
  if (runSync) {
    reaction = new Reaction(name, function() {
      this.track(reactionRunner);
    }, opts.onError, opts.requiresObservable);
  } else {
    var scheduler = createSchedulerFromOptions(opts);
    var isScheduled = false;
    reaction = new Reaction(name, function() {
      if (!isScheduled) {
        isScheduled = true;
        scheduler(function() {
          isScheduled = false;
          if (!reaction.isDisposed) {
            reaction.track(reactionRunner);
          }
        });
      }
    }, opts.onError, opts.requiresObservable);
  }
  function reactionRunner() {
    view(reaction);
  }
  if (!((_opts2 = opts) != null && (_opts2 = _opts2.signal) != null && _opts2.aborted)) {
    reaction.schedule_();
  }
  return reaction.getDisposer_((_opts3 = opts) == null ? void 0 : _opts3.signal);
}
var run = function run2(f) {
  return f();
};
function createSchedulerFromOptions(opts) {
  return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
    return setTimeout(f, opts.delay);
  } : run;
}
var ON_BECOME_OBSERVED = "onBO";
var ON_BECOME_UNOBSERVED = "onBUO";
function onBecomeObserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
}
function onBecomeUnobserved(thing, arg2, arg3) {
  return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
}
function interceptHook(hook, thing, arg2, arg3) {
  var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
  var cb = isFunction(arg3) ? arg3 : arg2;
  var listenersKey = hook + "L";
  if (atom[listenersKey]) {
    atom[listenersKey].add(cb);
  } else {
    atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
  }
  return function() {
    var hookListeners = atom[listenersKey];
    if (hookListeners) {
      hookListeners["delete"](cb);
      if (hookListeners.size === 0) {
        delete atom[listenersKey];
      }
    }
  };
}
function extendObservable(target, properties, annotations, options) {
  if (true) {
    if (arguments.length > 4) {
      die("'extendObservable' expected 2-4 arguments");
    }
    if (typeof target !== "object") {
      die("'extendObservable' expects an object as first argument");
    }
    if (isObservableMap(target)) {
      die("'extendObservable' should not be used on maps, use map.merge instead");
    }
    if (!isPlainObject(properties)) {
      die("'extendObservable' only accepts plain objects as second argument");
    }
    if (isObservable(properties) || isObservable(annotations)) {
      die("Extending an object with another observable (object) is not supported");
    }
  }
  var descriptors = getOwnPropertyDescriptors(properties);
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    ownKeys(descriptors).forEach(function(key) {
      adm.extend_(
        key,
        descriptors[key],
        // must pass "undefined" for { key: undefined }
        !annotations ? true : key in annotations ? annotations[key] : true
      );
    });
  });
  return target;
}
function getDependencyTree(thing, property) {
  return nodeToDependencyTree(getAtom(thing, property));
}
function nodeToDependencyTree(node) {
  var result = {
    name: node.name_
  };
  if (node.observing_ && node.observing_.length > 0) {
    result.dependencies = unique(node.observing_).map(nodeToDependencyTree);
  }
  return result;
}
function unique(list) {
  return Array.from(new Set(list));
}
var generatorId = 0;
function FlowCancellationError() {
  this.message = "FLOW_CANCELLED";
}
FlowCancellationError.prototype = Object.create(Error.prototype);
var flowAnnotation = createFlowAnnotation("flow");
var flowBoundAnnotation = createFlowAnnotation("flow.bound", {
  bound: true
});
var flow = Object.assign(function flow2(arg1, arg2) {
  if (is20223Decorator(arg2)) {
    return flowAnnotation.decorate_20223_(arg1, arg2);
  }
  if (isStringish(arg2)) {
    return storeAnnotation(arg1, arg2, flowAnnotation);
  }
  if (arguments.length !== 1) {
    die("Flow expects single argument with generator function");
  }
  var generator = arg1;
  var name = generator.name || "<unnamed flow>";
  var res = function res2() {
    var ctx = this;
    var args = arguments;
    var runId = ++generatorId;
    var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
    var rejector;
    var pendingPromise = void 0;
    var promise = new Promise(function(resolve, reject) {
      var stepId = 0;
      rejector = reject;
      function onFulfilled(res3) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function onRejected(err) {
        pendingPromise = void 0;
        var ret;
        try {
          ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
        } catch (e) {
          return reject(e);
        }
        next(ret);
      }
      function next(ret) {
        if (isFunction(ret == null ? void 0 : ret.then)) {
          ret.then(next, reject);
          return;
        }
        if (ret.done) {
          return resolve(ret.value);
        }
        pendingPromise = Promise.resolve(ret.value);
        return pendingPromise.then(onFulfilled, onRejected);
      }
      onFulfilled(void 0);
    });
    promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
      try {
        if (pendingPromise) {
          cancelPromise(pendingPromise);
        }
        var _res = gen["return"](void 0);
        var yieldedPromise = Promise.resolve(_res.value);
        yieldedPromise.then(noop, noop);
        cancelPromise(yieldedPromise);
        rejector(new FlowCancellationError());
      } catch (e) {
        rejector(e);
      }
    });
    return promise;
  };
  res.isMobXFlow = true;
  return res;
}, flowAnnotation);
flow.bound = createDecoratorAnnotation(flowBoundAnnotation);
function cancelPromise(promise) {
  if (isFunction(promise.cancel)) {
    promise.cancel();
  }
}
function isFlow(fn2) {
  return (fn2 == null ? void 0 : fn2.isMobXFlow) === true;
}
function _isObservable(value, property) {
  if (!value) {
    return false;
  }
  if (property !== void 0) {
    if (isObservableMap(value) || isObservableArray(value)) {
      return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
    }
    if (isObservableObject(value)) {
      return value[$mobx].values_.has(property);
    }
    return false;
  }
  return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
}
function isObservable(value) {
  if (arguments.length !== 1) {
    die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
  }
  return _isObservable(value);
}
function trace() {
  if (false) {
    return;
  }
  var enterBreakPoint = false;
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (typeof args[args.length - 1] === "boolean") {
    enterBreakPoint = args.pop();
  }
  var derivation = getAtomFromArgs(args);
  if (!derivation) {
    return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
  }
  if (derivation.isTracing_ === TraceMode.NONE) {
    console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
  }
  derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
}
function getAtomFromArgs(args) {
  switch (args.length) {
    case 0:
      return globalState.trackingDerivation;
    case 1:
      return getAtom(args[0]);
    case 2:
      return getAtom(args[0], args[1]);
  }
}
function transaction(action2, thisArg) {
  if (thisArg === void 0) {
    thisArg = void 0;
  }
  startBatch();
  try {
    return action2.apply(thisArg);
  } finally {
    endBatch();
  }
}
function getAdm(target) {
  return target[$mobx];
}
var objectProxyTraps = {
  has: function has(target, name) {
    if (globalState.trackingDerivation) {
      warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
    }
    return getAdm(target).has_(name);
  },
  get: function get(target, name) {
    return getAdm(target).get_(name);
  },
  set: function set2(target, name, value) {
    var _getAdm$set_;
    if (!isStringish(name)) {
      return false;
    }
    if (!getAdm(target).values_.has(name)) {
      warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
    }
    return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
  },
  deleteProperty: function deleteProperty(target, name) {
    var _getAdm$delete_;
    if (true) {
      warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
    }
    if (!isStringish(name)) {
      return false;
    }
    return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
  },
  defineProperty: function defineProperty2(target, name, descriptor) {
    var _getAdm$definePropert;
    if (true) {
      warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
    }
    return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
  },
  ownKeys: function ownKeys2(target) {
    if (globalState.trackingDerivation) {
      warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
    }
    return getAdm(target).ownKeys_();
  },
  preventExtensions: function preventExtensions(target) {
    die(13);
  }
};
function asDynamicObservableObject(target, options) {
  var _target$$mobx, _target$$mobx$proxy_;
  assertProxies();
  target = asObservableObject(target, options);
  return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
}
function hasInterceptors(interceptable) {
  return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
}
function registerInterceptor(interceptable, handler) {
  var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
  interceptors.push(handler);
  return once(function() {
    var idx = interceptors.indexOf(handler);
    if (idx !== -1) {
      interceptors.splice(idx, 1);
    }
  });
}
function interceptChange(interceptable, change) {
  var prevU = untrackedStart();
  try {
    var interceptors = [].concat(interceptable.interceptors_ || []);
    for (var i = 0, l = interceptors.length; i < l; i++) {
      change = interceptors[i](change);
      if (change && !change.type) {
        die(14);
      }
      if (!change) {
        break;
      }
    }
    return change;
  } finally {
    untrackedEnd(prevU);
  }
}
function hasListeners(listenable) {
  return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
}
function registerListener(listenable, handler) {
  var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
  listeners.push(handler);
  return once(function() {
    var idx = listeners.indexOf(handler);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  });
}
function notifyListeners(listenable, change) {
  var prevU = untrackedStart();
  var listeners = listenable.changeListeners_;
  if (!listeners) {
    return;
  }
  listeners = listeners.slice();
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i](change);
  }
  untrackedEnd(prevU);
}
var keysSymbol = Symbol("mobx-keys");
function makeAutoObservable(target, overrides, options) {
  if (true) {
    if (!isPlainObject(target) && !isPlainObject(Object.getPrototypeOf(target))) {
      die("'makeAutoObservable' can only be used for classes that don't have a superclass");
    }
    if (isObservableObject(target)) {
      die("makeAutoObservable can only be used on objects not already made observable");
    }
  }
  if (isPlainObject(target)) {
    return extendObservable(target, target, overrides, options);
  }
  initObservable(function() {
    var adm = asObservableObject(target, options)[$mobx];
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
      keys["delete"]("constructor");
      keys["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys);
    }
    target[keysSymbol].forEach(function(key) {
      return adm.make_(
        key,
        // must pass "undefined" for { key: undefined }
        !overrides ? true : key in overrides ? overrides[key] : true
      );
    });
  });
  return target;
}
var SPLICE = "splice";
var UPDATE = "update";
var MAX_SPLICE_SIZE = 1e4;
var arrayTraps = {
  get: function get2(target, name) {
    var adm = target[$mobx];
    if (name === $mobx) {
      return adm;
    }
    if (name === "length") {
      return adm.getArrayLength_();
    }
    if (typeof name === "string" && !isNaN(name)) {
      return adm.get_(parseInt(name));
    }
    if (hasProp(arrayExtensions, name)) {
      return arrayExtensions[name];
    }
    return target[name];
  },
  set: function set3(target, name, value) {
    var adm = target[$mobx];
    if (name === "length") {
      adm.setArrayLength_(value);
    }
    if (typeof name === "symbol" || isNaN(name)) {
      target[name] = value;
    } else {
      adm.set_(parseInt(name), value);
    }
    return true;
  },
  preventExtensions: function preventExtensions2() {
    die(15);
  }
};
var ObservableArrayAdministration = function() {
  function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
    if (name === void 0) {
      name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    this.owned_ = void 0;
    this.legacyMode_ = void 0;
    this.atom_ = void 0;
    this.values_ = [];
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.enhancer_ = void 0;
    this.dehancer = void 0;
    this.proxy_ = void 0;
    this.lastKnownLength_ = 0;
    this.owned_ = owned_;
    this.legacyMode_ = legacyMode_;
    this.atom_ = new Atom(name);
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, true ? name + "[..]" : "ObservableArray[..]");
    };
  }
  var _proto = ObservableArrayAdministration2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.dehanceValues_ = function dehanceValues_(values) {
    if (this.dehancer !== void 0 && values.length > 0) {
      return values.map(this.dehancer);
    }
    return values;
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === void 0) {
      fireImmediately = false;
    }
    if (fireImmediately) {
      listener({
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: "splice",
        index: 0,
        added: this.values_.slice(),
        addedCount: this.values_.length,
        removed: [],
        removedCount: 0
      });
    }
    return registerListener(this, listener);
  };
  _proto.getArrayLength_ = function getArrayLength_() {
    this.atom_.reportObserved();
    return this.values_.length;
  };
  _proto.setArrayLength_ = function setArrayLength_(newLength) {
    if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
      die("Out of range: " + newLength);
    }
    var currentLength = this.values_.length;
    if (newLength === currentLength) {
      return;
    } else if (newLength > currentLength) {
      var newItems = new Array(newLength - currentLength);
      for (var i = 0; i < newLength - currentLength; i++) {
        newItems[i] = void 0;
      }
      this.spliceWithArray_(currentLength, 0, newItems);
    } else {
      this.spliceWithArray_(newLength, currentLength - newLength);
    }
  };
  _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
    if (oldLength !== this.lastKnownLength_) {
      die(16);
    }
    this.lastKnownLength_ += delta;
    if (this.legacyMode_ && delta > 0) {
      reserveArrayBuffer(oldLength + delta + 1);
    }
  };
  _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
    var _this = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    var length = this.values_.length;
    if (index === void 0) {
      index = 0;
    } else if (index > length) {
      index = length;
    } else if (index < 0) {
      index = Math.max(0, length + index);
    }
    if (arguments.length === 1) {
      deleteCount = length - index;
    } else if (deleteCount === void 0 || deleteCount === null) {
      deleteCount = 0;
    } else {
      deleteCount = Math.max(0, Math.min(deleteCount, length - index));
    }
    if (newItems === void 0) {
      newItems = EMPTY_ARRAY;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_,
        type: SPLICE,
        index,
        removedCount: deleteCount,
        added: newItems
      });
      if (!change) {
        return EMPTY_ARRAY;
      }
      deleteCount = change.removedCount;
      newItems = change.added;
    }
    newItems = newItems.length === 0 ? newItems : newItems.map(function(v) {
      return _this.enhancer_(v, void 0);
    });
    if (this.legacyMode_ || true) {
      var lengthDelta = newItems.length - deleteCount;
      this.updateArrayLength_(length, lengthDelta);
    }
    var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
    if (deleteCount !== 0 || newItems.length !== 0) {
      this.notifyArraySplice_(index, newItems, res);
    }
    return this.dehanceValues_(res);
  };
  _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
    if (newItems.length < MAX_SPLICE_SIZE) {
      var _this$values_;
      return (_this$values_ = this.values_).splice.apply(_this$values_, [index, deleteCount].concat(newItems));
    } else {
      var res = this.values_.slice(index, index + deleteCount);
      var oldItems = this.values_.slice(index + deleteCount);
      this.values_.length += newItems.length - deleteCount;
      for (var i = 0; i < newItems.length; i++) {
        this.values_[index + i] = newItems[i];
      }
      for (var _i2 = 0; _i2 < oldItems.length; _i2++) {
        this.values_[index + newItems.length + _i2] = oldItems[_i2];
      }
      return res;
    }
  };
  _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      type: UPDATE,
      debugObjectName: this.atom_.name_,
      index,
      newValue,
      oldValue
    } : null;
    if (notifySpy) {
      spyReportStart(change);
    }
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
    if (notifySpy) {
      spyReportEnd();
    }
  };
  _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
    var notifySpy = !this.owned_ && isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "array",
      object: this.proxy_,
      debugObjectName: this.atom_.name_,
      type: SPLICE,
      index,
      removed,
      added,
      removedCount: removed.length,
      addedCount: added.length
    } : null;
    if (notifySpy) {
      spyReportStart(change);
    }
    this.atom_.reportChanged();
    if (notify) {
      notifyListeners(this, change);
    }
    if (notifySpy) {
      spyReportEnd();
    }
  };
  _proto.get_ = function get_(index) {
    if (this.legacyMode_ && index >= this.values_.length) {
      console.warn(true ? "[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX" : "[mobx] Out of bounds read: " + index);
      return void 0;
    }
    this.atom_.reportObserved();
    return this.dehanceValue_(this.values_[index]);
  };
  _proto.set_ = function set_(index, newValue) {
    var values = this.values_;
    if (this.legacyMode_ && index > values.length) {
      die(17, index, values.length);
    }
    if (index < values.length) {
      checkIfStateModificationsAreAllowed(this.atom_);
      var oldValue = values[index];
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_,
          // since "this" is the real array we need to pass its proxy
          index,
          newValue
        });
        if (!change) {
          return;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer_(newValue, oldValue);
      var changed = newValue !== oldValue;
      if (changed) {
        values[index] = newValue;
        this.notifyArrayChildUpdate_(index, newValue, oldValue);
      }
    } else {
      var newItems = new Array(index + 1 - values.length);
      for (var i = 0; i < newItems.length - 1; i++) {
        newItems[i] = void 0;
      }
      newItems[newItems.length - 1] = newValue;
      this.spliceWithArray_(values.length, 0, newItems);
    }
  };
  return ObservableArrayAdministration2;
}();
function createObservableArray(initialValues, enhancer, name, owned) {
  if (name === void 0) {
    name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
  }
  if (owned === void 0) {
    owned = false;
  }
  assertProxies();
  return initObservable(function() {
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      adm.spliceWithArray_(0, 0, initialValues);
    }
    return proxy;
  });
}
var arrayExtensions = {
  clear: function clear() {
    return this.splice(0);
  },
  replace: function replace(newItems) {
    var adm = this[$mobx];
    return adm.spliceWithArray_(0, adm.values_.length, newItems);
  },
  // Used by JSON.stringify
  toJSON: function toJSON() {
    return this.slice();
  },
  /*
   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
   * since these functions alter the inner structure of the array, the have side effects.
   * Because the have side effects, they should not be used in computed function,
   * and for that reason the do not call dependencyState.notifyObserved
   */
  splice: function splice(index, deleteCount) {
    for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      newItems[_key - 2] = arguments[_key];
    }
    var adm = this[$mobx];
    switch (arguments.length) {
      case 0:
        return [];
      case 1:
        return adm.spliceWithArray_(index);
      case 2:
        return adm.spliceWithArray_(index, deleteCount);
    }
    return adm.spliceWithArray_(index, deleteCount, newItems);
  },
  spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
    return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
  },
  push: function push() {
    var adm = this[$mobx];
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    adm.spliceWithArray_(adm.values_.length, 0, items);
    return adm.values_.length;
  },
  pop: function pop() {
    return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
  },
  shift: function shift() {
    return this.splice(0, 1)[0];
  },
  unshift: function unshift() {
    var adm = this[$mobx];
    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      items[_key3] = arguments[_key3];
    }
    adm.spliceWithArray_(0, 0, items);
    return adm.values_.length;
  },
  reverse: function reverse() {
    if (globalState.trackingDerivation) {
      die(37, "reverse");
    }
    this.replace(this.slice().reverse());
    return this;
  },
  sort: function sort() {
    if (globalState.trackingDerivation) {
      die(37, "sort");
    }
    var copy = this.slice();
    copy.sort.apply(copy, arguments);
    this.replace(copy);
    return this;
  },
  remove: function remove(value) {
    var adm = this[$mobx];
    var idx = adm.dehanceValues_(adm.values_).indexOf(value);
    if (idx > -1) {
      this.splice(idx, 1);
      return true;
    }
    return false;
  }
};
addArrayExtension("at", simpleFunc);
addArrayExtension("concat", simpleFunc);
addArrayExtension("flat", simpleFunc);
addArrayExtension("includes", simpleFunc);
addArrayExtension("indexOf", simpleFunc);
addArrayExtension("join", simpleFunc);
addArrayExtension("lastIndexOf", simpleFunc);
addArrayExtension("slice", simpleFunc);
addArrayExtension("toString", simpleFunc);
addArrayExtension("toLocaleString", simpleFunc);
addArrayExtension("toSorted", simpleFunc);
addArrayExtension("toSpliced", simpleFunc);
addArrayExtension("with", simpleFunc);
addArrayExtension("every", mapLikeFunc);
addArrayExtension("filter", mapLikeFunc);
addArrayExtension("find", mapLikeFunc);
addArrayExtension("findIndex", mapLikeFunc);
addArrayExtension("findLast", mapLikeFunc);
addArrayExtension("findLastIndex", mapLikeFunc);
addArrayExtension("flatMap", mapLikeFunc);
addArrayExtension("forEach", mapLikeFunc);
addArrayExtension("map", mapLikeFunc);
addArrayExtension("some", mapLikeFunc);
addArrayExtension("toReversed", mapLikeFunc);
addArrayExtension("reduce", reduceLikeFunc);
addArrayExtension("reduceRight", reduceLikeFunc);
function addArrayExtension(funcName, funcFactory) {
  if (typeof Array.prototype[funcName] === "function") {
    arrayExtensions[funcName] = funcFactory(funcName);
  }
}
function simpleFunc(funcName) {
  return function() {
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
function mapLikeFunc(funcName) {
  return function(callback, thisArg) {
    var _this2 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    return dehancedValues[funcName](function(element, index) {
      return callback.call(thisArg, element, index, _this2);
    });
  };
}
function reduceLikeFunc(funcName) {
  return function() {
    var _this3 = this;
    var adm = this[$mobx];
    adm.atom_.reportObserved();
    var dehancedValues = adm.dehanceValues_(adm.values_);
    var callback = arguments[0];
    arguments[0] = function(accumulator, currentValue, index) {
      return callback(accumulator, currentValue, index, _this3);
    };
    return dehancedValues[funcName].apply(dehancedValues, arguments);
  };
}
var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
function isObservableArray(thing) {
  return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
}
var ObservableMapMarker = {};
var ADD = "add";
var DELETE = "delete";
var ObservableMap = function() {
  function ObservableMap2(initialData, enhancer_, name_) {
    var _this = this;
    if (enhancer_ === void 0) {
      enhancer_ = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = true ? "ObservableMap@" + getNextId() : "ObservableMap";
    }
    this.enhancer_ = void 0;
    this.name_ = void 0;
    this[$mobx] = ObservableMapMarker;
    this.data_ = void 0;
    this.hasMap_ = void 0;
    this.keysAtom_ = void 0;
    this.interceptors_ = void 0;
    this.changeListeners_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = enhancer_;
    this.name_ = name_;
    if (!isFunction(Map)) {
      die(18);
    }
    initObservable(function() {
      _this.keysAtom_ = createAtom(true ? _this.name_ + ".keys()" : "ObservableMap.keys()");
      _this.data_ = /* @__PURE__ */ new Map();
      _this.hasMap_ = /* @__PURE__ */ new Map();
      if (initialData) {
        _this.merge(initialData);
      }
    });
  }
  var _proto = ObservableMap2.prototype;
  _proto.has_ = function has_(key) {
    return this.data_.has(key);
  };
  _proto.has = function has2(key) {
    var _this2 = this;
    if (!globalState.trackingDerivation) {
      return this.has_(key);
    }
    var entry = this.hasMap_.get(key);
    if (!entry) {
      var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
      this.hasMap_.set(key, newEntry);
      onBecomeUnobserved(newEntry, function() {
        return _this2.hasMap_["delete"](key);
      });
    }
    return entry.get();
  };
  _proto.set = function set4(key, value) {
    var hasKey = this.has_(key);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: hasKey ? UPDATE : ADD,
        object: this,
        newValue: value,
        name: key
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (hasKey) {
      this.updateValue_(key, value);
    } else {
      this.addValue_(key, value);
    }
    return this;
  };
  _proto["delete"] = function _delete(key) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        name: key
      });
      if (!change) {
        return false;
      }
    }
    if (this.has_(key)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: this.data_.get(key).value_,
        name: key
      } : null;
      if (notifySpy) {
        spyReportStart(_change);
      }
      transaction(function() {
        var _this3$hasMap_$get;
        _this3.keysAtom_.reportChanged();
        (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null || _this3$hasMap_$get.setNewValue_(false);
        var observable2 = _this3.data_.get(key);
        observable2.setNewValue_(void 0);
        _this3.data_["delete"](key);
      });
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
      return true;
    }
    return false;
  };
  _proto.updateValue_ = function updateValue_(key, newValue) {
    var observable2 = this.data_.get(key);
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: UPDATE,
        object: this,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    }
  };
  _proto.addValue_ = function addValue_(key, newValue) {
    var _this4 = this;
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    transaction(function() {
      var _this4$hasMap_$get;
      var observable2 = new ObservableValue(newValue, _this4.enhancer_, true ? _this4.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
      _this4.data_.set(key, observable2);
      newValue = observable2.value_;
      (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null || _this4$hasMap_$get.setNewValue_(true);
      _this4.keysAtom_.reportChanged();
    });
    var notifySpy = isSpyEnabled();
    var notify = hasListeners(this);
    var change = notify || notifySpy ? {
      observableKind: "map",
      debugObjectName: this.name_,
      type: ADD,
      object: this,
      name: key,
      newValue
    } : null;
    if (notifySpy) {
      spyReportStart(change);
    }
    if (notify) {
      notifyListeners(this, change);
    }
    if (notifySpy) {
      spyReportEnd();
    }
  };
  _proto.get = function get3(key) {
    if (this.has(key)) {
      return this.dehanceValue_(this.data_.get(key).get());
    }
    return this.dehanceValue_(void 0);
  };
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.keys = function keys() {
    this.keysAtom_.reportObserved();
    return this.data_.keys();
  };
  _proto.values = function values() {
    var self2 = this;
    var keys = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
        return {
          done,
          value: done ? void 0 : self2.get(value)
        };
      }
    });
  };
  _proto.entries = function entries() {
    var self2 = this;
    var keys = this.keys();
    return makeIterableForMap({
      next: function next() {
        var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
        return {
          done,
          value: done ? void 0 : [value, self2.get(value)]
        };
      }
    });
  };
  _proto[Symbol.iterator] = function() {
    return this.entries();
  };
  _proto.forEach = function forEach(callback, thisArg) {
    for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
      callback.call(thisArg, value, key, this);
    }
  };
  _proto.merge = function merge(other) {
    var _this5 = this;
    if (isObservableMap(other)) {
      other = new Map(other);
    }
    transaction(function() {
      if (isPlainObject(other)) {
        getPlainObjectKeys(other).forEach(function(key) {
          return _this5.set(key, other[key]);
        });
      } else if (Array.isArray(other)) {
        other.forEach(function(_ref) {
          var key = _ref[0], value = _ref[1];
          return _this5.set(key, value);
        });
      } else if (isES6Map(other)) {
        if (!isPlainES6Map(other)) {
          die(19, other);
        }
        other.forEach(function(value, key) {
          return _this5.set(key, value);
        });
      } else if (other !== null && other !== void 0) {
        die(20, other);
      }
    });
    return this;
  };
  _proto.clear = function clear2() {
    var _this6 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var key = _step2.value;
          _this6["delete"](key);
        }
      });
    });
  };
  _proto.replace = function replace2(values) {
    var _this7 = this;
    transaction(function() {
      var replacementMap = convertToMap(values);
      var orderedData = /* @__PURE__ */ new Map();
      var keysReportChangedCalled = false;
      for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
        var key = _step3.value;
        if (!replacementMap.has(key)) {
          var deleted = _this7["delete"](key);
          if (deleted) {
            keysReportChangedCalled = true;
          } else {
            var value = _this7.data_.get(key);
            orderedData.set(key, value);
          }
        }
      }
      for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
        var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
        var keyExisted = _this7.data_.has(_key);
        _this7.set(_key, _value);
        if (_this7.data_.has(_key)) {
          var _value2 = _this7.data_.get(_key);
          orderedData.set(_key, _value2);
          if (!keyExisted) {
            keysReportChangedCalled = true;
          }
        }
      }
      if (!keysReportChangedCalled) {
        if (_this7.data_.size !== orderedData.size) {
          _this7.keysAtom_.reportChanged();
        } else {
          var iter1 = _this7.data_.keys();
          var iter2 = orderedData.keys();
          var next1 = iter1.next();
          var next2 = iter2.next();
          while (!next1.done) {
            if (next1.value !== next2.value) {
              _this7.keysAtom_.reportChanged();
              break;
            }
            next1 = iter1.next();
            next2 = iter2.next();
          }
        }
      }
      _this7.data_ = orderedData;
    });
    return this;
  };
  _proto.toString = function toString2() {
    return "[object ObservableMap]";
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === true) {
      die("`observe` doesn't support fireImmediately=true in combination with maps.");
    }
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  return _createClass(ObservableMap2, [{
    key: "size",
    get: function get3() {
      this.keysAtom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get3() {
      return "Map";
    }
  }]);
}();
var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
function makeIterableForMap(iterator) {
  iterator[Symbol.toStringTag] = "MapIterator";
  return makeIterable(iterator);
}
function convertToMap(dataStructure) {
  if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
    return dataStructure;
  } else if (Array.isArray(dataStructure)) {
    return new Map(dataStructure);
  } else if (isPlainObject(dataStructure)) {
    var map2 = /* @__PURE__ */ new Map();
    for (var key in dataStructure) {
      map2.set(key, dataStructure[key]);
    }
    return map2;
  } else {
    return die(21, dataStructure);
  }
}
var ObservableSetMarker = {};
var ObservableSet = function() {
  function ObservableSet2(initialData, enhancer, name_) {
    var _this = this;
    if (enhancer === void 0) {
      enhancer = deepEnhancer;
    }
    if (name_ === void 0) {
      name_ = true ? "ObservableSet@" + getNextId() : "ObservableSet";
    }
    this.name_ = void 0;
    this[$mobx] = ObservableSetMarker;
    this.data_ = /* @__PURE__ */ new Set();
    this.atom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.dehancer = void 0;
    this.enhancer_ = void 0;
    this.name_ = name_;
    if (!isFunction(Set)) {
      die(22);
    }
    this.enhancer_ = function(newV, oldV) {
      return enhancer(newV, oldV, name_);
    };
    initObservable(function() {
      _this.atom_ = createAtom(_this.name_);
      if (initialData) {
        _this.replace(initialData);
      }
    });
  }
  var _proto = ObservableSet2.prototype;
  _proto.dehanceValue_ = function dehanceValue_(value) {
    if (this.dehancer !== void 0) {
      return this.dehancer(value);
    }
    return value;
  };
  _proto.clear = function clear2() {
    var _this2 = this;
    transaction(function() {
      untracked(function() {
        for (var _iterator = _createForOfIteratorHelperLoose(_this2.data_.values()), _step; !(_step = _iterator()).done; ) {
          var value = _step.value;
          _this2["delete"](value);
        }
      });
    });
  };
  _proto.forEach = function forEach(callbackFn, thisArg) {
    for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
      var value = _step2.value;
      callbackFn.call(thisArg, value, value, this);
    }
  };
  _proto.add = function add(value) {
    var _this3 = this;
    checkIfStateModificationsAreAllowed(this.atom_);
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: ADD,
        object: this,
        newValue: value
      });
      if (!change) {
        return this;
      }
      value = change.newValue;
    }
    if (!this.has(value)) {
      transaction(function() {
        _this3.data_.add(_this3.enhancer_(value, void 0));
        _this3.atom_.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        newValue: value
      } : null;
      if (notifySpy && true) {
        spyReportStart(_change);
      }
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy && true) {
        spyReportEnd();
      }
    }
    return this;
  };
  _proto["delete"] = function _delete(value) {
    var _this4 = this;
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: DELETE,
        object: this,
        oldValue: value
      });
      if (!change) {
        return false;
      }
    }
    if (this.has(value)) {
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var _change2 = notify || notifySpy ? {
        observableKind: "set",
        debugObjectName: this.name_,
        type: DELETE,
        object: this,
        oldValue: value
      } : null;
      if (notifySpy && true) {
        spyReportStart(_change2);
      }
      transaction(function() {
        _this4.atom_.reportChanged();
        _this4.data_["delete"](value);
      });
      if (notify) {
        notifyListeners(this, _change2);
      }
      if (notifySpy && true) {
        spyReportEnd();
      }
      return true;
    }
    return false;
  };
  _proto.has = function has2(value) {
    this.atom_.reportObserved();
    return this.data_.has(this.dehanceValue_(value));
  };
  _proto.entries = function entries() {
    var values = this.values();
    return makeIterableForSet({
      next: function next() {
        var _values$next = values.next(), value = _values$next.value, done = _values$next.done;
        return !done ? {
          value: [value, value],
          done
        } : {
          value: void 0,
          done
        };
      }
    });
  };
  _proto.keys = function keys() {
    return this.values();
  };
  _proto.values = function values() {
    this.atom_.reportObserved();
    var self2 = this;
    var values2 = this.data_.values();
    return makeIterableForSet({
      next: function next() {
        var _values$next2 = values2.next(), value = _values$next2.value, done = _values$next2.done;
        return !done ? {
          value: self2.dehanceValue_(value),
          done
        } : {
          value: void 0,
          done
        };
      }
    });
  };
  _proto.intersection = function intersection(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.intersection(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.intersection(otherSet);
    }
  };
  _proto.union = function union(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.union(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.union(otherSet);
    }
  };
  _proto.difference = function difference(otherSet) {
    return new Set(this).difference(otherSet);
  };
  _proto.symmetricDifference = function symmetricDifference(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.symmetricDifference(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.symmetricDifference(otherSet);
    }
  };
  _proto.isSubsetOf = function isSubsetOf(otherSet) {
    return new Set(this).isSubsetOf(otherSet);
  };
  _proto.isSupersetOf = function isSupersetOf(otherSet) {
    return new Set(this).isSupersetOf(otherSet);
  };
  _proto.isDisjointFrom = function isDisjointFrom(otherSet) {
    if (isES6Set(otherSet) && !isObservableSet(otherSet)) {
      return otherSet.isDisjointFrom(this);
    } else {
      var dehancedSet = new Set(this);
      return dehancedSet.isDisjointFrom(otherSet);
    }
  };
  _proto.replace = function replace2(other) {
    var _this5 = this;
    if (isObservableSet(other)) {
      other = new Set(other);
    }
    transaction(function() {
      if (Array.isArray(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (isES6Set(other)) {
        _this5.clear();
        other.forEach(function(value) {
          return _this5.add(value);
        });
      } else if (other !== null && other !== void 0) {
        die("Cannot initialize set from " + other);
      }
    });
    return this;
  };
  _proto.observe_ = function observe_(listener, fireImmediately) {
    if (fireImmediately === true) {
      die("`observe` doesn't support fireImmediately=true in combination with sets.");
    }
    return registerListener(this, listener);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.toJSON = function toJSON2() {
    return Array.from(this);
  };
  _proto.toString = function toString2() {
    return "[object ObservableSet]";
  };
  _proto[Symbol.iterator] = function() {
    return this.values();
  };
  return _createClass(ObservableSet2, [{
    key: "size",
    get: function get3() {
      this.atom_.reportObserved();
      return this.data_.size;
    }
  }, {
    key: Symbol.toStringTag,
    get: function get3() {
      return "Set";
    }
  }]);
}();
var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);
function makeIterableForSet(iterator) {
  iterator[Symbol.toStringTag] = "SetIterator";
  return makeIterable(iterator);
}
var descriptorCache = /* @__PURE__ */ Object.create(null);
var REMOVE = "remove";
var ObservableObjectAdministration = function() {
  function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
    if (values_ === void 0) {
      values_ = /* @__PURE__ */ new Map();
    }
    if (defaultAnnotation_ === void 0) {
      defaultAnnotation_ = autoAnnotation;
    }
    this.target_ = void 0;
    this.values_ = void 0;
    this.name_ = void 0;
    this.defaultAnnotation_ = void 0;
    this.keysAtom_ = void 0;
    this.changeListeners_ = void 0;
    this.interceptors_ = void 0;
    this.proxy_ = void 0;
    this.isPlainObject_ = void 0;
    this.appliedAnnotations_ = void 0;
    this.pendingKeys_ = void 0;
    this.target_ = target_;
    this.values_ = values_;
    this.name_ = name_;
    this.defaultAnnotation_ = defaultAnnotation_;
    this.keysAtom_ = new Atom(true ? this.name_ + ".keys" : "ObservableObject.keys");
    this.isPlainObject_ = isPlainObject(this.target_);
    if (!isAnnotation(this.defaultAnnotation_)) {
      die("defaultAnnotation must be valid annotation");
    }
    if (true) {
      this.appliedAnnotations_ = {};
    }
  }
  var _proto = ObservableObjectAdministration2.prototype;
  _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
    return this.values_.get(key).get();
  };
  _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
    var observable2 = this.values_.get(key);
    if (observable2 instanceof ComputedValue) {
      observable2.set(newValue);
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        type: UPDATE,
        object: this.proxy_ || this.target_,
        name: key,
        newValue
      });
      if (!change) {
        return null;
      }
      newValue = change.newValue;
    }
    newValue = observable2.prepareNewValue_(newValue);
    if (newValue !== globalState.UNCHANGED) {
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var _change = notify || notifySpy ? {
        type: UPDATE,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        oldValue: observable2.value_,
        name: key,
        newValue
      } : null;
      if (notifySpy) {
        spyReportStart(_change);
      }
      observable2.setNewValue_(newValue);
      if (notify) {
        notifyListeners(this, _change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    }
    return true;
  };
  _proto.get_ = function get_(key) {
    if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
      this.has_(key);
    }
    return this.target_[key];
  };
  _proto.set_ = function set_(key, value, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (hasProp(this.target_, key)) {
      if (this.values_.has(key)) {
        return this.setObservablePropValue_(key, value);
      } else if (proxyTrap) {
        return Reflect.set(this.target_, key, value);
      } else {
        this.target_[key] = value;
        return true;
      }
    } else {
      return this.extend_(key, {
        value,
        enumerable: true,
        writable: true,
        configurable: true
      }, this.defaultAnnotation_, proxyTrap);
    }
  };
  _proto.has_ = function has_(key) {
    if (!globalState.trackingDerivation) {
      return key in this.target_;
    }
    this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
    var entry = this.pendingKeys_.get(key);
    if (!entry) {
      entry = new ObservableValue(key in this.target_, referenceEnhancer, true ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
      this.pendingKeys_.set(key, entry);
    }
    return entry.get();
  };
  _proto.make_ = function make_2(key, annotation) {
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return;
    }
    assertAnnotable(this, annotation, key);
    if (!(key in this.target_)) {
      var _this$target_$storedA;
      if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
        return;
      } else {
        die(1, annotation.annotationType_, this.name_ + "." + key.toString());
      }
    }
    var source = this.target_;
    while (source && source !== objectPrototype) {
      var descriptor = getDescriptor(source, key);
      if (descriptor) {
        var outcome = annotation.make_(this, key, descriptor, source);
        if (outcome === 0) {
          return;
        }
        if (outcome === 1) {
          break;
        }
      }
      source = Object.getPrototypeOf(source);
    }
    recordAnnotationApplied(this, annotation, key);
  };
  _proto.extend_ = function extend_2(key, descriptor, annotation, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    if (annotation === true) {
      annotation = this.defaultAnnotation_;
    }
    if (annotation === false) {
      return this.defineProperty_(key, descriptor, proxyTrap);
    }
    assertAnnotable(this, annotation, key);
    var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
    if (outcome) {
      recordAnnotationApplied(this, annotation, key);
    }
    return outcome;
  };
  _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: descriptor.value
        });
        if (!change) {
          return null;
        }
        var newValue = change.newValue;
        if (descriptor.value !== newValue) {
          descriptor = _extends({}, descriptor, {
            value: newValue
          });
        }
      }
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.notifyPropertyAddition_(key, descriptor.value);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: value
        });
        if (!change) {
          return null;
        }
        value = change.newValue;
      }
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: true,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      var observable2 = new ObservableValue(value, enhancer, true ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
      this.values_.set(key, observable2);
      this.notifyPropertyAddition_(key, observable2.value_);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    try {
      startBatch();
      var deleteOutcome = this.delete_(key);
      if (!deleteOutcome) {
        return deleteOutcome;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: ADD,
          newValue: void 0
        });
        if (!change) {
          return null;
        }
      }
      options.name || (options.name = true ? this.name_ + "." + key.toString() : "ObservableObject.key");
      options.context = this.proxy_ || this.target_;
      var cachedDescriptor = getCachedObservablePropDescriptor(key);
      var descriptor = {
        configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
        enumerable: false,
        get: cachedDescriptor.get,
        set: cachedDescriptor.set
      };
      if (proxyTrap) {
        if (!Reflect.defineProperty(this.target_, key, descriptor)) {
          return false;
        }
      } else {
        defineProperty(this.target_, key, descriptor);
      }
      this.values_.set(key, new ComputedValue(options));
      this.notifyPropertyAddition_(key, void 0);
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.delete_ = function delete_(key, proxyTrap) {
    if (proxyTrap === void 0) {
      proxyTrap = false;
    }
    checkIfStateModificationsAreAllowed(this.keysAtom_);
    if (!hasProp(this.target_, key)) {
      return true;
    }
    if (hasInterceptors(this)) {
      var change = interceptChange(this, {
        object: this.proxy_ || this.target_,
        name: key,
        type: REMOVE
      });
      if (!change) {
        return null;
      }
    }
    try {
      var _this$pendingKeys_;
      startBatch();
      var notify = hasListeners(this);
      var notifySpy = isSpyEnabled();
      var observable2 = this.values_.get(key);
      var value = void 0;
      if (!observable2 && (notify || notifySpy)) {
        var _getDescriptor2;
        value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
      }
      if (proxyTrap) {
        if (!Reflect.deleteProperty(this.target_, key)) {
          return false;
        }
      } else {
        delete this.target_[key];
      }
      if (true) {
        delete this.appliedAnnotations_[key];
      }
      if (observable2) {
        this.values_["delete"](key);
        if (observable2 instanceof ObservableValue) {
          value = observable2.value_;
        }
        propagateChanged(observable2);
      }
      this.keysAtom_.reportChanged();
      (_this$pendingKeys_ = this.pendingKeys_) == null || (_this$pendingKeys_ = _this$pendingKeys_.get(key)) == null || _this$pendingKeys_.set(key in this.target_);
      if (notify || notifySpy) {
        var _change2 = {
          type: REMOVE,
          observableKind: "object",
          object: this.proxy_ || this.target_,
          debugObjectName: this.name_,
          oldValue: value,
          name: key
        };
        if (notifySpy) {
          spyReportStart(_change2);
        }
        if (notify) {
          notifyListeners(this, _change2);
        }
        if (notifySpy) {
          spyReportEnd();
        }
      }
    } finally {
      endBatch();
    }
    return true;
  };
  _proto.observe_ = function observe_(callback, fireImmediately) {
    if (fireImmediately === true) {
      die("`observe` doesn't support the fire immediately property for observable objects.");
    }
    return registerListener(this, callback);
  };
  _proto.intercept_ = function intercept_(handler) {
    return registerInterceptor(this, handler);
  };
  _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
    var _this$pendingKeys_2;
    var notify = hasListeners(this);
    var notifySpy = isSpyEnabled();
    if (notify || notifySpy) {
      var change = notify || notifySpy ? {
        type: ADD,
        observableKind: "object",
        debugObjectName: this.name_,
        object: this.proxy_ || this.target_,
        name: key,
        newValue: value
      } : null;
      if (notifySpy) {
        spyReportStart(change);
      }
      if (notify) {
        notifyListeners(this, change);
      }
      if (notifySpy) {
        spyReportEnd();
      }
    }
    (_this$pendingKeys_2 = this.pendingKeys_) == null || (_this$pendingKeys_2 = _this$pendingKeys_2.get(key)) == null || _this$pendingKeys_2.set(true);
    this.keysAtom_.reportChanged();
  };
  _proto.ownKeys_ = function ownKeys_() {
    this.keysAtom_.reportObserved();
    return ownKeys(this.target_);
  };
  _proto.keys_ = function keys_() {
    this.keysAtom_.reportObserved();
    return Object.keys(this.target_);
  };
  return ObservableObjectAdministration2;
}();
function asObservableObject(target, options) {
  var _options$name;
  if (options && isObservableObject(target)) {
    die("Options can't be provided for already observable objects.");
  }
  if (hasProp(target, $mobx)) {
    if (!(getAdministration(target) instanceof ObservableObjectAdministration)) {
      die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
    }
    return target;
  }
  if (!Object.isExtensible(target)) {
    die("Cannot make the designated object observable; it is not extensible");
  }
  var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : true ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
  var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
  addHiddenProp(target, $mobx, adm);
  return target;
}
var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
function getCachedObservablePropDescriptor(key) {
  return descriptorCache[key] || (descriptorCache[key] = {
    get: function get3() {
      return this[$mobx].getObservablePropValue_(key);
    },
    set: function set4(value) {
      return this[$mobx].setObservablePropValue_(key, value);
    }
  });
}
function isObservableObject(thing) {
  if (isObject(thing)) {
    return isObservableObjectAdministration(thing[$mobx]);
  }
  return false;
}
function recordAnnotationApplied(adm, annotation, key) {
  var _adm$target_$storedAn;
  if (true) {
    adm.appliedAnnotations_[key] = annotation;
  }
  (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null || delete _adm$target_$storedAn[key];
}
function assertAnnotable(adm, annotation, key) {
  if (!isAnnotation(annotation)) {
    die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
  }
  if (!isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
    var fieldName = adm.name_ + "." + key.toString();
    var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
    var requestedAnnotationType = annotation.annotationType_;
    die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':" + ("\nThe field is already annotated with '" + currentAnnotationType + "'.") + "\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overridden by subclass.");
  }
}
var ENTRY_0 = createArrayEntryDescriptor(0);
var safariPrototypeSetterInheritanceBug = function() {
  var v = false;
  var p = {};
  Object.defineProperty(p, "0", {
    set: function set4() {
      v = true;
    }
  });
  Object.create(p)["0"] = 1;
  return v === false;
}();
var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
var StubArray = function StubArray2() {
};
function inherit(ctor, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ctor.prototype, proto);
  } else if (ctor.prototype.__proto__ !== void 0) {
    ctor.prototype.__proto__ = proto;
  } else {
    ctor.prototype = proto;
  }
}
inherit(StubArray, Array.prototype);
var LegacyObservableArray = function(_StubArray) {
  function LegacyObservableArray2(initialValues, enhancer, name, owned) {
    var _this;
    if (name === void 0) {
      name = true ? "ObservableArray@" + getNextId() : "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    _this = _StubArray.call(this) || this;
    initObservable(function() {
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _this;
      addHiddenFinalProp(_this, $mobx, adm);
      if (initialValues && initialValues.length) {
        _this.spliceWithArray(0, 0, initialValues);
      }
      if (safariPrototypeSetterInheritanceBug) {
        Object.defineProperty(_this, "0", ENTRY_0);
      }
    });
    return _this;
  }
  _inheritsLoose(LegacyObservableArray2, _StubArray);
  var _proto = LegacyObservableArray2.prototype;
  _proto.concat = function concat() {
    this[$mobx].atom_.reportObserved();
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply(
      this.slice(),
      //@ts-ignore
      arrays.map(function(a) {
        return isObservableArray(a) ? a.slice() : a;
      })
    );
  };
  _proto[Symbol.iterator] = function() {
    var self2 = this;
    var nextIndex = 0;
    return makeIterable({
      next: function next() {
        return nextIndex < self2.length ? {
          value: self2[nextIndex++],
          done: false
        } : {
          done: true,
          value: void 0
        };
      }
    });
  };
  return _createClass(LegacyObservableArray2, [{
    key: "length",
    get: function get3() {
      return this[$mobx].getArrayLength_();
    },
    set: function set4(newLength) {
      this[$mobx].setArrayLength_(newLength);
    }
  }, {
    key: Symbol.toStringTag,
    get: function get3() {
      return "Array";
    }
  }]);
}(StubArray);
Object.entries(arrayExtensions).forEach(function(_ref) {
  var prop = _ref[0], fn2 = _ref[1];
  if (prop !== "concat") {
    addHiddenProp(LegacyObservableArray.prototype, prop, fn2);
  }
});
function createArrayEntryDescriptor(index) {
  return {
    enumerable: false,
    configurable: true,
    get: function get3() {
      return this[$mobx].get_(index);
    },
    set: function set4(value) {
      this[$mobx].set_(index, value);
    }
  };
}
function createArrayBufferItem(index) {
  defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
}
function reserveArrayBuffer(max) {
  if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) {
      createArrayBufferItem(index);
    }
    OBSERVABLE_ARRAY_BUFFER_SIZE = max;
  }
}
reserveArrayBuffer(1e3);
function createLegacyArray(initialValues, enhancer, name) {
  return new LegacyObservableArray(initialValues, enhancer, name);
}
function getAtom(thing, property) {
  if (typeof thing === "object" && thing !== null) {
    if (isObservableArray(thing)) {
      if (property !== void 0) {
        die(23);
      }
      return thing[$mobx].atom_;
    }
    if (isObservableSet(thing)) {
      return thing.atom_;
    }
    if (isObservableMap(thing)) {
      if (property === void 0) {
        return thing.keysAtom_;
      }
      var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
      if (!observable2) {
        die(25, property, getDebugName(thing));
      }
      return observable2;
    }
    if (isObservableObject(thing)) {
      if (!property) {
        return die(26);
      }
      var _observable = thing[$mobx].values_.get(property);
      if (!_observable) {
        die(27, property, getDebugName(thing));
      }
      return _observable;
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
  } else if (isFunction(thing)) {
    if (isReaction(thing[$mobx])) {
      return thing[$mobx];
    }
  }
  die(28);
}
function getAdministration(thing, property) {
  if (!thing) {
    die(29);
  }
  if (property !== void 0) {
    return getAdministration(getAtom(thing, property));
  }
  if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
    return thing;
  }
  if (isObservableMap(thing) || isObservableSet(thing)) {
    return thing;
  }
  if (thing[$mobx]) {
    return thing[$mobx];
  }
  die(24, thing);
}
function getDebugName(thing, property) {
  var named;
  if (property !== void 0) {
    named = getAtom(thing, property);
  } else if (isAction(thing)) {
    return thing.name;
  } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
    named = getAdministration(thing);
  } else {
    named = getAtom(thing);
  }
  return named.name_;
}
function initObservable(cb) {
  var derivation = untrackedStart();
  var allowStateChanges = allowStateChangesStart(true);
  startBatch();
  try {
    return cb();
  } finally {
    endBatch();
    allowStateChangesEnd(allowStateChanges);
    untrackedEnd(derivation);
  }
}
var toString = objectPrototype.toString;
function deepEqual(a, b, depth) {
  if (depth === void 0) {
    depth = -1;
  }
  return eq(a, b, depth);
}
function eq(a, b, depth, aStack, bStack) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  }
  if (a == null || b == null) {
    return false;
  }
  if (a !== a) {
    return b !== b;
  }
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") {
    return false;
  }
  var className = toString.call(a);
  if (className !== toString.call(b)) {
    return false;
  }
  switch (className) {
    case "[object RegExp]":
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) {
        return +b !== +b;
      }
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);
    case "[object Map]":
    case "[object Set]":
      if (depth >= 0) {
        depth++;
      }
      break;
  }
  a = unwrap(a);
  b = unwrap(b);
  var areArrays = className === "[object Array]";
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") {
      return false;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) {
      return false;
    }
  }
  if (depth === 0) {
    return false;
  } else if (depth < 0) {
    depth = -1;
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) {
      return bStack[length] === b;
    }
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) {
      return false;
    }
    while (length--) {
      if (!eq(a[length], b[length], depth - 1, aStack, bStack)) {
        return false;
      }
    }
  } else {
    var keys = Object.keys(a);
    var _length = keys.length;
    if (Object.keys(b).length !== _length) {
      return false;
    }
    for (var i = 0; i < _length; i++) {
      var key = keys[i];
      if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) {
        return false;
      }
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function unwrap(a) {
  if (isObservableArray(a)) {
    return a.slice();
  }
  if (isES6Map(a) || isObservableMap(a)) {
    return Array.from(a.entries());
  }
  if (isES6Set(a) || isObservableSet(a)) {
    return Array.from(a.entries());
  }
  return a;
}
var _getGlobal$Iterator;
var maybeIteratorPrototype = ((_getGlobal$Iterator = getGlobal().Iterator) == null ? void 0 : _getGlobal$Iterator.prototype) || {};
function makeIterable(iterator) {
  iterator[Symbol.iterator] = getSelf;
  return Object.assign(Object.create(maybeIteratorPrototype), iterator);
}
function getSelf() {
  return this;
}
function isAnnotation(thing) {
  return (
    // Can be function
    thing instanceof Object && typeof thing.annotationType_ === "string" && isFunction(thing.make_) && isFunction(thing.extend_)
  );
}
["Symbol", "Map", "Set"].forEach(function(m2) {
  var g = getGlobal();
  if (typeof g[m2] === "undefined") {
    die("MobX requires global '" + m2 + "' to be available or polyfilled");
  }
});
if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
  __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
    spy,
    extras: {
      getDebugName
    },
    $mobx
  });
}

// node_modules/.pnpm/piche.npm.core@1.1.113_vite@4.5.14_@types+node@20.19.25_sass@1.94.2_/node_modules/piche.npm.core/dist/index.js
var import_react_dom = __toESM(require_react_dom());
(function() {
  "use strict";
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.appendChild(document.createTextNode('.pl__wrapper{font:1em/1.5 sans-serif;height:100%;display:grid;place-items:center}.pl,.pl__ball,.pl__ball-inner-shadow,.pl__ball-side-shadows,.pl__ball-texture,.pl__inner-ring,.pl__outer-ring,.pl__track-cover{border-radius:50%}.pl{position:relative;width:16em;height:16em}.pl__ball,.pl__ball-inner-shadow,.pl__ball-outer-shadow,.pl__ball-side-shadows,.pl__ball-texture,.pl__ball-texture:before,.pl__inner-ring,.pl__outer-ring,.pl__track-cover{position:absolute}.pl__ball,.pl__ball-inner-shadow,.pl__ball-outer-shadow,.pl__ball-texture:before,.pl__track-cover{animation:ball 4s linear infinite}.pl__ball{top:calc(50% - 1.25em);left:calc(50% - 1.25em);transform:rotate(0) translateY(-6.5em);width:2.5em;height:2.5em}.pl__ball-inner-shadow{animation-name:ballInnerShadow;box-shadow:0 .1em .2em #0000004d,0 0 .2em #0000001a inset,0 -1em .5em #00000026 inset;width:100%;height:100%}.pl__ball-outer-shadow{animation-name:ballOuterShadow;background-image:linear-gradient(hsla(0,0%,0%,.15),hsla(0,0%,0%,0));border-radius:0 0 50% 50%/0 0 100% 100%;filter:blur(2px);top:50%;left:0;width:100%;height:250%;transform:rotate(20deg);transform-origin:50% 0;z-index:-2}.pl__ball-side-shadows{background-color:#0000001a;filter:blur(2px);width:100%;height:100%;transform:scale(.75,1.1);z-index:-1}.pl__ball-texture{overflow:hidden;width:100%;height:100%;transform:translateZ(0)}.pl__ball-texture:before{animation-name:ballTexture;animation-duration:.25s;background:#fffafa 0 0/50% 100%;content:"";display:block;filter:brightness(1.05);top:0;right:0;width:200%;height:100%}.pl__inner-ring{box-shadow:0 -.25em .5em #fff6,0 .5em .75em #fff6 inset,0 .5em .375em #00000026,0 -.5em .75em #00000026 inset;top:2.375em;left:2.375em;width:calc(100% - 4.75em);height:calc(100% - 4.75em)}.pl__outer-ring{box-shadow:0 -.45em .375em #00000026,0 .5em .75em #00000026 inset,0 .25em .5em #fff6,0 -.5em .75em #fff6 inset;top:.75em;left:.75em;width:calc(100% - 1.5em);height:calc(100% - 1.5em)}.pl__track-cover{animation-name:trackCover;background-image:conic-gradient(#f5f8fa 210deg,hsla(223,90%,95%,0) 270deg);top:0;left:0;width:100%;height:100%}@keyframes ball{0%{transform:rotate(0) translateY(-6.5em)}50%{transform:rotate(180deg) translateY(-6em)}to{transform:rotate(360deg) translateY(-6.5em)}}@keyframes ballInnerShadow{0%{transform:rotate(0)}to{transform:rotate(-360deg)}}@keyframes ballOuterShadow{0%{transform:rotate(20deg)}to{transform:rotate(-340deg)}}@keyframes ballTexture{0%{transform:translate(0)}to{transform:translate(50%)}}@keyframes trackCover{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.piche-login{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;font-size:16px}.piche-login input#email,.piche-login input#password{max-width:240px;width:100%}.piche-login .form{max-width:400px;width:100%;padding:1rem}.piche-login .form__group{display:flex;justify-content:space-between;margin-bottom:16px}.piche-login .form__text-wrapper{margin-bottom:48px;text-align:center}.piche-login .form__title{margin-bottom:16px}.piche-login .form__subtitle{margin-bottom:16px;font-weight:600}.piche-login .form__remember-me{display:flex;flex-direction:row!important;align-items:center;margin-bottom:16px;gap:8px}.piche-login .form label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.piche-login .form button{width:100%}:root{--toastify-color-light: #fff;--toastify-color-dark: #121212;--toastify-color-info: #3498db;--toastify-color-success: #07bc0c;--toastify-color-warning: #f1c40f;--toastify-color-error: #e74c3c;--toastify-color-transparent: rgba(255, 255, 255, .7);--toastify-icon-color-info: var(--toastify-color-info);--toastify-icon-color-success: var(--toastify-color-success);--toastify-icon-color-warning: var(--toastify-color-warning);--toastify-icon-color-error: var(--toastify-color-error);--toastify-toast-width: 320px;--toastify-toast-background: #fff;--toastify-toast-min-height: 64px;--toastify-toast-max-height: 800px;--toastify-font-family: sans-serif;--toastify-z-index: 9999;--toastify-text-color-light: #757575;--toastify-text-color-dark: #fff;--toastify-text-color-info: #fff;--toastify-text-color-success: #fff;--toastify-text-color-warning: #fff;--toastify-text-color-error: #fff;--toastify-spinner-color: #616161;--toastify-spinner-color-empty-area: #e0e0e0;--toastify-color-progress-light: linear-gradient( to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55 );--toastify-color-progress-dark: #bb86fc;--toastify-color-progress-info: var(--toastify-color-info);--toastify-color-progress-success: var(--toastify-color-success);--toastify-color-progress-warning: var(--toastify-color-warning);--toastify-color-progress-error: var(--toastify-color-error)}.Toastify__toast-container{z-index:var(--toastify-z-index);-webkit-transform:translate3d(0,0,var(--toastify-z-index));position:fixed;padding:4px;width:var(--toastify-toast-width);box-sizing:border-box;color:#fff}.Toastify__toast-container--top-left{top:1em;left:1em}.Toastify__toast-container--top-center{top:1em;left:50%;transform:translate(-50%)}.Toastify__toast-container--top-right{top:1em;right:1em}.Toastify__toast-container--bottom-left{bottom:1em;left:1em}.Toastify__toast-container--bottom-center{bottom:1em;left:50%;transform:translate(-50%)}.Toastify__toast-container--bottom-right{bottom:1em;right:1em}@media only screen and (max-width : 480px){.Toastify__toast-container{width:100vw;padding:0;left:0;margin:0}.Toastify__toast-container--top-left,.Toastify__toast-container--top-center,.Toastify__toast-container--top-right{top:0;transform:translate(0)}.Toastify__toast-container--bottom-left,.Toastify__toast-container--bottom-center,.Toastify__toast-container--bottom-right{bottom:0;transform:translate(0)}.Toastify__toast-container--rtl{right:0;left:initial}}.Toastify__toast{position:relative;min-height:var(--toastify-toast-min-height);box-sizing:border-box;margin-bottom:1rem;padding:8px;border-radius:4px;box-shadow:0 1px 10px #0000001a,0 2px 15px #0000000d;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;max-height:var(--toastify-toast-max-height);overflow:hidden;font-family:var(--toastify-font-family);cursor:default;direction:ltr;z-index:0}.Toastify__toast--rtl{direction:rtl}.Toastify__toast--close-on-click{cursor:pointer}.Toastify__toast-body{margin:auto 0;-ms-flex:1 1 auto;flex:1 1 auto;padding:6px;display:-ms-flexbox;display:flex;-ms-flex-align:center;align-items:center}.Toastify__toast-body>div:last-child{word-break:break-word;-ms-flex:1;flex:1}.Toastify__toast-icon{-webkit-margin-end:10px;margin-inline-end:10px;width:20px;-ms-flex-negative:0;flex-shrink:0;display:-ms-flexbox;display:flex}.Toastify--animate{animation-fill-mode:both;animation-duration:.7s}.Toastify--animate-icon{animation-fill-mode:both;animation-duration:.3s}@media only screen and (max-width : 480px){.Toastify__toast{margin-bottom:0;border-radius:0}}.Toastify__toast-theme--dark{background:var(--toastify-color-dark);color:var(--toastify-text-color-dark)}.Toastify__toast-theme--light,.Toastify__toast-theme--colored.Toastify__toast--default{background:var(--toastify-color-light);color:var(--toastify-text-color-light)}.Toastify__toast-theme--colored.Toastify__toast--info{color:var(--toastify-text-color-info);background:var(--toastify-color-info)}.Toastify__toast-theme--colored.Toastify__toast--success{color:var(--toastify-text-color-success);background:var(--toastify-color-success)}.Toastify__toast-theme--colored.Toastify__toast--warning{color:var(--toastify-text-color-warning);background:var(--toastify-color-warning)}.Toastify__toast-theme--colored.Toastify__toast--error{color:var(--toastify-text-color-error);background:var(--toastify-color-error)}.Toastify__progress-bar-theme--light{background:var(--toastify-color-progress-light)}.Toastify__progress-bar-theme--dark{background:var(--toastify-color-progress-dark)}.Toastify__progress-bar--info{background:var(--toastify-color-progress-info)}.Toastify__progress-bar--success{background:var(--toastify-color-progress-success)}.Toastify__progress-bar--warning{background:var(--toastify-color-progress-warning)}.Toastify__progress-bar--error{background:var(--toastify-color-progress-error)}.Toastify__progress-bar-theme--colored.Toastify__progress-bar--info,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--success,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--warning,.Toastify__progress-bar-theme--colored.Toastify__progress-bar--error{background:var(--toastify-color-transparent)}.Toastify__close-button{color:#fff;background:transparent;outline:none;border:none;padding:0;cursor:pointer;opacity:.7;transition:.3s ease;-ms-flex-item-align:start;align-self:flex-start}.Toastify__close-button--light{color:#000;opacity:.3}.Toastify__close-button>svg{fill:currentColor;height:16px;width:14px}.Toastify__close-button:hover,.Toastify__close-button:focus{opacity:1}@keyframes Toastify__trackProgress{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Toastify__progress-bar{position:absolute;bottom:0;left:0;width:100%;height:5px;z-index:var(--toastify-z-index);opacity:.7;transform-origin:left}.Toastify__progress-bar--animated{animation:Toastify__trackProgress linear 1 forwards}.Toastify__progress-bar--controlled{transition:transform .2s}.Toastify__progress-bar--rtl{right:0;left:initial;transform-origin:right}.Toastify__spinner{width:20px;height:20px;box-sizing:border-box;border:2px solid;border-radius:100%;border-color:var(--toastify-spinner-color-empty-area);border-right-color:var(--toastify-spinner-color);animation:Toastify__spin .65s linear infinite}@keyframes Toastify__bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutRight{20%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(2000px,0,0)}}@keyframes Toastify__bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes Toastify__bounceOutLeft{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}@keyframes Toastify__bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes Toastify__bounceOutUp{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes Toastify__bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes Toastify__bounceOutDown{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Toastify__bounce-enter--top-left,.Toastify__bounce-enter--bottom-left{animation-name:Toastify__bounceInLeft}.Toastify__bounce-enter--top-right,.Toastify__bounce-enter--bottom-right{animation-name:Toastify__bounceInRight}.Toastify__bounce-enter--top-center{animation-name:Toastify__bounceInDown}.Toastify__bounce-enter--bottom-center{animation-name:Toastify__bounceInUp}.Toastify__bounce-exit--top-left,.Toastify__bounce-exit--bottom-left{animation-name:Toastify__bounceOutLeft}.Toastify__bounce-exit--top-right,.Toastify__bounce-exit--bottom-right{animation-name:Toastify__bounceOutRight}.Toastify__bounce-exit--top-center{animation-name:Toastify__bounceOutUp}.Toastify__bounce-exit--bottom-center{animation-name:Toastify__bounceOutDown}@keyframes Toastify__zoomIn{0%{opacity:0;transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes Toastify__zoomOut{0%{opacity:1}50%{opacity:0;transform:scale3d(.3,.3,.3)}to{opacity:0}}.Toastify__zoom-enter{animation-name:Toastify__zoomIn}.Toastify__zoom-exit{animation-name:Toastify__zoomOut}@keyframes Toastify__flipIn{0%{transform:perspective(400px) rotateX(90deg);animation-timing-function:ease-in;opacity:0}40%{transform:perspective(400px) rotateX(-20deg);animation-timing-function:ease-in}60%{transform:perspective(400px) rotateX(10deg);opacity:1}80%{transform:perspective(400px) rotateX(-5deg)}to{transform:perspective(400px)}}@keyframes Toastify__flipOut{0%{transform:perspective(400px)}30%{transform:perspective(400px) rotateX(-20deg);opacity:1}to{transform:perspective(400px) rotateX(90deg);opacity:0}}.Toastify__flip-enter{animation-name:Toastify__flipIn}.Toastify__flip-exit{animation-name:Toastify__flipOut}@keyframes Toastify__slideInRight{0%{transform:translate3d(110%,0,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideInLeft{0%{transform:translate3d(-110%,0,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideInUp{0%{transform:translate3d(0,110%,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideInDown{0%{transform:translate3d(0,-110%,0);visibility:visible}to{transform:translateZ(0)}}@keyframes Toastify__slideOutRight{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(110%,0,0)}}@keyframes Toastify__slideOutLeft{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(-110%,0,0)}}@keyframes Toastify__slideOutDown{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(0,500px,0)}}@keyframes Toastify__slideOutUp{0%{transform:translateZ(0)}to{visibility:hidden;transform:translate3d(0,-500px,0)}}.Toastify__slide-enter--top-left,.Toastify__slide-enter--bottom-left{animation-name:Toastify__slideInLeft}.Toastify__slide-enter--top-right,.Toastify__slide-enter--bottom-right{animation-name:Toastify__slideInRight}.Toastify__slide-enter--top-center{animation-name:Toastify__slideInDown}.Toastify__slide-enter--bottom-center{animation-name:Toastify__slideInUp}.Toastify__slide-exit--top-left,.Toastify__slide-exit--bottom-left{animation-name:Toastify__slideOutLeft}.Toastify__slide-exit--top-right,.Toastify__slide-exit--bottom-right{animation-name:Toastify__slideOutRight}.Toastify__slide-exit--top-center{animation-name:Toastify__slideOutUp}.Toastify__slide-exit--bottom-center{animation-name:Toastify__slideOutDown}@keyframes Toastify__spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')), document.head.appendChild(t);
    }
  } catch (o) {
    console.error("vite-plugin-css-injected-by-js", o);
  }
})();
var Qn = Object.defineProperty;
var Yn = (t, e, r) => e in t ? Qn(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var m = (t, e, r) => (Yn(t, typeof e != "symbol" ? e + "" : e, r), r);
var jt = { exports: {} };
var Le = {};
var vr;
function as() {
  if (vr)
    return Le;
  vr = 1;
  var t = import_react.default, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, s = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: true, ref: true, __self: true, __source: true };
  function i(c, l, u) {
    var f, y = {}, b = null, g = null;
    u !== void 0 && (b = "" + u), l.key !== void 0 && (b = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (f in l)
      n.call(l, f) && !o.hasOwnProperty(f) && (y[f] = l[f]);
    if (c && c.defaultProps)
      for (f in l = c.defaultProps, l)
        y[f] === void 0 && (y[f] = l[f]);
    return { $$typeof: e, type: c, key: b, ref: g, props: y, _owner: s.current };
  }
  return Le.Fragment = r, Le.jsx = i, Le.jsxs = i, Le;
}
var xe = {};
var Rr;
function cs() {
  return Rr || (Rr = 1, "production".NODE_ENV !== "production" && function() {
    var t = import_react.default, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), c = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), y = Symbol.for("react.memo"), b = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), h = Symbol.iterator, E = "@@iterator";
    function R(a) {
      if (a === null || typeof a != "object")
        return null;
      var p = h && a[h] || a[E];
      return typeof p == "function" ? p : null;
    }
    var v = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _14(a) {
      {
        for (var p = arguments.length, w = new Array(p > 1 ? p - 1 : 0), T = 1; T < p; T++)
          w[T - 1] = arguments[T];
        D("error", a, w);
      }
    }
    function D(a, p, w) {
      {
        var T = v.ReactDebugCurrentFrame, I = T.getStackAddendum();
        I !== "" && (p += "%s", w = w.concat([I]));
        var x = w.map(function(S) {
          return String(S);
        });
        x.unshift("Warning: " + p), Function.prototype.apply.call(console[a], console, x);
      }
    }
    var C = false, L = false, ne = false, se = false, q = false, oe;
    oe = Symbol.for("react.module.reference");
    function pe(a) {
      return !!(typeof a == "string" || typeof a == "function" || a === n || a === o || q || a === s || a === u || a === f || se || a === g || C || L || ne || typeof a == "object" && a !== null && (a.$$typeof === b || a.$$typeof === y || a.$$typeof === i || a.$$typeof === c || a.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      a.$$typeof === oe || a.getModuleId !== void 0));
    }
    function le(a, p, w) {
      var T = a.displayName;
      if (T)
        return T;
      var I = p.displayName || p.name || "";
      return I !== "" ? w + "(" + I + ")" : w;
    }
    function H(a) {
      return a.displayName || "Context";
    }
    function $(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && _14("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case s:
          return "StrictMode";
        case u:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case c:
            var p = a;
            return H(p) + ".Consumer";
          case i:
            var w = a;
            return H(w._context) + ".Provider";
          case l:
            return le(a, a.render, "ForwardRef");
          case y:
            var T = a.displayName || null;
            return T !== null ? T : $(a.type) || "Memo";
          case b: {
            var I = a, x = I._payload, S = I._init;
            try {
              return $(S(x));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var F = Object.assign, J = 0, W, Q, ie, Ee, nr, sr, or;
    function ir() {
    }
    ir.__reactDisabledLog = true;
    function On() {
      {
        if (J === 0) {
          W = console.log, Q = console.info, ie = console.warn, Ee = console.error, nr = console.group, sr = console.groupCollapsed, or = console.groupEnd;
          var a = {
            configurable: true,
            enumerable: true,
            value: ir,
            writable: true
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        J++;
      }
    }
    function Sn() {
      {
        if (J--, J === 0) {
          var a = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: F({}, a, {
              value: W
            }),
            info: F({}, a, {
              value: Q
            }),
            warn: F({}, a, {
              value: ie
            }),
            error: F({}, a, {
              value: Ee
            }),
            group: F({}, a, {
              value: nr
            }),
            groupCollapsed: F({}, a, {
              value: sr
            }),
            groupEnd: F({}, a, {
              value: or
            })
          });
        }
        J < 0 && _14("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var wt = v.ReactCurrentDispatcher, bt;
    function Ve(a, p, w) {
      {
        if (bt === void 0)
          try {
            throw Error();
          } catch (I) {
            var T = I.stack.trim().match(/\n( *(at )?)/);
            bt = T && T[1] || "";
          }
        return `
` + bt + a;
      }
    }
    var vt = false, Ke;
    {
      var An = typeof WeakMap == "function" ? WeakMap : Map;
      Ke = new An();
    }
    function ar(a, p) {
      if (!a || vt)
        return "";
      {
        var w = Ke.get(a);
        if (w !== void 0)
          return w;
      }
      var T;
      vt = true;
      var I = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var x;
      x = wt.current, wt.current = null, On();
      try {
        if (p) {
          var S = function() {
            throw Error();
          };
          if (Object.defineProperty(S.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(S, []);
            } catch (de) {
              T = de;
            }
            Reflect.construct(a, [], S);
          } else {
            try {
              S.call();
            } catch (de) {
              T = de;
            }
            a.call(S.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (de) {
            T = de;
          }
          a();
        }
      } catch (de) {
        if (de && T && typeof de.stack == "string") {
          for (var O = de.stack.split(`
`), V = T.stack.split(`
`), M = O.length - 1, j = V.length - 1; M >= 1 && j >= 0 && O[M] !== V[j]; )
            j--;
          for (; M >= 1 && j >= 0; M--, j--)
            if (O[M] !== V[j]) {
              if (M !== 1 || j !== 1)
                do
                  if (M--, j--, j < 0 || O[M] !== V[j]) {
                    var Y = `
` + O[M].replace(" at new ", " at ");
                    return a.displayName && Y.includes("<anonymous>") && (Y = Y.replace("<anonymous>", a.displayName)), typeof a == "function" && Ke.set(a, Y), Y;
                  }
                while (M >= 1 && j >= 0);
              break;
            }
        }
      } finally {
        vt = false, wt.current = x, Sn(), Error.prepareStackTrace = I;
      }
      var Se = a ? a.displayName || a.name : "", br = Se ? Ve(Se) : "";
      return typeof a == "function" && Ke.set(a, br), br;
    }
    function Cn(a, p, w) {
      return ar(a, false);
    }
    function In(a) {
      var p = a.prototype;
      return !!(p && p.isReactComponent);
    }
    function Ge(a, p, w) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return ar(a, In(a));
      if (typeof a == "string")
        return Ve(a);
      switch (a) {
        case u:
          return Ve("Suspense");
        case f:
          return Ve("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case l:
            return Cn(a.render);
          case y:
            return Ge(a.type, p, w);
          case b: {
            var T = a, I = T._payload, x = T._init;
            try {
              return Ge(x(I), p, w);
            } catch {
            }
          }
        }
      return "";
    }
    var Je = Object.prototype.hasOwnProperty, cr = {}, ur = v.ReactDebugCurrentFrame;
    function Qe(a) {
      if (a) {
        var p = a._owner, w = Ge(a.type, a._source, p ? p.type : null);
        ur.setExtraStackFrame(w);
      } else
        ur.setExtraStackFrame(null);
    }
    function Pn(a, p, w, T, I) {
      {
        var x = Function.call.bind(Je);
        for (var S in a)
          if (x(a, S)) {
            var O = void 0;
            try {
              if (typeof a[S] != "function") {
                var V = Error((T || "React class") + ": " + w + " type `" + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[S] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw V.name = "Invariant Violation", V;
              }
              O = a[S](p, S, T, w, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (M) {
              O = M;
            }
            O && !(O instanceof Error) && (Qe(I), _14("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", T || "React class", w, S, typeof O), Qe(null)), O instanceof Error && !(O.message in cr) && (cr[O.message] = true, Qe(I), _14("Failed %s type: %s", w, O.message), Qe(null));
          }
      }
    }
    var Nn = Array.isArray;
    function Rt(a) {
      return Nn(a);
    }
    function Ln(a) {
      {
        var p = typeof Symbol == "function" && Symbol.toStringTag, w = p && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return w;
      }
    }
    function xn(a) {
      try {
        return lr(a), false;
      } catch {
        return true;
      }
    }
    function lr(a) {
      return "" + a;
    }
    function dr(a) {
      if (xn(a))
        return _14("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ln(a)), lr(a);
    }
    var Ne = v.ReactCurrentOwner, kn = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, fr, hr, Tt;
    Tt = {};
    function Un(a) {
      if (Je.call(a, "ref")) {
        var p = Object.getOwnPropertyDescriptor(a, "ref").get;
        if (p && p.isReactWarning)
          return false;
      }
      return a.ref !== void 0;
    }
    function Dn(a) {
      if (Je.call(a, "key")) {
        var p = Object.getOwnPropertyDescriptor(a, "key").get;
        if (p && p.isReactWarning)
          return false;
      }
      return a.key !== void 0;
    }
    function Fn(a, p) {
      if (typeof a.ref == "string" && Ne.current && p && Ne.current.stateNode !== p) {
        var w = $(Ne.current.type);
        Tt[w] || (_14('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(Ne.current.type), a.ref), Tt[w] = true);
      }
    }
    function Mn(a, p) {
      {
        var w = function() {
          fr || (fr = true, _14("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        w.isReactWarning = true, Object.defineProperty(a, "key", {
          get: w,
          configurable: true
        });
      }
    }
    function jn(a, p) {
      {
        var w = function() {
          hr || (hr = true, _14("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        w.isReactWarning = true, Object.defineProperty(a, "ref", {
          get: w,
          configurable: true
        });
      }
    }
    var $n = function(a, p, w, T, I, x, S) {
      var O = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: a,
        key: p,
        ref: w,
        props: S,
        // Record the component responsible for creating this element.
        _owner: x
      };
      return O._store = {}, Object.defineProperty(O._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(O, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: T
      }), Object.defineProperty(O, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: I
      }), Object.freeze && (Object.freeze(O.props), Object.freeze(O)), O;
    };
    function Bn(a, p, w, T, I) {
      {
        var x, S = {}, O = null, V = null;
        w !== void 0 && (dr(w), O = "" + w), Dn(p) && (dr(p.key), O = "" + p.key), Un(p) && (V = p.ref, Fn(p, I));
        for (x in p)
          Je.call(p, x) && !kn.hasOwnProperty(x) && (S[x] = p[x]);
        if (a && a.defaultProps) {
          var M = a.defaultProps;
          for (x in M)
            S[x] === void 0 && (S[x] = M[x]);
        }
        if (O || V) {
          var j = typeof a == "function" ? a.displayName || a.name || "Unknown" : a;
          O && Mn(S, j), V && jn(S, j);
        }
        return $n(a, O, V, I, T, Ne.current, S);
      }
    }
    var _t = v.ReactCurrentOwner, pr = v.ReactDebugCurrentFrame;
    function Oe(a) {
      if (a) {
        var p = a._owner, w = Ge(a.type, a._source, p ? p.type : null);
        pr.setExtraStackFrame(w);
      } else
        pr.setExtraStackFrame(null);
    }
    var Ot;
    Ot = false;
    function St(a) {
      return typeof a == "object" && a !== null && a.$$typeof === e;
    }
    function mr() {
      {
        if (_t.current) {
          var a = $(_t.current.type);
          if (a)
            return `

Check the render method of \`` + a + "`.";
        }
        return "";
      }
    }
    function qn(a) {
      {
        if (a !== void 0) {
          var p = a.fileName.replace(/^.*[\\\/]/, ""), w = a.lineNumber;
          return `

Check your code at ` + p + ":" + w + ".";
        }
        return "";
      }
    }
    var gr = {};
    function Wn(a) {
      {
        var p = mr();
        if (!p) {
          var w = typeof a == "string" ? a : a.displayName || a.name;
          w && (p = `

Check the top-level render call using <` + w + ">.");
        }
        return p;
      }
    }
    function yr(a, p) {
      {
        if (!a._store || a._store.validated || a.key != null)
          return;
        a._store.validated = true;
        var w = Wn(p);
        if (gr[w])
          return;
        gr[w] = true;
        var T = "";
        a && a._owner && a._owner !== _t.current && (T = " It was passed a child from " + $(a._owner.type) + "."), Oe(a), _14('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', w, T), Oe(null);
      }
    }
    function Er(a, p) {
      {
        if (typeof a != "object")
          return;
        if (Rt(a))
          for (var w = 0; w < a.length; w++) {
            var T = a[w];
            St(T) && yr(T, p);
          }
        else if (St(a))
          a._store && (a._store.validated = true);
        else if (a) {
          var I = R(a);
          if (typeof I == "function" && I !== a.entries)
            for (var x = I.call(a), S; !(S = x.next()).done; )
              St(S.value) && yr(S.value, p);
        }
      }
    }
    function zn(a) {
      {
        var p = a.type;
        if (p == null || typeof p == "string")
          return;
        var w;
        if (typeof p == "function")
          w = p.propTypes;
        else if (typeof p == "object" && (p.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        p.$$typeof === y))
          w = p.propTypes;
        else
          return;
        if (w) {
          var T = $(p);
          Pn(w, a.props, "prop", T, a);
        } else if (p.PropTypes !== void 0 && !Ot) {
          Ot = true;
          var I = $(p);
          _14("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", I || "Unknown");
        }
        typeof p.getDefaultProps == "function" && !p.getDefaultProps.isReactClassApproved && _14("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Hn(a) {
      {
        for (var p = Object.keys(a.props), w = 0; w < p.length; w++) {
          var T = p[w];
          if (T !== "children" && T !== "key") {
            Oe(a), _14("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", T), Oe(null);
            break;
          }
        }
        a.ref !== null && (Oe(a), _14("Invalid attribute `ref` supplied to `React.Fragment`."), Oe(null));
      }
    }
    function wr(a, p, w, T, I, x) {
      {
        var S = pe(a);
        if (!S) {
          var O = "";
          (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (O += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var V = qn(I);
          V ? O += V : O += mr();
          var M;
          a === null ? M = "null" : Rt(a) ? M = "array" : a !== void 0 && a.$$typeof === e ? (M = "<" + ($(a.type) || "Unknown") + " />", O = " Did you accidentally export a JSX literal instead of a component?") : M = typeof a, _14("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", M, O);
        }
        var j = Bn(a, p, w, I, x);
        if (j == null)
          return j;
        if (S) {
          var Y = p.children;
          if (Y !== void 0)
            if (T)
              if (Rt(Y)) {
                for (var Se = 0; Se < Y.length; Se++)
                  Er(Y[Se], a);
                Object.freeze && Object.freeze(Y);
              } else
                _14("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Er(Y, a);
        }
        return a === n ? Hn(j) : zn(j), j;
      }
    }
    function Vn(a, p, w) {
      return wr(a, p, w, true);
    }
    function Kn(a, p, w) {
      return wr(a, p, w, false);
    }
    var Gn = Kn, Jn = Vn;
    xe.Fragment = n, xe.jsx = Gn, xe.jsxs = Jn;
  }()), xe;
}
"production".NODE_ENV === "production" ? jt.exports = as() : jt.exports = cs();
var P = jt.exports;
function zr(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number")
    n += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = zr(t[e])) && (n && (n += " "), n += r);
    else
      for (e in t)
        t[e] && (n && (n += " "), n += e);
  return n;
}
function us() {
  for (var t, e, r = 0, n = ""; r < arguments.length; )
    (t = arguments[r++]) && (e = zr(t)) && (n && (n += " "), n += e);
  return n;
}
var $t = ((t) => (t.Completed = "completed", t.InProgress = "inProgress", t.Rejected = "rejected", t))($t || {});
var Ue = ((t) => (t[t.OK = 0] = "OK", t[t.ERROR = 1] = "ERROR", t[t.OperationRejected = 2] = "OperationRejected", t))(Ue || {});
var ls = ((t) => (t.VideoMessage = "videoMessage", t.ScreenRecord = "screenRecord", t))(ls || {});
var z = ((t) => (t[t.EMERGENCY = 0] = "EMERGENCY", t[t.ALERT = 1] = "ALERT", t[t.CRITICAL = 2] = "CRITICAL", t[t.ERROR = 3] = "ERROR", t[t.WARN = 4] = "WARN", t[t.INFO = 6] = "INFO", t[t.DEBUG = 7] = "DEBUG", t))(z || {});
var Tr = () => {
};
var ut = ((t) => (t.password = "password", t.AD = "AD", t.microsoftEntraId = "microsoftEntraId", t.google = "google", t.refreshToken = "refresh_token", t))(ut || {});
var Hr = (0, import_react.createContext)({
  currentUser: void 0,
  currentUserLoading: true,
  setCurrentUser: Tr,
  logout: Tr
});
var ds = () => (0, import_react.useContext)(Hr);
var Vr = "piche-logger";
var _r = "_unknown_";
var Or = "logger.level.ns.";
var fs = "piche-navigate-host";
var it = 200;
var Kr = 2147483647;
var hs = "LOGIN_SUCCESSFULLY_FOR_PORTAL_USER";
var ps = "LOGOUT_SUCCESSFULLY_FOR_PORTAL_USER";
var ms = "/protocol/openid-connect/token";
var gs = "/protocol/openid-connect/logout";
var Gr = "piche-request-api-client";
var Jr = "piche-request-operation-client";
var ys = "REQUEST_TABLE_DATA_LOADER";
var Qr = "piche_request_api_configuration_event";
var Es = "piche-request-table-client";
var ws = "piche-request-view-client";
var Yr = "piche-react-toast";
var Xr = "REQUEST_PORTAL_USER_MANAGER";
var Zr = "piche-request-profile-contact-store";
var bs = "PROFILE_CONTACT_UPDATED";
var k = class {
};
m(k, "emitMessageAsync", (e, r) => {
  Promise.resolve().then(() => {
    const n = new CustomEvent(e, { detail: r });
    Promise.resolve().then(() => window.dispatchEvent(n));
  });
}), m(k, "subscribe", (e, r) => (window.addEventListener(e, r), {
  unsubscribe: () => window.removeEventListener(e, r)
}));
var lt = (t) => {
  k.emitMessageAsync(Vr, t);
};
var vs = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.INFO, error: r });
var Mi = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.DEBUG, error: r });
var ji = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.WARN, error: r });
var be = (t, e, r, n) => lt({ nameSpace: n, message: t, code: e, level: z.ERROR, error: r });
var re = class _re {
  isEmpty() {
    return !this.isPresent();
  }
  static of(e) {
    if (e != null)
      return new Sr(e);
    throw new TypeError("The passed value was null or undefined.");
  }
  static ofNonNull(e) {
    return _re.of(e);
  }
  static ofNullable(e) {
    return e != null ? new Sr(e) : new Ar();
  }
  static empty() {
    return new Ar();
  }
  static from(e) {
    switch (e.kind) {
      case "present":
        return _re.of(e.value);
      case "empty":
        return _re.empty();
      default:
        throw new TypeError("The passed value was not an Option type.");
    }
  }
};
var Sr = class extends re {
  constructor(e) {
    super(), this.payload = e;
  }
  isPresent() {
    return true;
  }
  get() {
    return this.payload;
  }
  ifPresent(e) {
    e(this.payload);
  }
  ifPresentOrElse(e, r) {
    e(this.payload);
  }
  filter(e) {
    return e(this.payload) ? this : re.empty();
  }
  map(e) {
    const r = e(this.payload);
    return re.ofNullable(r);
  }
  flatMap(e) {
    return e(this.payload);
  }
  or(e) {
    return this;
  }
  orElse(e) {
    return this.payload;
  }
  orElseGet(e) {
    return this.payload;
  }
  orElseThrow(e) {
    return this.payload;
  }
  orNull() {
    return this.payload;
  }
  orUndefined() {
    return this.payload;
  }
  toOption() {
    return { kind: "present", value: this.payload };
  }
  matches(e) {
    return e.present(this.payload);
  }
  toJSON(e) {
    return this.payload;
  }
};
var Ar = class extends re {
  isPresent() {
    return false;
  }
  constructor() {
    super();
  }
  get() {
    throw new TypeError("The optional is not present.");
  }
  ifPresent(e) {
  }
  ifPresentOrElse(e, r) {
    r();
  }
  filter(e) {
    return this;
  }
  map(e) {
    return re.empty();
  }
  flatMap(e) {
    return re.empty();
  }
  or(e) {
    return e();
  }
  orElse(e) {
    return e;
  }
  orElseGet(e) {
    return this.orElse(e());
  }
  orElseThrow(e) {
    throw e();
  }
  orNull() {
    return null;
  }
  orUndefined() {
  }
  toOption() {
    return { kind: "empty" };
  }
  matches(e) {
    return e.empty();
  }
  toJSON(e) {
    return null;
  }
};
function en(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
var { toString: Rs } = Object.prototype;
var { getPrototypeOf: Jt } = Object;
var dt = ((t) => (e) => {
  const r = Rs.call(e);
  return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var ue = (t) => (t = t.toLowerCase(), (e) => dt(e) === t);
var ft = (t) => (e) => typeof e === t;
var { isArray: Pe } = Array;
var qe = ft("undefined");
function Ts(t) {
  return t !== null && !qe(t) && t.constructor !== null && !qe(t.constructor) && ee(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
var tn = ue("ArrayBuffer");
function _s(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && tn(t.buffer), e;
}
var Os = ft("string");
var ee = ft("function");
var rn = ft("number");
var ht = (t) => t !== null && typeof t == "object";
var Ss = (t) => t === true || t === false;
var tt = (t) => {
  if (dt(t) !== "object")
    return false;
  const e = Jt(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
};
var As = ue("Date");
var Cs = ue("File");
var Is = ue("Blob");
var Ps = ue("FileList");
var Ns = (t) => ht(t) && ee(t.pipe);
var Ls = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || ee(t.append) && ((e = dt(t)) === "formdata" || // detect form-data instance
  e === "object" && ee(t.toString) && t.toString() === "[object FormData]"));
};
var xs = ue("URLSearchParams");
var ks = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ze(t, e, { allOwnKeys: r = false } = {}) {
  if (t === null || typeof t > "u")
    return;
  let n, s;
  if (typeof t != "object" && (t = [t]), Pe(t))
    for (n = 0, s = t.length; n < s; n++)
      e.call(null, t[n], n, t);
  else {
    const o = r ? Object.getOwnPropertyNames(t) : Object.keys(t), i = o.length;
    let c;
    for (n = 0; n < i; n++)
      c = o[n], e.call(null, t[c], c, t);
  }
}
function nn(t, e) {
  e = e.toLowerCase();
  const r = Object.keys(t);
  let n = r.length, s;
  for (; n-- > 0; )
    if (s = r[n], e === s.toLowerCase())
      return s;
  return null;
}
var sn = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)();
var on = (t) => !qe(t) && t !== sn;
function Bt() {
  const { caseless: t } = on(this) && this || {}, e = {}, r = (n, s) => {
    const o = t && nn(e, s) || s;
    tt(e[o]) && tt(n) ? e[o] = Bt(e[o], n) : tt(n) ? e[o] = Bt({}, n) : Pe(n) ? e[o] = n.slice() : e[o] = n;
  };
  for (let n = 0, s = arguments.length; n < s; n++)
    arguments[n] && ze(arguments[n], r);
  return e;
}
var Us = (t, e, r, { allOwnKeys: n } = {}) => (ze(e, (s, o) => {
  r && ee(s) ? t[o] = en(s, r) : t[o] = s;
}, { allOwnKeys: n }), t);
var Ds = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t);
var Fs = (t, e, r, n) => {
  t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), r && Object.assign(t.prototype, r);
};
var Ms = (t, e, r, n) => {
  let s, o, i;
  const c = {};
  if (e = e || {}, t == null)
    return e;
  do {
    for (s = Object.getOwnPropertyNames(t), o = s.length; o-- > 0; )
      i = s[o], (!n || n(i, t, e)) && !c[i] && (e[i] = t[i], c[i] = true);
    t = r !== false && Jt(t);
  } while (t && (!r || r(t, e)) && t !== Object.prototype);
  return e;
};
var js = (t, e, r) => {
  t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
  const n = t.indexOf(e, r);
  return n !== -1 && n === r;
};
var $s = (t) => {
  if (!t)
    return null;
  if (Pe(t))
    return t;
  let e = t.length;
  if (!rn(e))
    return null;
  const r = new Array(e);
  for (; e-- > 0; )
    r[e] = t[e];
  return r;
};
var Bs = ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Jt(Uint8Array));
var qs = (t, e) => {
  const n = (t && t[Symbol.iterator]).call(t);
  let s;
  for (; (s = n.next()) && !s.done; ) {
    const o = s.value;
    e.call(t, o[0], o[1]);
  }
};
var Ws = (t, e) => {
  let r;
  const n = [];
  for (; (r = t.exec(e)) !== null; )
    n.push(r);
  return n;
};
var zs = ue("HTMLFormElement");
var Hs = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, s) {
    return n.toUpperCase() + s;
  }
);
var Cr = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype);
var Vs = ue("RegExp");
var an = (t, e) => {
  const r = Object.getOwnPropertyDescriptors(t), n = {};
  ze(r, (s, o) => {
    e(s, o, t) !== false && (n[o] = s);
  }), Object.defineProperties(t, n);
};
var Ks = (t) => {
  an(t, (e, r) => {
    if (ee(t) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return false;
    const n = t[r];
    if (ee(n)) {
      if (e.enumerable = false, "writable" in e) {
        e.writable = false;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
};
var Gs = (t, e) => {
  const r = {}, n = (s) => {
    s.forEach((o) => {
      r[o] = true;
    });
  };
  return Pe(t) ? n(t) : n(String(t).split(e)), r;
};
var Js = () => {
};
var Qs = (t, e) => (t = +t, Number.isFinite(t) ? t : e);
var At = "abcdefghijklmnopqrstuvwxyz";
var Ir = "0123456789";
var cn = {
  DIGIT: Ir,
  ALPHA: At,
  ALPHA_DIGIT: At + At.toUpperCase() + Ir
};
var Ys = (t = 16, e = cn.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = e;
  for (; t--; )
    r += e[Math.random() * n | 0];
  return r;
};
function Xs(t) {
  return !!(t && ee(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
var Zs = (t) => {
  const e = new Array(10), r = (n, s) => {
    if (ht(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[s] = n;
        const o = Pe(n) ? [] : {};
        return ze(n, (i, c) => {
          const l = r(i, s + 1);
          !qe(l) && (o[c] = l);
        }), e[s] = void 0, o;
      }
    }
    return n;
  };
  return r(t, 0);
};
var eo = ue("AsyncFunction");
var to = (t) => t && (ht(t) || ee(t)) && ee(t.then) && ee(t.catch);
var d = {
  isArray: Pe,
  isArrayBuffer: tn,
  isBuffer: Ts,
  isFormData: Ls,
  isArrayBufferView: _s,
  isString: Os,
  isNumber: rn,
  isBoolean: Ss,
  isObject: ht,
  isPlainObject: tt,
  isUndefined: qe,
  isDate: As,
  isFile: Cs,
  isBlob: Is,
  isRegExp: Vs,
  isFunction: ee,
  isStream: Ns,
  isURLSearchParams: xs,
  isTypedArray: Bs,
  isFileList: Ps,
  forEach: ze,
  merge: Bt,
  extend: Us,
  trim: ks,
  stripBOM: Ds,
  inherits: Fs,
  toFlatObject: Ms,
  kindOf: dt,
  kindOfTest: ue,
  endsWith: js,
  toArray: $s,
  forEachEntry: qs,
  matchAll: Ws,
  isHTMLForm: zs,
  hasOwnProperty: Cr,
  hasOwnProp: Cr,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: an,
  freezeMethods: Ks,
  toObjectSet: Gs,
  toCamelCase: Hs,
  noop: Js,
  toFiniteNumber: Qs,
  findKey: nn,
  global: sn,
  isContextDefined: on,
  ALPHABET: cn,
  generateString: Ys,
  isSpecCompliantForm: Xs,
  toJSONObject: Zs,
  isAsyncFn: eo,
  isThenable: to
};
function A(t, e, r, n, s) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), s && (this.response = s);
}
d.inherits(A, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: d.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var un = A.prototype;
var ln = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  ln[t] = { value: t };
});
Object.defineProperties(A, ln);
Object.defineProperty(un, "isAxiosError", { value: true });
A.from = (t, e, r, n, s, o) => {
  const i = Object.create(un);
  return d.toFlatObject(t, i, function(l) {
    return l !== Error.prototype;
  }, (c) => c !== "isAxiosError"), A.call(i, t.message, e, r, n, s), i.cause = t, i.name = t.name, o && Object.assign(i, o), i;
};
var ro = null;
function qt(t) {
  return d.isPlainObject(t) || d.isArray(t);
}
function dn(t) {
  return d.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function Pr(t, e, r) {
  return t ? t.concat(e).map(function(s, o) {
    return s = dn(s), !r && o ? "[" + s + "]" : s;
  }).join(r ? "." : "") : e;
}
function no(t) {
  return d.isArray(t) && !t.some(qt);
}
var so = d.toFlatObject(d, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function pt(t, e, r) {
  if (!d.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), r = d.toFlatObject(r, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function(E, R) {
    return !d.isUndefined(R[E]);
  });
  const n = r.metaTokens, s = r.visitor || f, o = r.dots, i = r.indexes, l = (r.Blob || typeof Blob < "u" && Blob) && d.isSpecCompliantForm(e);
  if (!d.isFunction(s))
    throw new TypeError("visitor must be a function");
  function u(h) {
    if (h === null)
      return "";
    if (d.isDate(h))
      return h.toISOString();
    if (!l && d.isBlob(h))
      throw new A("Blob is not supported. Use a Buffer instead.");
    return d.isArrayBuffer(h) || d.isTypedArray(h) ? l && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function f(h, E, R) {
    let v = h;
    if (h && !R && typeof h == "object") {
      if (d.endsWith(E, "{}"))
        E = n ? E : E.slice(0, -2), h = JSON.stringify(h);
      else if (d.isArray(h) && no(h) || (d.isFileList(h) || d.endsWith(E, "[]")) && (v = d.toArray(h)))
        return E = dn(E), v.forEach(function(D, C) {
          !(d.isUndefined(D) || D === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            i === true ? Pr([E], C, o) : i === null ? E : E + "[]",
            u(D)
          );
        }), false;
    }
    return qt(h) ? true : (e.append(Pr(R, E, o), u(h)), false);
  }
  const y = [], b = Object.assign(so, {
    defaultVisitor: f,
    convertValue: u,
    isVisitable: qt
  });
  function g(h, E) {
    if (!d.isUndefined(h)) {
      if (y.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + E.join("."));
      y.push(h), d.forEach(h, function(v, _14) {
        (!(d.isUndefined(v) || v === null) && s.call(
          e,
          v,
          d.isString(_14) ? _14.trim() : _14,
          E,
          b
        )) === true && g(v, E ? E.concat(_14) : [_14]);
      }), y.pop();
    }
  }
  if (!d.isObject(t))
    throw new TypeError("data must be an object");
  return g(t), e;
}
function Nr(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function Qt(t, e) {
  this._pairs = [], t && pt(t, this, e);
}
var fn = Qt.prototype;
fn.append = function(e, r) {
  this._pairs.push([e, r]);
};
fn.toString = function(e) {
  const r = e ? function(n) {
    return e.call(this, n, Nr);
  } : Nr;
  return this._pairs.map(function(s) {
    return r(s[0]) + "=" + r(s[1]);
  }, "").join("&");
};
function oo(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function hn(t, e, r) {
  if (!e)
    return t;
  const n = r && r.encode || oo, s = r && r.serialize;
  let o;
  if (s ? o = s(e, r) : o = d.isURLSearchParams(e) ? e.toString() : new Qt(e, r).toString(n), o) {
    const i = t.indexOf("#");
    i !== -1 && (t = t.slice(0, i)), t += (t.indexOf("?") === -1 ? "?" : "&") + o;
  }
  return t;
}
var io = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, r, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: r,
      synchronous: n ? n.synchronous : false,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    d.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
};
var Lr = io;
var pn = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var ao = typeof URLSearchParams < "u" ? URLSearchParams : Qt;
var co = typeof FormData < "u" ? FormData : null;
var uo = typeof Blob < "u" ? Blob : null;
var lo = (() => {
  let t;
  return typeof navigator < "u" && ((t = navigator.product) === "ReactNative" || t === "NativeScript" || t === "NS") ? false : typeof window < "u" && typeof document < "u";
})();
var fo = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")();
var ce = {
  isBrowser: true,
  classes: {
    URLSearchParams: ao,
    FormData: co,
    Blob: uo
  },
  isStandardBrowserEnv: lo,
  isStandardBrowserWebWorkerEnv: fo,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function ho(t, e) {
  return pt(t, new ce.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, s, o) {
      return ce.isNode && d.isBuffer(r) ? (this.append(n, r.toString("base64")), false) : o.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function po(t) {
  return d.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function mo(t) {
  const e = {}, r = Object.keys(t);
  let n;
  const s = r.length;
  let o;
  for (n = 0; n < s; n++)
    o = r[n], e[o] = t[o];
  return e;
}
function mn(t) {
  function e(r, n, s, o) {
    let i = r[o++];
    const c = Number.isFinite(+i), l = o >= r.length;
    return i = !i && d.isArray(s) ? s.length : i, l ? (d.hasOwnProp(s, i) ? s[i] = [s[i], n] : s[i] = n, !c) : ((!s[i] || !d.isObject(s[i])) && (s[i] = []), e(r, n, s[i], o) && d.isArray(s[i]) && (s[i] = mo(s[i])), !c);
  }
  if (d.isFormData(t) && d.isFunction(t.entries)) {
    const r = {};
    return d.forEachEntry(t, (n, s) => {
      e(po(n), s, r, 0);
    }), r;
  }
  return null;
}
var go = {
  "Content-Type": void 0
};
function yo(t, e, r) {
  if (d.isString(t))
    try {
      return (e || JSON.parse)(t), d.trim(t);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(t);
}
var mt = {
  transitional: pn,
  adapter: ["xhr", "http"],
  transformRequest: [function(e, r) {
    const n = r.getContentType() || "", s = n.indexOf("application/json") > -1, o = d.isObject(e);
    if (o && d.isHTMLForm(e) && (e = new FormData(e)), d.isFormData(e))
      return s && s ? JSON.stringify(mn(e)) : e;
    if (d.isArrayBuffer(e) || d.isBuffer(e) || d.isStream(e) || d.isFile(e) || d.isBlob(e))
      return e;
    if (d.isArrayBufferView(e))
      return e.buffer;
    if (d.isURLSearchParams(e))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e.toString();
    let c;
    if (o) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return ho(e, this.formSerializer).toString();
      if ((c = d.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return pt(
          c ? { "files[]": e } : e,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return o || s ? (r.setContentType("application/json", false), yo(e)) : e;
  }],
  transformResponse: [function(e) {
    const r = this.transitional || mt.transitional, n = r && r.forcedJSONParsing, s = this.responseType === "json";
    if (e && d.isString(e) && (n && !this.responseType || s)) {
      const i = !(r && r.silentJSONParsing) && s;
      try {
        return JSON.parse(e);
      } catch (c) {
        if (i)
          throw c.name === "SyntaxError" ? A.from(c, A.ERR_BAD_RESPONSE, this, null, this.response) : c;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ce.classes.FormData,
    Blob: ce.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
d.forEach(["delete", "get", "head"], function(e) {
  mt.headers[e] = {};
});
d.forEach(["post", "put", "patch"], function(e) {
  mt.headers[e] = d.merge(go);
});
var Yt = mt;
var Eo = d.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var wo = (t) => {
  const e = {};
  let r, n, s;
  return t && t.split(`
`).forEach(function(i) {
    s = i.indexOf(":"), r = i.substring(0, s).trim().toLowerCase(), n = i.substring(s + 1).trim(), !(!r || e[r] && Eo[r]) && (r === "set-cookie" ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n);
  }), e;
};
var xr = Symbol("internals");
function ke(t) {
  return t && String(t).trim().toLowerCase();
}
function rt(t) {
  return t === false || t == null ? t : d.isArray(t) ? t.map(rt) : String(t);
}
function bo(t) {
  const e = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(t); )
    e[n[1]] = n[2];
  return e;
}
var vo = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Ct(t, e, r, n, s) {
  if (d.isFunction(n))
    return n.call(this, e, r);
  if (s && (e = r), !!d.isString(e)) {
    if (d.isString(n))
      return e.indexOf(n) !== -1;
    if (d.isRegExp(n))
      return n.test(e);
  }
}
function Ro(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n);
}
function To(t, e) {
  const r = d.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(t, n + r, {
      value: function(s, o, i) {
        return this[n].call(this, e, s, o, i);
      },
      configurable: true
    });
  });
}
var gt = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, r, n) {
    const s = this;
    function o(c, l, u) {
      const f = ke(l);
      if (!f)
        throw new Error("header name must be a non-empty string");
      const y = d.findKey(s, f);
      (!y || s[y] === void 0 || u === true || u === void 0 && s[y] !== false) && (s[y || l] = rt(c));
    }
    const i = (c, l) => d.forEach(c, (u, f) => o(u, f, l));
    return d.isPlainObject(e) || e instanceof this.constructor ? i(e, r) : d.isString(e) && (e = e.trim()) && !vo(e) ? i(wo(e), r) : e != null && o(r, e, n), this;
  }
  get(e, r) {
    if (e = ke(e), e) {
      const n = d.findKey(this, e);
      if (n) {
        const s = this[n];
        if (!r)
          return s;
        if (r === true)
          return bo(s);
        if (d.isFunction(r))
          return r.call(this, s, n);
        if (d.isRegExp(r))
          return r.exec(s);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, r) {
    if (e = ke(e), e) {
      const n = d.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!r || Ct(this, this[n], n, r)));
    }
    return false;
  }
  delete(e, r) {
    const n = this;
    let s = false;
    function o(i) {
      if (i = ke(i), i) {
        const c = d.findKey(n, i);
        c && (!r || Ct(n, n[c], c, r)) && (delete n[c], s = true);
      }
    }
    return d.isArray(e) ? e.forEach(o) : o(e), s;
  }
  clear(e) {
    const r = Object.keys(this);
    let n = r.length, s = false;
    for (; n--; ) {
      const o = r[n];
      (!e || Ct(this, this[o], o, e, true)) && (delete this[o], s = true);
    }
    return s;
  }
  normalize(e) {
    const r = this, n = {};
    return d.forEach(this, (s, o) => {
      const i = d.findKey(n, o);
      if (i) {
        r[i] = rt(s), delete r[o];
        return;
      }
      const c = e ? Ro(o) : String(o).trim();
      c !== o && delete r[o], r[c] = rt(s), n[c] = true;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const r = /* @__PURE__ */ Object.create(null);
    return d.forEach(this, (n, s) => {
      n != null && n !== false && (r[s] = e && d.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, r]) => e + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...r) {
    const n = new this(e);
    return r.forEach((s) => n.set(s)), n;
  }
  static accessor(e) {
    const n = (this[xr] = this[xr] = {
      accessors: {}
    }).accessors, s = this.prototype;
    function o(i) {
      const c = ke(i);
      n[c] || (To(s, i), n[c] = true);
    }
    return d.isArray(e) ? e.forEach(o) : o(e), this;
  }
};
gt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
d.freezeMethods(gt.prototype);
d.freezeMethods(gt);
var he = gt;
function It(t, e) {
  const r = this || Yt, n = e || r, s = he.from(n.headers);
  let o = n.data;
  return d.forEach(t, function(c) {
    o = c.call(r, o, s.normalize(), e ? e.status : void 0);
  }), s.normalize(), o;
}
function gn(t) {
  return !!(t && t.__CANCEL__);
}
function He(t, e, r) {
  A.call(this, t ?? "canceled", A.ERR_CANCELED, e, r), this.name = "CanceledError";
}
d.inherits(He, A, {
  __CANCEL__: true
});
function _o(t, e, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? t(r) : e(new A(
    "Request failed with status code " + r.status,
    [A.ERR_BAD_REQUEST, A.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
var Oo = ce.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(r, n, s, o, i, c) {
        const l = [];
        l.push(r + "=" + encodeURIComponent(n)), d.isNumber(s) && l.push("expires=" + new Date(s).toGMTString()), d.isString(o) && l.push("path=" + o), d.isString(i) && l.push("domain=" + i), c === true && l.push("secure"), document.cookie = l.join("; ");
      },
      read: function(r) {
        const n = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
        return n ? decodeURIComponent(n[3]) : null;
      },
      remove: function(r) {
        this.write(r, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function So(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function Ao(t, e) {
  return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function yn(t, e) {
  return t && !So(e) ? Ao(t, e) : e;
}
var Co = ce.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const e = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");
    let n;
    function s(o) {
      let i = o;
      return e && (r.setAttribute("href", i), i = r.href), r.setAttribute("href", i), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return n = s(window.location.href), function(i) {
      const c = d.isString(i) ? s(i) : i;
      return c.protocol === n.protocol && c.host === n.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return true;
    };
  }()
);
function Io(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function Po(t, e) {
  t = t || 10;
  const r = new Array(t), n = new Array(t);
  let s = 0, o = 0, i;
  return e = e !== void 0 ? e : 1e3, function(l) {
    const u = Date.now(), f = n[o];
    i || (i = u), r[s] = l, n[s] = u;
    let y = o, b = 0;
    for (; y !== s; )
      b += r[y++], y = y % t;
    if (s = (s + 1) % t, s === o && (o = (o + 1) % t), u - i < e)
      return;
    const g = f && u - f;
    return g ? Math.round(b * 1e3 / g) : void 0;
  };
}
function kr(t, e) {
  let r = 0;
  const n = Po(50, 250);
  return (s) => {
    const o = s.loaded, i = s.lengthComputable ? s.total : void 0, c = o - r, l = n(c), u = o <= i;
    r = o;
    const f = {
      loaded: o,
      total: i,
      progress: i ? o / i : void 0,
      bytes: c,
      rate: l || void 0,
      estimated: l && i && u ? (i - o) / l : void 0,
      event: s
    };
    f[e ? "download" : "upload"] = true, t(f);
  };
}
var No = typeof XMLHttpRequest < "u";
var Lo = No && function(t) {
  return new Promise(function(r, n) {
    let s = t.data;
    const o = he.from(t.headers).normalize(), i = t.responseType;
    let c;
    function l() {
      t.cancelToken && t.cancelToken.unsubscribe(c), t.signal && t.signal.removeEventListener("abort", c);
    }
    d.isFormData(s) && (ce.isStandardBrowserEnv || ce.isStandardBrowserWebWorkerEnv ? o.setContentType(false) : o.setContentType("multipart/form-data;", false));
    let u = new XMLHttpRequest();
    if (t.auth) {
      const g = t.auth.username || "", h = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
      o.set("Authorization", "Basic " + btoa(g + ":" + h));
    }
    const f = yn(t.baseURL, t.url);
    u.open(t.method.toUpperCase(), hn(f, t.params, t.paramsSerializer), true), u.timeout = t.timeout;
    function y() {
      if (!u)
        return;
      const g = he.from(
        "getAllResponseHeaders" in u && u.getAllResponseHeaders()
      ), E = {
        data: !i || i === "text" || i === "json" ? u.responseText : u.response,
        status: u.status,
        statusText: u.statusText,
        headers: g,
        config: t,
        request: u
      };
      _o(function(v) {
        r(v), l();
      }, function(v) {
        n(v), l();
      }, E), u = null;
    }
    if ("onloadend" in u ? u.onloadend = y : u.onreadystatechange = function() {
      !u || u.readyState !== 4 || u.status === 0 && !(u.responseURL && u.responseURL.indexOf("file:") === 0) || setTimeout(y);
    }, u.onabort = function() {
      u && (n(new A("Request aborted", A.ECONNABORTED, t, u)), u = null);
    }, u.onerror = function() {
      n(new A("Network Error", A.ERR_NETWORK, t, u)), u = null;
    }, u.ontimeout = function() {
      let h = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
      const E = t.transitional || pn;
      t.timeoutErrorMessage && (h = t.timeoutErrorMessage), n(new A(
        h,
        E.clarifyTimeoutError ? A.ETIMEDOUT : A.ECONNABORTED,
        t,
        u
      )), u = null;
    }, ce.isStandardBrowserEnv) {
      const g = (t.withCredentials || Co(f)) && t.xsrfCookieName && Oo.read(t.xsrfCookieName);
      g && o.set(t.xsrfHeaderName, g);
    }
    s === void 0 && o.setContentType(null), "setRequestHeader" in u && d.forEach(o.toJSON(), function(h, E) {
      u.setRequestHeader(E, h);
    }), d.isUndefined(t.withCredentials) || (u.withCredentials = !!t.withCredentials), i && i !== "json" && (u.responseType = t.responseType), typeof t.onDownloadProgress == "function" && u.addEventListener("progress", kr(t.onDownloadProgress, true)), typeof t.onUploadProgress == "function" && u.upload && u.upload.addEventListener("progress", kr(t.onUploadProgress)), (t.cancelToken || t.signal) && (c = (g) => {
      u && (n(!g || g.type ? new He(null, t, u) : g), u.abort(), u = null);
    }, t.cancelToken && t.cancelToken.subscribe(c), t.signal && (t.signal.aborted ? c() : t.signal.addEventListener("abort", c)));
    const b = Io(f);
    if (b && ce.protocols.indexOf(b) === -1) {
      n(new A("Unsupported protocol " + b + ":", A.ERR_BAD_REQUEST, t));
      return;
    }
    u.send(s || null);
  });
};
var nt = {
  http: ro,
  xhr: Lo
};
d.forEach(nt, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
var xo = {
  getAdapter: (t) => {
    t = d.isArray(t) ? t : [t];
    const { length: e } = t;
    let r, n;
    for (let s = 0; s < e && (r = t[s], !(n = d.isString(r) ? nt[r.toLowerCase()] : r)); s++)
      ;
    if (!n)
      throw n === false ? new A(
        `Adapter ${r} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        d.hasOwnProp(nt, r) ? `Adapter '${r}' is not available in the build` : `Unknown adapter '${r}'`
      );
    if (!d.isFunction(n))
      throw new TypeError("adapter is not a function");
    return n;
  },
  adapters: nt
};
function Pt(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new He(null, t);
}
function Ur(t) {
  return Pt(t), t.headers = he.from(t.headers), t.data = It.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", false), xo.getAdapter(t.adapter || Yt.adapter)(t).then(function(n) {
    return Pt(t), n.data = It.call(
      t,
      t.transformResponse,
      n
    ), n.headers = he.from(n.headers), n;
  }, function(n) {
    return gn(n) || (Pt(t), n && n.response && (n.response.data = It.call(
      t,
      t.transformResponse,
      n.response
    ), n.response.headers = he.from(n.response.headers))), Promise.reject(n);
  });
}
var Dr = (t) => t instanceof he ? t.toJSON() : t;
function Ie(t, e) {
  e = e || {};
  const r = {};
  function n(u, f, y) {
    return d.isPlainObject(u) && d.isPlainObject(f) ? d.merge.call({ caseless: y }, u, f) : d.isPlainObject(f) ? d.merge({}, f) : d.isArray(f) ? f.slice() : f;
  }
  function s(u, f, y) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(u))
        return n(void 0, u, y);
    } else
      return n(u, f, y);
  }
  function o(u, f) {
    if (!d.isUndefined(f))
      return n(void 0, f);
  }
  function i(u, f) {
    if (d.isUndefined(f)) {
      if (!d.isUndefined(u))
        return n(void 0, u);
    } else
      return n(void 0, f);
  }
  function c(u, f, y) {
    if (y in e)
      return n(u, f);
    if (y in t)
      return n(void 0, u);
  }
  const l = {
    url: o,
    method: o,
    data: o,
    baseURL: i,
    transformRequest: i,
    transformResponse: i,
    paramsSerializer: i,
    timeout: i,
    timeoutMessage: i,
    withCredentials: i,
    adapter: i,
    responseType: i,
    xsrfCookieName: i,
    xsrfHeaderName: i,
    onUploadProgress: i,
    onDownloadProgress: i,
    decompress: i,
    maxContentLength: i,
    maxBodyLength: i,
    beforeRedirect: i,
    transport: i,
    httpAgent: i,
    httpsAgent: i,
    cancelToken: i,
    socketPath: i,
    responseEncoding: i,
    validateStatus: c,
    headers: (u, f) => s(Dr(u), Dr(f), true)
  };
  return d.forEach(Object.keys(Object.assign({}, t, e)), function(f) {
    const y = l[f] || s, b = y(t[f], e[f], f);
    d.isUndefined(b) && y !== c || (r[f] = b);
  }), r;
}
var En = "1.4.0";
var Xt = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  Xt[t] = function(n) {
    return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
var Fr = {};
Xt.transitional = function(e, r, n) {
  function s(o, i) {
    return "[Axios v" + En + "] Transitional option '" + o + "'" + i + (n ? ". " + n : "");
  }
  return (o, i, c) => {
    if (e === false)
      throw new A(
        s(i, " has been removed" + (r ? " in " + r : "")),
        A.ERR_DEPRECATED
      );
    return r && !Fr[i] && (Fr[i] = true, console.warn(
      s(
        i,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), e ? e(o, i, c) : true;
  };
};
function ko(t, e, r) {
  if (typeof t != "object")
    throw new A("options must be an object", A.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(t);
  let s = n.length;
  for (; s-- > 0; ) {
    const o = n[s], i = e[o];
    if (i) {
      const c = t[o], l = c === void 0 || i(c, o, t);
      if (l !== true)
        throw new A("option " + o + " must be " + l, A.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== true)
      throw new A("Unknown option " + o, A.ERR_BAD_OPTION);
  }
}
var Wt = {
  assertOptions: ko,
  validators: Xt
};
var me = Wt.validators;
var at = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new Lr(),
      response: new Lr()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(e, r) {
    typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = Ie(this.defaults, r);
    const { transitional: n, paramsSerializer: s, headers: o } = r;
    n !== void 0 && Wt.assertOptions(n, {
      silentJSONParsing: me.transitional(me.boolean),
      forcedJSONParsing: me.transitional(me.boolean),
      clarifyTimeoutError: me.transitional(me.boolean)
    }, false), s != null && (d.isFunction(s) ? r.paramsSerializer = {
      serialize: s
    } : Wt.assertOptions(s, {
      encode: me.function,
      serialize: me.function
    }, true)), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let i;
    i = o && d.merge(
      o.common,
      o[r.method]
    ), i && d.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete o[h];
      }
    ), r.headers = he.concat(i, o);
    const c = [];
    let l = true;
    this.interceptors.request.forEach(function(E) {
      typeof E.runWhen == "function" && E.runWhen(r) === false || (l = l && E.synchronous, c.unshift(E.fulfilled, E.rejected));
    });
    const u = [];
    this.interceptors.response.forEach(function(E) {
      u.push(E.fulfilled, E.rejected);
    });
    let f, y = 0, b;
    if (!l) {
      const h = [Ur.bind(this), void 0];
      for (h.unshift.apply(h, c), h.push.apply(h, u), b = h.length, f = Promise.resolve(r); y < b; )
        f = f.then(h[y++], h[y++]);
      return f;
    }
    b = c.length;
    let g = r;
    for (y = 0; y < b; ) {
      const h = c[y++], E = c[y++];
      try {
        g = h(g);
      } catch (R) {
        E.call(this, R);
        break;
      }
    }
    try {
      f = Ur.call(this, g);
    } catch (h) {
      return Promise.reject(h);
    }
    for (y = 0, b = u.length; y < b; )
      f = f.then(u[y++], u[y++]);
    return f;
  }
  getUri(e) {
    e = Ie(this.defaults, e);
    const r = yn(e.baseURL, e.url);
    return hn(r, e.params, e.paramsSerializer);
  }
};
d.forEach(["delete", "get", "head", "options"], function(e) {
  at.prototype[e] = function(r, n) {
    return this.request(Ie(n || {}, {
      method: e,
      url: r,
      data: (n || {}).data
    }));
  };
});
d.forEach(["post", "put", "patch"], function(e) {
  function r(n) {
    return function(o, i, c) {
      return this.request(Ie(c || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: o,
        data: i
      }));
    };
  }
  at.prototype[e] = r(), at.prototype[e + "Form"] = r(true);
});
var st = at;
var Zt = class _Zt {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    const n = this;
    this.promise.then((s) => {
      if (!n._listeners)
        return;
      let o = n._listeners.length;
      for (; o-- > 0; )
        n._listeners[o](s);
      n._listeners = null;
    }), this.promise.then = (s) => {
      let o;
      const i = new Promise((c) => {
        n.subscribe(c), o = c;
      }).then(s);
      return i.cancel = function() {
        n.unsubscribe(o);
      }, i;
    }, e(function(o, i, c) {
      n.reason || (n.reason = new He(o, i, c), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(e);
    r !== -1 && this._listeners.splice(r, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new _Zt(function(s) {
        e = s;
      }),
      cancel: e
    };
  }
};
var Uo = Zt;
function Do(t) {
  return function(r) {
    return t.apply(null, r);
  };
}
function Fo(t) {
  return d.isObject(t) && t.isAxiosError === true;
}
var zt = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(zt).forEach(([t, e]) => {
  zt[e] = t;
});
var Mo = zt;
function wn(t) {
  const e = new st(t), r = en(st.prototype.request, e);
  return d.extend(r, st.prototype, e, { allOwnKeys: true }), d.extend(r, e, null, { allOwnKeys: true }), r.create = function(s) {
    return wn(Ie(t, s));
  }, r;
}
var B = wn(Yt);
B.Axios = st;
B.CanceledError = He;
B.CancelToken = Uo;
B.isCancel = gn;
B.VERSION = En;
B.toFormData = pt;
B.AxiosError = A;
B.Cancel = B.CanceledError;
B.all = function(e) {
  return Promise.all(e);
};
B.spread = Do;
B.isAxiosError = Fo;
B.mergeConfig = Ie;
B.AxiosHeaders = he;
B.formToJSON = (t) => mn(d.isHTMLForm(t) ? new FormData(t) : t);
B.HttpStatusCode = Mo;
B.default = B;
var jo = B;
var $o = () => ({
  emit(t, ...e) {
    for (let r = this.events[t] || [], n = 0, s = r.length; n < s; n++)
      r[n](...e);
  },
  events: {},
  on(t, e) {
    var r;
    return ((r = this.events)[t] || (r[t] = [])).push(e), () => {
      var n;
      this.events[t] = (n = this.events[t]) == null ? void 0 : n.filter((s) => e !== s);
    };
  }
});
var Bo = class {
  constructor() {
    m(this, "remove", (e) => sessionStorage.removeItem(e));
  }
  set(e, r) {
    try {
      return sessionStorage.setItem(e, JSON.stringify(r)), true;
    } catch {
      return false;
    }
  }
  get(e) {
    try {
      const r = sessionStorage.getItem(e);
      return r ? JSON.parse(r) : null;
    } catch {
      return null;
    }
  }
};
var X = new Bo();
var qo = "/api/users/userinfo";
var Wo = async (t) => {
  const e = `${t}${qo}`;
  return (await (await ye()).get(e)).data;
};
var Nt = "piche";
var zo = "authorization_code";
var Ho = "password";
async function er(t, e, r) {
  const n = await ye(), s = `${t.location}/${e}${ms}`, o = new URLSearchParams({
    ...r,
    client_id: e
  });
  return (await n.post(s, o, {
    headers: { "Content-Type": "application/x-www-form-urlencoded" }
  })).data;
}
var Vo = (t, e) => er(e, t.clientId, {
  grant_type: zo,
  code: t.code,
  scope: t.scope,
  redirect_uri: t.redirectUri
});
var Ko = (t, e) => er(e, t.clientId, {
  grant_type: Ho,
  username: t.userName,
  password: t.password,
  scope: t.scope
});
async function Go(t, e, r) {
  const n = await ye(), s = `${t.location}/${e}${gs}`, o = new URLSearchParams({ client_id: e, refresh_token: r });
  await n.post(s, o, { headers: { "Content-Type": "application/x-www-form-urlencoded" } });
}
var Jo = (t, e) => er(e, t.client_id, {
  grant_type: ut.refreshToken,
  refresh_token: t.refresh_token
});
var Re = class _Re {
  constructor(e, r, n) {
    m(this, "error");
    m(this, "response");
    m(this, "statusCode");
    m(this, "isError", () => this.statusCode === Ue.ERROR);
    this.error = e, this.response = r, this.statusCode = n;
  }
  static Ok(e) {
    return new _Re(void 0, e, Ue.OK);
  }
  static Error(e) {
    return new _Re(e, void 0, Ue.ERROR);
  }
  static OperationRejected(e) {
    return new _Re(void 0, e, Ue.OperationRejected);
  }
};
function* Qo(t, e, r) {
  for (; t < e; )
    yield t, t += r;
}
var Yo = async () => new Promise((t) => {
  const e = (r) => t(r);
  k.emitMessageAsync(Jr, e);
});
var $i = class {
  constructor(e) {
    m(this, "url");
    m(this, "handleRetry", (e2, r, n) => {
      const s = e2.shift();
      s == null ? n(Re.Error(new Error("retry count depleted"))) : setTimeout(() => r(), s);
    });
    m(this, "fetchOperationStatusAsync", async (e2, r = "1.0") => new Promise((n) => {
      const s = Array.from(Qo(1, 10, 1), (i, c) => Math.pow(2, c) * 100), o = async () => {
        try {
          const i = await ei(this.url, e2, r);
          switch (i.state) {
            case $t.Completed:
              n(Re.Ok(i));
              break;
            case $t.InProgress:
              this.handleRetry(s, o, n);
              break;
            default:
              n(Re.OperationRejected(i));
              break;
          }
        } catch (i) {
          be("Error while fetching for operation status", "error_fetching_operation", i), this.handleRetry(s, o, n);
        }
      };
      o();
    }));
    this.url = e;
  }
  subscribe() {
    k.subscribe(Jr, (e) => e.detail(this));
  }
};
var Xo = async (t, e) => {
  const n = (await e()).headers["x-operation"];
  if (t.pendingCreateOperationRequests -= 1, n == null)
    throw Error("operation id not found");
  return t.operationIds.push({ operationId: n, time: Date.now() }), t.pendingCreateOperationRequests === 0 && t.emitter.emit("no-pending-create-operation-requests"), await (await Yo()).fetchOperationStatusAsync(n);
};
var Zo = class {
  constructor() {
    m(this, "queue", []);
    m(this, "tripWire", false);
    m(this, "enqueue", (e) => {
      this.queue.push(e);
    });
    m(this, "dequeue", () => this.queue.shift());
  }
  get length() {
    return this.queue.length;
  }
  get isTripWire() {
    return this.tripWire;
  }
  set isTripWire(e) {
    this.tripWire = e;
  }
};
var ye = async () => new Promise((t) => {
  k.emitMessageAsync(
    Gr,
    (e) => t(e)
  );
});
var Bi = class {
  constructor(e) {
    m(this, "getLocale", () => this.locale);
    m(this, "setLocale", (e2) => this.locale = e2);
    m(this, "getAxiosInstance", () => this.instance);
    m(this, "identityService");
    m(this, "instance");
    m(this, "locale", "lv-LV");
    m(this, "userManager");
    m(this, "onRejected", async (e2, r) => {
      var i, c, l, u;
      const n = e2.config, s = this.identityService.storageKey, o = X.get(`${s}.refresh_token`);
      if (!o)
        throw new Error("Session expired");
      if (r.isTripWire)
        return new Promise((f, y) => {
          r.enqueue({ resolve: f, reject: y, config: n });
        });
      {
        r.isTripWire = true;
        const f = {
          client_id: ((i = this.userManager) == null ? void 0 : i.tenantId) || "",
          refresh_token: o
        }, y = await Jo(f, this.identityService);
        for ((c = this.userManager) == null || c.storeToken(y, f.client_id), r.isTripWire = false; r.length > 0; ) {
          const b = r.dequeue();
          b && (b.config.headers.Authorization = `${y.token_type} ${y.access_token}`, await ((l = this.instance) == null ? void 0 : l.request(b.config)));
        }
        return (u = this.instance) == null ? void 0 : u.request(n);
      }
    });
    this.identityService = e, setInterval(() => this.cleanupOperations(), 10 * 60 * 1e3);
  }
  setup(e) {
    this.userManager = e, this.instance = Object.assign(jo.create({ baseURL: {}.VITE_API_URL }), {
      operationIds: [],
      pendingCreateOperationRequests: 0,
      emitter: $o()
    }), this.instance.interceptors.request.use((n) => {
      var s, o;
      return (s = n.url) != null && s.includes("/protocol/openid-connect/") || (n.headers["x-piche-locale"] = this.locale), (o = this.userManager) != null && o.IsAuthenticated && (n.headers.Authorization = `Bearer ${this.userManager.AuthorizationToken}`), n;
    });
    const r = new Zo();
    this.instance.interceptors.response.use(
      (n) => n,
      async (n) => {
        var s;
        try {
          if (((s = n.response) == null ? void 0 : s.status) === 401)
            return await this.onRejected(n, r);
          throw n;
        } catch (o) {
          return Promise.reject(o);
        }
      }
    );
  }
  cleanupOperations() {
    if (!this.instance)
      return;
    const e = Date.now();
    this.instance.operationIds = this.instance.operationIds.filter(
      (r) => e - r.time <= 10 * 60 * 1e3
    );
  }
  subscribe() {
    k.subscribe(Gr, (e) => {
      e.detail(this.instance);
    });
  }
};
var Te = async (t) => {
  const e = await ye();
  return await t(e);
};
var te = async (t) => {
  const e = await ye();
  return e.pendingCreateOperationRequests += 1, await Xo(e, async () => await t(e));
};
var ei = async (t, e, r) => {
  const n = `${t}/api/operations/${e}?api-version=${r}`;
  return (await (await ye()).get(n)).data;
};
var Ae = () => {
  function t() {
    return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
  }
  return t() + t() + "-" + t() + "-" + t() + "-" + t() + "-" + t() + t() + t();
};
var qi = () => (window && window.location && window.location.hostname) === "localhost";
var Lt = () => Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
var ti = 1e4;
var De = /* @__PURE__ */ new Map();
var ri = (t, e) => {
  if (De.size >= ti) {
    const r = De.keys().next().value;
    r && De.delete(r);
  }
  De.set(t, e);
};
var ni = [
  [//g, "ss"],
  [/[]/g, "ae"],
  [/[]/g, "oe"],
  [/[]/g, "th"],
  [/[]/g, "d"],
  [/[]/g, "l"],
  [/[]/g, "o"],
  [/[]/g, "c"],
  [/[]/g, "n"]
];
var Mr = (t) => {
  if (t == null)
    return "";
  const e = String(t), r = De.get(e);
  if (r !== void 0)
    return r;
  let n = e.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
  for (const [s, o] of ni)
    n = n.replace(s, o);
  return n = n.toLowerCase(), ri(e, n), n;
};
var Wi = (t, e) => Mr(t).includes(Mr(e));
var si = 1e4;
var rr = class {
  constructor() {
    m(this, "eventListeners", /* @__PURE__ */ new Map());
    m(this, "requestHandlers", /* @__PURE__ */ new Map());
    m(this, "pendingRequests", /* @__PURE__ */ new Map());
    m(this, "errorListeners", /* @__PURE__ */ new Set());
  }
  static getInstance() {
    return this.instance || (this.instance = new rr()), this.instance;
  }
  onError(e) {
    return this.errorListeners.add(e), () => this.errorListeners.delete(e);
  }
  onEvent(e, r, n) {
    let s = this.eventListeners.get(e);
    s || (s = /* @__PURE__ */ new Set(), this.eventListeners.set(e, s));
    const o = (i) => {
      try {
        r(i);
      } catch (c) {
        this.emitError(c, { message: i, localErrorHandler: n });
      }
    };
    return s.add(o), () => {
      s == null || s.delete(o), (s == null ? void 0 : s.size) === 0 && this.eventListeners.delete(e);
    };
  }
  emit(e, r, n, s) {
    const o = {
      id: Ae(),
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "event",
      event: e,
      payload: r
    };
    this.deliverMessage(o);
  }
  onRequest(e, r) {
    return this.requestHandlers.set(e, r), () => {
      this.requestHandlers.delete(e);
    };
  }
  async request(e, r, n, s) {
    const o = Ae(), i = {
      id: o,
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "request",
      action: e,
      payload: r,
      expectsResponse: true,
      requestId: o
    };
    return new Promise((c, l) => {
      const u = setTimeout(() => {
        this.pendingRequests.delete(o), l(new Error(`Request "${String(e)}" timed out`));
      }, si);
      this.pendingRequests.set(o, { resolve: c, reject: l, timeout: u }), this.deliverMessage(i);
    });
  }
  respond(e, r, n, s, o) {
    const i = {
      id: Ae(),
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "response",
      action: r,
      requestId: e,
      payload: o,
      success: true
    };
    this.deliverMessage(i);
  }
  deliverMessage(e) {
    switch (e.type) {
      case "event":
        this.handleEvent(e);
        break;
      case "request":
        this.handleRequest(e);
        break;
      case "response":
        this.handleResponse(e);
        break;
      default:
        console.warn("[MessageBus] Unknown message type:", e);
    }
  }
  handleEvent(e) {
    const r = this.eventListeners.get(e.event);
    if (r)
      for (const n of r)
        try {
          n(e);
        } catch (s) {
          this.emitError(s, { message: e });
        }
  }
  handleRequest(e) {
    const r = e.action, n = this.requestHandlers.get(r);
    if (!n) {
      this.respondError(
        e.id,
        r,
        e.source,
        e.target,
        `No handler registered for action "${String(r)}"`
      );
      return;
    }
    try {
      const s = n(e.payload);
      Promise.resolve(s).then((o) => {
        this.respond(e.id, r, e.source, e.target, o);
      }).catch((o) => {
        this.respondError(e.id, r, e.source, e.target, o.message);
      });
    } catch (s) {
      const o = s instanceof Error ? s : new Error(String(s));
      this.respondError(e.id, r, e.source, e.target, o.message);
    }
  }
  handleResponse(e) {
    const r = this.pendingRequests.get(e.requestId);
    r && (clearTimeout(r.timeout), this.pendingRequests.delete(e.requestId), e.success ? r.resolve(e.payload) : r.reject(new Error(e.error ?? "Unknown error")));
  }
  respondError(e, r, n, s, o) {
    const i = {
      id: Ae(),
      timestamp: Date.now(),
      source: n,
      target: s,
      type: "response",
      action: r,
      requestId: e,
      payload: {},
      success: false,
      error: o
    };
    this.deliverMessage(i);
  }
  emitError(e, r) {
    const n = e instanceof Error ? e : new Error(String(e));
    if (r != null && r.localErrorHandler)
      try {
        r.localErrorHandler(n, r.message);
        return;
      } catch (s) {
        console.error("[MessageBus] Error in localErrorHandler", s);
      }
    if (this.errorListeners.size > 0) {
      for (const s of this.errorListeners)
        try {
          s(n, r);
        } catch (o) {
          console.error("[MessageBus] Error in global error listener", o);
        }
      return;
    }
    console.error("[MessageBus] Unhandled error", n, r == null ? void 0 : r.message);
  }
};
var Me = rr;
m(Me, "instance");
var zi = Me.getInstance();
var Ht = Symbol.for("__picheBridge_internal");
function Hi() {
  if (window[Ht])
    return;
  const t = Me.getInstance();
  window[Ht] = { messageBus: t };
}
function oi() {
  const t = window[Ht];
  if (!t)
    throw new Error("Bridge not initialized. Call initializeBridge() first.");
  return t;
}
function bn() {
  return (0, import_react.useMemo)(() => {
    try {
      return oi().messageBus;
    } catch (e) {
      console.warn(e);
    }
  }, []);
}
function Vi(t, e) {
  const r = bn(), n = (0, import_react.useRef)(e);
  (0, import_react.useEffect)(() => {
    n.current = e;
  }, [e]), (0, import_react.useEffect)(() => r == null ? void 0 : r.onEvent(t, (o) => {
    n.current(o);
  }), [t, r]);
}
function Ki(t, e) {
  const r = bn(), n = (0, import_react.useRef)(e);
  (0, import_react.useEffect)(() => {
    n.current = e;
  }, [e]), (0, import_react.useEffect)(() => r == null ? void 0 : r.onRequest(t, (o) => n.current(o)), [t, r]);
}
var ii = class {
  constructor() {
    m(this, "listeners", {});
    m(this, "addListener", (e, r) => this.storeListener(e, r, false));
    m(this, "on", (e, r) => this.addListener(e, r));
    m(this, "subscribe", (e, r) => (this.on(e, r), { unsubscribe: () => this.off(e, r) }));
    m(this, "addOnceListener", (e, r) => this.storeListener(e, r, true));
    m(this, "once", (e, r) => this.addOnceListener(e, r));
    m(this, "removeListener", (e, r) => this.listeners[e] ? this.listeners[e].length ? r ? (this.listeners[e] = this.listeners[e].filter((n) => n.listener !== r), this) : (delete this.listeners[e], this) : this : this);
    m(this, "emit", (e, r) => this.listeners[e] ? (this.listeners[e].forEach((n) => {
      Promise.resolve().then(() => {
        n.listener.apply(this, [r]), n.once && this.removeListener(e, n.listener);
      });
    }), this) : this);
    m(this, "storeListener", (e, r, n) => (this.listeners[e] = this.listeners[e] || [], this.listeners[e].push({ listener: r, once: n }), this));
  }
  off(e, r) {
    return this.removeListener(e, r);
  }
};
var ai = async (t, e) => {
  const r = {
    headers: {
      "Content-Type": "application/json;charset=UTF-8",
      "Access-Control-Allow-Origin": "*"
    },
    withCredentials: false
  };
  r.headers = { ...r.headers, ...e.headers }, await (await ye()).post(e.url, t, r);
};
var jr = "logger.id";
var ci = "logger.console";
var ui = {
  [z.INFO]: console.info,
  [z.ERROR]: console.error,
  [z.DEBUG]: console.debug,
  [z.WARN]: console.warn,
  [z.ALERT]: console.info,
  [z.EMERGENCY]: console.error,
  [z.CRITICAL]: console.error
};
var Be = class {
  constructor(e) {
    m(this, "loggerId");
    m(this, "options");
    m(this, "messages", []);
    m(this, "interval");
    m(this, "events", new ii());
    m(this, "lastTimeLogsWasSent", 0);
    m(this, "getKey", (e2) => re.ofNullable(localStorage.getItem(e2)));
    m(this, "setKey", (e2, r) => localStorage.setItem(e2, r));
    m(this, "isConsoleOutputEnabled", () => this.getKey(ci).orElse("false") === "true");
    m(this, "enableRemoteLogging", () => {
      if (!this.options.remote)
        throw Error("Remote options not set");
      return this.startLogSending(), this;
    });
    m(this, "log", (e2, r, n, s, o) => {
      const i = {
        id: Ae(),
        version: "1.0",
        loggerId: this.loggerId,
        identity: this.getLogIdentity(),
        text: e2,
        code: r,
        logLevel: n,
        timestamp: Lt()
      };
      return s && (i.error = {
        message: s.message || "",
        stack: s.stack || ""
      }), this.write(i, n, o || ""), i;
    });
    m(this, "getStoredLogLevel", (e2) => {
      const r = this.getKey(e2);
      if (!r.isPresent())
        return false;
      const n = z[r.get()];
      return n || z.ERROR;
    });
    m(this, "enableEventDrivenLogging", () => {
      const e2 = (r) => {
        const n = r.detail;
        setTimeout(() => this.log(n.message, n.code, n.level, n.error, n.nameSpace), 0);
      };
      return k.subscribe(Vr, e2), this;
    });
    m(this, "canWriteLog", (e2, r) => {
      const n = this.getStoredLogLevel(`${Or}*`), s = this.getStoredLogLevel(`${Or}${r || "*"}`);
      return s ? e2 <= s : n ? e2 <= n : e2 <= z.INFO;
    });
    m(this, "write", (e2, r, n) => {
      this.canWriteLog(r, n) && this.events.emit(Be.WRITE_LOG_EVENT, e2);
    });
    m(this, "handleConsole", (e2) => {
      this.isConsoleOutputEnabled() && ui[e2.logLevel](e2);
    });
    m(this, "handleRemote", (e2) => {
      this.interval && (this.resetLastTimeLogsWasSent(), this.messages.push(e2));
    });
    m(this, "resetLastTimeLogsWasSent", () => {
      this.messages.length === 0 && (this.lastTimeLogsWasSent = Lt());
    });
    m(this, "getLogIdentity", () => {
      var r;
      const e2 = { userId: _r };
      return this.options.userManager && this.options.userManager.IsAuthenticated && this.options.userManager.userInfo() !== void 0 && (e2.userId = ((r = this.options.userManager.userInfo()) == null ? void 0 : r.id) || _r), e2;
    });
    m(this, "getLoggerId", () => this.getKey(jr).orElseGet(() => this.createLoggerId()));
    m(this, "createLoggerId", () => {
      const e2 = Ae();
      return this.setKey(jr, e2), e2;
    });
    m(this, "startLogSending", () => {
      clearInterval(this.interval), this.interval = setInterval(this.checkForLogsToSend, 1e3);
    });
    m(this, "checkForLogsToSend", () => {
      if (!this.isThereSomethingToSend())
        return;
      const e2 = this.cloneLogMessages();
      this.clearLogMessages();
      const r = async (n) => {
        try {
          await ai(e2, this.options.remote);
        } catch (s) {
          this.log("Log send error", "log_send_error", z.ERROR, s), setTimeout(() => r(Math.pow(2, n)), n * 1e3);
        }
      };
      setTimeout(() => r(1), 0);
    });
    m(this, "cloneLogMessages", () => this.messages.slice(0));
    m(this, "clearLogMessages", () => {
      this.messages = [];
    });
    m(this, "isSendTimeReached", () => {
      const e2 = this.options.remote.sendIntervalInSeconds || 60;
      return Lt() - this.lastTimeLogsWasSent > e2;
    });
    m(this, "isThereSomethingToSend", () => {
      const e2 = this.messages.length, r = this.options.remote.batchSize || 0;
      return e2 !== 0 && (e2 >= r || this.isSendTimeReached());
    });
    this.loggerId = this.getLoggerId(), this.options = e, this.events.subscribe(Be.WRITE_LOG_EVENT, this.handleConsole), this.events.subscribe(Be.WRITE_LOG_EVENT, this.handleRemote);
  }
};
var xt = Be;
m(xt, "WRITE_LOG_EVENT", "write_log_event");
var ve = async () => new Promise((t) => {
  k.emitMessageAsync(Qr, (e) => t(e));
});
var Gi = class {
  constructor(e) {
    m(this, "config", { apiUrl: "", domain: "", graphQLUrl: "", signalRUrl: "", hubLinkUrl: "" });
    this.config = e;
  }
  subscribe() {
    k.subscribe(Qr, (e) => {
      e.detail(this.config);
    });
  }
};
var Vt = () => new Promise((t) => {
  const e = (r) => {
    t(r);
  };
  k.emitMessageAsync(Xr, { consumerUserManager: e });
});
var Ji = class {
  constructor(e) {
    m(this, "accessToken");
    m(this, "refreshToken");
    m(this, "expiresIn");
    m(this, "userInformation");
    m(this, "identityService");
    m(this, "tenantId", Nt);
    m(this, "userInfo", () => this.userInformation);
    m(this, "loginWithCodeAsync", async (e2) => this.processLogin(e2, e2.type, Vo));
    m(this, "loginAsync", async (e2) => this.processLogin(e2, ut.password, Ko));
    m(this, "tryAutoLogin", async () => {
      const e2 = X.get(`${this.identityService.storageKey}.access_token`), r = X.get(`${this.identityService.storageKey}.expireDate`), n = X.get(`${this.identityService.storageKey}.tenantId`);
      if (!r)
        return Promise.resolve();
      if (/* @__PURE__ */ new Date() < new Date(r)) {
        this.accessToken = e2 || void 0, this.expiresIn = new Date(r), this.tenantId = n ?? "";
        try {
          await this.getUserInformation();
        } catch (o) {
          be("Unable to retrieve user information", "user_info_fetch_error", o, "UserManager"), this.logout();
        }
      }
      return Promise.resolve();
    });
    m(this, "logout", async () => {
      const e2 = this.userInformation;
      if (this.refreshToken)
        try {
          await Go(this.identityService, this.tenantId, this.refreshToken);
        } catch (r) {
          be("KC logout failed", "kc_logout_failed", r, "UserManager");
        }
      this.removeSessionFromBrowser(), this.accessToken = void 0, this.refreshToken = void 0, this.expiresIn = void 0, this.userInformation = void 0, k.emitMessageAsync(ps, e2);
    });
    m(this, "getUserInformation", async () => {
      const e2 = await ve(), { name: r, role: n, sub: s } = await Wo(e2.apiUrl), o = typeof n == "string" ? [n] : n;
      this.userInformation = {
        id: s,
        name: r,
        roles: o,
        tenantId: this.tenantId
      };
    });
    m(this, "setupEventListener", () => {
      k.subscribe(Xr, (e2) => {
        e2.detail.consumerUserManager(this);
      });
    });
    this.identityService = e;
  }
  get IsAuthenticated() {
    return !this.accessToken || !this.expiresIn ? false : /* @__PURE__ */ new Date() < this.expiresIn;
  }
  get AuthorizationToken() {
    return this.accessToken;
  }
  get RefreshToken() {
    return this.refreshToken;
  }
  subscribe() {
    this.setupEventListener();
  }
  async processLogin(e, r, n) {
    if (e.type !== r)
      return false;
    try {
      const s = await n(e, this.identityService);
      this.storeToken(s, e.clientId);
      try {
        await this.getUserInformation();
      } catch (o) {
        return be("Unable to retrieve user information", "user_info_fetch_error", o, "UserManager"), false;
      }
      return k.emitMessageAsync(hs, this.userInformation), vs("Authentication successful", "authentication_successful", void 0, "UserManager"), true;
    } catch (s) {
      return be("Authentication failed", "authentication_unsuccessful", s, "UserManager"), false;
    }
  }
  async resetPasswordAsync(e, r = Nt) {
    const s = `${(await ve()).apiUrl}/api/users/${r ?? this.tenantId}/${e}/reset`;
    return await te(async (o) => await o.get(s));
  }
  async updatePasswordAsync(e, r = Nt) {
    const s = `${(await ve()).apiUrl}/api/users/${r}/update-password`;
    return await te(async (o) => await o.post(s, e));
  }
  async registerAsync(e, r) {
    const s = `${(await ve()).apiUrl}/api/public/${this.tenantId}/user-invites/${r}`;
    return await te(async (o) => await o.post(s, e));
  }
  removeSessionFromBrowser() {
    X.remove(`${this.identityService.storageKey}.access_token`), X.remove(`${this.identityService.storageKey}.refresh_token`), X.remove(`${this.identityService.storageKey}.expireDate`), X.remove(`${this.identityService.storageKey}.tenantId`);
  }
  storeToken(e, r) {
    const n = e.access_token, s = e.refresh_token, o = new Date((/* @__PURE__ */ new Date()).getTime() + e.expires_in * 1e3);
    X.set(`${this.identityService.storageKey}.access_token`, n), X.set(`${this.identityService.storageKey}.refresh_token`, s), X.set(`${this.identityService.storageKey}.expireDate`, o.toString()), X.set(`${this.identityService.storageKey}.tenantId`, r), this.accessToken = n, this.refreshToken = s, this.expiresIn = o, this.tenantId = r;
  }
};
var li = () => {
  const [t, e] = (0, import_react.useState)(""), [r, n] = (0, import_react.useState)(""), [s, o] = (0, import_react.useState)(true), [i, c] = (0, import_react.useState)(false), { setCurrentUser: l } = ds(), u = async (g) => {
    g.preventDefault();
    try {
      c(true);
      const h = await Vt();
      await h.loginAsync({
        scope: "email openid profile",
        clientId: "piche",
        password: r,
        userName: t,
        type: ut.password
      });
      const E = h.userInfo();
      l(E);
    } finally {
      c(false);
    }
  }, f = (g) => {
    e(g.target.value);
  }, y = (g) => {
    n(g.target.value);
  }, b = (g) => {
    o(g.target.checked);
  };
  return P.jsx("div", { className: "piche-login", children: P.jsxs(
    "form",
    {
      className: "form",
      onSubmit: u,
      children: [
        P.jsxs("div", { className: "form__text-wrapper", children: [
          P.jsx("h1", { className: "form__title", children: "Sign In" }),
          P.jsx("div", { className: "form__subtitle", children: "Piche Bosio" })
        ] }),
        P.jsxs("div", { className: "form__group", children: [
          P.jsx("label", { htmlFor: "email", children: "Email address" }),
          P.jsx(
            "input",
            {
              name: "email",
              type: "email",
              id: "email",
              value: t,
              onChange: f,
              placeholder: "Enter email",
              autoComplete: "email"
            }
          )
        ] }),
        P.jsxs("div", { className: "form__group", children: [
          P.jsx("label", { htmlFor: "password", children: "Password" }),
          P.jsx(
            "input",
            {
              name: "password",
              type: "password",
              id: "password",
              value: r,
              onChange: y,
              placeholder: "Password",
              autoComplete: "current-password"
            }
          )
        ] }),
        P.jsxs("div", { className: "form__remember-me", children: [
          P.jsx(
            "input",
            {
              type: "checkbox",
              checked: s,
              onChange: b,
              id: "remember-me"
            }
          ),
          P.jsx("label", { htmlFor: "remember-me", children: "Remember Me" })
        ] }),
        P.jsx(
          "button",
          {
            disabled: i,
            type: "submit",
            children: "Continue"
          }
        )
      ]
    }
  ) });
};
var Qi = ({ children: t, withLogin: e }) => {
  const [r, n] = (0, import_react.useState)(), [s, o] = (0, import_react.useState)(true), i = () => {
    n(void 0), Vt().then((l) => l.logout());
  };
  (0, import_react.useEffect)(() => {
    o(true);
    try {
      Vt().then((l) => l.userInfo && n(l.userInfo())).finally(() => o(false));
    } catch (l) {
      o(false), be("LoginPage init error", "login_init", l, "AuthInit");
    }
  }, []);
  const c = !r && e;
  return P.jsx(Hr.Provider, { value: { currentUser: r, currentUserLoading: s, setCurrentUser: n, logout: i }, children: c ? P.jsx(li, {}) : t });
};
var vn = class {
  constructor() {
    m(this, "cache", {});
  }
  get(e, r) {
    const n = this.getCacheKey(e, r), s = this.cache[n];
    if (s)
      return s.data;
  }
  set(e, r, n, s) {
    const o = this.getCacheKey(e, r), i = this.cache[o];
    i && clearTimeout(i.timeout), this.cache[o] = {
      data: n,
      timeout: setTimeout(() => {
        this.clearCacheKey(e, r);
      }, s),
      cacheClearTime: s
    };
  }
  clearCacheKey(e, r) {
    const n = this.getCacheKey(e, r), s = this.cache[n];
    s && (clearTimeout(s.timeout), delete this.cache[n]);
  }
  getCacheKey(e, r) {
    return `${e}_${r}`;
  }
};
var di = new vn();
var Yi = class {
  constructor(e) {
    m(this, "requestQueue", {});
    m(this, "configuration");
    m(this, "tableCache", new vn());
    this.configuration = e, this.tableCache = di;
  }
  subscribe() {
    k.subscribe(ys, (e) => {
      e.detail(this);
    });
  }
  async request(e, r) {
    if (this.tableCache) {
      const o = this.tableCache.get(e, r);
      if (o)
        return Promise.resolve(o);
    }
    this.requestQueue[e] || (this.requestQueue[e] = {
      ids: {},
      timeout: null
    });
    const n = this.requestQueue[e];
    if (n.ids[r] !== void 0)
      return n.ids[r].promise;
    n.ids[r] = {};
    const s = new Promise((o, i) => {
      n.ids[r].resolver = { resolve: o, reject: i };
    });
    return n.ids[r].promise = s, Object.keys(n.ids).length >= this.configuration.maxBatchSize ? await this.executeBatchRequest(e) : (n.timeout && clearTimeout(n.timeout), n.timeout = setTimeout(async () => {
      await this.executeBatchRequest(e);
    }, this.configuration.debounceTime)), s;
  }
  async executeBatchRequest(e) {
    const r = this.requestQueue[e];
    r.timeout && (clearTimeout(r.timeout), r.timeout = null);
    const n = r.ids;
    r.ids = {};
    const i = (await (await ye()).post(
      this.configuration.apiTemplateUrl.replace("[table]", e),
      Object.keys(n).map((c) => c)
    )).data;
    if (i != null) {
      const c = /* @__PURE__ */ new Map();
      i.rows.forEach((l) => {
        c.set(l.id, l);
      }), Object.keys(n).forEach((l) => {
        const u = c.get(l);
        n[l].resolver.resolve(u), this.tableCache && this.tableCache.set(e, l, u, this.configuration.cacheClearTime);
      });
    } else
      Object.keys(n).forEach((c) => {
        n[c].resolver.resolve(void 0);
      });
  }
};
var Xi = (t) => k.emitMessageAsync(fs, { url: t });
var fi = `
query GetContacts($tenantId: String!, $userId: String!) {
  contacts(tenantId: $tenantId, userIds: [$userId]) {
    id
    userId
    name
    avatarUrl
    avatarColor
    email
    details
    phone
    birthDate
    phoneNumbers
    address
    company
    socialMedia
    statusMessage
    additionalEmails
    publicColumns
    pathAlias
    coverImageUrl
    coverImageConfig
    user {
      id
    }
    positionId
    departmentId
    additionalAttributes
    department {
      id
      name
    }
    position {
      id
      jobTitle
    }
  }
}
`;
var hi = async (t, e) => {
  const { graphQLUrl: r } = await ve(), n = `${r}/graphql`;
  return await Te(
    async (s) => await s.post(n, { query: fi, variables: { tenantId: t, userId: e } })
  ).then((s) => s.data.data.contacts).catch((s) => {
    throw be("Error fetching contacts", "error_fetching_contacts", s), s;
  });
};
var Zi = async () => new Promise((t) => {
  k.emitMessageAsync(
    Zr,
    (e) => t(e)
  );
});
var ea = class {
  constructor(e, r) {
    m(this, "_contactData", null);
    m(this, "_tenantId");
    m(this, "_userId");
    m(this, "_disposer", null);
    m(this, "_isInitialLoad", true);
    this._tenantId = e, this._userId = r, makeAutoObservable(this), this.setReactions();
  }
  get contactData() {
    return this._contactData;
  }
  updateContactData(e) {
    runInAction(() => {
      this._contactData = e;
    }), this._isInitialLoad || k.emitMessageAsync(bs, e);
  }
  updateContactDataSilent(e) {
    runInAction(() => {
      this._contactData = e;
    });
  }
  updateUser(e, r) {
    (this._tenantId !== e || this._userId !== r) && (runInAction(() => {
      this._tenantId = e, this._userId = r, this._contactData = null;
    }), this.restartReactions());
  }
  setReactions() {
    this._disposer = autorun(async () => {
      if (this._tenantId && this._userId)
        try {
          const e = await hi(this._tenantId, this._userId);
          runInAction(() => {
            this._contactData = e[0], this._isInitialLoad = false;
          });
        } catch (e) {
          console.error("Failed to fetch contact data", e);
        }
    });
  }
  restartReactions() {
    this._disposer && this._disposer(), this.setReactions();
  }
  subscribe() {
    k.subscribe(Zr, (e) => {
      e.detail(this);
    });
  }
  dispose() {
    this._disposer && (this._disposer(), this._disposer = null);
  }
};
var We = class {
};
m(We, "buildQuery", (e) => {
  const { skip: r = 0, search: n = "", orderBy: s = "", top: o = 30, filter: i = "", select: c = "" } = e, l = ["skip=" + r, "top=" + o];
  return n !== "" && l.push("search=" + n), s !== "" && l.push("orderBy=" + s), i !== "" && l.push("filter=" + i), c !== "" && l.push("select=" + c), "?" + l.filter((f) => f).join("&");
});
var pi = class {
  subscribe() {
    k.subscribe(Es, (e) => e.detail(this));
  }
  async getAsync(e, r) {
    const n = await this.getUrl(e, r), s = await Te(async (o) => await o.get(n));
    if (s.status == it)
      return s.data;
    throw new Error("Record not found");
  }
  async getAllAsync(e, r = Kr, n = 0) {
    const s = {
      skip: n,
      top: r
    }, o = We.buildQuery(s);
    let i = await this.getUrl(e);
    i = `${i}${o}`;
    const c = await Te(async (l) => await l.get(i));
    return this.getDataOrThrowRecordNotFound(c);
  }
  async filterAsync(e) {
    const { table: r } = e;
    if (!r)
      throw new Error("Table name is required");
    const n = We.buildQuery(e);
    let s = await this.getUrl(r);
    s = `${s}${n}`;
    const o = await Te(async (i) => await i.get(s));
    return this.getDataOrThrowRecordNotFound(o);
  }
  async updateAsync(e, r, n) {
    const s = await this.getUrl(e, r);
    return await te(async (o) => await o.put(s, n));
  }
  async insertAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.post(n, r));
  }
  async bulkInsertAsync(e, r) {
    const n = await this.getUrl(e), s = await this.insertRowsAsync(r, n);
    return this.formatInsertResults(s);
  }
  async deleteOneAsync(e, r) {
    return await this.deleteManyAsync(e, [r]);
  }
  async deleteManyAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.delete(n, { data: r }));
  }
  async getUrl(e, r = "") {
    return `${(await ve()).apiUrl}/api/tables/${e}/rows${r === "" ? "" : `/${r}`}`;
  }
  getDataOrThrowRecordNotFound(e) {
    if (e.status == it)
      return e.data;
    throw new Error("Record not found");
  }
  async insertRowsAsync(e, r) {
    const n = [];
    for (let o = 0; o < e.length; o++)
      n.push(te(async (i) => await i.post(r, e[o])));
    return await Promise.all(n);
  }
  formatInsertResults(e) {
    return e.map((r) => {
      var n;
      return {
        rowId: (n = r.response) == null ? void 0 : n.resourceId,
        success: r.statusCode,
        error: r.error
      };
    });
  }
};
var ta = new pi();
var mi = class {
  subscribe() {
    k.subscribe(ws, (e) => e.detail(this));
  }
  async getAsync(e, r) {
    const n = await this.getUrl(e, r), s = await Te(async (o) => await o.get(n));
    if (s.status == it)
      return s.data;
    throw new Error("Record not found");
  }
  async getAllAsync(e, r = Kr, n = 0) {
    const s = {
      skip: n,
      top: r
    }, o = We.buildQuery(s);
    let i = await this.getUrl(e);
    i = `${i}${o}`;
    const c = await Te(async (l) => await l.get(i));
    return this.getDataOrThrowRecordNotFound(c);
  }
  async filterAsync(e) {
    const { table: r } = e;
    if (!r)
      throw new Error("Table name is required");
    const n = We.buildQuery(e);
    let s = await this.getUrl(r);
    s = `${s}${n}`;
    const o = await Te(async (i) => await i.get(s));
    return this.getDataOrThrowRecordNotFound(o);
  }
  async updateAsync(e, r, n) {
    const s = await this.getUrl(e, r);
    return await te(async (o) => await o.put(s, n));
  }
  async insertAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.post(n, r));
  }
  async bulkInsertAsync(e, r) {
    const n = await this.getUrl(e), s = await this.insertRowsAsync(r, n);
    return this.formatInsertResults(s);
  }
  async deleteOneAsync(e, r) {
    return await this.deleteManyAsync(e, [r]);
  }
  async deleteManyAsync(e, r) {
    const n = await this.getUrl(e);
    return await te(async (s) => await s.delete(n, { data: r }));
  }
  async getUrl(e, r = "") {
    return `${(await ve()).apiUrl}/api/views/${e}/rows${r === "" ? "" : `/${r}`}`;
  }
  getDataOrThrowRecordNotFound(e) {
    if (e.status == it)
      return e.data;
    throw new Error("Record not found");
  }
  async insertRowsAsync(e, r) {
    const n = [];
    for (let o = 0; o < e.length; o++)
      n.push(te(async (i) => await i.post(r, e[o])));
    return await Promise.all(n);
  }
  formatInsertResults(e) {
    return e.map((r) => {
      var n;
      return {
        rowId: (n = r.response) == null ? void 0 : n.resourceId,
        success: r.statusCode,
        error: r.error
      };
    });
  }
};
var ra = new mi();
var tr = "PICHE_EVENT_APP_LOADING";
var na = () => k.emitMessageAsync(tr, true);
var sa = () => k.emitMessageAsync(tr, false);
var oa = ({ children: t, loading: e }) => {
  const [r, n] = (0, import_react.useState)(e);
  return (0, import_react.useEffect)(() => {
    const s = k.subscribe(tr, (o) => n(o.detail));
    return () => {
      s.unsubscribe();
    };
  }, []), P.jsxs(P.Fragment, { children: [
    P.jsx("div", { className: us({ "h-100 w-100 d-flex": !r }, { "d-none": r }), children: t }),
    r && P.jsx("div", { className: "pl__wrapper w-100 h-100", children: P.jsxs("div", { className: "pl", children: [
      P.jsx("div", { className: "pl__outer-ring" }),
      P.jsx("div", { className: "pl__inner-ring" }),
      P.jsx("div", { className: "pl__track-cover" }),
      P.jsxs("div", { className: "pl__ball", children: [
        P.jsx("div", { className: "pl__ball-texture" }),
        P.jsx("div", { className: "pl__ball-outer-shadow" }),
        P.jsx("div", { className: "pl__ball-inner-shadow" }),
        P.jsx("div", { className: "pl__ball-side-shadows" })
      ] })
    ] }) })
  ] });
};
function Rn(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number")
    n += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = Rn(t[e])) && (n && (n += " "), n += r);
    else
      for (e in t)
        t[e] && (n && (n += " "), n += e);
  return n;
}
function ge() {
  for (var t, e, r = 0, n = ""; r < arguments.length; )
    (t = arguments[r++]) && (e = Rn(t)) && (n && (n += " "), n += e);
  return n;
}
var je = (t) => typeof t == "number" && !isNaN(t);
var _e = (t) => typeof t == "string";
var K = (t) => typeof t == "function";
var ot = (t) => _e(t) || K(t) ? t : null;
var kt = (t) => (0, import_react.isValidElement)(t) || _e(t) || K(t) || je(t);
function gi(t, e, r) {
  r === void 0 && (r = 300);
  const { scrollHeight: n, style: s } = t;
  requestAnimationFrame(() => {
    s.minHeight = "initial", s.height = n + "px", s.transition = `all ${r}ms`, requestAnimationFrame(() => {
      s.height = "0", s.padding = "0", s.margin = "0", setTimeout(e, r);
    });
  });
}
function yt(t) {
  let { enter: e, exit: r, appendPosition: n = false, collapse: s = true, collapseDuration: o = 300 } = t;
  return function(i) {
    let { children: c, position: l, preventExitTransition: u, done: f, nodeRef: y, isIn: b } = i;
    const g = n ? `${e}--${l}` : e, h = n ? `${r}--${l}` : r, E = (0, import_react.useRef)(0);
    return (0, import_react.useLayoutEffect)(() => {
      const R = y.current, v = g.split(" "), _14 = (D) => {
        D.target === y.current && (R.dispatchEvent(new Event("d")), R.removeEventListener("animationend", _14), R.removeEventListener("animationcancel", _14), E.current === 0 && D.type !== "animationcancel" && R.classList.remove(...v));
      };
      R.classList.add(...v), R.addEventListener("animationend", _14), R.addEventListener("animationcancel", _14);
    }, []), (0, import_react.useEffect)(() => {
      const R = y.current, v = () => {
        R.removeEventListener("animationend", v), s ? gi(R, f, o) : f();
      };
      b || (u ? v() : (E.current = 1, R.className += ` ${h}`, R.addEventListener("animationend", v)));
    }, [b]), import_react.default.createElement(import_react.default.Fragment, null, c);
  };
}
function $r(t, e) {
  return t != null ? { content: t.content, containerId: t.props.containerId, id: t.props.toastId, theme: t.props.theme, type: t.props.type, data: t.props.data || {}, isLoading: t.props.isLoading, icon: t.props.icon, status: e } : {};
}
var Z = { list: /* @__PURE__ */ new Map(), emitQueue: /* @__PURE__ */ new Map(), on(t, e) {
  return this.list.has(t) || this.list.set(t, []), this.list.get(t).push(e), this;
}, off(t, e) {
  if (e) {
    const r = this.list.get(t).filter((n) => n !== e);
    return this.list.set(t, r), this;
  }
  return this.list.delete(t), this;
}, cancelEmit(t) {
  const e = this.emitQueue.get(t);
  return e && (e.forEach(clearTimeout), this.emitQueue.delete(t)), this;
}, emit(t) {
  this.list.has(t) && this.list.get(t).forEach((e) => {
    const r = setTimeout(() => {
      e(...[].slice.call(arguments, 1));
    }, 0);
    this.emitQueue.has(t) || this.emitQueue.set(t, []), this.emitQueue.get(t).push(r);
  });
} };
var Xe = (t) => {
  let { theme: e, type: r, ...n } = t;
  return import_react.default.createElement("svg", { viewBox: "0 0 24 24", width: "100%", height: "100%", fill: e === "colored" ? "currentColor" : `var(--toastify-icon-color-${r})`, ...n });
};
var Ut = { info: function(t) {
  return import_react.default.createElement(Xe, { ...t }, import_react.default.createElement("path", { d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z" }));
}, warning: function(t) {
  return import_react.default.createElement(Xe, { ...t }, import_react.default.createElement("path", { d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z" }));
}, success: function(t) {
  return import_react.default.createElement(Xe, { ...t }, import_react.default.createElement("path", { d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z" }));
}, error: function(t) {
  return import_react.default.createElement(Xe, { ...t }, import_react.default.createElement("path", { d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z" }));
}, spinner: function() {
  return import_react.default.createElement("div", { className: "Toastify__spinner" });
} };
function yi(t) {
  const [, e] = (0, import_react.useReducer)((g) => g + 1, 0), [r, n] = (0, import_react.useState)([]), s = (0, import_react.useRef)(null), o = (0, import_react.useRef)(/* @__PURE__ */ new Map()).current, i = (g) => r.indexOf(g) !== -1, c = (0, import_react.useRef)({ toastKey: 1, displayedToast: 0, count: 0, queue: [], props: t, containerId: null, isToastActive: i, getToast: (g) => o.get(g) }).current;
  function l(g) {
    let { containerId: h } = g;
    const { limit: E } = c.props;
    !E || h && c.containerId !== h || (c.count -= c.queue.length, c.queue = []);
  }
  function u(g) {
    n((h) => g == null ? [] : h.filter((E) => E !== g));
  }
  function f() {
    const { toastContent: g, toastProps: h, staleId: E } = c.queue.shift();
    b(g, h, E);
  }
  function y(g, h) {
    let { delay: E, staleId: R, ...v } = h;
    if (!kt(g) || function(H) {
      return !s.current || c.props.enableMultiContainer && H.containerId !== c.props.containerId || o.has(H.toastId) && H.updateId == null;
    }(v))
      return;
    const { toastId: _14, updateId: D, data: C } = v, { props: L } = c, ne = () => u(_14), se = D == null;
    se && c.count++;
    const q = { ...L, style: L.toastStyle, key: c.toastKey++, ...Object.fromEntries(Object.entries(v).filter((H) => {
      let [$, F] = H;
      return F != null;
    })), toastId: _14, updateId: D, data: C, closeToast: ne, isIn: false, className: ot(v.className || L.toastClassName), bodyClassName: ot(v.bodyClassName || L.bodyClassName), progressClassName: ot(v.progressClassName || L.progressClassName), autoClose: !v.isLoading && (oe = v.autoClose, pe = L.autoClose, oe === false || je(oe) && oe > 0 ? oe : pe), deleteToast() {
      const H = $r(o.get(_14), "removed");
      o.delete(_14), Z.emit(4, H);
      const $ = c.queue.length;
      if (c.count = _14 == null ? c.count - c.displayedToast : c.count - 1, c.count < 0 && (c.count = 0), $ > 0) {
        const F = _14 == null ? c.props.limit : 1;
        if ($ === 1 || F === 1)
          c.displayedToast++, f();
        else {
          const J = F > $ ? $ : F;
          c.displayedToast = J;
          for (let W = 0; W < J; W++)
            f();
        }
      } else
        e();
    } };
    var oe, pe;
    q.iconOut = function(H) {
      let { theme: $, type: F, isLoading: J, icon: W } = H, Q = null;
      const ie = { theme: $, type: F };
      return W === false || (K(W) ? Q = W(ie) : (0, import_react.isValidElement)(W) ? Q = (0, import_react.cloneElement)(W, ie) : _e(W) || je(W) ? Q = W : J ? Q = Ut.spinner() : ((Ee) => Ee in Ut)(F) && (Q = Ut[F](ie))), Q;
    }(q), K(v.onOpen) && (q.onOpen = v.onOpen), K(v.onClose) && (q.onClose = v.onClose), q.closeButton = L.closeButton, v.closeButton === false || kt(v.closeButton) ? q.closeButton = v.closeButton : v.closeButton === true && (q.closeButton = !kt(L.closeButton) || L.closeButton);
    let le = g;
    (0, import_react.isValidElement)(g) && !_e(g.type) ? le = (0, import_react.cloneElement)(g, { closeToast: ne, toastProps: q, data: C }) : K(g) && (le = g({ closeToast: ne, toastProps: q, data: C })), L.limit && L.limit > 0 && c.count > L.limit && se ? c.queue.push({ toastContent: le, toastProps: q, staleId: R }) : je(E) ? setTimeout(() => {
      b(le, q, R);
    }, E) : b(le, q, R);
  }
  function b(g, h, E) {
    const { toastId: R } = h;
    E && o.delete(E);
    const v = { content: g, props: h };
    o.set(R, v), n((_14) => [..._14, R].filter((D) => D !== E)), Z.emit(4, $r(v, v.props.updateId == null ? "added" : "updated"));
  }
  return (0, import_react.useEffect)(() => (c.containerId = t.containerId, Z.cancelEmit(3).on(0, y).on(1, (g) => s.current && u(g)).on(5, l).emit(2, c), () => {
    o.clear(), Z.emit(3, c);
  }), []), (0, import_react.useEffect)(() => {
    c.props = t, c.isToastActive = i, c.displayedToast = r.length;
  }), { getToastToRender: function(g) {
    const h = /* @__PURE__ */ new Map(), E = Array.from(o.values());
    return t.newestOnTop && E.reverse(), E.forEach((R) => {
      const { position: v } = R.props;
      h.has(v) || h.set(v, []), h.get(v).push(R);
    }), Array.from(h, (R) => g(R[0], R[1]));
  }, containerRef: s, isToastActive: i };
}
function Br(t) {
  return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientX : t.clientX;
}
function qr(t) {
  return t.targetTouches && t.targetTouches.length >= 1 ? t.targetTouches[0].clientY : t.clientY;
}
function Ei(t) {
  const [e, r] = (0, import_react.useState)(false), [n, s] = (0, import_react.useState)(false), o = (0, import_react.useRef)(null), i = (0, import_react.useRef)({ start: 0, x: 0, y: 0, delta: 0, removalDistance: 0, canCloseOnClick: true, canDrag: false, boundingRect: null, didMove: false }).current, c = (0, import_react.useRef)(t), { autoClose: l, pauseOnHover: u, closeToast: f, onClick: y, closeOnClick: b } = t;
  function g(C) {
    if (t.draggable) {
      C.nativeEvent.type === "touchstart" && C.nativeEvent.preventDefault(), i.didMove = false, document.addEventListener("mousemove", v), document.addEventListener("mouseup", _14), document.addEventListener("touchmove", v), document.addEventListener("touchend", _14);
      const L = o.current;
      i.canCloseOnClick = true, i.canDrag = true, i.boundingRect = L.getBoundingClientRect(), L.style.transition = "", i.x = Br(C.nativeEvent), i.y = qr(C.nativeEvent), t.draggableDirection === "x" ? (i.start = i.x, i.removalDistance = L.offsetWidth * (t.draggablePercent / 100)) : (i.start = i.y, i.removalDistance = L.offsetHeight * (t.draggablePercent === 80 ? 1.5 * t.draggablePercent : t.draggablePercent / 100));
    }
  }
  function h(C) {
    if (i.boundingRect) {
      const { top: L, bottom: ne, left: se, right: q } = i.boundingRect;
      C.nativeEvent.type !== "touchend" && t.pauseOnHover && i.x >= se && i.x <= q && i.y >= L && i.y <= ne ? R() : E();
    }
  }
  function E() {
    r(true);
  }
  function R() {
    r(false);
  }
  function v(C) {
    const L = o.current;
    i.canDrag && L && (i.didMove = true, e && R(), i.x = Br(C), i.y = qr(C), i.delta = t.draggableDirection === "x" ? i.x - i.start : i.y - i.start, i.start !== i.x && (i.canCloseOnClick = false), L.style.transform = `translate${t.draggableDirection}(${i.delta}px)`, L.style.opacity = "" + (1 - Math.abs(i.delta / i.removalDistance)));
  }
  function _14() {
    document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", _14), document.removeEventListener("touchmove", v), document.removeEventListener("touchend", _14);
    const C = o.current;
    if (i.canDrag && i.didMove && C) {
      if (i.canDrag = false, Math.abs(i.delta) > i.removalDistance)
        return s(true), void t.closeToast();
      C.style.transition = "transform 0.2s, opacity 0.2s", C.style.transform = `translate${t.draggableDirection}(0)`, C.style.opacity = "1";
    }
  }
  (0, import_react.useEffect)(() => {
    c.current = t;
  }), (0, import_react.useEffect)(() => (o.current && o.current.addEventListener("d", E, { once: true }), K(t.onOpen) && t.onOpen((0, import_react.isValidElement)(t.children) && t.children.props), () => {
    const C = c.current;
    K(C.onClose) && C.onClose((0, import_react.isValidElement)(C.children) && C.children.props);
  }), []), (0, import_react.useEffect)(() => (t.pauseOnFocusLoss && (document.hasFocus() || R(), window.addEventListener("focus", E), window.addEventListener("blur", R)), () => {
    t.pauseOnFocusLoss && (window.removeEventListener("focus", E), window.removeEventListener("blur", R));
  }), [t.pauseOnFocusLoss]);
  const D = { onMouseDown: g, onTouchStart: g, onMouseUp: h, onTouchEnd: h };
  return l && u && (D.onMouseEnter = R, D.onMouseLeave = E), b && (D.onClick = (C) => {
    y && y(C), i.canCloseOnClick && f();
  }), { playToast: E, pauseToast: R, isRunning: e, preventExitTransition: n, toastRef: o, eventHandlers: D };
}
function Tn(t) {
  let { closeToast: e, theme: r, ariaLabel: n = "close" } = t;
  return import_react.default.createElement("button", { className: `Toastify__close-button Toastify__close-button--${r}`, type: "button", onClick: (s) => {
    s.stopPropagation(), e(s);
  }, "aria-label": n }, import_react.default.createElement("svg", { "aria-hidden": "true", viewBox: "0 0 14 16" }, import_react.default.createElement("path", { fillRule: "evenodd", d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z" })));
}
function wi(t) {
  let { delay: e, isRunning: r, closeToast: n, type: s = "default", hide: o, className: i, style: c, controlledProgress: l, progress: u, rtl: f, isIn: y, theme: b } = t;
  const g = o || l && u === 0, h = { ...c, animationDuration: `${e}ms`, animationPlayState: r ? "running" : "paused", opacity: g ? 0 : 1 };
  l && (h.transform = `scaleX(${u})`);
  const E = ge("Toastify__progress-bar", l ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${b}`, `Toastify__progress-bar--${s}`, { "Toastify__progress-bar--rtl": f }), R = K(i) ? i({ rtl: f, type: s, defaultClassName: E }) : ge(E, i);
  return import_react.default.createElement("div", { role: "progressbar", "aria-hidden": g ? "true" : "false", "aria-label": "notification timer", className: R, style: h, [l && u >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: l && u < 1 ? null : () => {
    y && n();
  } });
}
var bi = (t) => {
  const { isRunning: e, preventExitTransition: r, toastRef: n, eventHandlers: s } = Ei(t), { closeButton: o, children: i, autoClose: c, onClick: l, type: u, hideProgressBar: f, closeToast: y, transition: b, position: g, className: h, style: E, bodyClassName: R, bodyStyle: v, progressClassName: _14, progressStyle: D, updateId: C, role: L, progress: ne, rtl: se, toastId: q, deleteToast: oe, isIn: pe, isLoading: le, iconOut: H, closeOnClick: $, theme: F } = t, J = ge("Toastify__toast", `Toastify__toast-theme--${F}`, `Toastify__toast--${u}`, { "Toastify__toast--rtl": se }, { "Toastify__toast--close-on-click": $ }), W = K(h) ? h({ rtl: se, position: g, type: u, defaultClassName: J }) : ge(J, h), Q = !!ne || !c, ie = { closeToast: y, type: u, theme: F };
  let Ee = null;
  return o === false || (Ee = K(o) ? o(ie) : (0, import_react.isValidElement)(o) ? (0, import_react.cloneElement)(o, ie) : Tn(ie)), import_react.default.createElement(b, { isIn: pe, done: oe, position: g, preventExitTransition: r, nodeRef: n }, import_react.default.createElement("div", { id: q, onClick: l, className: W, ...s, style: E, ref: n }, import_react.default.createElement("div", { ...pe && { role: L }, className: K(R) ? R({ type: u }) : ge("Toastify__toast-body", R), style: v }, H != null && import_react.default.createElement("div", { className: ge("Toastify__toast-icon", { "Toastify--animate-icon Toastify__zoom-enter": !le }) }, H), import_react.default.createElement("div", null, i)), Ee, import_react.default.createElement(wi, { ...C && !Q ? { key: `pb-${C}` } : {}, rtl: se, theme: F, delay: c, isRunning: e, isIn: pe, closeToast: y, hide: f, type: u, style: D, className: _14, controlledProgress: Q, progress: ne || 0 })));
};
var Et = function(t, e) {
  return e === void 0 && (e = false), { enter: `Toastify--animate Toastify__${t}-enter`, exit: `Toastify--animate Toastify__${t}-exit`, appendPosition: e };
};
var vi = yt(Et("bounce", true));
yt(Et("slide", true));
yt(Et("zoom"));
yt(Et("flip"));
var Kt = (0, import_react.forwardRef)((t, e) => {
  const { getToastToRender: r, containerRef: n, isToastActive: s } = yi(t), { className: o, style: i, rtl: c, containerId: l } = t;
  function u(f) {
    const y = ge("Toastify__toast-container", `Toastify__toast-container--${f}`, { "Toastify__toast-container--rtl": c });
    return K(o) ? o({ position: f, rtl: c, defaultClassName: y }) : ge(y, ot(o));
  }
  return (0, import_react.useEffect)(() => {
    e && (e.current = n.current);
  }, []), import_react.default.createElement("div", { ref: n, className: "Toastify", id: l }, r((f, y) => {
    const b = y.length ? { ...i } : { ...i, pointerEvents: "none" };
    return import_react.default.createElement("div", { className: u(f), style: b, key: `container-${f}` }, y.map((g, h) => {
      let { content: E, props: R } = g;
      return import_react.default.createElement(bi, { ...R, isIn: s(R.toastId), style: { ...R.style, "--nth": h + 1, "--len": y.length }, key: `toast-${R.key}` }, E);
    }));
  }));
});
Kt.displayName = "ToastContainer", Kt.defaultProps = { position: "top-right", transition: vi, autoClose: 5e3, closeButton: Tn, pauseOnHover: true, pauseOnFocusLoss: true, closeOnClick: true, draggable: true, draggablePercent: 80, draggableDirection: "x", role: "alert", theme: "light" };
var Dt;
var we = /* @__PURE__ */ new Map();
var Fe = [];
var Ri = 1;
function _n() {
  return "" + Ri++;
}
function Ti(t) {
  return t && (_e(t.toastId) || je(t.toastId)) ? t.toastId : _n();
}
function $e(t, e) {
  return we.size > 0 ? Z.emit(0, t, e) : Fe.push({ content: t, options: e }), e.toastId;
}
function ct(t, e) {
  return { ...e, type: e && e.type || t, toastId: Ti(e) };
}
function Ze(t) {
  return (e, r) => $e(e, ct(t, r));
}
function U(t, e) {
  return $e(t, ct("default", e));
}
U.loading = (t, e) => $e(t, ct("default", { isLoading: true, autoClose: false, closeOnClick: false, closeButton: false, draggable: false, ...e })), U.promise = function(t, e, r) {
  let n, { pending: s, error: o, success: i } = e;
  s && (n = _e(s) ? U.loading(s, r) : U.loading(s.render, { ...r, ...s }));
  const c = { isLoading: null, autoClose: null, closeOnClick: null, closeButton: null, draggable: null }, l = (f, y, b) => {
    if (y == null)
      return void U.dismiss(n);
    const g = { type: f, ...c, ...r, data: b }, h = _e(y) ? { render: y } : y;
    return n ? U.update(n, { ...g, ...h }) : U(h.render, { ...g, ...h }), b;
  }, u = K(t) ? t() : t;
  return u.then((f) => l("success", i, f)).catch((f) => l("error", o, f)), u;
}, U.success = Ze("success"), U.info = Ze("info"), U.error = Ze("error"), U.warning = Ze("warning"), U.warn = U.warning, U.dark = (t, e) => $e(t, ct("default", { theme: "dark", ...e })), U.dismiss = (t) => {
  we.size > 0 ? Z.emit(1, t) : Fe = Fe.filter((e) => t != null && e.options.toastId !== t);
}, U.clearWaitingQueue = function(t) {
  return t === void 0 && (t = {}), Z.emit(5, t);
}, U.isActive = (t) => {
  let e = false;
  return we.forEach((r) => {
    r.isToastActive && r.isToastActive(t) && (e = true);
  }), e;
}, U.update = function(t, e) {
  e === void 0 && (e = {}), setTimeout(() => {
    const r = function(n, s) {
      let { containerId: o } = s;
      const i = we.get(o || Dt);
      return i && i.getToast(n);
    }(t, e);
    if (r) {
      const { props: n, content: s } = r, o = { delay: 100, ...n, ...e, toastId: e.toastId || t, updateId: _n() };
      o.toastId !== t && (o.staleId = t);
      const i = o.render || s;
      delete o.render, $e(i, o);
    }
  }, 0);
}, U.done = (t) => {
  U.update(t, { progress: 1 });
}, U.onChange = (t) => (Z.on(4, t), () => {
  Z.off(4, t);
}), U.POSITION = { TOP_LEFT: "top-left", TOP_RIGHT: "top-right", TOP_CENTER: "top-center", BOTTOM_LEFT: "bottom-left", BOTTOM_RIGHT: "bottom-right", BOTTOM_CENTER: "bottom-center" }, U.TYPE = { INFO: "info", SUCCESS: "success", WARNING: "warning", ERROR: "error", DEFAULT: "default" }, Z.on(2, (t) => {
  Dt = t.containerId || t, we.set(Dt, t), Fe.forEach((e) => {
    Z.emit(0, e.content, e.options);
  }), Fe = [];
}).on(3, (t) => {
  we.delete(t.containerId || t), we.size === 0 && Z.off(0).off(1).off(5);
});
async function _i() {
  return new Promise((t) => {
    const e = (r) => {
      t(r);
    };
    k.emitMessageAsync(Yr, e);
  });
}
async function ia(t, e) {
  return (await _i())(t, e);
}
var aa = () => ((0, import_react.useEffect)(() => {
  const t = k.subscribe(Yr, (e) => e.detail(U));
  return () => {
    t.unsubscribe();
  };
}, []), P.jsx(Kt, {}));
var Gt;
var et = import_react_dom.default;
if ("production".NODE_ENV === "production")
  Gt = et.createRoot, et.hydrateRoot;
else {
  Wr = et.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  Gt = function(t, e) {
    Wr.usingClientEntryPoint = true;
    try {
      return et.createRoot(t, e);
    } finally {
      Wr.usingClientEntryPoint = false;
    }
  };
}
var Wr;
var Oi = {
  stringify: (t) => t ? "true" : "false",
  parse: (t) => /^[ty1-9]/i.test(t)
};
var Si = {
  stringify: (t) => JSON.stringify(t),
  parse: (t) => JSON.parse(t)
};
var Ai = {
  stringify: (t) => `${t}`,
  parse: (t) => parseFloat(t)
};
var Ci = {
  stringify: (t) => t,
  parse: (t) => t
};
var Ft = {
  string: Ci,
  number: Ai,
  boolean: Oi,
  json: Si
};
function Ii(t, e, r) {
  e.props || (e.props = t.propTypes ? Object.keys(t.propTypes) : []);
  const n = (Array.isArray(e.props) ? e.props.slice() : Object.keys(e.props)).filter((l) => l !== "container"), s = {}, o = {}, i = {};
  for (const l of n) {
    s[l] = Array.isArray(e.props) ? "string" : e.props[l];
    const u = Pi(l);
    o[l] = u, i[u] = l;
  }
  class c extends HTMLElement {
    constructor() {
      super();
      m(this, "connected", true);
      m(this, "context");
      m(this, "props", {});
      m(this, "container");
      e.shadow ? this.container = this.attachShadow({
        mode: e.shadow
      }) : this.container = this, this.props.container = this.container;
      for (const f of n) {
        const y = o[f], b = this.getAttribute(y), g = s[f], h = Ft[g];
        b && (h != null && h.parse) && (this.props[f] = h.parse(b, this));
      }
    }
    static get observedAttributes() {
      return Object.keys(i);
    }
    connectedCallback() {
      this.connected = true, this.render();
    }
    disconnectedCallback() {
      if (this.connected = false, this.context !== void 0) {
        const f = this.context;
        this.context = void 0, setTimeout(() => r.unmount(f));
      }
    }
    attributeChangedCallback(f, y, b) {
      const g = i[f], h = s[g], E = Ft[h];
      g in s && (E != null && E.parse) && (this.props[g] = E.parse(b, this), this.render());
    }
    render() {
      this.connected && (this.context ? r.update(this.context, this.props) : this.context = r.mount(this.container, t, this.props));
    }
  }
  for (const l of n) {
    const u = o[l], f = s[l];
    Object.defineProperty(c.prototype, l, {
      enumerable: true,
      configurable: true,
      get() {
        return this.props[l];
      },
      set(y) {
        this.props[l] = y;
        const b = Ft[f];
        if (b != null && b.stringify) {
          const g = b.stringify(y);
          this.getAttribute(u) !== g && this.setAttribute(u, g);
        }
      }
    });
  }
  return c;
}
function Pi(t = "") {
  return t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function Ni(t, e, r) {
  const n = Gt(t), s = import_react.default.createElement(e, r);
  return n.render(s), {
    root: n,
    ReactComponent: e
  };
}
function Li({ root: t, ReactComponent: e }, r) {
  const n = import_react.default.createElement(e, r);
  t.render(n);
}
function xi({ root: t }) {
  t.unmount();
}
function ca(t, e = {}) {
  return Ii(t, e, { mount: Ni, update: Li, unmount: xi });
}
export {
  ut as AUTHENTICATION_TYPE,
  Bi as ApiClient,
  Gi as AppConfig,
  oa as AppLoadingScreen,
  Hr as AuthContext,
  Qi as AuthProvider,
  Tr as EmptyAction,
  Vr as LOGGER_EVENT_LISTENER,
  hs as LOGIN_SUCCESSFULLY_FOR_PORTAL_USER,
  gs as LOGOUT_PATH,
  ps as LOGOUT_SUCCESSFULLY_FOR_PORTAL_USER,
  Mi as LogDebug,
  be as LogError,
  vs as LogInfo,
  z as LogLevel,
  ji as LogWarn,
  xt as Logger,
  li as Login,
  Kr as MAX_ITEMS,
  Me as MessageBus,
  ii as MicroEmitter,
  fs as NAVIGATE_HOST,
  $i as OperationClient,
  $t as OperationResponseStatus,
  Re as OperationStatus,
  Ue as OperationStatusCode,
  aa as PicheToast,
  k as PortalMessage,
  ea as ProfileContactData,
  Gr as REQUEST_API_CLIENT_EVENT,
  Qr as REQUEST_API_CONFIGURATION_EVENT,
  Jr as REQUEST_OPERATION_CLIENT_EVENT,
  Xr as REQUEST_PORTAL_USER_MANAGER,
  Zr as REQUEST_PROFILE_CONTACT_STORE_EVENT,
  Yr as REQUEST_REACT_TOAST,
  Es as REQUEST_TABLE_CLIENT_EVENT,
  ys as REQUEST_TABLE_DATA_LOADER,
  ws as REQUEST_VIEW_CLIENT_EVENT,
  Zo as RequestQueue,
  it as STATUS_OK,
  Or as STORAGE_LOGGER_NAME_SPACE_PREFIX,
  ms as TOKEN_PATH,
  pi as TableClient,
  Yi as TableDataLoader,
  _r as UNKNOWN,
  bs as UPDATE_PROFILE_CONTACT,
  Ji as UserManager,
  ls as VideoRecordType,
  mi as ViewClient,
  Te as doAxiosAsync,
  te as doAxiosWithResult,
  oi as getBridge,
  Ae as guid,
  sa as hideAppLoading,
  Wi as includesNormalized,
  Hi as initializeBridge,
  qi as isLocal,
  zi as messageBus,
  Xi as navigateHost,
  Mr as normalizeEnglishForSearch,
  Yo as operationClient,
  ca as reactToWebComponent,
  ye as requestApiClientAsync,
  ve as requestApiConfigAsync,
  Zi as requestProfileContactStoreAsync,
  _i as requestToastAsync,
  Vt as requestUserManagerAsync,
  na as showAppLoading,
  ia as showMessage,
  ta as tableClient,
  Lt as unixTimestampUTC,
  ds as useAuth,
  Vi as useBusEvent,
  Ki as useBusRequest,
  bn as useMessageBus,
  ra as viewClient,
  Xo as waitForOperation
};
/*! Bundled license information:

piche.npm.core/dist/index.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=piche__npm__core.js.map
